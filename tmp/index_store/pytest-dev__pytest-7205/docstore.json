{"docstore/metadata": {"/tmp/repos/swe-bench_pytest-dev__pytest/bench/bench.py__": {"doc_hash": "5c7bbcecec56f9980fd38b6be101dc4286fa9a17e3f9e9321d341a9875d3ff06"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/bench_argcomplete.py__": {"doc_hash": "4163864837c26626fc4e24da53de2e7f3ec609e5bb52f5af40c26f3c209ccf41"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/empty.py__": {"doc_hash": "0022e394fd6487d01ecb1455a85339be6bca4d9b29f07bf071673acc0a5f0f1c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/manyparam.py__": {"doc_hash": "00a84600fcb0a9f9713fb368ef2b6576f37a42c5b85907933cf844e0cc0720ca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/skip.py__": {"doc_hash": "d86128600c3322a0dc011451699ff683f450c22e4cc47fb6d544f9933adffd01"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conftest.py__": {"doc_hash": "9de7f7170c697461db927b029fc70676cf2f96a2ffcb216f57cff89cb65d3db2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py_test_attribute_test_dynamic_compile_shows_nicely": {"doc_hash": "183598d9736d647f8d46b5a868016c1290fa957ef1c860ef15fa0047a3094c98"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py_TestMoreErrors_": {"doc_hash": "f4c5d020289df71fdac50388d99256dd56ba744f8a48e1358f99f7f6d8b3d5e7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/global_testmodule_config/conftest.py__": {"doc_hash": "886a2063b0802353986fa05a34a4a61f74675ee64a9512d7986a982cd957b206"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/global_testmodule_config/test_hello_world.py__": {"doc_hash": "dfaefaeea08b2b3722775390fdac340efb0c8fb54cf23686b8c76af6a9363343"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/test_failures.py__": {"doc_hash": "1da7b37f55647788feb063d886e5df4369fca197f1a0f31ef91587a4f202c3d0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/conftest.py__": {"doc_hash": "03cc2fe3b3dc34d0b4c736f078e3b7df98479bb6b862063428df5450151766a1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/pythoncollection.py__": {"doc_hash": "792064627c4bdf0f039c7f6fdb0d810cae3b1f74b1f81c9bc8f366872def4020"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/xfail_demo.py__": {"doc_hash": "68a0281ab123b0a293371ca96ef92b4280a7fce77cb2c8c72bbb4a45e77143f2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/extra/setup-py.test/setup.py__": {"doc_hash": "14a12f36f00ec1962a3da811258e38b16ba548dbed25f3bc3e12e689b8502178"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release.py_regen_": {"doc_hash": "224390842ed9a78b1bfb0357cb9cd47f9ebbf3ff30598aa1724abf2a777404d6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/__init__.py__": {"doc_hash": "dd1d93bfcda3ccfddbbda4c1436cc4644f0f84133d66182a1886de3676f6a0d2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/__init__.py__": {"doc_hash": "7524a3c5c1f8272291e17b416cbdd31a8b891f89e893dc7fac100eba9276b2d2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Frame_Frame.getargs": {"doc_hash": "7026d676e33a04a178ad6bfcff4784f45224c644dd8b40e472bda5949f44b48b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_TracebackEntry_TracebackEntry.name": {"doc_hash": "f2ff7d9a05f61a9849ad6904aaa6e4290f72b5eb05baa095a96250255499d924"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback.__getitem___Traceback.getcrashentry": {"doc_hash": "39998a681e843481f88dc2e3bdba0a7d8b37419c83c24e019f9280f46f674421"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo_FormattedExcinfo.repr_args": {"doc_hash": "934b5b716076fafb89cb9faec99e79df8497d078f3e2d1aacb145b15e03c4b68"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.get_source_FormattedExcinfo.get_exconly": {"doc_hash": "6c0b09612e0f775ad9a05ebb49b8db3a2826182e4882aacb2a80d9e39c77c765"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo._truncate_recursive_traceback_FormattedExcinfo._truncate_recursive_traceback.return_traceback_extrali": {"doc_hash": "ad2a8b794836f801b832a5388f6fc634762f568dfdb265d4ae29f4bf86ab2ee1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_getstatementrange_ast_": {"doc_hash": "691ec181d809ef80ead0e4ae4cb8ebb977919e046671a403ce1ac5d106e08911"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook._early_rewrite_bailout_AssertionRewritingHook._early_rewrite_bailout.return_True": {"doc_hash": "ca6fd084e23b8020f1b58a4d96f3d87715ccb1f4dd90adbacce369fee1eaed2e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.run_AssertionRewriter.run.while_nodes_": {"doc_hash": "e3418929e4a68dd7a75f3b09c687cff57845cd5742d5d3a37e0d003c60526eaa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/truncate.py__truncate_explanation_": {"doc_hash": "da6c696a777c08754e8221322708e4cfb59ad6c1ce9188b06bbea5b8b6b8d13d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__format_lines_isiterable": {"doc_hash": "4bae314aed06af8c197b410938f918425ede5b9378fe172829f226812351c2cf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py_assertrepr_compare_assertrepr_compare.return_summary_explan": {"doc_hash": "4984b0a6dcea7a9f1c8bb2d40a60a3a72fa448bfe1df957deac16d601a36b9d5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__diff_text__diff_text.return_explanation": {"doc_hash": "90cf2c50e955eb5de6f4c33e2a7955421e10b0cacd7774f0a0c5854fa9887c51"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_cls_": {"doc_hash": "850b05a6bf6a17c8b48475ee02396b92b0ee6c32b23318b8855a59c157af6157"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_Cache_Cache.get": {"doc_hash": "15dc435e8cf36b4fefda717404a0dcaa19624dcd8ef16c43cec55ff84bc2a179"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_Cache.set_Cache._ensure_supporting_files": {"doc_hash": "28597bb4d0a0005d07e31c52838f563b53db7ff7571205aa3e899b722a8e96ee"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPlugin_LFPlugin.pytest_collectreport": {"doc_hash": "abbcace0a7a02aa27b68abf164881cbf900b2cc8e7ff1e32e550b211a3df97b5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPlugin.pytest_collection_modifyitems_LFPlugin.pytest_sessionfinish": {"doc_hash": "522a915bdfe6f3e4acf7bfa62c0ecbd5eeb6760e96282a0dfb78714009031953"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_NFPlugin_NFPlugin.pytest_sessionfinish": {"doc_hash": "22ae16ae889d8b7b8824b39dc334a4ac7fad4dc5360349b2dbc1355213437b69"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_pytest_addoption_pytest_addoption.None_6": {"doc_hash": "7aa2837d5bfe55016fad3795b3235c5a9856cb220383a005fdff7ae45b9776bf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_pytest_cmdline_main_pytest_report_header": {"doc_hash": "4f2bda33052ac3004072efb4a66106da91c7ee7a50d551a0cc737dce27930ec6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_cacheshow_": {"doc_hash": "ef31453b2829648cff3521d597e230e5db67e0efc486d9182871efa53f4915f6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager_CaptureManager._Fixture_Control_it_s_j": {"doc_hash": "6e9ebba15d87ba40bf6dc3e2d0054e3f93b32b162e9ae748e90e1cfa779600a7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager.activate_fixture_CaptureManager.pytest_internalerror": {"doc_hash": "fe9b0ed81788981b8cf5d121bda7c7290bb80987f2bf93707775965d069c8b3c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_MultiCapture_NoCapture.__init__": {"doc_hash": "a7f75f78cd8501af74e4f4b1b453d68a5742e7e7696d6b0c3e0a644f31db63f6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_FDCaptureBinary_FDCaptureBinary.writeorg": {"doc_hash": "fa59d76bc2f8939f5fe52b32a81d147e0eef0067ca38ac5f453aefda9ef8e051"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py__readline_workaround__readline_workaround": {"doc_hash": "0d99ccdcc2c6efb5afeb58ef03e9ae94b9daeba69df3eb1cee5160535dd9390a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py__py36_windowsconsoleio_workaround_": {"doc_hash": "d24995d2f0075b483d25c559e70436aa3466389add02ea673e75f9a95db61009"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_main_main.try_.except_UsageError_as_e_": {"doc_hash": "67352a4956cb2ba41e9bd1af01a4dc92710570aa74b23a1a3c61c988868a1ef7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.parse_hookimpl_opts_PytestPluginManager.parse_hookimpl_opts.return_opts": {"doc_hash": "68487e78576d98412f553ea9b5c3779583bf4148ba926b9848fb2d087fe10dcf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.parse_hookspec_opts_PytestPluginManager.None_3": {"doc_hash": "a1cd35df09aa8f9b630d336b469c42fb26b46fe327b2c3d126a84f6d21675286"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._set_initial_conftests_PytestPluginManager._set_initial_conftests.if_not_foundanchor_": {"doc_hash": "202dfcc8348c56d1da9a6dfe7da353eb27169d5a6256024c1a0f63e51befec3a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._checkversion_Config.parse": {"doc_hash": "195fd3980706273b95868132f3b78c5c109d347547145c9311e82a1bbc5bf9d1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config.addinivalue_line_Config._getini.if_type_pathlist_": {"doc_hash": "0cab05d3629dbc7164cdc016b79b624aba560882b593261f0222ff383d4616c2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._getconftest_pathlist_Config.getvalueorskip": {"doc_hash": "cd0c03bf14ef1b517a270a26b033ba25dc388f7457104e142380c8e68fd66231"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__assertion_supported_": {"doc_hash": "752f9f66adaacfe774b639400cbe75a2104238016df1b1d8bc796ce471682d32"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Argument._set_opt_strings_Argument.__repr__": {"doc_hash": "78118864fefc79ba913d69fdabb82700f9e3dc8ca89a8dcd32899735bcbcb23f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_OptionGroup_OptionGroup._addoption_instance": {"doc_hash": "daef5d0299322d23e5a215417d553ac9d5dfd45ab33d1b66812cc77b25e48ce9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_DropShorterLongHelpFormatter_": {"doc_hash": "ef907b77aced72480279c2665cec1299e56a383d312c4563a09614aac023c6a7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/exceptions.py__": {"doc_hash": "cdbf7bcb34af03084584c39802e4245a22f816ae35c6f87348a072e36bb549dc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_determine_setup_": {"doc_hash": "e5f8d27db564adb4ca374e3fcdf70b6b5731fbc2bdda45ad1dd2468ff3e89e91"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_PdbInvoke_": {"doc_hash": "c7a3f5ecf9800da904da4fad6196e878a69a33d4a6af0173a9192e8aeb8046fb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_runner_class__get_runner": {"doc_hash": "399e10a29eaef3389b787c0c29a603f09622e053fe7d3cac294ff9f68860c4c0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestItem_DoctestItem._disable_output_capturing_for_darwin": {"doc_hash": "b51c237e44bff697bc571390039e22e82a468a0cb4d8b5578fef7d6a0a2dc55a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestItem.repr_failure_DoctestItem.reportinfo": {"doc_hash": "ca2d811fa77b021be2aff4228dc24c0e2e01fa6203fc3493ec4d0b899e854247"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_add_funcarg_pseudo_fixture_def_add_funcarg_pseudo_fixture_def.for_argname_valuelist_in.if_node_and_argname_in_no": {"doc_hash": "3323185d4cfc3a2e1a5b21e585809b2c6df7f421d1f8d4e0ec478ffc4c19f5f6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_getfixturemarker_get_parametrized_fixture_keys": {"doc_hash": "6750ad5d3b621c87bf9c44c24a1405cfa47b50bd18078f1c2ec1daef2838e6b0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py__algorithm_for_sorting_o_fix_cache_order": {"doc_hash": "6d131d79a682575e4af7ec3de74db1052bde1f651fa887c226e4f7af07cbfb77"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FuncFixtureInfo_FuncFixtureInfo.prune_dependency_tree.self_names_closure_s": {"doc_hash": "32e67b83316b3193821d0bcbaea651a1221d51e8a83d06750598a97eff318268"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest._compute_fixture_value_FixtureRequest._compute_fixture_value.None_1": {"doc_hash": "1ffccbb2816664e89e2d2c1c4406d2d29c9e5b370e984fef9936462223794b69"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest._schedule_finalizers_FixtureRequest.__repr__": {"doc_hash": "f25114cb7fa4ad44f94e5a712ccb0c285b25cd63bc4b27239f0936eaab4ba205"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_SubRequest_scope2index": {"doc_hash": "b441a77e187ab141eb29378b5cf0ab6ce7e78a6eb07fab10e5ca071afdfec24a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureLookupError_FixtureLookupError.formatrepr.return_FixtureLookupError": {"doc_hash": "2b149463b4f7b1e059668084765c1be567264e545a93c9f93e7284c4da5e296d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureLookupErrorRepr_FixtureLookupErrorRepr.toterminal": {"doc_hash": "a99285a6353cc16af4e71a122229b67f749745b2f1e9cf176f88fc2770c01123"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureDef.execute_FixtureDef.__repr__": {"doc_hash": "da6991ea196b935aee9824c843b11b3c2c2e4774c0e3df11de1f5342883bf389"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.getfixtureclosure_FixtureManager.getfixtureclosure.return_initialnames_fixt": {"doc_hash": "188cbd97b71a217e094e475a57a62623050ef25a5a7828773ef3fd179f214df0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.pytest_generate_tests_FixtureManager.pytest_collection_modifyitems": {"doc_hash": "c34599c7254fd1523a25b292a4539d2f5b48d9febf8c404a3df38e5e23aa483e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.parsefactories_": {"doc_hash": "197299f8ad39782ca3227d0651680fc7202860f349645eab80d4d297864ff53f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_pytest_addoption_pytest_addoption.None_5": {"doc_hash": "3831c27264fbf21855ace1e41d7db36fde48508ec1ae9b8dbdb5b735d07908f4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_pytest_cmdline_parse_pytest_cmdline_main": {"doc_hash": "678666043e064c33b257d4b67a75e6641d8607dad15565ec12f6414ff80915a4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_showhelp_showhelp.return": {"doc_hash": "8f86eedb3d5097df26488638e5bc7521f1ebdd7a91df287b0626c9e2de2ffaa2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_conftest_options_": {"doc_hash": "691dea320635778b9b09e513c9ed034b3315d5d2420fbf10a0ddb1f6c92d7d8e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter__NodeReporter.record_testreport.self.attrs_6": {"doc_hash": "e021b0768186eb4f62a876d1fe531cd72df346dad8c8e0c0f2ce1d0c6e9c8305"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__warn_incompatibility_with_xunit2__check_record_param_type": {"doc_hash": "ce6964476a2421c43bedc78519670a3295927c2101201d89d31904d21a9874e0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_record_testsuite_property_record_testsuite_property.return_record_func": {"doc_hash": "9b134465da800da60cddf11cda49acb6e1d54744efb0ca493a3f4212a1476e23"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_pytest_configure_mangle_test_address": {"doc_hash": "ca42408dac4e736504cc1a81761b2b9f7ccc2ae17099f8aced8226b12b6b7973"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML_LogXML._opentestcase": {"doc_hash": "e734a8b852111774096a5e762d9eb4cdf3f371c8e1c7f4ee153c3781a30fed24"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML.pytest_runtest_logreport_LogXML.pytest_runtest_logreport.if_report_when_teardo": {"doc_hash": "fca738cb8af258fbe26da7629b3e7a67394af96a692d8bb0b251d20ae99bd786"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML.update_testcase_duration_": {"doc_hash": "5ec01d3197e0a1d20229e401a612ccbca88e00deee88a3e2b7f8295a550c9f57"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_catching_logs_LogCaptureHandler.reset": {"doc_hash": "732cc5184d57c579b4491f9596ef1fd2b16542d1a304da99324162e50173b8d2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_caplog_pytest_configure": {"doc_hash": "30cd4f73dbf2b71baae29a9098839918d846e2d3fc704e3ddc8c9e79d1e680a2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin.set_log_path_LoggingPlugin._runtest_for": {"doc_hash": "31e24b5810de161027322a049995b03d563207817a08dce76da6a8dd1a759b75"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin._runtest_for_main_LoggingPlugin._runtest_for_main.with_catching_logs_": {"doc_hash": "6d1180e21fb855205e5324ae457b3269e011f1d670d94ddc81ad323dcb3b27b5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin.pytest_runtest_setup_LoggingPlugin.pytest_runtestloop": {"doc_hash": "7b45c4f6008393adcab533f3893d1431612af6b6e74baa6a54c9f5cdf2275491"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py__LiveLoggingStreamHandler_": {"doc_hash": "c5df0ab7c4a1e53fb1012d5f9bec5bf66106625c2833cd007e14dfcbc14669df"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_cmdline_main__in_venv": {"doc_hash": "cb0307ea856e5ec97d87d8cf28a195eed54bf23430a7e5221b63198e497bff04"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session_Session.perform_collect": {"doc_hash": "5016c8bb503153276bf2c6f90a19cf660fcd9255f64c2c8bd71be198e3115fb6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._perform_collect_Session.collect": {"doc_hash": "778d6b9c964f03a356326a448d700bf7b5a227ef9ed26f1a8f296f794f15880f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._matchnodes_": {"doc_hash": "ee22fc5b38189b211b3816bc9940ac59beec837e4c819c33249a3febf7b1958c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py_pytest_addoption_pytest_addoption.parser_addini_EMPTY_PARAM": {"doc_hash": "234821aa1390c43e7897b41bd41505ff8f4d80b07f8e64672361757e0f2b5484"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py_pytest_cmdline_main_": {"doc_hash": "55f1bdfdc4a9189a08884cae5a3fd50ec2758fefb079e8176ce870a62bf4c616"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/evaluate.py_MarkEvaluator._istrue_": {"doc_hash": "d8f2282e73ff736927fd0da1860ba325902405e7b688ad3cdca571190188cdfc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MarkDecorator_MarkDecorator.__call__": {"doc_hash": "8434098af61ba8e50bf9619de668a48711241b72c1baa3bbd8bb18e174db68f2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_get_unpacked_marks_store_mark": {"doc_hash": "ccfc492870e9e972cbf454bc84588f1dd604c2cb735b9ba48f2ba30d3f2c65aa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MarkGenerator_MarkGenerator.__getattr__.return_MarkDecorator_Mark": {"doc_hash": "ee7a2b7da4d39561affd914203e6d3db8970ffa089684df1fdf4668b7eb70e28"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MARK_GEN_": {"doc_hash": "241f098959471a97c8f280971e52615752793b1832f0154bb7abdee1bf550158"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch_MonkeyPatch.context": {"doc_hash": "09db7a34939f55d803576bf24542f06da977d5951dd43bcc19692c13edc949fe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.setattr_MonkeyPatch.setattr.setattr_target_name_val": {"doc_hash": "d1419b2dfa310453f0d779b5587fe11c8e76b457a4a8eec7f9088a8ec7be675c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.delattr_MonkeyPatch.delattr.if_not_hasattr_target_na": {"doc_hash": "79508f865f3d25289cce56d2fbc1e2c85cf8a7ff92681fbdb8b154aadb22ea83"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.setitem_MonkeyPatch.delenv": {"doc_hash": "c7f02741c7cae28a9cba0627eb6aff934863f750526c05e373678fbccf64afde"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.syspath_prepend_MonkeyPatch.chdir": {"doc_hash": "f219c38e584367037ac9cf5a1a76a751221f8c76c9e4623e18cf5d65a6ad7aca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.undo_": {"doc_hash": "32fbae2a03b374e19824c178feb3dc2675377f3c874299665b28515ff7e4075c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node._repr_failure_py_Node.repr_failure": {"doc_hash": "7e223bf7e015602921e075a8d8f74f5fb43f1fb7ba92d815d00987c288162bcf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_fnmatch_ex_": {"doc_hash": "2220f74fbe93e59adc23ed0f6679589547435bf7a8f4b9b3c92b05c4cd89da8c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LsofFdLeakChecker_LsofFdLeakChecker.matching_platform": {"doc_hash": "c78ff474a28b4500bbebda32d747b991c18267c52d69bd6385b02e0df37b5f6d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LsofFdLeakChecker.pytest_runtest_protocol_LsofFdLeakChecker.pytest_runtest_protocol": {"doc_hash": "f83ed5405882bfbe4dc3f55a57b2726494da4963e925c724016475209c932591"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_RunResult_RunResult.parseoutcomes": {"doc_hash": "56f6420d09d1112487171bbaae6857966f59cbe33b1cb7c2dd256e2f923c8527"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_RunResult.assert_outcomes_SysPathsSnapshot.restore": {"doc_hash": "352209001022831eecc62d2f54d56697169f9b26b1950270d960b4b38188cf10"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.Session_Testdir.inline_runsource": {"doc_hash": "8fff5c7a78bb7333631672be8e3eaa1e0e434e6bdb933872d152a9058f8aea59"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.inline_genitems_Testdir.inline_run.try_.finally_": {"doc_hash": "36ff382c401fb4a3c6cf725a09f2f20224f0a2deb421285da20b1604f52be3c8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.runpytest_inprocess_Testdir.runpytest_inprocess.return_res": {"doc_hash": "7c43aa3e9a6b1f9bde4ffa764d7213e3de25a92c5373660212ff0e897cafa0f5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.run_Testdir.run.return_RunResult_ret_out": {"doc_hash": "e8888f24ae3e8df8a70f68af772f39a85684ce316c21ed1a50b3d726c102b49e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.spawn_pytest_LineComp.assert_contains_lines": {"doc_hash": "e62e10f9a08546c0bd9af46cd25d699aaa780097462425878e12dd7c7e492e65"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_cmdline_main_pytest_configure": {"doc_hash": "92f7bae78459a157232d6dba6a0f153531920cb83939de316bf2382f91fca843"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyobjMixin_PyobjMixin.reportinfo": {"doc_hash": "6462f0791069b98bb602983431f064e96c80a722a7b0ab37a6e25ff23011fb8e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector._genfunctions_PyCollector._genfunctions.if_not_metafunc__calls_": {"doc_hash": "01371960702aa0308c4c30dc32551e4a42fd72ec551632270b0bb1ad2c9a29f0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module_Module._inject_setup_module_fixture.self.obj.__pytest_setup_module": {"doc_hash": "265541c8854e9a3a7c369ea761a8426b2dadb27f8a300138939a701b7ed9f2dc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module._inject_setup_function_fixture_Module._inject_setup_function_fixture.self.obj.__pytest_setup_function": {"doc_hash": "291cc882655c250346802adaa9e2e83a5d8be4988b2f69191914d408e7c2a98a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module._importtestmodule_Module._importtestmodule.return_mod": {"doc_hash": "ebdf9c51aaa6375aa9d195caf3eb420dbad56eb778920bd1209f16e7f2035a1b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Package_Package.isinitpath": {"doc_hash": "9a7a5b573e68e8c6d7c2e31cde8ac304256d551ab3e605c07c1d07a872ddcb07"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._resolve_arg_value_types_Metafunc._resolve_arg_value_types.return_valtypes": {"doc_hash": "21f9cde527734d8d22bb8be69e4f665aec7351be9b2e34ac9f26b177281d9d0e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_if_using_arg_names_Metafunc._validate_if_using_arg_names.for_arg_in_argnames_": {"doc_hash": "1c3b6ebc39e713c560d92b2a493b7174cad9ee93b5ff9aac28d25223cf1de155"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__find_parametrized_scope__ascii_escaped_by_config": {"doc_hash": "a1d9bd59422e91713074931da9136f653d050b2865e2a388c4604863211477b1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__idval__idval.return_str_argname_str": {"doc_hash": "3d72bbcaa5c9c2a61c4a42431c6c21f3a5e4591cdc8f3a19fd687bc386f94a6b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__recursive_list_map_ApproxNumpy._yield_comparisons": {"doc_hash": "b866790b3e93b87aaaabbcbe5214b1fa1d1311c6914cc3c13b2f57f0ffb74828"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxMapping_ApproxMapping._check_type": {"doc_hash": "6efc89c32c942b02986115d319c5ea3e0fb98df854e1106734a3e8ab014246d6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxSequencelike_ApproxSequencelike._check_type": {"doc_hash": "972c4f223bfc6b6badd3e3db1391d94743e4880efc16561645d89617b4d229e9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar.tolerance_approx": {"doc_hash": "d272ce710d859263bffe665999c7d11a33726fd4f7571a754d42c50e1efd3e8d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_approx.__approx._": {"doc_hash": "8e915fd92e5d7b67f757dda0802b9ba3e00ea49984de4dcacd25ee09654a6b2d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_WarningsChecker_": {"doc_hash": "7bb4927eeff902ac770ee7da9c018c235681d4b9268eedee67d27f8d87a4b360"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_unserialization_failure_TestReport.__repr__": {"doc_hash": "135622d0c2c04bb818f3c1d4a7a4d5e1381f3890a74b4214df3eceab7dde38e5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_TestReport.from_item_and_call_TestReport.from_item_and_call.return_cls_": {"doc_hash": "0046debb2d843edf7dda95b079a0f8e7d242a7898a3310cbbd4804a938e344a6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/resultlog.py_ResultLog_": {"doc_hash": "e38938d51c771be16864d62ed9e359f8ee49b9a1a8ff8417e961606fa78eaaaf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_sessionstart__update_current_test_var": {"doc_hash": "5d00c45211792c49d811177b2f09a1796c43943c7b708157a0176a87960ef7d9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_report_teststatus_call_runtest_hook": {"doc_hash": "b590049cfaeb83ec2b7929a23ed54b75c75c13b418a79804001f8f6a8ecf0522"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_CallInfo_CallInfo.__repr__": {"doc_hash": "323e6bab676a0c1c34ab530f43bccc928c26ea0e4f15fe0f4ca2b1ef1d95ac4d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_SetupState_": {"doc_hash": "dcffe846d914aa58fc20d1cec903f6a8a9f322870b101573f2c220c6d62ad4ac"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setuponly.py__show_fixture_action_": {"doc_hash": "0ba6ced77f0e6e39f1c22e69bf41f6b2cd2100558275beea8ac16996a11ba68c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setupplan.py__": {"doc_hash": "31af0054b1fa04c09fd971115891076fc7de6429f7298ed77ae7d5c5df69ce1a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py_pytest_runtest_setup_check_strict_xfail": {"doc_hash": "b0a68ffab49890f24dd0cc376227d795f7424da07faaf7eff49760c18a2005ab"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py_pytest_runtest_makereport_": {"doc_hash": "b056458f33b3b043953cae1249fca32998680911b70cf7fc9dee3d25f077eca1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_pytest_addoption_pytest_addoption.parser_addini_": {"doc_hash": "d2711bdb8cfbab573774b3e2564c3d98ce6b76301f5ec4737be8337f6a08a41a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_pytest_configure_pytest_report_teststatus": {"doc_hash": "7ea86ca1962f796637e12d1d11fbfd0ade1deee2f3061bb94b56223b36f49352"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_WarningReport_WarningReport.get_location": {"doc_hash": "d424e58b72e1e96d87e0f76413a10bb53d61c4b679f06a2522757c497adc7601"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.report_collect_TerminalReporter.report_collect.if_self_isatty_": {"doc_hash": "0ac90a74a392b51f7fd93eb8a476f280a689d01fed3b71e14afa20f8d2ab8be5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_sessionstart_TerminalReporter.pytest_sessionstart.self__write_report_lines_": {"doc_hash": "55661c5aaa7b02cfec161492852a3d43de2d865b8afe8ab531e3b554ad964b4b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._write_report_lines_from_hooks_TerminalReporter.pytest_collection_finish": {"doc_hash": "1be7cbe680215947ab39478c0cc916acde052a4d85d82171c8985bf9690ba337"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._printcollecteditems_TerminalReporter._printcollecteditems.for_item_in_items_": {"doc_hash": "90045bc2ad6601d3e78d4c1d3d02a9a8f9ceba0b97d73a3d7c0a2a8db4cafe1f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_sessionfinish_TerminalReporter.getreports": {"doc_hash": "79d8d7f7b84c25b5b61b39355fb86a2396b7881c0e272161e78c16299ff9f000"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_warnings_TerminalReporter.summary_warnings.if_self_hasopt_w_.self__tw_line_Docs_h": {"doc_hash": "66b56fd50074bd063167d7ebefb58e0d51f4ec9e87e23f3a62e56bbe4c7c032a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.short_test_summary_TerminalReporter.short_test_summary.if_lines_": {"doc_hash": "e59e49c96a420ca9b7a0ff9b6fb51fb9a0bce5136fcb0d16923109072bed37e2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempPathFactory.getbasetemp_TempPathFactory.getbasetemp": {"doc_hash": "4a5b4ca0856cea5d5b883c34bd1533c52c5613f0c3b93448f86a9fa6da0ecf9f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_pytest_runtest_makereport_": {"doc_hash": "e5d5a359062d57bd989efcf29ca3cf828009946f57b94e9d4a68166c12b4af62"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_early_load_setuptools_name_TestGeneralUsage.test_early_load_setuptools_name.if_load_cov_early_": {"doc_hash": "4c44938ef6a87ccf9d86ecc13ec92021b2119bd1c6542f9e1d06a49dc88a0f58"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_assertion_magic_TestGeneralUsage.test_not_collectable_arguments": {"doc_hash": "bb1c185fd09657e59b5b42927cce7bb8d78f8aadb39bdeb7d8a60285b694676f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_early_skip_TestGeneralUsage.test_directory_skipped": {"doc_hash": "199281b211fa0fdf9744569e9fb11297702b8489b75b911640c9a108dc12dc76"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_multiple_items_per_collector_byid_TestGeneralUsage.test_issue134_report_error_when_collecting_member": {"doc_hash": "a433d99ee0b3568a625b56748fe82868df8c0b66e07f60d06756247226433624"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_report_all_failed_collections_initargs_TestGeneralUsage.test_parametrized_with_null_bytes": {"doc_hash": "30f81a0b6a31955c643946e8e8a607037e46d03ae2bc097e7dabcf595c606667"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants_TestInvocationVariants.test_invoke_plugin_api": {"doc_hash": "88b6673836f79266cca9ef7dc7b4936c15c8aea090f3700949b5c399c084ef42"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_namespace_package_TestInvocationVariants.test_invoke_test_and_doctestmodules": {"doc_hash": "9eb03935ca37eb047f038a95b3668428fe263f9cd3a08db760e1d7f52c4a8ab0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_symlink_TestInvocationVariants.test_cmdline_python_package_symlink.if_hasattr_py_path_local_": {"doc_hash": "2e5ff7ef8b6157910fd5a6b5297e85355e56e2280259d0ddd246310327ef3120"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestDurations_TestDurations.test_with_not": {"doc_hash": "31179866c578fad1a8f37d55f316b9fccc0d9262e419bc06f3219747b607f724"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_fixture_values_leak_test_fixture_values_leak.result_stdout_fnmatch_lin": {"doc_hash": "94eda2360ed68350f898171786df9204f0524ec00b96721623a47105fad58492"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_TestExceptionInfo_": {"doc_hash": "4412487f2609d2c87f4f54a4aebb603b03932253a65418fef69f23ef4adf4e54"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h_TestTraceback_f_g_h.test_traceback_filter": {"doc_hash": "42342957e61fd6c6a1a05b7987feb648cd73e198082ad5a1fe5e2d509ed11259"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h.test_traceback_filter_selective_TestTraceback_f_g_h.test_traceback_filter_selective.if_matching_": {"doc_hash": "16e92182143f00f9a59a2b0ccdd09c41007cdb3f865b0a5f6afaf11d46f4dd9c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h.test_traceback_recursion_index_TestTraceback_f_g_h.test_traceback_getcrashentry_empty": {"doc_hash": "8412b350e281200e088a3f2d1ef99505a50c6100c2620d63f5f34b82b23ecfd4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_local_TestFormattedExcinfo.test_repr_local_truncated": {"doc_hash": "f28629447e2e30fe59a3b758164d4353cc1f8a883052bf47302e5b0e1a5ee13b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines_TestFormattedExcinfo.test_repr_tracebackentry_lines._assert_loc_message_": {"doc_hash": "e523794f9eb6f668a73619233efd8766195d933496b17c3e7fceb6d39fc1a8b3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines2_TestFormattedExcinfo.test_repr_tracebackentry_lines2": {"doc_hash": "692d0037dda6426160d6ae7cc9d7cfe0d5e05fd12b9f87e2dfb0f4a9102896c5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines_var_kw_args_TestFormattedExcinfo.test_repr_tracebackentry_lines_var_kw_args": {"doc_hash": "6f2d07e98a4212416c1521bc9b3e574b215fc6c462603a8d0343ef25a87549cc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_short_TestFormattedExcinfo.test_repr_tracebackentry_short.None_6": {"doc_hash": "3d6f716dff250a327d139f3c0e60c2c373aa493c05324aa2f379d210eee7c197"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_no_TestFormattedExcinfo.test_repr_traceback_tbfilter": {"doc_hash": "759789e06070cfde5e04b54506c0ad065b1287200e5e831a84338e2d8dce688f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_traceback_short_no_source_TestFormattedExcinfo.test_traceback_short_no_source": {"doc_hash": "b9ec60f58008a3a247e6b0fe852b7c46f5d9cbffcf756411295e0c8ce6bf1969"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_traceback_and_excinfo_TestFormattedExcinfo.test_repr_traceback_and_excinfo": {"doc_hash": "79e069839c709e9eae6786cd40227882f5e297f5bc186ff9d92859bbaac758fd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_without_traceback_TestFormattedExcinfo.test_exc_chain_repr_without_traceback.matcher_fnmatch_lines_": {"doc_hash": "6fb6d1e5d86a20a96b27fb144c4aa3ff1cbfcd82b3f582779fb8044a9759cc59"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_cycle_TestFormattedExcinfo.test_exc_chain_repr_cycle.assert_out_expected_ou": {"doc_hash": "2094015e562e75f9964b87325fec2ed8f7745d2d469dfe03122a94fd1989b4e7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_test_repr_traceback_with_unicode_": {"doc_hash": "89e1835ac03236ba966ae703941217bf2ecf8579feb4948f94bc3b5168a81290"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_TestSourceParsingAndCompiling.test_getstatementrange_ast_issue58_TestSourceParsingAndCompiling.test_offsetless_synerr": {"doc_hash": "ff16be20cf2dd761d2fe9fb971ebe105a8b14f25aea77491d28c64355c2f124d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/acceptance/fixture_mock_integration.py__": {"doc_hash": "e7149a99afe5dbd5a9864c815778b693e8a3a8c27b0025b219bb1690aa78e8cb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/collect_init_tests/tests/__init__.py__": {"doc_hash": "db7eb4a31a425ab3e1b33d8d25c64f3503d150a9ed10990cba0a977524d054af"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/collect_init_tests/tests/test_foo.py__": {"doc_hash": "a0261fa97e45a32973dffc762828fffdec688fdc01611435d5cb2d14d96d6a0c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_infinite_recursion/conftest.py__": {"doc_hash": "ce89549a61c454564906a4f9ff27cdcbb193463de3fb324796cffdb363e7331e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_infinite_recursion/tests/test_basic.py__": {"doc_hash": "5f6752bdb3e1fff185ddf44e1aee76a207bd9d0debac164028f61c581d892ca7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_init_given_as_arg/pkg/test_foo.py__": {"doc_hash": "2cdbd52b12251cac4ece4fff0749696c54f2ca97ee833b99d35553ec040bf0f6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/config/collect_pytest_prefix/conftest.py__": {"doc_hash": "4eb5f2fd8b38b3acd7e79483b08b0cf3d7e2f1cead8bb0af1ca1ba95a442ada8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/config/collect_pytest_prefix/test_foo.py__": {"doc_hash": "167846a0f817b03efce558732ec3e233b4ee9203e1796600b315871a43ea7baf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/conftest_usageerror/conftest.py__": {"doc_hash": "28e9fad718fa35319fe76691a1dc4ecb4f433dbc8aa0c4598e87b8e102532a0d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses.py__": {"doc_hash": "8c4ca647858e46e58280e21787cedeb48fe10b3d4e0323afcaf9d643cb6193a5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses_field_comparison_off.py__": {"doc_hash": "8e72a751c83cb63bd3a5ccd859f9b6c360a23b59a6bcfbdbd36bf493a86c4feb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses_verbose.py__": {"doc_hash": "9dadd258f67b0c513f634cd3c0a5a05bd5c71ba5c5083f1a627e635561f663ac"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_two_different_dataclasses.py__": {"doc_hash": "d90a4159da6c4e767711eb9839d6cbc8530df25299475eae717d9981492052de"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/custom_item/conftest.py__": {"doc_hash": "c57fa84573bbf250ebc6371c48642f21007b2f3842833ed1210739911b8d5997"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/custom_item/foo/test_foo.py__": {"doc_hash": "d6c8d2f1b8513efd014ede4667a7d227b2ad5ba7de1170a2ed7154806e0b0e3d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/conftest.py__": {"doc_hash": "d090363c33e61571d9603b2e049e82056b36be59fadf3d569b4c882161ae1bd8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/test_in_sub1.py__": {"doc_hash": "36cb1f353cf5157828f2216e6ae5c732318cea5808b4d18513d428289eacc260"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/conftest.py__": {"doc_hash": "c184b8da6b086b5985943be8fc573e7c90637260d1d676f7a95b34ca531874fd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/test_in_sub2.py__": {"doc_hash": "3cd0baafbe0afea522e2f7651b961a623e20cb59bbbc498c20dfc797173e5d53"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_detect_recursive_dependency_error.py__": {"doc_hash": "c95eb68485646d8b050089e48361e80bd5bd5fc9a2435a30f2d10c16f8e87268"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/conftest.py__": {"doc_hash": "20cb3bf4f17a59d8433cb54e28d695463cac6eb3643862b9e20234b138bb36bf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/conftest.py__": {"doc_hash": "358a37c592635602827c56c6d99fa02ced65fb8c4b938f638bff504d612b9dff"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/test_spam.py__": {"doc_hash": "d08aca08d5725278cf8e9fa110f212c20efe13cf554122e9e6fe26d0701e44e1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/conftest.py__": {"doc_hash": "7a8e72a43948fee9559bb23af7e099343af6c6cd8374bb7e57b88b2ae69d1470"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/test_extend_fixture_conftest_module.py__": {"doc_hash": "7f85491a8aadd9df90c1079c7f33614d4cb8d007dabb08dfb4e18dddcb4fd6c3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_module_class.py__": {"doc_hash": "6838d904e05c5e2b0ea5c50a6c4313a9200dfe2afa014d31f83fac10a8dd90e3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_basic.py__": {"doc_hash": "dc545d818225c07158c389628bb884b87230ba06b5fe190d56d4775cac40e14e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_classlevel.py__": {"doc_hash": "4daf6c3fdf60677b062fada1a1c419718017d05f3d3f1f12670ae12aafa60d72"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_modulelevel.py__": {"doc_hash": "6666bd0c114df3cf89395f5b86e620e893e4a1e176bb1ce7fa3a426a51f3cb78"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookupfails.py__": {"doc_hash": "151630fd6cf7728cafc99432acb4fbe8afba129ade900155b8d0db3bc9c03ddd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/test_getfixturevalue_dynamic.py__": {"doc_hash": "5d805e9d1c365a50d6c351fd419e78e0faceed8e8180bc04e3bfbce6db5a4890"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue88_initial_file_multinodes/conftest.py__": {"doc_hash": "64828eefa343c2e734e99ac7ab61538ca74b313e17aed8fe7ed1bd442cea170d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue88_initial_file_multinodes/test_hello.py__": {"doc_hash": "8372e1120df4220a19463659808219a918f8c6565748a57fbb2b981418cde342"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/marks/marks_considered_keywords/test_marks_as_keywords.py__": {"doc_hash": "90e01bff394c486c006bc92f08ecb7cd4cb13de2fa1035784c6496ad2d017a25"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/perf_examples/collect_stats/template_test.py__": {"doc_hash": "2b7993f84669688a70b76a770407a688e3ec37c8fd5ef5fe8df62761c2224783"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/tmpdir/tmpdir_fixture.py__": {"doc_hash": "3e7c95e1c514844c5dbbf3de1dd97f4dfd17aec3d6950c8842a582893b2dbfc6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_parametrized_fixture_error_message.py__": {"doc_hash": "3dc470dec406e19815f8082f3a4e381ba14a804da44c21401841d65d007ed714"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip.py__": {"doc_hash": "063412502e47f12ab003963654dfa5cf4d2fbd2648240a2db62f1d7e1ad78bdb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip_class.py__": {"doc_hash": "fd669f8972560462cc6f1093b1b2f679fbf3a1ca5a14373af716e3188dca98fe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip_module.py__": {"doc_hash": "9acd2ba1434ff3cf657b6bc196e29c7c5713f720859ab4db8c991720b8e06e08"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message.py__": {"doc_hash": "ac5ea1db2b9560f03578736e338a03d555f06aba4904ddefae087aa10cbd8cdb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/examples/test_issue519.py__": {"doc_hash": "2bbec61d9ef8cf1b6d1775b9a2044f96a6739690b107457a939256bc297fb9f4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/create_executable.py__": {"doc_hash": "f45aff2a121622cfe204b1b60b8e1f4ecfe1716ceeff6f6cbceedb4997eb53af"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/runtests_script.py__": {"doc_hash": "cf51b8b9f99fcd76a04d0c3af880a6fcf9f6a3fad3d6ad71b449e3f53afa8845"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/tests/test_trivial.py__": {"doc_hash": "9c38ed0ac5428c43414f5b784306a704a9f9b90ed3963c12b03931fd474361e4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/tox_run.py__": {"doc_hash": "1274ca3b922adfa7276f2acee3483835a352cfd611b5400b83dd63f12032d493"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_fixture.py_test_unicode_": {"doc_hash": "13ea4ef76e83453f05f8258bf9308218bc31b2ce8c16cfd378d96317a794925f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_root_logger_affected_test_root_logger_affected.with_open_log_file_as_rf": {"doc_hash": "0076ca3e3153cc945591815c1da80eb0c13b34bf35cc02a703db8c79a7eaab29"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_level_log_level_interaction_test_disable_log_capturing": {"doc_hash": "65321aeedb2dd19dbc9d5bddd06fa6d316c4d3e0d6400563d4dd39b631e07553"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_disable_log_capturing_ini_test_log_cli_enabled_disabled.None_1": {"doc_hash": "eae29a174826464f0b52692fbf20a1e4e3ad26ef11c1216a7888560d9150343a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_test_log_cli_default_level.assert_result_ret_0": {"doc_hash": "92d935c532e65d317ca4f18445fbf129c9d6d312b5e8a7a1c57b47dd66e30f9b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_multiple_tests_test_log_cli_default_level_multiple_tests.result_stdout_fnmatch_lin": {"doc_hash": "13c81ea55dc65f8ff9c38e799a38bcbb79c9e59c7bc4a65d658aa3c534e2db65"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_sections_test_log_cli_default_level_sections.result_stdout_fnmatch_lin": {"doc_hash": "76c1f2a4a9023779f5f509b766244f87d28b418af5a9b91ee6b53f53d75d07b8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_live_logs_unknown_sections_test_live_logs_unknown_sections.result_stdout_fnmatch_lin": {"doc_hash": "c5c01b566c8cbc9476ae47240ac4aea81600341de784d81f874a9240460d0234"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_sections_single_new_line_after_test_outcome_test_sections_single_new_line_after_test_outcome.None_1": {"doc_hash": "e15c8e007e528b9551d837950866c6c72d559515f5ba1a443fd44bcefcfd729d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_ini_level_test_log_cli_ini_level.assert_result_ret_0": {"doc_hash": "27f12d08540f94faf21389537ffd52a407085906668fd760d8ea8e0ac91aa6fe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_auto_enable_test_log_cli_auto_enable.if_cli_args_log_cli": {"doc_hash": "3d51d46b92133c795e27c00bc2a0d232f3a34cad5e15697112af13500fdb1666"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_cli_test_log_file_cli.with_open_log_file_as_rf": {"doc_hash": "3482f7fd05c2f942ffef7f422aa37bc993686b69adb42084c0bbe2cb4bbf9f05"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_cli_level_test_log_level_not_changed_by_default": {"doc_hash": "61b077b5ff2268644d9e27bc0f646c735e9d6a286a94fe733a131958a5cf78f0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_ini_test_log_file_ini.with_open_log_file_as_rf": {"doc_hash": "3e388452fa7041d710ba3e7594d3506c86e4827885f91a6e39c415d91e264497"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_ini_level_test_log_file_ini_level.with_open_log_file_as_rf": {"doc_hash": "b894ced95085185823270a20641018b3b6c315f801459fbfc4449becc28f39fa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_unicode_test_log_file_unicode.with_open_log_file_encod": {"doc_hash": "4e4ffda8e62258302245b7641dcf39f8e338fa1e44f74c8c91b1370ebe6e2edb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_live_logging_suspends_capture_test_live_logging_suspends_capture.assert_out_file_getvalue_": {"doc_hash": "1842d5a29d40997aa34eb00401a16fe8d8b12b8cf5d4740166a39af0ca764292"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_repr_nd_array_TestApprox.test_repr_nd_array": {"doc_hash": "81e5da534e27484327c9703336b2ed0610cbc09f3bccc45ddcbb52c17a9799bd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_operator_overloading_TestApprox.test_inf_tolerance": {"doc_hash": "800c31ebce4dace0ea230074b3ff8469713213a948efc82f00c771200905fceb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_inf_tolerance_expecting_zero_TestApprox.test_default_tolerances": {"doc_hash": "aff90cceecb46ea0a362b6e28ddea18f512e3e397f0aa8846cd8b4ae90f0f0df"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_custom_tolerances_TestApprox.test_custom_tolerances": {"doc_hash": "97afc326300c6a61fbd2f2c58380f25162d73047f19df4c4453401520817f777"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_relative_tolerance_TestApprox.test_int": {"doc_hash": "bc1e2756fa6b8966248d1906ce3304555551989edc3ab14c01df5c3c93ca0369"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_decimal_TestApprox.test_list_wrong_len": {"doc_hash": "525543c9c029cad7a626be45a2223adcd5da8d5ce699a4b335849a7294ca6f8b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_tuple_TestApprox.test_dict_wrong_len": {"doc_hash": "7d0f2ee68aba5d83f6e93dd44ed94b3fa00ba2d8be3344665968fb705c7f4518"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_array_TestApprox.test_numpy_array": {"doc_hash": "03ab962b6275e6546c068cd276a59b3c34accaa03dfe5731aaba0d2a472e6f31"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_tolerance_args_TestApprox.test_numpy_tolerance_args.for_op__abs__rel_in_tes": {"doc_hash": "d83235bc432f7c3c55bb3edcd000de81e4a47aa86370bbd71424731b88e39000"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_expecting_nan_TestApprox.test_comparison_operator_type_error": {"doc_hash": "6a474037da8bca06c593f9a355a31a899485a1a47ad2278c866fec5de05abc1f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_array_with_scalar_": {"doc_hash": "9027878bb964a2709a325c79d865bc7b32a4ef6dfc23e7ab99b4a731a6a8ffc1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestModule.test_show_traceback_import_error_TestModule.test_show_traceback_import_error_unicode": {"doc_hash": "0252d8b0fe4c5a414dc09133b1df173f35df53eb4c69d59bc3aa9903724de624"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestClass_TestClass.test_issue2234_property": {"doc_hash": "679b3592e8b4b84607e9bdef6409a6b39c64ec3857345ea7b958f2ba7b5cc933"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction_TestFunction.test_issue213_parametrize_value_no_equal": {"doc_hash": "8b402524381885451e524a87e75e7705d2bfab9144d35678c5ce77d6061402b3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_with_non_hashable_values_TestFunction.test_parametrize_overrides_parametrized_fixture": {"doc_hash": "317aaf44432af57695798ac58e1f289f87ad9fd39000dc1a6cae9209ec856427"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestSorting_TestSorting.test_allow_sane_sorting_for_decorators": {"doc_hash": "4c9d847053634fba280a32acd96b6e3978cdf26e823ad30b73946ba5f7eb30b6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestConftestCustomization_TestConftestCustomization.test_makeitem_non_underscore": {"doc_hash": "e05c0760f05c5d99ce85cb57e17d04618d610ee70452fe0d92bdd0074386330d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestConftestCustomization.test_issue2369_collect_module_fileext_TestConftestCustomization.test_issue2369_collect_module_fileext.result_stdout_fnmatch_lin": {"doc_hash": "151ae1ec5c35df5a32bfb6d433dd8d147a92c9e02be72d797738768d50187227"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_setup_only_available_in_subdir_test_modulecol_roundtrip": {"doc_hash": "41b4869b5e383edf024a375309ec9e27c149f598fa2447c6059e1c8902241c14"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestReportInfo_TestReportInfo.test_reportinfo_with_nasty_getattr": {"doc_hash": "83c99919022e9eb2d41a67039f32ad5b30151d3c58c4473f0c108bc9f9e088aa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_package_ordering_": {"doc_hash": "6b6227a4438d5d817ef14c32599622ae98fbf8cedc6004653eca0f36a4f12dca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures_TestFillFixtures.test_extend_fixture_conftest_plugin.assert_result_ret_0": {"doc_hash": "c23d8702a86b8c3a31e053b5593be9d4de97761a3d2e8129d4c2b36d90c18887"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_extend_fixture_plugin_plugin_TestFillFixtures.test_override_parametrized_fixture_conftest_module.None_2": {"doc_hash": "f250b62c2a07ba76150ef025c3fb7d08abbd2ff39a97ef599a3aa0609ad013d5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_parametrized_fixture_conftest_conftest_TestFillFixtures.test_override_non_parametrized_fixture_conftest_module.None_2": {"doc_hash": "1ae977b97aa9b86f4f44eb18e495a062699b6cc3a7dacd0c34964f8620270fc5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_non_parametrized_fixture_conftest_conftest_TestFillFixtures.test_override_non_parametrized_fixture_conftest_conftest.None_4": {"doc_hash": "4bad44c35abca7ed10152749b2c450a9ee9968e1787979ddcc6797719e641975"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_autouse_fixture_with_parametrized_fixture_conftest_conftest_TestFillFixtures.test_autouse_fixture_plugin": {"doc_hash": "53bd1f2ee26959ca15a9a872903e7c1f6e43ef929ca982828b68a7ca24a66114"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_funcarg_lookup_error_TestFillFixtures.test_fixture_excinfo_leak": {"doc_hash": "15c77af2cef71301717726d3bccb68ebb4f0017d9d4a1622b9b5fcd8f1662971"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic_TestRequestBasic.test_request_contains_funcarg_arg2fixturedefs": {"doc_hash": "6fd5d9cdae91a9bd5bcb5206cdc2cfbf87c5df2cc810023641c1358b711b3645"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_garbage_TestRequestBasic.test_getfixturevalue_recursive": {"doc_hash": "562d16b236108ef8b07cdb10e2e9bd1f8223e15e07b4f5a44a860187794af3ee"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_getfixturevalue_teardown_TestRequestBasic.test_getfixturevalue_teardown.result_stdout_fnmatch_lin": {"doc_hash": "156d44e502d9eaddabb40ea7759f77c6feb3da8d08386235fa8011383f35ed5d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_subrequest_addfinalizer_exceptions_TestRequestBasic.test_request_subrequest_addfinalizer_exceptions.result_stdout_fnmatch_lin": {"doc_hash": "107b9337614b1240010a125d38c35812b37332ee2cf5b221dc6d9ea7c77ddc31"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestMarking_TestRequestMarking.test_accessmarker_dynamic.reprec_assertoutcome_pass": {"doc_hash": "3448dc8cb22b590c65fe84a5213757c15848d96e5ec2285ff9f9d612b4d4c7b3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories_TestFixtureManagerParseFactories.test_parsefactories_conftest_and_module_and_class": {"doc_hash": "35e2092be93455fb8625c2a3f2e8d6d4beb3f1b33506c2acd141428d113d5c5e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_parsefactories_relative_node_ids_TestFixtureManagerParseFactories.test_parsefactories_relative_node_ids.with_runner_as_cwd_": {"doc_hash": "b1544efc9eec7ad00bf382c81d2ce9131138adc335507fe43d64be146b3e5c1b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_package_xunit_fixture_TestFixtureManagerParseFactories.test_package_xunit_fixture.reprec_assertoutcome_pass": {"doc_hash": "41b893d53a5d1e5c053e2df532409d23092af5b522211e4c8859107c6dec54b1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_package_fixture_complex_TestFixtureManagerParseFactories.test_collect_custom_items": {"doc_hash": "b14a81805537c8ebb91f5bdc913fe9295b474fa183af5da089674d14968b9aac"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseDiscovery_TestAutouseDiscovery.test_setup_enabled_functionnode.reprec_assertoutcome_pass": {"doc_hash": "ccca91f52da2310566b817c2c084cbb459c1266d1d59a0670a02316503a92efd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseDiscovery.test_callables_nocode_TestAutouseDiscovery.test_autouse_in_module_and_two_classes": {"doc_hash": "834793e9bdd8070bbf5f3776a671de21b71bb7fa53248546983f3dc272e06909"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement_TestAutouseManagement.test_session_parametrized_function.reprec_assertoutcome_pass": {"doc_hash": "0dd2d5092ba8cbabe70ae90766822fb14b8e90db9e851133432ae32934332f58"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_class_function_parametrization_finalization_TestAutouseManagement.test_class_function_parametrization_finalization.assert_values_fin_a1": {"doc_hash": "bea4623a3ab6a69a5cddba20db4c4cf8d4dab362c9aa3134d64ce06b0b9d0b99"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_scope_ordering_TestAutouseManagement.test_parametrization_setup_teardown_ordering.reprec_assertoutcome_pass": {"doc_hash": "d678847a17135c08a56ac1ff83eed267b9513bba0af72d147f570bed88badab8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_ordering_autouse_before_explicit_TestAutouseManagement.test_ordering_dependencies_torndown_first.reprec_assertoutcome_pass": {"doc_hash": "44c2f6f470402850062274cddecc80d1fe7ebc997cfaa9dcbe4d3ae8121c0ed6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker_TestFixtureMarker.test_scope_session_exc": {"doc_hash": "96032478e1e58a688baf85c9a42f923da9b2aebac489d541ca226b2f47c9762b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_session_exc_two_fix_TestFixtureMarker.test_scope_module_uses_session": {"doc_hash": "889bdae6956d587b4f071e1778852e3f235bf1c1f5d7b875bfc43851ee12cac4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_module_and_finalizer_TestFixtureMarker.test_scope_module_and_finalizer.reprec_assertoutcome_pass": {"doc_hash": "62572dc30a3ab49ef8ad7d5e64ce9c48538c5848100b2e6b268c1bc3615b6d05"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_module_parametrized_ordering_TestFixtureMarker.test_module_parametrized_ordering.result_stdout_fnmatch_lin": {"doc_hash": "d6f5a4251152cfbad7eab55b1f6643c13b73c3675ed652e36484737d893b32eb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_dynamic_parametrized_ordering_TestFixtureMarker.test_dynamic_parametrized_ordering.result_stdout_fnmatch_lin": {"doc_hash": "06c84621460cc3560f3e75c94ee017a7da601c23866cc6d876066fc6b6408ab4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_class_ordering_TestFixtureMarker.test_class_ordering.result_stdout_re_match_li": {"doc_hash": "8bd9f834b8036725461c7ab33de39170eb529411ab33e175f63d453313091bbb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_separated_order_higher_scope_first_TestFixtureMarker.test_parametrize_separated_order_higher_scope_first.assert_values_expected": {"doc_hash": "5fd7622549fb865f07a693e72985c0094c7cb4da8e33b24ae63bf76bb3291b28"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_fixture_finalizer_TestFixtureMarker.test_request_is_clean": {"doc_hash": "91a44f07f661f0beb666c9dc26362174141213098b55d4de6f18370b2867473a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_separated_lifecycle_TestFixtureMarker.test_parametrize_function_scoped_finalizers_called": {"doc_hash": "19e4ac2eaba4c5e7d283c7c2264b5cde86f9c69138edc8051fe88da768289c38"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_finalizer_order_on_parametrization_TestFixtureMarker.test_finalizer_order_on_parametrization.reprec_assertoutcome_pass": {"doc_hash": "fc9f8e5f8db14f28a3dc65ea69e8dfb6db75ef611e7c2939307372d105762622"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_class_scope_parametrization_ordering_TestFixtureMarker.test_class_scope_parametrization_ordering.assert_values_": {"doc_hash": "f75af01ee95b0cd591b423aa5b68a497c3b2acfe6641f6c5d100c0097f45cad9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_setup_function_TestFixtureMarker.test_parametrize_setup_function.reprec_assertoutcome_pass": {"doc_hash": "167691f55d40754df6e2358ff196e1e4ee81875f3d1aca62d763812bf5fa0abd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_fixture_marked_function_not_collected_as_test_TestFixtureMarker.test_params_and_ids_yieldfixture": {"doc_hash": "fb6d337282113b4f8d4527d13cdd38f89acc1023cfe3d6ba4fdb9bf38c8fa45e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_deterministic_fixture_collection_TestFixtureMarker.test_deterministic_fixture_collection.assert_out1_out2": {"doc_hash": "0af079e4b0e1128139a855fe92d91d3861678cde1cef63c2abe982c0899ac729"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestScopeAccess_TestRequestScopeAccess.test_funcarg": {"doc_hash": "6536c68708bdd37644e17202f7f6712d052b33bfab085d4983eec71aa6be3d7d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestErrors_TestErrors.test_setupfunc_missing_funcarg": {"doc_hash": "4a493b46b88b7b912c486b212a5695b0cd13423924a9de70618201e6fb1953ac"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures_TestShowFixtures.test_show_fixtures_indented_doc": {"doc_hash": "44df91dd061a0263d06a5902084ef715907e749c6ff36c1483e2eeedff0f889d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures.test_show_fixtures_indented_doc_first_line_unindented_TestShowFixtures.test_show_fixtures_different_files.result_stdout_fnmatch_lin": {"doc_hash": "95acf1c7627584a7b3d580e6a30fb28e85fca7b8831670f9dc1bd1064507f568"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures.test_show_fixtures_with_same_name_TestShowFixtures.test_fixture_disallow_twice": {"doc_hash": "daf330f29ad2efbf291f5a4aa638c2f7fd4171925f56803ca1ff6a529b5f9cfe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestContextManagerFixtureFuncs_TestContextManagerFixtureFuncs.test_custom_name": {"doc_hash": "8bc056574a236fe3aa6f6a38c82c320dd7d832e732b3582d2efc108563d6f0a9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestParameterizedSubRequest_TestParameterizedSubRequest.test_external_fixture.result_stdout_fnmatch_lin": {"doc_hash": "2aa48070d89e1474eacab0ec0e481db5a20e37b9ac81d3d784a7eb7d83d439f0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_pytest_fixture_setup_and_post_finalizer_hook_test_pytest_fixture_setup_and_post_finalizer_hook.result_stdout_fnmatch_lin": {"doc_hash": "87788d73f3158d837e70188d33a8d3ba800a7f534d4791317e33d315bc8cf7a6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering_TestScopeOrdering.test_func_closure_module_auto.assert_request_fixturenam": {"doc_hash": "7692c0f9e72e869b31c847331ad9caef6b25cb36da5d391513627c957b24fd9f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_with_native_fixtures_TestScopeOrdering.test_func_closure_with_native_fixtures.None_2": {"doc_hash": "49ad53267b6fab2f132d535bedf73ec3e54bf6b054f852ef6451910a2558462c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_module_TestScopeOrdering.test_func_closure_scopes_reordered.assert_request_fixturenam": {"doc_hash": "344b0d939d15ec443c26b2b0832e9571361f12486b04ded3c1ba89f22c22ea02"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_same_scope_closer_root_first_TestScopeOrdering.test_func_closure_same_scope_closer_root_first.assert_request_fixturenam": {"doc_hash": "a8913776ee14cabf12be992b175e8e5db39067e3d952f1361b1f7630381afb6d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_all_scopes_complex_TestScopeOrdering.test_func_closure_all_scopes_complex.assert_request_fixturenam": {"doc_hash": "7e1a5a57388d98c59947097469dbea9689c73f5ed5ccf33ee0719f6f041fe592"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestOEJSKITSpecials.test_autouse_fixture_test_wrapped_getfslineno": {"doc_hash": "ca7445bedf136e568c1dbe65f3726e21ce28db5cfa35d17229ceb3943182fd6c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration_TestMockDecoration.test_unittest_mock_and_pypi_mock": {"doc_hash": "b2330c0b8f6ae864cde040e1245e2147adf1cf6b72be7286118855ebffc9f708"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_TestMockDecoration.test_mock.assert_funcnames_T_t": {"doc_hash": "a7459cf6465b40814f740b8f076d9af7744dd1d54be5663e67979785c4e9a756"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_sorting_TestMockDecoration.test_mock_double_patch_issue473": {"doc_hash": "6006cacf146ad30ada66a9e2acf6ea529c802a09a0d558ee2e071cf8113b8ca3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestReRunTests_test_pytestconfig_is_session_scoped": {"doc_hash": "9b83d029cf0b44f0df85229738bccc288d4a92bdfe32ee8c1d8b66f25c4fc8ec"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestNoselikeTestAttribute_TestNoselikeTestAttribute.test_class_with_nasty_getattr.assert_not_call_items": {"doc_hash": "aa1c0b0a79fa99910f39aa333937ed18f5490772f1bf260be4053140d0fdcde5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestParameterize_": {"doc_hash": "82061cd1e90ad2ee91555d3babe8fa08e6ed5254814efa8c1499e039fafad377"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_find_parametrized_scope_TestMetafunc.test_find_parametrized_scope.None_12": {"doc_hash": "3e0020ca93773a91240790c1543a5307d27de999f8fc5feefa7180323fa950c8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_native_strings_TestMetafunc.test_idmaker_native_strings.assert_result_": {"doc_hash": "064531032726ee222e58bfbad86be75ee0e7211dde1d5d36cd69cbfce66a3ffb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional_TestMetafuncFunctional.test_attributes.result_assert_outcomes_pa": {"doc_hash": "7f63397859dfb2e142f11a39397562e82531e592d5a9405dce0160564c18a756"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_generate_same_function_names_issue403_TestMetafuncFunctional.test_parametrize_misspelling": {"doc_hash": "4bb70c50eaa4c8c555920f60a6325026049e1cc2d1ac622da39389c159b7aa1a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto_TestMetafuncFunctionalAuto.test_parametrize_all_indirects.result_stdout_fnmatch_lin": {"doc_hash": "85b51d20c821e09dff71830290396be3ee049733625326d1964a98c47651f8bf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto.test_parametrize_some_arguments_auto_scope_TestMetafuncFunctionalAuto.test_parametrize_some_arguments_auto_scope.assert_class_fix_setup_": {"doc_hash": "7170ecce8b810611f7bf0ead59856ea0e38adae1fc9f35963f45c180b0aa752f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto.test_parametrize_issue634_TestMetafuncFunctionalAuto.test_parametrize_issue634.None_1": {"doc_hash": "b2e01b024783ebb0be60e87ec57d6cfd316bb520612ba8e535f029e9b68563dc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_should_show_fixtures_used_by_test_test_should_show_fixtures_used_by_test.result_stdout_fnmatch_lin": {"doc_hash": "71d05176cb77e29ca9435fada2d38ed2dc97403fef5729fe2a6760b6fa6447c3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_verbose_include_private_fixtures_and_loc_": {"doc_hash": "858e7adf89228af5dd3d1ebee58f2ea2604cc58ecc36fe5f866b5943f2d64d27"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_FilesCompleter_FilesCompleter.__call__.return_completion": {"doc_hash": "736ec478818cadba405527340bde615dfdefc2ecfe685de59e872a8bf7e77cf8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_TestArgComplete_": {"doc_hash": "9bd96d07d9efc42fb8aad02195431f1cb65964ceb4529f6962d311d70d2e0ac0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_installed_plugin_rewrite_TestImportHookInstallation.test_installed_plugin_rewrite.result_stdout_fnmatch_lin": {"doc_hash": "cedf42dd4f7cadc02fe7285ee952077deb43eeea41e5f8021a696d007e043b4b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_iterable_full_diff_TestAssert_reprcompare.test_iterable_full_diff.assert_expl_endswith_text": {"doc_hash": "c54f4aa19007d6c40efc0db31acdb094f25de7f3db3a13726b721975d06f547d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_different_items_TestAssert_reprcompare.test_dict_different_items": {"doc_hash": "4a29cce58fef38140b8a53aae8f307946f0ddeaa3a82ffb7de0ec846dcca9413"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_dataclass_TestAssert_reprcompare_dataclass.test_comparing_two_different_data_classes": {"doc_hash": "2910c35589c9f19e4e12a78e6ce55b294a63967d46f2c51d5480ff5dbda70a78"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_attrsclass_TestAssert_reprcompare_attrsclass.test_comparing_two_different_attrs_classes": {"doc_hash": "a2e65b5d8943641fc57c332bb813c12e068d8dbfe24dcf2e02a74529b1d1a8be"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestFormatExplanation_TestFormatExplanation.test_fmt_multi_newline_before_where": {"doc_hash": "7252df6bb86d8d0889a588bb859e844a5b871a4c6c4bde9f3ec40e05a9ea6783"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestTruncateExplanation_TestTruncateExplanation.test_truncates_at_4_lines_when_first_4_lines_are_GT_max_chars": {"doc_hash": "96fd9922f972aef5f6fbb8bb74501bd6a13c6511603d22b57b4584e6e5ca7393"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestTruncateExplanation.test_truncates_at_1_line_when_first_line_is_GT_max_chars_TestTruncateExplanation.test_full_output_truncated.None_5": {"doc_hash": "59ec91d41955983162e4f8613ca9bc48074878028013a48811825a59f45397a3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_python25_compile_issue257_test_sequence_comparison_uses_repr": {"doc_hash": "9380c3762e3e115b8ab8ec35f9b88ebc544296f3074d32727fac4f73ebba6898"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_assertrepr_loaded_per_dir_test_triple_quoted_string_issue113": {"doc_hash": "d619a6c11a739e357ce42f8d5a09f9cb7fea2d2024bd33c0fe54ac82990d9053"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_traceback_failure_test_traceback_failure.None_1": {"doc_hash": "5ddfc461c3b45a4c81d6d1ace5b53f9300ce2a5d29c7ec98bcfafe786a4679cc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite_TestAssertionRewrite.test_place_initial_imports.None_9": {"doc_hash": "6de5eb96314cea0b83e611c266366ddbbb3da5783ee813e01e515e25a290ba21"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_short_circuit_evaluation_TestAssertionRewrite.test_starred_with_side_effect": {"doc_hash": "334d25eeda4c7861c53f6cd848e9902d1e6b558206db856a81cb0b57e2ceb68e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_call_TestAssertionRewrite.test_call.None_6": {"doc_hash": "e74c7ab8d9d0c9b59359aca0a85f0760116159ba4ff666cc65e2afff2ff87bb3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_attribute_TestAssertionRewrite.test_formatchar": {"doc_hash": "db02655998e305d3239b66be67431643387dbd57fedf1835524b3f54c1326094"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_custom_repr_TestAssertionRewrite.test_custom_repr_non_ascii": {"doc_hash": "b85fa939a6d0b132b5eb17521d0480a3c62031a297eb31ac39fa511e0c973a80"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_issue731_TestIssue925.test_many_brackets": {"doc_hash": "b196b337eec98fd93e293de201c01be56c791644a1985ff73d9b47b859cdbc0f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestIssue2121_test_source_mtime_long_long": {"doc_hash": "81f61178a08f6c751df3879db0f5c6d0b16472e8e76fdae70e3477f4c2b58b9e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_rewrite_infinite_recursion_test_rewrite_infinite_recursion.assert_len_write_pyc_call": {"doc_hash": "6fca7edfae0201347a631b08e0c368015ee3c728ff7f1836cd2ff87e5cc5b53b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestEarlyRewriteBailout_TestEarlyRewriteBailout.test_basic.None_7": {"doc_hash": "865600cc9d7d326b9b76cc08e75958e8bf963536b64f8f18d228d909b23257d9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_test_cache_reportheader_test_cache_reportheader_external_abspath": {"doc_hash": "d547f57a7e79f288042478c5d4d1740617e276178d4e5f76b8f9b6e642495308"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_test_cache_show_test_cache_show.None_5": {"doc_hash": "132718eaa34722c72afd61e89d48ab3c1cd1fd0d40dd747b979bfd7bb5680b7c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed_TestLastFailed.test_lastfailed_usecase.None_6": {"doc_hash": "cd935bdca1cca238ac37471fb7e294e66dbabf32a2d8c6ed32f213b2bcf7f1b5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_failedfirst_order_TestLastFailed.test_lastfailed_failedfirst_order": {"doc_hash": "96bdfba706948ca8eac09ce1254350ce55ab0e8cf419a43c575f874e1280ad6c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_usecase_splice_TestLastFailed.test_non_serializable_parametrize": {"doc_hash": "5fcd275a1c143ceaacefa44d31848e378fa9bc3d63045ecdabc59cb0270d14e2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_terminal_report_lastfailed_TestLastFailed.test_terminal_report_lastfailed.None_4": {"doc_hash": "c109e289e35c76d4aed4621aa8186d28a33b77341cddcf75239e0933733ce7af"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_terminal_report_failedfirst_TestLastFailed.test_lastfailed_collectfailure.None_2": {"doc_hash": "68e8f2ea83adb62c1f5cef097942d66eb4aca1efc9b79010f93c4f25b4815f35"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_failure_subset_TestLastFailed.test_lastfailed_failure_subset.None_3": {"doc_hash": "8588a55b0d871ddc7670029782be1497cf7f193fdb4efade0bcd1f5481875d0c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_creates_cache_when_needed_TestLastFailed.get_cached_last_failed": {"doc_hash": "76762ed11f66ec9158ebb093f01ed737e4da2a363de0915e4f4feb7d01e07964"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_cache_cumulative_TestLastFailed.test_cache_cumulative.None_4": {"doc_hash": "01ed68aba9c5655e44a076a053481759befde0ba796ff2349c32553ca74bea74"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_no_failures_behavior_all_passed_TestLastFailed.test_lastfailed_no_failures_behavior_empty_cache": {"doc_hash": "e1320685a95a95fd649b1f027be878a892735a6d1cc75d5f4d0a488b9708d8ae"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_skip_collection_TestLastFailed.test_lastfailed_skip_collection.None_4": {"doc_hash": "0b8e863a3f3d22184d39e85e07a1b13126d07319af26948cea73b62bc68f3182"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewFirst_TestNewFirst.test_newfirst_usecase.None_6": {"doc_hash": "f22965d06838fd9fda22401b1e6407bc56d843a241108eae193919c806a2a8e9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestReadme_": {"doc_hash": "2645f93bbb5094905ad1e9ef2ba0a313bfe012219a64b3dd74a53a18b4e0700b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capturing_unicode_test_collect_capturing": {"doc_hash": "53f4d4c62cd4227122b6ea5a3fba61a70023fcae19333fcd27baee821b52fc0c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestPerTestCapturing_TestPerTestCapturing.test_capturing_outerr.result_stdout_fnmatch_lin": {"doc_hash": "d790b16e1cd71b3ddecc90ea144bfbaae9f40f0d66d37d1709d1bade629664ca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestLoggingInteraction_TestLoggingInteraction.test_logging_after_cap_stopped.assert_": {"doc_hash": "f9d790e5fd21ba6abbe6f9dbf7323624f7923868cfc7bbd3e7c58afa81e7206b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture_TestCaptureFixture.test_stdfd_functional": {"doc_hash": "3ca1d570bc7a3356bd19122682b51194b3c3a28abf5d048303645dfaa528de18"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_disabled_capture_fixture_TestCaptureFixture.test_disabled_capture_fixture.if_no_capture_": {"doc_hash": "02463b101b702ba2ae22a63316238425ac162a83d6350598c58bb7a73e608ebc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_fixture_use_by_other_fixtures_teardown_TestCaptureFixture.test_fixture_use_by_other_fixtures_teardown.reprec_assertoutcome_pass": {"doc_hash": "d202811421818dab1d9cbc76895b2bd03744f881c9c0a74a63d0c17db23772fa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_setup_failure_does_not_kill_capturing_test_error_during_readouterr": {"doc_hash": "a1a04b369d08d6cd9734daae9f62da7c7234f842741518e4aadfb34e2900276b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestStdCaptureFDinvalidFD_TestStdCaptureFDinvalidFD.test_stdcapture_fd_invalid_fd.assert_result_parseoutcom": {"doc_hash": "0fd9530589a0dcdc9a9e6e4a38946b5c6bea47a314f7096efeb33e4a79217487"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capture_not_started_but_reset_test_close_and_capture_again": {"doc_hash": "5c2ded0f9dbc0ede8be63a1fede730537239d32591f41ee02522717d0891db6f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capturing_and_logging_fundamentals_test_capturing_and_logging_fundamentals.assert_atexit_not_in_re": {"doc_hash": "965747b8bde4ead7cdc7eda35dfa6abc79f27a1679c69c78dfba9a344d9df671"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_global_capture_with_live_logging_test_global_capture_with_live_logging.None_7": {"doc_hash": "11c109e540ec7eb53e0eecd3be6680924a0c93bc421b880c2ea1f90f198ade07"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capture_with_live_logging_": {"doc_hash": "0c4a1f9076dab0749ca45e05b15b988f656237f7fc93232c2538589169e836d8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollector.test_getparent_TestCollector.test_can_skip_class_with_test_attr": {"doc_hash": "05cf1e95d22d6f8d76f66f69156ea49cb15c7da71ed74620effb4be245ddd83c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test_ignored_virtualenvs_norecursedirs_precedence_TestCollectFS.test_ignored_virtualenvs_norecursedirs_precedence": {"doc_hash": "fb3095e20cf4e2d357e5bcaa33507295728dd9480c749bc601afbce5f59373b7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test__in_venv_TestCollectFS.test_custom_norecursedirs": {"doc_hash": "fb039131c85d21795a702e4f27bacec1b3195c56b0c0b6c58f2758d9b1836b6b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestPrunetraceback_TestPrunetraceback.test_collect_report_postprocessing": {"doc_hash": "48afb9498c14000294e10efc6125b7181024d6b46aacbcec50dc21ce9c59f393"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCustomConftests_TestCustomConftests.test_pytest_fs_collect_hooks_are_seen": {"doc_hash": "02f5bf13cff9e8ca9660bcbe5cdf8117bed1b8bae805df0de33fe64a6d0ed590"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCustomConftests.test_pytest_collect_file_from_sister_dir_TestCustomConftests.test_pytest_collect_file_from_sister_dir.result_stdout_fnmatch_lin": {"doc_hash": "7f55c28752dfc9cec4f53b40a1d461d784f36a36ac9a8439dc079b96bc5cafc1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession_TestSession.get_reported_items": {"doc_hash": "c9a9a4ca45db1fa02656cea0d45c95b875acd1b0d1f586bfe8c5845f39fc9e67"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_protocol_single_function_TestSession.test_collect_protocol_method": {"doc_hash": "c989be5336dfe69d89b936a7ed5b5bd1c4f646b6bb683d4b05b66f614a06cda6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_custom_nodes_multi_id_TestSession.test_collect_custom_nodes_multi_id.assert_len_self_get_repor": {"doc_hash": "f5b682704cc25d8fda83f69a97fc26675b401832ca38ca97f4a658d50d2a49c7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_subdir_event_ordering_TestSession.test_collect_two_commandline_args": {"doc_hash": "2dc6deae4966d993fa59612f7d204dcf89779b7311eabbf8af64855780d0e638"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_serialization_byid_TestSession.test_find_byid_without_instance_parents": {"doc_hash": "8a52dc99dabef105ef894acf3950795e9aa52f5ccfe2925032b7e8fc641efbf2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_Test_getinitialnodes_Test_getinitialnodes.test_pkgfile": {"doc_hash": "cccac7dc70d21dbd9d407d71cb5e9a337b31435f1300b4846dfb07ec7c26cc71"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_Test_genitems_Test_genitems.test_class_and_functions_discovery_using_glob.assert_ids_MyTestSui": {"doc_hash": "ba8fcf7251e14662ac64454a37e883581c90c497599d1d6f78a774705c3ae5cf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_matchnodes_two_collections_same_file_test_matchnodes_two_collections_same_file.res_stdout_fnmatch_lines_": {"doc_hash": "c4fc1eafff85105f1d56e35184f4cc440c0ff3e5b165767cd158f3a41596a1df"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_invalid_signature_message_test_collect_handles_raising_on_dunder_class": {"doc_hash": "ed04f336c85a4622cfdb20f1a87a74543bc73e56b4fbc33cdad711ab149c1178"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_with_chdir_during_import_test_collect_with_chdir_during_import.None_4": {"doc_hash": "95dcdb28ed4e7858d37d84c75deccd51217ef87612cbbaaa977ebf3a937bc900"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pyargs_with_testpaths_test_collect_symlink_file_arg": {"doc_hash": "bb55316bffd689dbee2deb29d54021cd62dacd329e18fe622a23034c20cf37ce"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_symlink_out_of_tree_test_collectignore_via_conftest": {"doc_hash": "88898591bcc9869a44a1c233eb2e94a8ff2825f837ab7f9de9d0b73fbcfeed89"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigCmdlineParsing_TestConfigCmdlineParsing.test_absolute_win32_path": {"doc_hash": "50b147501de0e8d758c0b1c5d1ee36f18261a347b83521544463098228e276c4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI_TestConfigAPI.test_addini": {"doc_hash": "89d0d279c783f807fc0e3323de94d928ce91523c6a2ad28282e019d374562a62"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI.test_addini_pathlist_TestConfigAPI.test_addinivalue_line_existing": {"doc_hash": "94614a7ecb52e42eb19e466fb3f363a42eb3901262ef59eb154188ebb24bc762"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI.test_addinivalue_line_new_TestConfigAPI.test_iter_rewritable_modules": {"doc_hash": "6f89edcc03774b9fdfd297da800f42160fb66557df9f2cd51a5eac9c1f22cdfe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigFromdictargs.test_inifilename_TestConfigFromdictargs.test_inifilename.None_5": {"doc_hash": "f0d9a0d134ce56600f4c02254922da95c3cc45814c72f9dc8c8a1869d09c8fd8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs_TestOverrideIniArgs.test_override_ini_pathlist": {"doc_hash": "6cebab1ebbe6e8c9bafa65ee03ad66e63bda71484bd9a01d64f28e75a7632abc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_override_multiple_and_default_TestOverrideIniArgs.test_override_multiple_and_default.result_stdout_fnmatch_lin": {"doc_hash": "1d5004edd28ab68472b66d76c3ff11178d5e855e2525ba9dc35f463445f2e1e3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_multiple_override_ini_options_test_help_via_addopts": {"doc_hash": "183e607249f3e83776d779f1f014a4a71a814940b609026cd0abec25c1a13a15"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_in_nonpkg_with_init_test_issue151_load_all_conftests": {"doc_hash": "47026212871ede36466bf40c5f8ae1a1cb9abc0bc1a09503ae9638076eec2859"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_global_import_test_conftest_global_import": {"doc_hash": "4ba1dad3d1dd950c3b33e230b1bbecf1b823bc9238cd10cb8d4254261e67fcfc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftestcutdir_test_conftestcutdir": {"doc_hash": "a84766f8c616c64d5b1444eb62dc8434dd06b93e01e7b5d7387fcce7876b7548"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftestcutdir_inplace_considered_test_conftest_confcutdir": {"doc_hash": "d6b04705445b7967b753790fd8c11b7f04df52addce5c1f991282d9990c68771"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_symlink_test_conftest_symlink.None_2": {"doc_hash": "f01d263a282481800a8564678e47eef2513afd9a524c88745a3b183f28a31eee"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_fixture_dependency_test_conftest_found_with_double_dash": {"doc_hash": "785bd348a41c587d2daf8b7940ad1df50aa5ae27794b21025e2c9a35f16c118e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_TestConftestVisibility_TestConftestVisibility._setup_tree.return_runner_runner_": {"doc_hash": "315ade435762dcb5628e5019607e4bdafc2b55e97b5b967277aec2a25c709f04"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_TestConftestVisibility._N_B_swc_stands_for__TestConftestVisibility.test_parsefactories_relative_node_ids.with_dirs_chdir_as_cwd_": {"doc_hash": "71129796ed4a3fa16080dbceed19acbac3a4b2572c33dc6b1cb2d8d40dd885dd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_search_conftest_up_to_inifile_test_search_conftest_up_to_inifile.result_stdout_fnmatch_lin": {"doc_hash": "b23649e0544755a46619bbfef1f81721a5319ead9ecb7703b102276a8105ec6b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_issue1073_conftest_special_objects_": {"doc_hash": "8545bc8a1e6f2fb28509ce30b5429b18c06bc87c871fc8663ea988706dc92a51"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_new_pattern_TestDoctests.test_multiple_patterns.None_4": {"doc_hash": "fb12a063e7db290d18656ebec7f0cf26caa7ac42954a99e4cb9a557c81d52dba"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals_TestLiterals.test_allow_unicode.reprec_assertoutcome_pass": {"doc_hash": "2bd2fe10bb47f1e5fcbc43df060eb56630ff5f11d343e3f6973e0f1ec97d1926"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestSkips_TestDoctestSkips.test_continue_on_failure": {"doc_hash": "c854e106bdfea08e70879a91d0eda6aed1616f8ad2a3050fb598cd4803377f94"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures_TestDoctestAutoUseFixtures.test_doctest_module_session_fixture.result_stdout_fnmatch_lin": {"doc_hash": "eb015988340d62ba0fb9e11bbb3a66d88a79f003414eecd9f5a25cabb287947c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_fixture_scopes_TestDoctestAutoUseFixtures.test_fixture_scopes.result_stdout_fnmatch_lin": {"doc_hash": "4f576cf39d566693fe8793d1b0933f54f41e9b784ca54200ef8d902a8d84d6be"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_fixture_module_doctest_scopes_TestDoctestAutoUseFixtures.test_fixture_module_doctest_scopes.result_stdout_fnmatch_lin": {"doc_hash": "3b25c955bb844a070eb9422e3d5026c868bda84d55505c565191f428ae301ee0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_auto_use_request_attributes_TestDoctestAutoUseFixtures.test_auto_use_request_attributes.result_stdout_fnmatch_lin": {"doc_hash": "1b34ec3656ace62919cbcf6b08b5dde4a2590a23e3fea91d5c687b0b848ff5c3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestNamespaceFixture_TestDoctestNamespaceFixture.test_namespace_pyfile.reprec_assertoutcome_pass": {"doc_hash": "6f40551acc5ca77827ce06e2eca9c09e82ebb5aa84b81299e414a44629b08b7b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_entry_points.py__": {"doc_hash": "965a21b93fa9f238e5789c59f967be15e993f33c57a2ae32258d2210972b94fb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython_TestPython.test_timing_function": {"doc_hash": "f696ddddb74c1e577478d23860f20913650c9dab34ea0ab6ef1b8c990164a24f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_junit_duration_report_TestPython.test_junit_duration_report.if_duration_report_to": {"doc_hash": "f1536e95f7e64a8ca9d1b9611f1b469e90e61bb3329c11584702cafeb30f5a4e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_TestPython.test_skip_contains_name_reason": {"doc_hash": "82421773c1e84349763bb8acc280da3c5e3e5754cab2c21ed388f0eba59afd02"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_mark_skip_contains_name_reason_TestPython.test_classname_nested_dir": {"doc_hash": "118a103383d9c79957132530abe149f8bb57f257bb8c8db7735c8bcb58028b05"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_mangle_test_address_test_dont_configure_on_slaves": {"doc_hash": "a36cac469c990ba909decfc5db0df9074e8722e988aa689af8e2c486f085d237"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestNonPython_TestNonPython.test_summing_simple.assert_custom_item_runte": {"doc_hash": "59ee0a42fec1aeb9b66e760b1cec5c7029e4a27cbc75d0595ac0b24d78c4ded2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_nullbyte_test_nullbyte_replace": {"doc_hash": "d81668ddaa14005cd10a45722479d1bec3d77147dbadce426ac18f93f6a16186"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_invalid_xml_escape_test_invalid_xml_escape.for_i_in_valid_": {"doc_hash": "13d95b6d8f36d2b2a0346098b72fa01ce03dfc9ac3aade01eebca6a7351eaf82"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_logxml_path_expansion_test_double_colon_split_method_issue469": {"doc_hash": "a3d3421aa71b91f672f29f1ce68cb18f5d4cd0e96e2758fe60e885cfa7f08188"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_unicode_issue368_test_unicode_issue368.log_pytest_sessionfinish_": {"doc_hash": "5402eabc00828bf59093872d22def0a785e3806fb1de02c2e94977efdba2beb1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_record_property_test_record_attribute.result_stdout_fnmatch_lin": {"doc_hash": "95a91b2074cbcf96c702b90ff46bbb190a29f3011bab843229e45ad8452e85ed"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_record_fixtures_xunit2_test_record_fixtures_xunit2.result_stdout_fnmatch_lin": {"doc_hash": "c3b4d9931a4e386da04b94f0dd74527f6dff2bbf7f2272bfbf51c24889408e71"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_random_report_log_xdist_test_random_report_log_xdist": {"doc_hash": "9aa82e924aa5c180dbb83738b3b5e7b976c25b3f600196ffdc736299e7111818"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_fancy_items_regression_test_fancy_items_regression.assert_items_": {"doc_hash": "ffbfa435603875c175ba3f93c3a27886bb8d071bb64a1a6d6690afd600be5f36"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional_TestFunctional.test_mark_closest": {"doc_hash": "1f2a9a67dd7cf10effb4ebeae8982cdd6291da4060422804869d2d02674396c4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestKeywordSelection_TestKeywordSelection.test_select_extra_keywords.assert_dlist_0_items_0_": {"doc_hash": "ee79c5ff5a55a5f64b98858979303ff99ddfccea38c2e96e28ee749c35f4dcbc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestKeywordSelection.test_select_starton_TestKeywordSelection.test_no_magic_values": {"doc_hash": "f13fde771dab8fbbe105d4a6219b5c8164c37f6f5f88929f5aeded1ea6226b33"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestMarkDecorator_test_parameterset_for_parametrize_marks": {"doc_hash": "9c37a6b8fb03ed8a3472f7a0dd9e8bc3fe712c03fe530735c7a34248b4749fba"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_TestSetattrWithImportPath_TestSetattrWithImportPath.test_delattr": {"doc_hash": "8d07e4360c95eb3fca4f6b88be0e99097d8393116f41a4abb0382a57a0f5568f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_delattr_test_setenv": {"doc_hash": "ca75942832e84737d62fbe5d61bd1b10db2f47b72ddcd839d51dedbfc2ccd439"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_syspath_prepend_with_namespace_packages_": {"doc_hash": "73f1532f8aac13b385fdd7200ceb56a8f176f766959544c62dc0f081021e5ba2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_nose_setup_partial_test_apiwrapper_problem_issue260": {"doc_hash": "362d29a8c8d3054fb93eef8da24b8f6e16177790d81ad5d4c2c651d812497242"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_group_addoption_conflict_TestParser.test_parse_special_destination": {"doc_hash": "be20d2748bb79b47f64527581a4cb437ecaebfd2ee2b8082e0e3f1748051b756"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_parse_split_positional_arguments_TestParser.test_parse_defaultgetter": {"doc_hash": "51053539129ed8d2ce5f873547a54cb378516fc35a6a89ec0892705011463920"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_drop_short_helper_TestParser.test_drop_short_helper.assert_join_args_file": {"doc_hash": "1af14ed14b849bc074dfad17ec9bce40b5e7ed4f90a732c9664f0ad9d98062e3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_drop_short_0_TestParser.test_multiple_metavar_help": {"doc_hash": "c0491f31753a54107c2c42a9e8e69d1d5439900891117acc6dce2425bc7c5797"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_test_argcomplete_": {"doc_hash": "197f3bf2d7de4d4ff8b38d0592a8c49f500495dfebf11957dd46796965e9db74"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pastebin.py_TestPaste_": {"doc_hash": "47e35e352040ecc04a11a37895939f512a15b556406efd9dcf443de4516056b7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManager_TestPytestPluginManager.test_plugin_skip": {"doc_hash": "3a9399063c8822b96f7ac9963769990bc70a331b5a2614cd442364a809071c5e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManager.test_consider_env_plugin_instantiation_TestPytestPluginManager.test_consider_conftest_deps": {"doc_hash": "c0584d16534b2fa82196246db853550a88a23270d0197434152e3f6514c1836a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManagerBootstrapming_": {"doc_hash": "17f62f306035d9801466d33dfe0ad411d43b4bdc9ea1f4fd5141058d4999a8e9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_assert_outcomes_after_pytest_error_TestSysModulesSnapshot.test_preserve_container": {"doc_hash": "a362aba1f0c84ee24ee7d3bb1793f4c152596209b6bfcbe0dc6497c7ebc6de42"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_TestSysPathsSnapshot_TestSysPathsSnapshot.test_preserve_container": {"doc_hash": "689e803be5713fb22c29d911b042abbad3915b8b81682d8af3b4af2348b6f4f5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestDeprecatedCall_TestDeprecatedCall.test_deprecated_call_modes": {"doc_hash": "7331ca1afac1c50608adc84096b1478dfd6929bd88f062804a936960ead8617e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestDeprecatedCall.test_deprecated_call_exception_is_raised_TestDeprecatedCall.test_deprecated_call_supports_match": {"doc_hash": "30c25c8049ccb4c56aeb126ee611cc5c24f842f98eff067a60f047440a227bfc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns_TestWarns.test_warning_tuple": {"doc_hash": "2b4819f79a8f64bbc19cc0ecb3bc472350931c74580ba1e8f1c985c2657bf4a8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns.test_as_contextmanager_TestWarns.test_as_contextmanager.None_3": {"doc_hash": "66c4851db54dc021ef018c4cdfe52d7ffbadb24cb60915a903b34688806474fa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns.test_record_": {"doc_hash": "8a223eb403c57e422399da3c788f1e4fc2ae252ef870988cef9a8988ed7f38f7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_xdist_report_longrepr_reprcrash_130_TestReportSerialization.test_xdist_report_longrepr_reprcrash_130.assert_added_section_in_a": {"doc_hash": "cfe24a21526e7878bbea952a1fc378f0f22b39d9dcaa81100e1cef34b2532bd7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_reprentries_serialization_170_TestReportSerialization.test_reprentries_serialization_170.for_i_in_range_len_a_entr": {"doc_hash": "5b1b622ac93ff831ae0141f7b5715656c2f6c80b9a6f7eafc5d1b1abb4e28ad0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_reprentries_serialization_196_TestReportSerialization.test_itemreport_outcomes.for_rep_in_reports_": {"doc_hash": "c8794106ee9b3ca4495af39ba1e2576fb620079aaace478ad0a8fcec11d92f20"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestHooks_": {"doc_hash": "10fbb4f3a0615aff782ee807ba0327828094896e7fcc466290c4c997e2fda236"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_TestWithFunctionIntegration_TestWithFunctionIntegration.test_collection_report": {"doc_hash": "d59a7bdbb2da273069576dbb27461c12a3f47eabdcd00c0687f69cff5ca9134a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_TestWithFunctionIntegration.test_log_test_outcomes_TestWithFunctionIntegration.test_internal_exception": {"doc_hash": "858c8ac02320ca26422377e17d450d46b0338668f9b7f7c6acf4fb7ebeebe06c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests_BaseFunctionalTests.test_failure_in_teardown_function": {"doc_hash": "51283b2208a36bdae14e7400e814c4926a3e47114e7d25f61b945818094bf397"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_custom_failure_repr_BaseFunctionalTests.test_logstart_logfinish_hooks": {"doc_hash": "f534e444b98512a3324b010190ef36ace3bf2eb90fa3db36b7606ca8a45cdefe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_exact_teardown_issue90_BaseFunctionalTests.test_exact_teardown_issue90.assert_reps_5_failed": {"doc_hash": "a287c0b94875e2d0c133e01e0cf2d5e625d832252a80548d9621a23f46389775"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_exact_teardown_issue1206_BaseFunctionalTests.test_exact_teardown_issue1206.assert_reps_2_longrepr_r": {"doc_hash": "0dcb1d514b126d42b7fc4a78854eccc6b9c0d827839a0f27f2313b635fe8a07d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_failure_in_setup_function_ignores_custom_repr_BaseFunctionalTests.test_exit_propagates": {"doc_hash": "660e97472b4ffc0d4cc1f71b402d032489dfb0a8621d76e71c5c8d38c0d8e164"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py__design_question_do_we__test_runtest_in_module_ordering.result_stdout_fnmatch_lin": {"doc_hash": "b8cb795013282d2a968469ffde1a242448811564156dd93a198df27c5d8b246e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_current_test_env_var_test_current_test_env_var.assert_PYTEST_CURRENT_TE": {"doc_hash": "07761c885dd1737ca19fcc1fd4f10d08ef9cce2047133fa60778c09b0e86ab65"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_TestReportContents_": {"doc_hash": "bdcac3a662e43c30b219359adf065e0432fdee5afd456e3d9933015b474706f2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py_test_setup_teardown_function_level_with_optional_argument_": {"doc_hash": "7b78aa738be7fef757c0bb68479da0bc8e8f5c39def4dba12b90c17145171e4a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_nested_import_error_SessionTests.test_maxfail": {"doc_hash": "e4918c97d71e8d4e39c60dd04f7bef77196814d92fb3fe32ae9003e32bf90a99"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_broken_repr_with_showlocals_verbose_SessionTests.test_skip_file_by_conftest": {"doc_hash": "913b53e7b9d39a9a37990e03570607666ebb7bef0581c23c58451a6e7fa610a7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_TestNewSession_TestNewSession.test_minus_x_overridden_by_maxfail": {"doc_hash": "1edc9c6a5d8658a1ba2e6933780f6f2b098cd4d6d2da28707d90bc60fa501c48"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_test_plugin_specify_test_sessionfinish_with_start": {"doc_hash": "324945ad4744866a7db75868f8888b9dd65058a7f0585b99bf907a5a6825f79a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_test_rootdir_option_arg_": {"doc_hash": "cbc047b5e3991f668b6490a1b182be85c1218342738bcb2f591e929bab2647c0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail_TestXFail.test_xfail_not_report_default": {"doc_hash": "248aeda48d0ca4cf847d24fb777e5bad066c468304b360aca9b41df76b0ae37f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.test_xfail_not_run_xfail_reporting_TestXFail.test_xfail_imperative_in_setup_function": {"doc_hash": "8f3f79f3804998f6bd7e311c86082d16b2622d8a1f171893c561b95dd4d7b1c7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.xtest_dynamic_xfail_set_during_setup_TestXFail.test_strict_sanity": {"doc_hash": "a1588a097a1c55eab5e0ca6d24f879da8a6297307323c433c00299d20aa26e75"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.test_strict_xfail_TestXFail.test_strict_xfail_default_from_file": {"doc_hash": "a8eb23a9c02f1a78134e8453d1738abc06d62cd986dd3d7926fcd55c9becbaa7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFailwithSetupTeardown_TestSkip.test_strict_and_skip": {"doc_hash": "60417478b0fc92a580cd278406456156bca989e10377460328a8348f8d4f2ea2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestSkipif_TestSkipif.test_skipif_using_platform": {"doc_hash": "64214fbd954ee5cb41dd1706052a681a87a46e43024773b8bb3ffc949dd89c15"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestSkipif.test_skipif_reporting_multiple_TestSkipif.test_skipif_reporting_multiple": {"doc_hash": "7bf2847fc9744eaf27043811890763ee754c28609337d03f10b2c563283ec6f7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_skip_not_report_default_test_reportchars_error": {"doc_hash": "9b94e8bec0c2add892fd28e9c142c32e927eccd6f8856e1000b9dc44bf9a52b1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_reportchars_all_test_reportchars_all_error": {"doc_hash": "1c107a4f4e607541bafefba868ba735e52fed68ed70b0d1668bd1c175a75848e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_errors_in_xfail_skip_expressions_test_errors_in_xfail_skip_expressions.result_stdout_fnmatch_lin": {"doc_hash": "78550b0f4011174c53f4aced9de179d57dd610269e89895341c5f15b927943a5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_xfail_skipif_with_globals_test_imperativeskip_on_xfail_test.result_stdout_fnmatch_lin": {"doc_hash": "b30453509c287955f702c9e4340d2e30675325e1e76255a5f025b95516af8b1f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestBooleanCondition_TestBooleanCondition.test_xfail": {"doc_hash": "aa0d23833dd4f01662a72ffff9411ae862267863fad7d4f5709f277c357f2ca8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_xfail_item_": {"doc_hash": "b8b1af8ab83f2358e0411e37b1f787c537831e768c392813356fcbee4b91f0b9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_error_testdir_test_fail_and_continue_with_stepwise": {"doc_hash": "91afec76bc00dbe0639c86f7da513583a24ef54b3f80d1c031b8a5847f221b87"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal_TestTerminal.test_runtest_location_shown_before_test_starts": {"doc_hash": "e50a2d055392906d7fd4028c06d5d8ec4cdfbf012a4916825c7f338513ea5744"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestCollectonly_TestCollectonly.test_collectonly_more_quiet": {"doc_hash": "785486c7de8afb6cd18f7cef52b0b5af83be317f4fef2dfe1b444d68ffe1ec85"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestFixtureReporting_TestFixtureReporting.test_setup_teardown_output_and_test_failure.result_stdout_fnmatch_lin": {"doc_hash": "088d25a713a12254946afd99fd998d93da2b1a5cb98136b1ac57307c09959453"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional_TestTerminalFunctional.test_passes": {"doc_hash": "69e5fb36392e13949f569ce49e37ec48963afa9eb30df03b114895b3540a6378"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_header_trailer_info_TestTerminalFunctional.test_header.None_7": {"doc_hash": "5fbe8ae83a66c090fa5d9b03348a555947da8649a160232f0cf63093b21952c2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_fail_extra_reporting_test_pass_reporting_on_fail": {"doc_hash": "e743608a56ce1387ded0eefcd1afe21fd05f9cd62501e883e88a06453bf7fadd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_pass_output_reporting_test_pass_output_reporting.result_stdout_fnmatch_lin": {"doc_hash": "f0d823d8ca6c890ab3c26a0d84c19ad51141eda3f80a43f1d5ac72a8be8032ee"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_terminalreporter_reportopt_addopts_test_traceconfig": {"doc_hash": "2af291f8c23b96be273762555b1d380214477db5fc810d16cf68e8db2b393577"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_tb_crashline_TestGenericReporting.test_pytest_report_header": {"doc_hash": "bca3fd32cb45b625aa47fa51d77d3f0194437b9dfebfcfa236ac0aec88db6454"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_show_capture_TestGenericReporting.test_show_capture.None_11": {"doc_hash": "41c187e871aa85b6ecbaee51530f6f927cf99bce1b5f80eb55ae87526eb64913"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_show_capture_with_teardown_logs_TestGenericReporting.test_show_capture_with_teardown_logs.None_11": {"doc_hash": "6b0681368376238059dbc5671ce8b86e0f9282fec20b32cfb76c070f87c644bd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_fdopen_kept_alive_issue124_test_terminal_summary": {"doc_hash": "8e5c947261f761824516fe3119f245f4f2f713f506dc7b9d3816a31aa995504d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_summary_stats_test_summary_stats.assert_color_exp_color": {"doc_hash": "7945bfa0e04422d0f0ab3ff9bd2fa81b1b53f9680e66f6042413f26dba5bc98f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_skip_counting_towards_summary_TestClassicOutputStyle.test_quiet": {"doc_hash": "beb5107e2ecde57f7db3799bca80f2e9e513e2b6facbd0f10bdf35ded6debd50"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressWithTeardown_test_skip_reasons_folding.assert_reason_message": {"doc_hash": "2114a54fe4db58b8808da6631823bae7bf8802727d94052f85aa5caa62adca47"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_custom_exception_info_test_testcase_custom_exception_info.result_stdout_fnmatch_lin": {"doc_hash": "c99dcbf7cdcc2865527fc909de367bc4eb380461ecf9c80de891274bebf1af20"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_totally_incompatible_exception_info_TestTrialUnittest.test_trial_testcase_runtest_not_collected": {"doc_hash": "ba91fb41fea73544fc383e07055cd97822e06baf74494d1b622faf8aa706f218"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_error_TestTrialUnittest.test_trial_error.result_stdout_fnmatch_lin": {"doc_hash": "8e98bd27bafdef53e08c3ca8eb1600f724b583f04517f4f735fa1336c738c69a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_pdb_TestTrialUnittest.test_trial_testfunction_todo_property": {"doc_hash": "643553a6e4838d61d28d6408f53ee821a1aee9490b70bf27cfb4aaa721be583d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_djangolike_testcase_test_djangolike_testcase.result_stdout_fnmatch_lin": {"doc_hash": "2bf61c6b073a7e87bc68dfec3eed96cb323cb99b5576f0f784be7c359bcced0f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_setup_interaction_test_unittest_setup_interaction.result_stdout_fnmatch_lin": {"doc_hash": "5d4ea48ec58d8a5c6446b91919005e294477b23f6ab902ca35bce622fd2a011a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_warning_captured_hook_test_warning_captured_hook.assert_collected_expec": {"doc_hash": "dedf31ef5961acc7bde61ba807d02491adf34a065253234ad0f4d89a2221d907"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_collection_warnings_test_mark_regex_escape": {"doc_hash": "a148580d134c5218889642e4ebc1909b142d97e62904d765aed41a473d938324"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_hide_pytest_internal_warnings_test_hide_pytest_internal_warnings.None_1": {"doc_hash": "e6d0c03d4c7d3238e441f176d05ca4cdb05c1583a3d31893cf77e8bf45e361ec"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_option_precedence_cmdline_over_ini_test_option_precedence_mark": {"doc_hash": "25769d1e1aae07a704acd2f067a9d1798f8b4e877d5ac661466c92708e414e15"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestDeprecationWarningsByDefault_TestDeprecationWarningsByDefault.test_hidden_by_system": {"doc_hash": "0253b4ecc9ec79b909bb06c4b3ae02bb4bff95a88a1e863bbbe5f540092e202f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB_pytestPDB._import_pdb_cls.return_wrapped_cls": {"doc_hash": "01fb1194d7cb648565bf71d8ed2d7cf8f086b5125a00cdbef0b5c842015e8d7f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB._get_pdb_wrapper_class_pytestPDB._get_pdb_wrapper_class.return_PytestPdbWrapper": {"doc_hash": "b0c5a60ee3f50c7151189c19b26fc45f15888fefcb3f70fc992fb899b49945ad"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB._init_pdb_pytestPDB.set_trace": {"doc_hash": "2690dc7aa2f9d3feb9a019cd20f0b431d9d35273167d46abf0757d5cac0e0496"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureDef_FixtureDef.finish": {"doc_hash": "4074c5dd6d685fcea5501971c68e23d22194a2460ecda40f0b4bdf7c8d283ca6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager_FixtureManager.getfixtureinfo": {"doc_hash": "4ee8ee49a1a4f5ce207fc83344eca8eb4e3486ba14c022c97618010fd169d627"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.pytest_plugin_registered_FixtureManager._getautousenames": {"doc_hash": "d158a22a4a00dcbe2718485a3043fa2ccc33ffa42ce3e097e27d043d602a667c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_pytest_addoption_pytest_addoption.None_6": {"doc_hash": "f196511cc6762e5ad3c714f6c6e51031e470c7568f53d6ff142e07a9c97086eb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin_LoggingPlugin._create_formatter": {"doc_hash": "f5c4762a658c713f92874c9c3778f1aad8b47e96eec9497cc6cae381af4d7ae9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin._setup_cli_logging_LoggingPlugin._setup_cli_logging": {"doc_hash": "91f9689f7571ea6925b3fc6cbdbb9796700d3dd6672e0a369283be313c4c4f61"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_ParameterSet_ParameterSet._parse_parametrize_parameters": {"doc_hash": "e370cc2c7897ca3735969012d6f18ef1fa3281e002d6c9ebb7f5043f510b219e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.getmodulecol_Testdir.getmodulecol.return_self_getnode_confi": {"doc_hash": "32fc77a197b32d0064857ba6fde2e14615f4d65bf88b6eaecabfd51642f0027a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.collect_by_name_Testdir.popen.return_popen": {"doc_hash": "e037e171738a228954248ac3743798f1be78ef287ce1731a7b95de12aab0d7c9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_addoption_pytest_addoption.None_6": {"doc_hash": "f5b864839d3ee895e1a0ce07c85ddd8046a26ec2f7a0098615c75b3eb737f753"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_collection_live_logging_test_collection_collect_only_live_logging.result_stdout_fnmatch_lin": {"doc_hash": "d28160773251d9575ca597437bfa4eb7536a548cdab2a56bfe6f517f71bc4b62"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_collection_logging_to_file_test_log_in_runtest_logreport.with_open_log_file_as_rf": {"doc_hash": "bed8ec92fe9e49e108db68938fad37b5d39198601f0e0240f0c7ceaa68c46881"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_set_path_test_log_set_path.None_1": {"doc_hash": "29cd015dee7bf4dfad638806c3603bac535ba4dbf547ffdb64cbf4bad1e4f63e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_colored_captured_log_": {"doc_hash": "df8fd38398d52321b0683b404d697039f065ed4384b550008317b9b83c364b91"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_non_printable_characters_TestMetafunc.test_idmaker_idfn_unique_names": {"doc_hash": "5e7305a51e72a5f7e17c95139b5038cae87839eb3a93c7cc98a35f0b2c122aed"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_idfn_and_config_TestMetafunc.test_idmaker_with_idfn_and_config.for_config_expected_in_v": {"doc_hash": "cd889452f25880984a2f81205e21802f93d6f54b814e8cb781b8bc81b67cd86f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_with_known_failures_not_being_selected_TestLastFailed.test_lastfailed_with_known_failures_not_being_selected.None_7": {"doc_hash": "2d65152e778e114cc70e8a72122361bb02ab75864a999b5dbafd6dc133d8d246"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_options_on_small_file_do_not_blow_up_test_importlib_metadata_broken_distribution": {"doc_hash": "8760a8c72a85be0df31da1bc1a84574308d6ebbac87fdf621424b7571191bfa7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_plugin_preparse_prevents_setuptools_loading_test_plugin_preparse_prevents_setuptools_loading.if_block_it_": {"doc_hash": "c94980663bda18131e81dd6c7c1e76f3de26291f951509ac7ce02bb4438c4af0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_consider_args_after_options_for_rootdir_test_consider_args_after_options_for_rootdir.result_stdout_fnmatch_lin": {"doc_hash": "fb0b30677bca3c3c9af15256e62a92775e25f261ade5ee4ca1741c01138446f4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestReportingOption_TestDoctestReportingOption.test_doctest_report_invalid": {"doc_hash": "bb6493a556e2e58dae256336ad30b3b12ef23ebeeedcd21e7025bc194979407d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_test_doctest_mock_objects_dont_recurse_missbehaved_": {"doc_hash": "17a19554cb42d1b83b0bb831df5edbe947d2f456a9474eab3a3da3eb2230609c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_test_run_with_skip_option_test_stop_on_collection_errors": {"doc_hash": "7afb1d44ed366499791f2d85ca606ed1f791b0cd28590d70c0be20147063d293"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_test_xfail_handling_": {"doc_hash": "3962574f5a6b5323d754968770918566452ca5206fe1a27a1aeae456eb3e4d5a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_attempt_symlink_to_": {"doc_hash": "f5ac90f7c2d0e1e5a5c2ce05bf29756357f165b94bf219a0f467449ea63550e3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_new_instances_test_method_and_teardown_failing_reporting": {"doc_hash": "48a01b1eed864f322182477649faa59f3fe0da154590a6b9fdf49d09b40c7a30"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_setup_failure_is_shown_test_testcase_adderrorandfailure_defers": {"doc_hash": "a4554fde40bd382e0668390b0f0854f4a114cc2333f89f6b071492dd80ad3541"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__builtin_pytest_approx_h_ApproxBase._check_type": {"doc_hash": "a262b9da77b3333abac3d1fce9422618cdda10ce6da780e78824a9b80532af86"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_allow_bytes_TestLiterals.test_allow_bytes.reprec_assertoutcome_pass": {"doc_hash": "d01582d9e1f0d1639e301eb09d7839f62b95288d315984f7fb035cdfa0e7af1e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestNumberedDir_TestNumberedDir.test_removal_accepts_lock": {"doc_hash": "fef1445db2355aab11090bb8c1c850b121259570c8c04e413b60f2e5d15ecae9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/_themes/flask_theme_support.py__flasky_extensions_fla_": {"doc_hash": "42d2244f2a125ced38c3a7cb46e4e66ccc3d9a858fefd7199d85a14dc9360754"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py__pytest._code_TestSpecialisedExplanations.test_eq_attrs": {"doc_hash": "39ee2d2fb3385f5dcba87105f3849372e200bf085a7eda366ebae71d66d81446"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/test_setup_flow_example.py_setup_module_": {"doc_hash": "53f3578e6813051a87935b2f79a882934e67b3db4398641a0c80acbe240e7c3b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/fixtures/test_fixtures_order.py__": {"doc_hash": "5c05a1bdb90a74db1918f9bcaf21043ca5162f1a8105168a348fbbb710084ff3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/multipython.py___": {"doc_hash": "1ddecd0f99a76c8d6d0f6579bfaef89a44ec3d4a9369a37887ec1cdf3ddf3c4b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/nonpython/conftest.py__content_of_conftest_py_": {"doc_hash": "de80b9fb9d142765b61a23399126b8dd6f262d8a55dc3450b3626a7076d2ec68"}, "/tmp/repos/swe-bench_pytest-dev__pytest/extra/get_issues.py_json_": {"doc_hash": "7c38864436083fac81d4b06021962d4b8340e0e0250bc35c29a39d5604e5061f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release.py___announce.check_call_git_add_": {"doc_hash": "7d80d9aae59e218aaf22ac7f3c553e1af242f5576f0dc99c8d74a5bc846bcdbb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/setup.py_from_setuptools_import_se_": {"doc_hash": "d837ab606447b280eda303602329a06e689fad7f4698c22cb032e4adcf4f2b1e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback.recursionindex__E": {"doc_hash": "1cd0c6e5d484912db7e2d1d6d9d89ca6d68e7f8ba02813d10967fe83cd9300cb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo_ExceptionInfo.tb": {"doc_hash": "a979f0afd0a1d43df947e6799bcb9a66b73227658fdb0596efaa3a67a9ffdfd2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo.typename_ExceptionInfo._getreprcrash": {"doc_hash": "0dfc4330d37f60f1993d0c1ce9850ef754bdb4113f33647bf4dc4cc61d069d5d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo.getrepr_ExceptionInfo.match": {"doc_hash": "bab2793bc3b51edea26ae2b4aa8152d245e8f7e6f4e7fb131708111f7e5a89af"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_excinfo_FormattedExcinfo.repr_excinfo.return_ExceptionChainRepr": {"doc_hash": "0bf27ece108b9936699978428b2dd9b85e231b59482651034522e3ae21c61792"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook.find_spec_AssertionRewritingHook.create_module": {"doc_hash": "24087527900459ed4ec0c9cda798a1aa773c90e54298247e7666bc621a19d58a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook.exec_module_AssertionRewritingHook.exec_module.exec_co_module___dict___": {"doc_hash": "5e09b37f4b2e22f1a6f0e05be4ffab21327713c4211b2e24075ab736523f96cd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook._should_rewrite_AssertionRewritingHook.get_data": {"doc_hash": "b8112770720f0dc80cb2ed58fa31fb4cf1a05b3400a829bf287c7dbc9d6e7e5f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__read_pyc__read_pyc.with_fp_.return_co": {"doc_hash": "07cdfb424cce7442af7d3ca5cdad6b68eaa2c84f6eb6a84e7211acc2c11a1519"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_rewrite_asserts_UNARY_MAP": {"doc_hash": "a8f3fb50435c358bd4f13669c128b8783cf2157300162fe400598a06b56193de"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_BINOP_MAP_set_location": {"doc_hash": "542ce4a0a9f361b9761524d0a81e41cf5662d8fcf9a5e98fbddb25708d9d991d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__get_assertion_exprs__get_assertion_exprs.return_ret": {"doc_hash": "3554ec1ac66497c1c75b097d9724e6aeb2362a99347454e52ae2c343422d9fb9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter_AssertionRewriter._assert_expr_to_lineno": {"doc_hash": "4652d866f211092f5122c62a1e3d843242e65c96765b7dde6b0b83744f6eb99d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.is_rewrite_disabled_AssertionRewriter.push_format_context": {"doc_hash": "71ce02ad56eb8e82465b5ab0eecf690b105f27799083d4fb3b44a279b34e49f0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.pop_format_context_AssertionRewriter.generic_visit": {"doc_hash": "8bf993b5efcd17d2b2ed14db513f9f1c7d654c64276f80920172296b04b2f652"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_UnaryOp_AssertionRewriter.visit_Attribute": {"doc_hash": "f57bc699a6416ad9cb59d5476faac80fdc333f3a0b092cebab73b8ea7996a7a8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/truncate.py____running_on_ci": {"doc_hash": "2b48704d481d75b12e211dae01edbc3936b0e592332d647cec474ce52ef83a93"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__Utilities_for_assertio__split_explanation": {"doc_hash": "827250c4b1328a9bfb363c3dd9b96a27f9d082a878b655bff3b8b520be73189b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_set__compare_eq_dict.return_explanation": {"doc_hash": "ba0b16d3cd103ab3f668b183c2d3affd59ce9d05d437a0a6d88522145140d158"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py___CACHEDIR_TAG_CONTENT": {"doc_hash": "e883205c5f8090e5b598b0e0d159d0ef9ec2dbd78460c504ad16a5907bf0b10f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_ascii_escaped__PytestWrapper.obj": {"doc_hash": "cb390aa961d4b0cee242312c7dc159ee2da4b98e15caeb4e815a5c85f2891c28"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_get_real_func_get_real_func.return_obj": {"doc_hash": "3bb6bfcdbab693e5779e9d46d34cce42004a0d6c570dd0f03d629f5ebee1f076"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_get_real_method_": {"doc_hash": "76dfceff15e1a9b018db563457bea176454aa0e8791265ffdb39225e529e456c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__command_line_options__ConftestImportFailure.__init__": {"doc_hash": "271c8d48a605d2ceff9720e9309449618502911f67fc4be182f546f6572840fa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._try_load_conftest_PytestPluginManager._rget_with_confmod": {"doc_hash": "e2a65775383621040a97285bf4200680454d9ab60c362e28d339cf456c91c70a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._importconftest_PytestPluginManager._importconftest.try_.except_KeyError_.return_mod": {"doc_hash": "901199833e22f465c26910c27a90cf28395afe823bda6901ea20055cb71fb6e6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._consider_importhook_Config._validate_args": {"doc_hash": "ce14c513bc13d31107f09e6166d1e57e48000e2fa66aaa3317c4e8a67d3367b9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._preparse_Config._preparse.try_": {"doc_hash": "a4eb4844deb7e75b765318a1de0dd85d301e8a5fb1805def72af099e916eb2e9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_os_getcfg.return_None_None_None": {"doc_hash": "263a10eb80d0cc9f253ce9bff38d7873cb10e5842bf904bfef2ed4fae0f7050d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_get_common_ancestor_CFG_PYTEST_SECTION": {"doc_hash": "9dd125175db89b1c3388af68e79a0d0efb334f0d340c3db88942ce47c6f90cf1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py__interactive_debugging_pytest_configure": {"doc_hash": "ceff2b4db00ad1a8dd3fe28b453d545760bdad1afeae74c2b3a482453f295af2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/deprecated.py___": {"doc_hash": "db880674b19a995b5aeb2ee487fa5a22f4cc87c34b96cc6faaff69a592586db1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__get_flag_lookup__is_mocked": {"doc_hash": "97e1893c87f7b9a7a830ca346127f598cc1fa105e43b9da539e6e876b66aae70"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__patch_unwrap_mock_aware__patch_unwrap_mock_aware.try_": {"doc_hash": "5947b5033940312f59b4b6b2d21a7868da9a89504e182d71e1d21107adfd5866"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_functools_get_scope_node": {"doc_hash": "463a5d9ccd73f425cc1007521995964ff1259161c0ee38ceda1f18242d1966c2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_resolve_fixture_function_resolve_fixture_function": {"doc_hash": "0c5c9d17732063801916cb2fe1428e56ca46db14e030829da4ac86659c8d8e2f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/freeze_support.py___": {"doc_hash": "52d46a87c61f8860f26eaac442a2420a8bf74b0e579923a0000dc8204eba628d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py__version_info_help_me_HelpAction.__call__": {"doc_hash": "7297fca8bf114daf74b06f6d6369fadda8f9aa43848cecaec2db8d6e128475b7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_assertion_pass_pytest_assertion_pass._": {"doc_hash": "1d6ea24ba3c4bd5562a583bbf870c1f671663338f28a6f8e53620532becc989a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_30_": {"doc_hash": "c89ebbe92df727c0bf1f129247ca13da24f618154d6e86204c589569a1e6a1f5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py___families_xunit2_fami": {"doc_hash": "fa57e694b310e6c6822f1e7ffb569e2721f02bdfd1f445873ad722dc9b16fc59"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py__Access_and_control_lo_ColoredLevelFormatter.format": {"doc_hash": "551cd9057262c3b29cd70aadf4163fa469a08c9a3c8b37cd00557892e1111378"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py__core_implementation_o_pytest_addoption.None_17": {"doc_hash": "a487467a3510077fb50ab6a6de72af748ac595d33b25d6adf8f037a1928f4ac2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_wrap_session_wrap_session.return_session_exitstatus": {"doc_hash": "841c2f115f548ccf8ff424c619e7a16bb34f26f54989d56abbbd34819e5c2b0c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_collection_modifyitems__bestrelpath_cache.__missing__": {"doc_hash": "6bed05b6c9ff59666a6e626308d2adee8ea08862291b2c2aadd54474068ff257"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._collect_Session._collect.if_argpath_check_dir_1_.else_": {"doc_hash": "b23a5369c09ea65621d5cd59ec5207e2e126b3feddd27bf5318a784e1287c440"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py__generic_mechanism_for_param": {"doc_hash": "5c6129b2436266999ca043b9ee86363b7371461d3948492f8a02d0e1f3214896"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/evaluate.py_os_MarkEvaluator._getglobals": {"doc_hash": "e208dd66f8b26d90d45970de1bda02146fc61753b7487d601a7b1b4fbbc4711a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_inspect_get_empty_parameterset_mark": {"doc_hash": "740d4e02142dd160623301adc662f56d79bb1164d4688817803036bbe3d132da"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py__monkeypatching_and_mo_notset": {"doc_hash": "d320bb2e82f1256a5386fc616e1af72272ea683649a5c57960e66c3674d14f72"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nose.py__run_test_suites_writt_": {"doc_hash": "170d23e7125ef41fcf7379e3227e7f6a386d698b199b55346bac62c834d7941b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_rm_rf_create_cleanup_lock": {"doc_hash": "22fa606f45744ca2960b79512ad6035959de9dc680c7f0e7484756689826fe1a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_register_cleanup_lock_removal_cleanup_numbered_dir": {"doc_hash": "667727f5ec9df0f77b8594de1f5902af35b92ecc6a0cf6b6d69ad410ab0b3e86"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_make_numbered_dir_with_cleanup_resolve_from_str": {"doc_hash": "427d7a7e2c7d76dc41095e172afeed45c92eed2686b1d7a42cd135cb1cb107e0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py__disabled_by_default__pytest_configure": {"doc_hash": "5991848b98557373e396c4404409f34cd5eafb3860beb4dfbb2335fdaafa66bc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder_HookRecorder.getreports": {"doc_hash": "671030d74fe758073f19be0e28703940f4f5cbc43256bd32dd9169d06d1f190f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder.matchreport_HookRecorder.matchreport.return_values_0_": {"doc_hash": "1f8cc5769b6c9125f7401d36bd9372909368c314b302f93cc32beb785bdf6244"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder.getfailures_HookRecorder.clear": {"doc_hash": "89252a988c4b4db6d7a8c2ae368c7232e6fac390f115289728358a5e5af6fcfe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_linecomp_rex_outcome": {"doc_hash": "3614aa7d3e370d2e8db504bf460d9cb28a879e43f641207fcd7cc4e7ea947daa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir._dump_lines_Testdir.runpytest_subprocess": {"doc_hash": "571fbd94fa4defcf857a194677427e96d4712e52fc04411ad632df46b5355d86"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__Python_test_discovery_pyobj_property": {"doc_hash": "5c1eef924a5af4792a43e5f68467e6e871f32e84b5a877caf1483e129a2c00d7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_CallSpec2_CallSpec2.setmulti2": {"doc_hash": "dfe4132c7ba5cdf51b934bed14b2e5089bb51a39d56db18a35600b2df646d93d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_inspect__non_numeric_type_error": {"doc_hash": "8d57021b36e23fa42f9d70c55fe34f06e79e335bcfc339ff9ca8cc1d89e44e12"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar_ApproxScalar.__repr__": {"doc_hash": "3d8edafa1c6009cee96659c454be9b836fd743512d6890748a0f1500b9287a92"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar.__eq___ApproxScalar._type_ignore": {"doc_hash": "6991464a05bc0d63f846fc47e3efaf71ca4543f3d795af54ee65cc8490ae7f9f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_approx._Delegate_the_comparison_approx.return_cls_expected_rel_": {"doc_hash": "a574b1f6a49b1d4a040e0bfa2322f2b5eecb3faf785a391e1c34f12add40251e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__is_numpy_array_raises_5": {"doc_hash": "cc9a46636659a8b4bf5aef469fa9d24e69da28b0b90ee3ac867191ccc8bd76a5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_raises_6_raises_6.r_": {"doc_hash": "ed7a611d46db6f1b19720e56864375c190579716bfd3e14f741837128a1339a6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_raises_6.__tracebackhide___raises.Exception": {"doc_hash": "bbf833618283cb0a6ed9678468cf013bf0a96e56dff3585f4f9b87226c307a08"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__type_ignore_": {"doc_hash": "09ef10259b03a2e49792e8283ce7e6504409a359f9ea2465491acf4c69269d7a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py__recording_warnings_du_warns_3": {"doc_hash": "59d470f9658dfd89624a517a4c671b9b89b2e914df4e93591d5fe83d41b9d335"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_warns_4_warns_4.if_not_args_": {"doc_hash": "d944d6ac1063cac96c158b5543e5bc1456dd397346b7d949baad9a1f0d167b69"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_WarningsRecorder_WarningsRecorder.__exit__": {"doc_hash": "b96f65feb0c899f07914a4997b0412db7bbda0d98eafe6cb3547506db24b3a41"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_BaseReport_BaseReport._from_json": {"doc_hash": "f9f82dd9055b50f91dfb9261e95eb442d81ae6a21ff38a0b6ee43a26856468e5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_CollectReport_pytest_report_from_serializable": {"doc_hash": "c977e296d2451bf330cbf3aa3f0c8908512f04f9b9cd22f45d2493a7b6564933"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_to_json__report_to_json.return_d": {"doc_hash": "323f71937d52fa164f3d1a311b2f1aeb1e706475366513bb5091b836f4df9d3b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_kwargs_from_json__report_kwargs_from_json.deserialize_repr_entry.return_reprentry": {"doc_hash": "1bea23529a5ccb5d60267dc97ded13af23d2959cf45e5bf71fb2aebb80a91fe1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_kwargs_from_json.deserialize_repr_traceback_": {"doc_hash": "ff082e1b670b90693698dd6dc9c3e4601abc8ce5bbe1937d1d6d1d608ab92b37"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/resultlog.py__log_machine_parseable_pytest_unconfigure": {"doc_hash": "8df668d251ccdd542cab83ae8c3aa6e73a1677c75dada345b3a4d35d3d6e2197"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py__support_for_skip_xfai_pytest_configure.None_2": {"doc_hash": "6560bf585831f80ff188d429845c65761d74cffd1c86993f8f8ecff7c3c93c72"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/stepwise.py_pytest_": {"doc_hash": "0e404b216fb7524e006b6bd9cf6f2c9a9ebbafce9e3681607880fac38cbc838b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__terminal_reporting_of_MoreQuietAction.__call__": {"doc_hash": "c1ffa7274236956b85ddc71e3d52cb939d55cb9bcfa0dd920151b6b8b2a0ad75"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempdirFactory_": {"doc_hash": "848c43e228a13caec76c0a9f9b202666569bee55b8444256a54bd236bd0034de"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py__discovery_and_running_UnitTestCase._inject_setup_teardown_fixtures": {"doc_hash": "d119ae0f7c9b102f63e20387d628ecd57f8934933c2af1100522a1538a083fed"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py__make_xunit_fixture_TestCaseFunction._addexcinfo.self___dict___setdefault_": {"doc_hash": "b2c9eafb85169e780328d61ad553c5546f44c962a81df76ffc008de994d9dc65"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_os_TestGeneralUsage.test_config_preparse_plugin_option": {"doc_hash": "bc0613d5cfde452616d8f9998a07a7ed2419f842023400efc7df98384ae9a673"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_pyargs_importerror_TestInvocationVariants.test_pyargs_filename_looks_like_module": {"doc_hash": "ebd3a8519dc8a2aeb0645c7c22a02d2d97f6c48c6c9700817345eb6a3aa16c13"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_TestInvocationVariants.test_cmdline_python_package.result_stderr_fnmatch_lin": {"doc_hash": "48adda17b96c92757bc6ac5c5f7098d35cff58bb70176a8b7d7f35749f623c24"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_sys_test_code_getargs": {"doc_hash": "062ce85f410863272fe174eeaf413eb055be9c3abb60f6a3ae5b9f531817a129"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_test_frame_getargs_test_frame_getargs": {"doc_hash": "2d7683b981f6e832f85ecaceb63d72ec5507a9f2f432f99511efa5d734ec6e79"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_TestFormattedExcinfo.test_toterminal_long.assert_tw_mock_lines_12_": {"doc_hash": "2e44cafb124f479732e43cfdb715c74de76ad681a004fec6f54ac3dbe3a42f14"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_missing_source_TestFormattedExcinfo.test_toterminal_long_missing_source.assert_tw_mock_lines_10_": {"doc_hash": "526253f148f59c5968f42b51a19bcea5f385741493cf5e71fef6b43bc966eca9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_incomplete_source_TestFormattedExcinfo.test_toterminal_long_incomplete_source.assert_tw_mock_lines_10_": {"doc_hash": "119cbb9e9242e4928a67784dc2fe698977e99658716321a006ed113ad775187f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_traceback_repr_style_TestFormattedExcinfo.test_traceback_repr_style.assert_tw_mock_lines_20_": {"doc_hash": "1b7eed1b9c6a2cc0f9b93efc694e5d88842f9564a44af22112196fb23984ce2c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_TestFormattedExcinfo.test_exc_chain_repr.assert_tw_mock_lines_47_": {"doc_hash": "4257ccbfed257a35161655392918a451e9e027241d908187f7bec23c5678696d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_repr_chain_suppression_TestFormattedExcinfo.test_exc_repr_chain_suppression.assert_len_tw_mock_lines_": {"doc_hash": "972fcf21ea022190e09fd1ea7bd2903af8a97d621d02e620f09837296b616b15"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/test_fixture_named_request.py__": {"doc_hash": "db922b241a15ce4bcaf5fd38c27f700ed140e0a4703612e85142356dfb37cbc2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue_519.py_pprint_": {"doc_hash": "95afe4bd50c5bf433ac5602b70891967b99242d9561b293da0a2c7810a1b72b2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/perf_examples/collect_stats/generate_folders.py__": {"doc_hash": "4e07de7b8bf7876d01b932e86900e14abb261a639f7a3cb95e80f9f5588ffa89"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_fixture.py_logging_test_record_tuples": {"doc_hash": "8ae1058968a06ba40b4631c5595402d63f6afeac631e13dee4b482a7ab12e7ef"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_io_test_messages_logged": {"doc_hash": "de94f1ce1400be66609afe40c91b562b3224a7d8f0085f78c0e29354dbe8c34c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_os_TestModule.test_invalid_test_module_name": {"doc_hash": "cf43ed9a863a0192b3da8ecc877ebdc651108f0702da5358fde4f8e4210feb9d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_customized_python_discovery_test_class_injection_does_not_break_collection.result_stdout_fnmatch_lin": {"doc_hash": "71da0bcba808b4bf64740905257a8dfdc4bf5a5ae4811c76ce5bbb186ed78431"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_syntax_error_with_non_ascii_chars_test_package_collection_init_given_as_argument": {"doc_hash": "894011aaf7ef60cae1d4ac948bffb132d774e7cf3b086e19a9d92710bf567b85"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_package_with_modules_test_package_with_modules.None_7": {"doc_hash": "ef41ee1b2b8c145e2c6fd2dc7ddada46bfc8b18f3ac8fd204bc3b02c220ce6ef"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_sys_test_getfuncargnames_staticmethod_partial": {"doc_hash": "fae6438586781c2b0e1cd699a1cab5186849c56e6a11213be4e569f28552ab8b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_getfixturevalue_TestRequestBasic.test_request_addfinalizer_partial_setup_failure": {"doc_hash": "f22c10253bd7b5064d5e711d673c9a07836f546304cb24caee07e5485c46b93e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_getmodulepath_TestRequestBasic.test_setupdecorator_and_xunit.reprec_assertoutcome_pass": {"doc_hash": "4ca1c302fa97309e5d53acc60b593cd62761c91ae8dcceee34aa7688e4ebeace"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_fixtures_sub_subdir_normalize_sep_TestRequestBasic.test_setupcontext_no_param": {"doc_hash": "d2ae54dd1ec2d74344cbed5734004f5a539fa29b58186ccdf147223afa82bbb9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_multiple_packages_TestScopeOrdering.test_class_fixture_self_instance.reprec_assertoutcome_pass": {"doc_hash": "72df296c321caba4d504a762bc9fc2b0129a5f0ba9ef158b1c778311f456d460"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_call_fixture_function_error_test_fixture_param_shadowing.None_5": {"doc_hash": "af42bc284514d46f4365e8cceaddf12c80e5b70ece287ca2ef3fefa8600bbbf3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_pytest_TestOEJSKITSpecials.test_funcarg_non_pycollectobj.assert_clscol_funcargs_a": {"doc_hash": "83346ba5fbfbcfa38e1afaa8f37fcc34cb94a6bfcfcc0906172a3d2343a17fa1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_sentinel_check_against_numpy_like_TestMockDecoration.test_mock_sentinel_check_against_numpy_like.reprec_assertoutcome_pass": {"doc_hash": "d2f95c6c10383fb0572573ab8f873ef40f694132de417e2fbed9c6f603f8bb12"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_noclass_TestRaises.test_raises_cyclic_reference.assert_refcount_len_gc": {"doc_hash": "b8c4a20172455bc8c0abd809b5ff3e0d003c0fe072c61a570d2e3927719211b1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_no_items_should_not_show_output_test_fixtures_in_conftest.result_stdout_fnmatch_lin": {"doc_hash": "3d5904d0be806759a6648517e3ff160a7db5ee8dbc1da3be8c313c812c00d711"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_subprocess__wrapcall": {"doc_hash": "09946dd450df32a4ff7f780e8c500795103cabf59e3739e5711f25a4ac6324e4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_TestAssert_reprcompare.test_list": {"doc_hash": "0e07e23634baa3d59d822cc2326081c70143f1dd68702ef693767842cd86ff22"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_exception_handling_no_traceback_test_assert_tuple_warning": {"doc_hash": "6f26e1e3d468b1e474fe54b642158d9b7b3845b2c71fb7e22d3fb071673d7112"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_assert_indirect_tuple_no_warning_": {"doc_hash": "f922e00ce1ad3d7c1188370b3aea7fd86dfa9124c31a86b0a762f5a80c13294c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_ast_getmsg": {"doc_hash": "44a017291eb155625e44a5dd8a5db89fae3b993ed9180de2fe4feb4e20d5dbfb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_dont_rewrite_TestAssertionRewrite.test_honors_pep_235": {"doc_hash": "b1f1db70800e7fcf4cddff7f0e3dbdbda73c02c65fc3fe44e80c4a616b2a8429"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport_TestRewriteOnImport.test_orphaned_pyc_file": {"doc_hash": "da323f8fef587dbbda2409e95927fded40384862d8d532745f63915633d098b1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport.test_cached_pyc_includes_pytest_version_TestRewriteOnImport.test_pyc_vs_pyo": {"doc_hash": "bdefdba63868394994a8ba3b1d1b7481aa07be93e70a6ec1e75a173329a02b64"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport.test_package_TestRewriteOnImport.test_rewrite_warning_using_pytest_plugins_env_var": {"doc_hash": "bbb1d32d0ed913d444217af03770489ff28013614a33d28ddee771ab47d6a564"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestEarlyRewriteBailout.test_pattern_contains_subdirectories_TestEarlyRewriteBailout.test_cwd_changed.result_stdout_fnmatch_lin": {"doc_hash": "be02ebcb853373df79253694d34eb32a8430416ea702681da3e45c8499f41b04"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionPass_TestAssertionPass.test_hook_not_called_without_hookimpl": {"doc_hash": "a8efaf8530f0a0ddfa30b61810fd82701c2c42459f9a333a1ca2784e2c666a53"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionPass.test_hook_not_called_without_cmd_option_TestAssertionPass.test_hook_not_called_without_cmd_option.result_assert_outcomes_pa": {"doc_hash": "d86bfc090112659847540f76ba5f90a80c172b481df2092871f543faa4de89e6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_get_assertion_exprs_test_get_assertion_exprs.assert__get_assertion_exp": {"doc_hash": "62f5ade8e6150d9cec57de4c65a072b6fe479d3cf89bed6d69259737dced0c27"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_contextlib_TestCaptureManager.test_init_capturing": {"doc_hash": "4c2751d64e2c4add6729889831568ba3ef3488a5c297c3f7d3d87c9de74c25c2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestStdCapture_TestStdCapture.test_stdin_nulled_by_default": {"doc_hash": "98b02380ff5158153462fbbef49592517676950d36b37f39294ffa907e8ca459"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_compat.py_sys_test_is_generator_async_syntax": {"doc_hash": "e37806d71e6f0f43279d4ce6fc51fa9a7ce415069382783b83ba3974cb45396e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_compat.py_test_is_generator_async_gen_syntax_": {"doc_hash": "80171a8370536f133dddce984a5601062af95590fafba4b4167ae6184ecd7469"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_os_TestParseIni.test_confcutdir": {"doc_hash": "6ba1d350864fccf0269ed5ffd86baedffd277a3c6b91ae8132e7a19c962a624f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigFromdictargs_TestConfigFromdictargs.test_invocation_params_args": {"doc_hash": "b2b640335877097dc4cd90eab4aa979053a448067415a80f1dc7784f657faa5b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_help_and_version_after_argument_error_test_help_and_version_after_argument_error.None_2": {"doc_hash": "d122a95041ad825d8c76bb0d06c10022f860445f7caa74d88422443548ab7095"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_config_blocked_default_plugins_TestSetupCfg.test_pytest_custom_cfg_unsupported": {"doc_hash": "500e8e46a561529a7f4560f6aa1fee609f6ad177b529255990d4ff7b21648840"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestPytestPluginsVariable_TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs.if_use_pyargs_": {"doc_hash": "8859ef9ed4a20de6870744e3b8da1f63e7ba1799d8c0d9ac6a6f8373c26fb839"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest_": {"doc_hash": "810d3b977f3a721a9d415f50818fa80bbb43874dcfe079af2f2a62757f0e721e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_symlink_files_test_conftest_symlink_files.assert_result_ret_Exit": {"doc_hash": "8a57fa9662418ade869712baabd63c53ef5bafc86136d7e3b1702deb2ce3c96a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_badcase_test_conftest_import_order": {"doc_hash": "115bf3be218140f97400bd65a1bed290553a650d265dee878043eb56748d5bab"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_inspect_TestDoctests.test_simple_doctestfile": {"doc_hash": "7a7ce13210ac7c00b4add8dcefa686b6aa3c2664c5b2e1e8993576c63aea0ab1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_unicode_string_TestLiterals.test_number_re.for_s_in_1_abc_": {"doc_hash": "8059f0c0bf96eabb830c0fe615f92dc00fb49ef3794b770f66f7a5c4c101aba0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_number_precision_TestLiterals.test_number_precision.reprec_assertoutcome_pass": {"doc_hash": "9a83ab7a2be30197ddff11940a9257c81e619cc79e02568e2d3a0e4be1c09fb3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_number_non_matches_TestLiterals.test_number_and_allow_unicode": {"doc_hash": "b1cbb320a5324f62c3dad1ed63e58d77797b5b042f031683911bfd56f58e38c0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_sys_test_disabled": {"doc_hash": "07c24f0611e9ba000bbdaaf5e83c9a77c02b3511d5e1a38f9e89406e620b0b15"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_helpconfig.py_pytest_": {"doc_hash": "6e92d8062996db0a01beccb8f54b3b906ddde4c5dbe8f9d926b84a59b0731500"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_os_assert_attr": {"doc_hash": "b84f426e51a8f74de6ccc7c98cea1c061c2d8a00a78c6e426b18d4c789dba171"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_DomNode_parametrize_families": {"doc_hash": "0bd50cab2b3241efee74244e6af10fa0005518b1812adb95c5a95eec18af4a8a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_xfailure_xpass_TestPython.test_assertion_binchars": {"doc_hash": "9e71c74d6f07760ba94584db1dcf2403309e1baa12471f57fccfc3020f1e6264"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_root_testsuites_tag_test_runs_twice_xdist": {"doc_hash": "26d9cfef9bd8def5c12ef79bb86f26be7d3ffcd54530e87137a9ee0a6ee20532"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_global_properties_test_global_properties.assert_actual_expected": {"doc_hash": "0cbe88c4c9872f6ba202797377780647a3ff351c40b430a6ec6f871dba9e7601"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_url_property_test_set_suite_name.node_assert_attr_name_exp": {"doc_hash": "c1d1383e0e03c26a3ed88968476fc46d9c47b82fe92f65358d38ea416b9beadf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_os_test_ini_markers_whitespace": {"doc_hash": "9a8a89b4722b7c03aac3528c328a057a7b8fd694b070645d022870a69a394bb3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parametrized_collected_from_command_line_test_parametrize_iterator": {"doc_hash": "aa009f463c8eb940d1fc3537be3190c4615e2a6892a32f8537704879c83ce0b4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parameterset_for_fail_at_collect_test_parameterset_for_fail_at_collect.assert_result_ret_Exit": {"doc_hash": "9638669c302e9a8eedb584f77cfaeafffe24023699aa62f9c12ea002b8abe02b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_os_test_setattr": {"doc_hash": "266382f6d72c8b72b469a23857e867f6a4110f98fa0af16ffd01665872df470e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_delenv_test_chdir_undo": {"doc_hash": "dbf817eeb3e8b1d315abeca1b7f24cc22193b21528a91ea85a435530d798eb93"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_chdir_double_undo_test_context": {"doc_hash": "cc85ce4b9a7bf5fe8c0789dd76ec4b8dc73cb2d613b1474818377200bff79bf4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nodes.py_py_": {"doc_hash": "a429c21b6d6152ec1285b5ab3c18e185f9b6d82261f0af0e5d904df73904d272"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_pytest_test_nose_setup_func_failure_2": {"doc_hash": "c008db7cbe63745297c5c2b4b2e34dc682598748f81c6a07800d0516eff86c78"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_argparse_TestParser.test_group_addoption": {"doc_hash": "7ef8fe1676eda085601bcefe92b70bb9077b18a1fe428a53567cf198b1cd2048"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pastebin.py_pytest_TestPasteCapture.test_non_ascii_paste_text": {"doc_hash": "c41599e267b3b41220c1d7ec0c1653f2e4bb43ccef587292e66408ae7fc64ee3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pathlib.py_os.path_": {"doc_hash": "13c1cf75efc4353659722dab31dbb0014d374044721c11c821859fe5b940c960"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_os_TestPytestPluginInteractions.test_configure": {"doc_hash": "1b435903f4f0b0c40698e945787012ea75c88d7a0e513e72c95b4a1039f8c626"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_os_test_make_hook_recorder.pytest_raises_ValueError_": {"doc_hash": "6223b708782f9830108a2f5c55967cbade84d84d90d6113169610a33b710fa46"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_TestInlineRunModulesCleanup_TestInlineRunModulesCleanup.test_external_test_module_imports_not_cleaned_up": {"doc_hash": "89ac53fb143e38768ee85aa24ad24d0ac5efc7890911e41810fec8cb2411a9c6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_re_TestWarningsRecorderChecker.test_invalid_enter_exit": {"doc_hash": "c6461122cab69078fc70cbffad54050c3572ab574079f98c5be52b98b5f9c619"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_collectreport_passed_TestReportSerialization.test_deserialization_failure": {"doc_hash": "5fee1a1c100ce1029940a6aad62d95bc93869c714b86dd0adf1e216bc03e2bcb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_chained_exceptions_TestReportSerialization.test_chained_exceptions.loaded_report_longrepr_to": {"doc_hash": "c19df66947e78cd23379a50d4f88071eedbfbad9d046c3bcc8d84e271fa5ef20"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_os_test_write_log_entry.None_14": {"doc_hash": "c24084060b4456954a92b9cff7ec37f936ca8ac4c4f4cbefd52b4d3be4e12e18"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_inspect_TestSetupState.test_teardown_multiple_scopes_one_fails": {"doc_hash": "afb11c4a063df5feb4395b4da49787a4300c8021d851ef433266593871110a50"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py___test_class_setup_failure_no_teardown": {"doc_hash": "a016808eba47a8df01e1e8c426a9a8c9602740d624c91cb20d5a48b788de626e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_pytest_SessionTests.test_basic_testitem_events._assert_colreports_1_re": {"doc_hash": "9f601902732c6c5fca0a1ceeeb325dfb4da9ee47584316b74f15ed8341095627"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_sys_TestEvaluator.test_skipif_class": {"doc_hash": "428c1a2e769b96159d8bb6dbc4c3b992208ff6a88923ea715d4cb867271432a9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_pytest_stepwise_testdir.return_testdir": {"doc_hash": "c1ee86637950c0279bd2d30f240fd511410613c60b89f28828e8fa3b4e0b4723"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py___test_plugin_nameversion": {"doc_hash": "2a2b46641677a81b848fd1cd2264ace29d8d7d4e90b853fe5ac8e4db988cc534"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestRmRf_TestRmRf.test_rm_rf_with_read_only_directory": {"doc_hash": "5d1ee3ed9f9639edbee1fec5b08febb243ad1d937ca9b65a61409d35fd116460"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_gc_test_setUpModule_failing_no_teardown": {"doc_hash": "b13e6b47aad410e516b3fb77b0cca517b87a16f768230922bbfc91efb4578e66"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_exceptions_with_skips_TestTrialUnittest.test_trial_exceptions_with_skips.assert_result_ret_1": {"doc_hash": "a59c0718896c1670ad5f9d3d9440d6c7b0a172caf7a7f9da59b4eb32c5c3ed29"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_not_shown_in_traceback_test_unittest_expected_failure_for_passing_test_is_fail": {"doc_hash": "c7af106b6ffae7910b3a3d79dcdbf1fc562e41c13977273ffe83ff0e43e7f9b0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warning_types.py_inspect_": {"doc_hash": "145fc7bd8c7a159b28b3f901c570a8b889cd02448cabb6174ca91030a5195082"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_ignore_test_filterwarnings_mark_registration": {"doc_hash": "a74a4f7ae8576ee32c2aad84167cbdb3d02f877a1c6f0cb0d1eea93cc06e70f4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_DummyRewriteHook_pytest_collection": {"doc_hash": "8346be14509e8f594e53a95d1d925efc2380e6ed6580980281a2041e5af93bb4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__Rewrite_assertion_AST__PYC_TAIL": {"doc_hash": "5b02da8872ca34551722e485321071b11063b6da31f1b39e3c30a69189ebf336"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook_AssertionRewritingHook._find_spec": {"doc_hash": "bf5e440bfca78ef44fe0488945ab4e99d58eca1c2f9237aa92ca4fcccdddfa17"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fail_fixturefunc__eval_scope_callable": {"doc_hash": "f3f2a9c734c607c14320fc9884f2b7aa0c0b6dad218f8a8d7e945255a6475f43"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_yield_fixture_pytest_addoption": {"doc_hash": "47514c220ea161298ff6dd2a9d278f2aafdaf4851133324fe41db1c8173a66e2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pastebin.py__submit_failure_or_tes_pytest_unconfigure": {"doc_hash": "15f897896f25e90b55daada8d93c82027926d1c55e5df012765d53416654bd68"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pastebin.py_create_new_paste_": {"doc_hash": "e07b5a69c1fb65c0fd7ccde941b9488a94661ba13b83dc5ab5ec638773358dda"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_from_io_import_StringIO_getslaveinfoline": {"doc_hash": "8dba605c3362ba6dd7a4626c807069f21a7b49d7b9cebf5c26422756f50e2eda"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_runtest_makereport_pytest_make_collect_report.return_rep": {"doc_hash": "bcbf16e2c10cd0426c8096fb570134be3bbcdc42653641823113b1ac940ea1f3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setuponly.py_pytest_pytest_fixture_post_finalizer": {"doc_hash": "3b90841b55f80b24588ef438cb05bb44319380d2debe906c02e8b568e6a37c53"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_mismatch_various_TestFixtureMarker.test_parametrize_and_scope": {"doc_hash": "7fbb4389cb04eb24891e9e2e69eff78c00314c3052c653b51cdc12a4bd56f985"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_mismatch_TestFixtureMarker.test_parametrize_separated_order": {"doc_hash": "44ed742d9af34a1ec90cea3a3b30f2d7fe703860e8d938d634d4bd134ab57a9a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewFirst.test_newfirst_parametrize_TestNewFirst.test_newfirst_parametrize.None_7": {"doc_hash": "0f4eeec93a658ba3a1d7c3fd5b02e2b7bbbec745c7f5390ae82a44c79767f755"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_os_TestConftestValueAccessGlobal.test_value_access_with_confmod": {"doc_hash": "860f8e6466bed027ef6e883910a697795d31ab89a91e8bdb0f927a244a1f4195"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_outcomeexception_exceptionattributes_test_pytest_fail_notrace_collection": {"doc_hash": "e02603b742c0e4ba462eaf96efcc7249b5883670b78603df7da072c98cd8653e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_pytest_fail_notrace_non_ascii_test_exception_printing_skip": {"doc_hash": "17674f6dbde9f7cd1125070f6f341a28d3df8ca1463f80efc6ad7491dae1f735"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestRmRf.test_on_rm_rf_error_TestRmRf.test_on_rm_rf_error.assert_not_fn_is_file_": {"doc_hash": "82007a893fe07fe15c583655af715fede5fd99364895e700ca05cf947c51f370"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pkg_init_and_file_in_args_test_collect_pkg_init_and_file_in_args.None_3": {"doc_hash": "ede117a29c7b6c939d2b61dd15422ffdd74d83fee1e9c82c01f9cea21b905cbe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pkg_init_only_test_collect_sub_with_symlinks": {"doc_hash": "c0876ac45a442e28753fd55a0ba6f7c1522a23006f9f1638a8bd2bc5ea72860b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collector_respects_tbstyle_": {"doc_hash": "350af82a7dde9a74494e022834a47a1450b1ef7d631240e5d7972fc0745e494c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py___add_module_names": {"doc_hash": "2769496694530ba38754483d4626e41d7edf39b9bd35b9aef0cb02c3f06d3424"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_pygments_style__If_false_no_index_is_g": {"doc_hash": "e0fa36de6c13d1a5dd630cecc886a8c803150958eb5ed16ac9d4078d5679a753"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_html_use_index__Example_configuration_f": {"doc_hash": "fd51d619050ff5a92a31c47030e94e3187dd29f2a85e09f6679b7e1a7b7bcfef"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_intersphinx_mapping_": {"doc_hash": "46b6a5cd84f98da47a516fb0094a30f11bd031da7dc2107d4410db2213e9e433"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/append_codecov_token.py___": {"doc_hash": "e3877ee14541462502ff9b75de85b0841809fed31cd88b03c4c82f42a0e8b5e7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/publish-gh-release-notes.py___convert_rst_to_md": {"doc_hash": "4910db56c378b0f04015284b781ef16e056e167f5963df3bd813ff31f65ea9c0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/publish-gh-release-notes.py_main_": {"doc_hash": "5def74287adbc66f97aabd362e39e5588d50ad187e641448f4dddb5e89b66148"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py___print_and_exit": {"doc_hash": "bd55833e7fc97521fca37e3a58e535f15c22716495abf5db6c37264ccc72c757"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py_trigger_release_trigger_release.None_1.except_Exception_as_e_": {"doc_hash": "6b107e4767bcb53eccc06915c7452a72fe5abcaacec9c8d11d8cf3d162fabf3d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py_find_next_version_": {"doc_hash": "7a2ab62d1c054bee975cc27200d1a3eb22830ef73dcc0379e7d1e0634f6fe720"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_argcomplete.py__allow_bash_completion__from_typing_import_Option": {"doc_hash": "a91542849ba4dab1a2382fa3532e0bbca2881df236e49c3643bdab195e75e88c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_argcomplete.py_FastFilesCompleter_": {"doc_hash": "eb4948dffcb1b82ef7f7796fa0e8b15ff54665fb3698e97d21b307e50b36db5c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_inspect_if_TYPE_CHECKING_": {"doc_hash": "5e9ca02f52e9430299e6be40ef5f82206bfd22ef96009012a87bf0c6234d48ca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Code_Code.getargs": {"doc_hash": "1745ea6f829d48ba29cfce6b5ad96afeb5cad642ec3484c9e2835b476982245e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback_Traceback.cut.return_self": {"doc_hash": "3fad14e0c599febb324593f9c84966d5c62c47f6a10042a1cbf4fdef265c8a82"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_locals_FormattedExcinfo.repr_locals.return_None": {"doc_hash": "a026201984b0d89c81dd4a32201ca4f6130cc68e31c4cae6481944dda660fa0d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_traceback_entry_FormattedExcinfo.repr_traceback_entry.return_ReprEntry_lines_N": {"doc_hash": "c130e6d8b174e8ed2d54dc01fd0d13390f179f683467b3b96faeb0e5dfb8b140"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo._makepath_FormattedExcinfo.repr_traceback": {"doc_hash": "a9537c131dc27fb5728f3fd31f22c55aeb2648a4a65a5f075b8e166f4cfeee54"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_TerminalRepr_ReprExceptionInfo.toterminal": {"doc_hash": "01d64418bbccd81217c33d42acd7d539fc1538ab31eb8f7e3e864d62b322d3ca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprTraceback_ReprEntryNative.toterminal": {"doc_hash": "ef59bfbd7b6e77c0939c53b82314e36dd25d4a1027cdbfcd77f256d4e99f3af4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprEntry_ReprEntry._write_entry_lines.for_line_in_failure_lines": {"doc_hash": "ee0a65a0e74f9236f881824de73a8a8ae0dba2a55a83dea256af9322c12cef2b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprEntry.toterminal_ReprEntry.__str__": {"doc_hash": "0f67300fd30cd3cd6561303e64d41dfe650842c445d570dbb2212ec77003b5ea"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprFileLocation_ReprFuncArgs.toterminal": {"doc_hash": "19ea7ffe9dda0fd26a0cc6d4f41cc7529b8c01dfcc1c101d222dab12cfa7dfbe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_getfslineno_getfslineno.try_": {"doc_hash": "1bec34b3f3fdda65af44b6cc673840aa13e6d01373a8f2fa13063c5e9c7988c2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py__relative_paths_that_we__": {"doc_hash": "ef139686215a1867bec744e0a19d5718ef4a2a669088918a8dfa0c52be3fb962"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_ast_Source.indent": {"doc_hash": "a5d654d81078eae11ce122923ac83a60e88c7c8ecc81a7a460bb0602a89001e7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_Source.getstatement_Source.compile_15": {"doc_hash": "8b488af1891b006ba0572bcc1b6034cd23db897a820677c3233860f6ce97f3ec"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_Source.compile_16_Source.compile_16.try_": {"doc_hash": "e679165abfc39ae42b69adc759f1f4c99c542c89f298fa46abbff67e161fbf07"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py___compile__2": {"doc_hash": "406ec9dc70166c8abcce319fb16666ac128d5070e889fa4bac363a722536e291"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_None_3_deindent": {"doc_hash": "01ce1399f33483baee78dcdf0bc0f0313bfcfc962cbc699e2469a6aa1e3f0c51"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_get_statement_startend2_get_statement_startend2": {"doc_hash": "5cc115cf8dc501a03119df661140df4e8314bad4a6938113ceca2b11b18eaa6e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/__init__.py__": {"doc_hash": "1008fae3c5f759597a3cae5a06f630d65a693cb8da89f86971ca9d95ccd4bec2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_pprint__ellipsize": {"doc_hash": "1c28c99e10e2082c001ef89fa6586bc8f55406849cea6c13c96d459bef30f11e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_SafeRepr_SafeRepr.repr_instance": {"doc_hash": "ac2e99163cb56bd49a09ddbc914e0bbf688f0095e89fe5aff5d62897e293f920"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_safeformat_": {"doc_hash": "b1dbb4dd9b8d9397f3a919c11868ab880ee23a8f52adedec1b9638f60a5f095b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py__Helper_functions_for_w_should_do_markup": {"doc_hash": "ffa007396d0c18f8ae80d3b7fc68ce0e82fa5a11e1726e6303e186680156d6f0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter_TerminalWriter.markup": {"doc_hash": "1fcdcda67add2b6ca9e8544dc59aa36118987fc377514132a1031501b997ebec"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter.sep_TerminalWriter.sep.self_line_line_markup_": {"doc_hash": "408bd99d8ae7ce8a9156b63a76f4bf6cf8b9fdf0e26d68fb9583314242fe3959"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter.write_": {"doc_hash": "0e91884200e4e588f0ff94c06c2c87df82b0692a9f149133d80afb1132e91b22"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py___pytest_addoption": {"doc_hash": "990d97390dbf1a9f0cd7c40c72da790e5f8911e2fc1c533b3e022f8862601733"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_register_assert_rewrite_register_assert_rewrite": {"doc_hash": "4a2b128a5bd0cab7c4745bf00db5306402a681300f6ed95b0a8e84e6291c974b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_pytest_runtest_protocol_": {"doc_hash": "1d995e6081ce9743766f678faf1aa6618e2f1e82fc5f453c382a1ffe7a2af6c4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__write_pyc_fp__rewrite_test": {"doc_hash": "900e4f4eeca402f69518fdb2ea263e7fa318cf070ddf9397af16c8c4fd6a5297"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Assert_AssertionRewriter.visit_Assert.negation": {"doc_hash": "fa5d69b30e703b758abe1a64f06cf9c513fc7172846cced51f1798aec4c6b485"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Assert.None_2_AssertionRewriter.visit_Assert.return_self_statements": {"doc_hash": "cfd3677e63088ea11711514406cef83b4dd8337e22756f770489403411f652a7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Name_AssertionRewriter.visit_BoolOp.return_ast_Name_res_var_": {"doc_hash": "15b45a96d09d9ebf1ddc572ed9814c2bcc17e2b6e2b19bc878a379ce613dc7fe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Compare_AssertionRewriter.visit_Compare.return_res_self_explanat": {"doc_hash": "9b8508f4afd1f492f2afad0dbb71707aac5edb6d75ac78d951bc471092a219d2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_try_makedirs_": {"doc_hash": "8c5db2b60a3e66c06c046d20ac7b08de4ebe63b1208b92823432e2891a7fc0c6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_verbose__surrounding_parens_on_own_lines": {"doc_hash": "ce3c263779f8090b971ae79a9b56268ff78bbfc00f83213d9d12aa396d0ccb64"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_iterable__compare_eq_iterable.return_explanation": {"doc_hash": "e60a30c466e250d20f8ec095c7f2251dad827eba60dcd7743d4ded2792485b3e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_sequence__compare_eq_sequence.return_explanation": {"doc_hash": "b2729a71e4cd18443d052886d4cb992790bb0baf276038708cf77d93dffd1318"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPluginCollWrapper_LFPluginCollSkipfiles.pytest_make_collect_report": {"doc_hash": "b3902acce61bab15236d29c3c88cea76e12df4b73da1b2fe22da7daabe1fbf86"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py____get_multicapture": {"doc_hash": "7e579f7296a28a20ec9b0d99a944f71aefc754ad65b49077d7c7a509d2a6955a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager._capturing_for_request_CaptureManager._capturing_for_request.self._capture_fixture_2": {"doc_hash": "f9d0decdfd2244fd9b9d3f61008ee7ffec565e8a083e71a3b85cefd9d51c6b17"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_capsys_TeeCaptureIO.write": {"doc_hash": "fb2bdf437d6e356409c19512fd026e7ac759e054b23abb0a16d4131550634a7f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureFixture_CaptureResult": {"doc_hash": "980ac12aa55ab2385e160641d37562aa657eb14e126498eda3034fd7aaf1eab2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_FDCapture_SysCaptureBinary.writeorg": {"doc_hash": "1aaab6f423e21d94fd2332c21bfc89234e923f348e69ed167c05bba23a80bddf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_SysCapture__colorama_workaround": {"doc_hash": "436854f32871536d64de784a1880534a56462c6273a88c7c663c6e1407296e4b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py___getlocation": {"doc_hash": "aac5c33f509e720972427b8d61155d69b8c5ca178554592aefe8e8c78aa402d9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_num_mock_patch_args_getfuncargnames.return_arg_names": {"doc_hash": "a91586ccadd3a6d0415d5286f78b2d08872f14d87bb2a7dd50defb086b4c7a9e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_None_4__bytes_to_ascii": {"doc_hash": "3002f711ad61303f9d3d7a483b6cc55ef1467fe5dad8bcaa350e02e71195b50f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_console_main_get_plugin_manager": {"doc_hash": "7b702e55d47605b891dcff7419b4179f5a04367d4d83147b380f1e53e89bd532"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__prepareconfig__fail_on_non_top_pytest_plugins": {"doc_hash": "6ab369999b2a9382eca0d060649fcbc1661a9e958024d58316caf410cbfb4d10"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager_PytestPluginManager.__init__.self._configured": {"doc_hash": "be7e6e637f7053299a951a3c76f36037557c45b17de53e3c0eec59bf96fdedb0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.None_4_PytestPluginManager.consider_pluginarg": {"doc_hash": "1a269567c0bbf5752c6871de02bfd1dd63c1fa419fd578dcced1a3d4ab1ce973"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.consider_conftest_PytestPluginManager.import_plugin.try_": {"doc_hash": "cce6253a159e580e2e160ebae93c3f75939c9a5cf6e6f52dc5d08ca75607f1fa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__get_plugin_specs_as_list_notset": {"doc_hash": "b355cd446f74e0560e01ae963ca3fae1fda3cc6c99cb94a82336dc826d19e255"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__iter_rewritable_modules__iter_rewritable_modules.if_not_seen_some_": {"doc_hash": "dcc0c99f50356de63aeaba7d2b8f798e894cd3c466aba998e7b9b74c5ba77e9a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config_Config._ensure_unconfigure": {"doc_hash": "b2a48c65bdd7dcacecf8fdb6b139eb954960ff661389a21dc2d92b8e282ee73b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config.get_terminal_writer_Config._initini": {"doc_hash": "2b894bce59666ce8e61649d281665846f65b3c29d2e041edab81a73c34b4733e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_argparse_Parser.processoption": {"doc_hash": "bf7c2b99d0a1a4b13876c7bca31e14eb72cba844754a9552c2bb271767ea808a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Parser.getgroup_Parser.getgroup": {"doc_hash": "9a6df22c22db04da20bbbdbbc92d1e84fb3b7bf1ff3501dbc307649dfac00c91"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Parser.addoption_Parser.addini": {"doc_hash": "eca9b277ba1d6117ff33c4f5dcaba8634f617bc6a49fb38e0c0ab555eece1bc2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_ArgumentError_Argument.attrs": {"doc_hash": "93f8c94ad02915c533c9e3fda368e5f3e0d367f0123b90ed3ae1870786f50612"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_MyOptionParser_MyOptionParser.parse_args": {"doc_hash": "7c085451ee57b42693bdc3f14bc1765e48012d78528d8763a446b82a47549e03"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_MyOptionParser.if_sys_version_info_2__MyOptionParser.if_sys_version_info_2_._parse_optional.return_None_arg_string_": {"doc_hash": "e98694ca0f389450497ec87ee83db24dc290d78de69db08ea322ed721626c901"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__discover_and_run_doct_CHECKER_CLASS": {"doc_hash": "ff4ec2079484297376a1c1730af631c608b85eaa3aa6bd2c3c904bc74cf8a4a0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__type_Optional_Type_doc_pytest_addoption.None_6": {"doc_hash": "509373882bf12bb97ce87c7984880322f63ef334b9afaca75ab08139cc232487"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_pytest_unconfigure_MultipleDoctestFailures.__init__": {"doc_hash": "45bd419c2463c28ae306291b4457b60717ee7215626595171532de05d85f6a4c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestModule_DoctestModule.collect.for_test_in_finder_find_m": {"doc_hash": "1745a4dfd3c253787c7dcafff5ebe71263ffa8f885a7d08cc14be5b7a8cfdd9f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__setup_fixtures__init_checker_class.LiteralsOutputChecker._number_re": {"doc_hash": "5bc191e128e096d4d9763aaf49757e10017e2d3bf5c31ec0caf80f4c13ab8400"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_checker_class.LiteralsOutputChecker.check_output__init_checker_class.LiteralsOutputChecker.check_output.return_doctest_OutputChec": {"doc_hash": "7b0c1d20ccf104ea3f26a4e8b1a69324cffdd8310b621a30c1d1b1aba91863f1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_checker_class.LiteralsOutputChecker._remove_unwanted_precision__init_checker_class.return_LiteralsOutputChec": {"doc_hash": "4cb30921335e43e25f5822dca50271106878920841d6ea52fe09e7180ba652d6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__get_checker_": {"doc_hash": "a3aa5212805355bc77911f8c7aa45997f33cb838c5914cbb76f11442fa9b74b1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/faulthandler.py_io_pytest_configure": {"doc_hash": "5966e92cdb4e9a32b552ab8a9239df9ae15c4ef7dd82795a02467a952ee1aa98"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/faulthandler.py_FaultHandlerHooks_": {"doc_hash": "93018a7fcab6c2acf8994e86a1f874e964c7485f136b118323d96371db4e15b5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_reorder_items_atscope_reorder_items_atscope.return_items_done": {"doc_hash": "ce5e1a530b75c11fc58ce05d0f6fe79eb86c45fd03a7a3797daf3e845351258d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fillfixtures_get_direct_param_fixture_func": {"doc_hash": "1d87870bdd87d5325bc0b4637b15a0f1831d35cb9b058fdb01fc7ed606b574d4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest_FixtureRequest.module": {"doc_hash": "1808e670701b1c2ae67dde1e3194912230f036fbbd8404ce44c2f1d9e1110873"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest.fspath_FixtureRequest._get_fixturestack": {"doc_hash": "0f0beba47ffbbd4c81130d8d880168aaef0f6a6b9421ce9aad24be08feb253c7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_pytest_fixture_setup__ensure_immutable_ids": {"doc_hash": "0ff5eb43f80da36870b8197bcca8d74383f04c58cf6df9c66bb0c2150d46a25d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_wrap_function_to_error_out_if_called_directly_wrap_function_to_error_out_if_called_directly": {"doc_hash": "5f972f6fea09ac8fad74c1d80b34f88c9243d581efdce8fa0f2d01022769b67e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureFunctionMarker_FixtureFunctionMarker.__call__": {"doc_hash": "6a8b4bedcecba910518924b83d487de4995c03793205fe8890b088218c8d6517"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fixture_fixture.if_len_args_2_": {"doc_hash": "88858feac6240b2f7d3559b41ca8992d1641a499db815f06e43dcda763077ec7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fixture.if_len_args_3__fixture.return_FixtureFunctionMar": {"doc_hash": "ade821de6e71a6c22a27971f8502f13002acf8e6769e490a1eb116040d15a30a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py__hook_specifications_f_pytest_plugin_registered": {"doc_hash": "18ff3e587ef04caf1bfe117f619ef0cfaedbe2865c58adbbbc70ac3e0c70934b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_addoption_pytest_addoption._register_argparse_styl": {"doc_hash": "55231182e1628382b62a6c86f851fe389a693bb89174757a0d7e3dfc7d5916f4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_configure_pytest_load_initial_conftests": {"doc_hash": "9be6e4d2fef4aee07cd5195206671cd6f3b9e945a67d59d04c32504829ec87c2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_8_pytest_collection": {"doc_hash": "fc7cb9cd202b1d0593f5081c160f16b79f2d1cc57ea06c933ced3a8aad6395cf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_collection_modifyitems_pytest_generate_tests": {"doc_hash": "f0a9a5a90c457e621368dc17cf254062eef64e5dbf57b36443c80c368b0689ab"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_make_parametrize_id_pytest_runtest_makereport": {"doc_hash": "2f5c1f90618c846e7d37a649a4c69b8936b6a0a6d9ccf9b575442c45863d0fa3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_runtest_logreport_pytest_assertrepr_compare": {"doc_hash": "9cf2daaf2658a182b05dc9557e4b70babd0a2335390466a23fa4cc8d69d11ec3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_27_pytest_report_collectionfinish": {"doc_hash": "9114171aec6d5b48be845d5844e2210b379707c16462243c41288001e547d68d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_report_teststatus_pytest_report_teststatus._Return_result_category": {"doc_hash": "e95e0f78364a221f0c86f2689f61ea176ab1dd74fecc661f45da4e28095e6855"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_terminal_summary_pytest_warning_captured._": {"doc_hash": "d40074419105ebda2f1984bb9b1d6308e6b3637faa443e644eee72bf3c728b76"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter.to_xml__NodeReporter.write_captured_output": {"doc_hash": "01d73989127e9306a0e3f909cff5458626d533d6be76819f695c1d72e89a8cd1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter._prepare_content__NodeReporter.finalize": {"doc_hash": "f42884c0436d6f57dfacb6e9e77986899abe96c2f17444ad93beb64464fce38f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_PercentStyleMultiline_PercentStyleMultiline.format": {"doc_hash": "7e8e478f94325a0a6d71bfc0f12c3b03688f132f8cc925aba1e81d3055160ed2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_get_option_ini_pytest_addoption.None_12": {"doc_hash": "0ae55a582fc67487e21440226605c7e269043eacc2fccf8445edec40c6b934d2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LogCaptureFixture_LogCaptureFixture.clear": {"doc_hash": "9305f4767094f3f3cdc3729d0970bfe24145dda96413b23651028430c7adb33d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LogCaptureFixture.set_level_LogCaptureFixture.at_level": {"doc_hash": "0abf5a2274685821129fe61171878dbded8120b67d30ac0b8cd1fc50277b7ce3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_ignore_collect_pytest_ignore_collect.return_None": {"doc_hash": "854d39b72656396fe017e8bd590f003fabbd5eec5e6fa40ad46ea3cd64501844"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._visit_filter_Session.matchnodes": {"doc_hash": "1b736ebf9f3ed7cb4023aaab3e8ce384162351e1c64f6ae9efd68bfa681ff88f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_r__ParseError.__str__": {"doc_hash": "4afb3a0136c2f9eac526ffb8a4a8e043bdf9802213f8a99cd20037d356222236"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_Scanner_Scanner.reject": {"doc_hash": "7e68d313130cc142954457ef4c443817b69f7eee48676e14bee5ddd9915c56f9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_expression_": {"doc_hash": "00d5556f99c33098afda0eb5f232c68bdc1bed6f34afbb61a4a12ae5ae4a52b8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/legacy.py___KeywordMatcher.__call__": {"doc_hash": "4d58fb78f2355addb4cc3ab78a969cf14bdd40acc934038f92adb3a4b59d87f7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/legacy.py_matchmark_": {"doc_hash": "eb2e7809d50260892f86ad5c549c7ccab5105a74f4ae052ece5f71deadf8c5b2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_ParameterSet._for_parametrize_ParameterSet._for_parametrize.return_argnames_paramete": {"doc_hash": "68530921f55eb2d9a9e5976240a544c8e42d34db446835121bd6ae0bbf44feac"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_Mark_Mark.combined_with.return_Mark_": {"doc_hash": "5bb984064f3fa6e5410828d9d3f0baf48358f42e5fe1256dceceb8e6713f355e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_os_tracebackcutdir": {"doc_hash": "aae8db9d8ea1cdae27008470d65232c49aa3b196d12bcea7e50683ae3fcd28d3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py__splitnode_NodeMeta._create": {"doc_hash": "9339aa4c75b4387611905800109a412f6243571e1e1ba700824476d55db24de6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node_Node.__repr__": {"doc_hash": "e5c8b0dd884c70fbece2560dcb4bf0e6f13b305ba963a992186ae6b7abe7ef10"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node.warn_Node.get_closest_marker": {"doc_hash": "3d0bd6526b30b743131b3931cfdbeadb6976b60f937368dfbc64ab14137a43d0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node.listextrakeywords_Node._prunetraceback": {"doc_hash": "0a840de4bb1cf40fce4c13ce4b92ba57ab18a349316551e65672de3982b4375e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_get_fslocation_from_item_FSHookProxy.__getattr__": {"doc_hash": "24133d460f49a4f9a94c5ac144cd7e28a4f97f2a0e0bf2de186f06f7e44cd3ed"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_FSCollector_FSCollector._collectfile": {"doc_hash": "e3427706af35026cf7ec6dab018d62c7be4df7277868f814e2ff0d9ab7bb149e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_File_": {"doc_hash": "598375e46856ad2c246181076de632f4deff651a3dbc8495aeeb762cd83750ab"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py____exposed_helper_methods": {"doc_hash": "e7372be31df86f3ccce1014f8da8b8d2533e025f5a9de7a65af285bc4a199541"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_exit_skip": {"doc_hash": "037437f45052a183ab5ec7779e380dd82bf793a34b5ccef1fbb9d1e1dbb9edcb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_fail_xfail": {"doc_hash": "3e8353d2a3abd753a379cb997de412eaaa065eb6a3ab34222749a51faf273c6a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_importorskip_": {"doc_hash": "018a42972079a9a4989543ba12ab10a55174f85de4ae2e9d74bd170aeb3d0271"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_atexit_ensure_reset_dir": {"doc_hash": "afc1fa0475cc583a74da188ec889d56dc65b2522ac98788a315d8f4b1f19415d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_on_rm_rf_error_on_rm_rf_error.return_True": {"doc_hash": "207951ca9511104fa3ff45fc7eca016bbf4ead19c711b1f5841cf2df2e127b7c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py__used_at_least_by_pytest_ParsedCall.if_TYPE_CHECKING_": {"doc_hash": "83420f4f62cf484b7f192fa589c76b782a6f636a36182128dc4eff52687c08f9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir_Testdir.__take_sys_modules_snapshot": {"doc_hash": "7608e3f1f3ebdf46a998d1d168fdd739bde1b759408f366fd7f389533497fc2f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.make_hook_recorder_Testdir.mkdir": {"doc_hash": "e699c60ff853afa7a326dd76d6676ad4ee8f2c30ce0a0dc8d639c8768d09776a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.mkpydir_Testdir.copy_example.if_example_path_isdir_a": {"doc_hash": "b8c0953afb9a90f02e7f83d586fca76186382e4201696643516d7327b1aa38cc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.runpytest_Testdir.parseconfig": {"doc_hash": "53a4d0cd0849bf8e5cfa0b8e6bda8f258565170e41ae7af07b0f702b4c119deb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.parseconfigure_Testdir.getitems": {"doc_hash": "1c19ffbd84272f52f26a47dac7488d67db22cc577d0f2828063bbc2451b63909"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher_LineMatcher.fnmatch_lines": {"doc_hash": "de13a4646b93e34cff3ab28bf1869641f0b0d2e785a13588ef5dcf02eb3f1624"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher.re_match_lines_LineMatcher._match_lines.self._log_output": {"doc_hash": "1b5286668c437e1e76036899a022248826ee10e490f6bf3fe350069d0242915c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher.no_fnmatch_line_": {"doc_hash": "fbf07e10193ae0592b5f197e74c92c08d8222feb745b588a4afa0ace4eec4543"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_async_warn_and_skip_pytest_pycollect_makemodule": {"doc_hash": "2ecad4c9f1adb01dfc18accd661a55ec817af4ab424878649efbe62dc3e480ad"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_pycollect_makeitem_pytest_pycollect_makeitem.if_safe_isclass_obj_.elif_collector_istestfunc.if_not_inspect_isfunctio": {"doc_hash": "fded001b73ec076ddfd892625c3ca77e944f7b966eb119adfbf45aee0106471c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector_PyCollector._matches_prefix_or_glob_option": {"doc_hash": "b00bad4f30da6ddcce74c7c8370d948e5de27a083be1ef29b8dabbc5356ea0b0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector.collect_PyCollector._makeitem": {"doc_hash": "2e3e1e73d0c612f07a8313dd21cb954e6fd41eb312c2271ffb55e5b023721ba7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Package.collect_Package.collect.for_path_in_this_path_vis": {"doc_hash": "082508fa2295b4cca7373d658b6c405824df31111248c9a8dc63f51dbf1a01c7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__call_with_optional_argument_Class.collect.return_Instance_from_par": {"doc_hash": "f59c5c411dba2aef5d177a553a652d16a7bf544fec8ca7be435b4c57f688c935"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Class._inject_setup_class_fixture_Class._inject_setup_class_fixture": {"doc_hash": "f3f095149c32fccccd47663e9b179ecfd3c0e14a70fe1db545b731d66f57414f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Class._inject_setup_method_fixture_hasnew": {"doc_hash": "8b309166875423f7254d50b7a2375ca64b9df10966d0588b26a243b7ad71e266"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc_Metafunc.funcargnames": {"doc_hash": "b55ae270c87c13f297430e757bee3f0ac00d40c227ad3f467b43f9845c663d3a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc.parametrize_Metafunc.parametrize.if_request_in_argnames_": {"doc_hash": "8d21bb554bb7a3c3e3552f43a1313da4dc0c72d01d5aa74cdfd0f3bfa01ddc2c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc.parametrize.if_scope_is_None__Metafunc.parametrize.self._calls": {"doc_hash": "3bca0b15f5fc01ecec4a2acda3dbda023f9a2c4628c7de773c4a6e57384d5cc2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._resolve_arg_ids_Metafunc._resolve_arg_ids.return_idmaker_argnames_": {"doc_hash": "1121f3ac8c06fe9a8a3691b5978693b424bc10ca669b5bf84c4ad8422a6ef75b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_ids_Metafunc._validate_ids.return_new_ids": {"doc_hash": "23f28070ddb85be0e162e7dc39daff69b20369dcfe409c4a2cddd7a671a6861c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_explicit_parameters_Metafunc._validate_explicit_parameters.for_arg_in_parametrized_a": {"doc_hash": "40097591e95e09de35d32cdf6064fb0462ef8e49564e20f167c0b6040ee76313"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__idvalset_idmaker.return_resolved_ids": {"doc_hash": "92354d6fda8e65a8673eae4e050ede0ebf704f8bc11e30e3782cc03e73c5204c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_show_fixtures_per_test__show_fixtures_per_test.for_session_item_in_sessi": {"doc_hash": "f30a26af029ee99317677c2c3773fa4c9fe82520738a008e69b839c4434a8ddb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_showfixtures_write_docstring": {"doc_hash": "7a78a624fd10d10e8672464b83ad86e56c752d885497ee0d5df7acd9811b1492"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Function_Function.setup": {"doc_hash": "96a8ba2a153496c5fe9e67707bd82cd4261607945054ff0cc1cc7e97bdcd3187"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Function._prunetraceback_": {"doc_hash": "dc3a7a9e9ea5e604a722f131ea0301544ece18c546e85b5c333ed567375da4f4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py__basic_collect_and_run_pytest_addoption": {"doc_hash": "b17836fbbae9debc185d9338baf802197bcac4f42322367fdb9d64539074bb39"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_terminal_summary_pytest_terminal_summary.for_i_rep_in_enumerate_d": {"doc_hash": "cc3013299399a452fc8cc2c3a1b4537fc075e0b4bc1bfc40d68039e78e3f7ec9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/store.py_from_typing_import_Any_": {"doc_hash": "2912b70ed6606cf0049bf077505cb0747e104fe7649519073b86bbb331f0c2ff"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter_TerminalReporter.write_fspath_result": {"doc_hash": "6bbd5232a0fe2a50074c4482ae199ed4ab36316660f6bd2249a6c9828847e9ec"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.write_ensure_prefix_TerminalReporter.pytest_deselected": {"doc_hash": "611bfa92eaa8cb18f6a4ea6cf56f32d189f38c9c262abed1e8c165ef03376614"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_runtest_logstart_TerminalReporter.pytest_runtest_logreport.self_flush_": {"doc_hash": "6491b0d05a194710d12d91189adee9b2164cddad39321a2ee3a3ea22ed5c1ad7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._is_last_item_TerminalReporter.pytest_collectreport": {"doc_hash": "5cb2bad729f29678e5d006b7878ca317a78afddad829ddfa7a3d3f3974835720"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_passes_TerminalReporter._outrep_summary": {"doc_hash": "52ae8e2666770db9bc8872b7553b6d46738fef79bb87d87f570ea7e7f504e6d4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_stats_TerminalReporter.summary_stats.None_5": {"doc_hash": "35e9bbd1ba45c3c1b9e270e75a1eb2dc021087d9b619e724a67b4f0b21fee485"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._get_main_color_TerminalReporter.build_summary_stats_line": {"doc_hash": "1d8c0bfc65a819fb0cb67092c75187536fe99a71639f256989e9d378c3ad513a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__get_pos__get_line_with_reprcrash_message.return_line": {"doc_hash": "479549a48cc49c6d3ac006881334b72f2669636e40191b723c98b251d35742a8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__folded_skips__folded_skips": {"doc_hash": "deb675975e51b3148cad1f4003c16b6161d6e3841ce5ccc09986c15d4d1f0da0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__color_for_type_": {"doc_hash": "78b4efe7c8940885b47b9d2a880a7af65b8b2c869cf07b1a59adab8439db2d23"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py__support_for_providing_TempPathFactory._ensure_relative_to_basetemp": {"doc_hash": "4b746ef988891c2b0ca7f9a69313ba8e84da9f2d6e85e6ef171a21668cdfe4f2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempPathFactory.mktemp_TempPathFactory.mktemp": {"doc_hash": "2fde742cf20c126d7cd74c04043463ebeb93ed9145d4d2f8c4c53534f49ed66e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_TestCaseFunction.addError_TestCaseFunction._expecting_failure": {"doc_hash": "8c569987d2ef62dad9b214e309fc8534d2e5bfbd4d305f5a12762287e66d94b8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_TestCaseFunction.runtest_TestCaseFunction._prunetraceback": {"doc_hash": "43da5d0a7a7d96abad88420f9c99080d59d6d3aa8303cfe37ae03df5557b5502"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warning_types.py_from_typing_import_Any_": {"doc_hash": "29c2c2082aca412bae21d9913800fd54763e6d1679bb0cf0d3880b3b72688ff1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_re__parse_filter.return_action_message_": {"doc_hash": "c61f47b209146dc78699f3139b16a8a1f29ff34b84b8081d5fceaab8dc0992cb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_pytest_addoption_catch_warnings_for_item.with_warnings_catch_warni.for_warning_message_in_lo": {"doc_hash": "1267e2301036120bda19a5b5cf33178c6baa5b06f34ece0fc40611a3a96ff191"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_warning_record_to_str_pytest_sessionfinish": {"doc_hash": "f9a1b07c3c9c8faa88d1c2052dbbb3ab575f6e320ef3a10ebe144f18da073a8d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py__issue_warning_captured_": {"doc_hash": "909f0078fa31c4941d7cbe3f63edd680efd41de45cad39aa44f67c71ebf2b7b6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/__init__.py__PYTHON_ARGCOMPLETE_OK_": {"doc_hash": "5d08def21ab81416bb1dee20414344a45c21b28f78068d693a64a27aa6364c38"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/__main__.py__": {"doc_hash": "db88376ca52f5ce90e2074f82f8000896930107d7c2c10cc3551137813e69502"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/collect.py__": {"doc_hash": "0c709faf628ae525b07ca5232d2f506ebf555a00b61c42381c845870aab54e30"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_better_reporting_on_conftest_load_failure_TestGeneralUsage.test_better_reporting_on_conftest_load_failure.assert_result_stderr_line": {"doc_hash": "960ca20ccd132371e994220bf00bb72a2725a155c51a0c2a085f7039a2850f3b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_not_exists_fake_time": {"doc_hash": "89b0834c890d1c969f37d873bc3c993829c333ef4cbfd95904b4c32670b1bb49"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestDurationsWithFixture_test_deferred_hook_checking.result_stdout_fnmatch_lin": {"doc_hash": "df5445b66ebba26447db8fec9d3ed3d85a479bc9ba6ad2d49de79ddaa650fc52"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_fixture_order_respects_scope_test_warn_on_async_function.assert_": {"doc_hash": "882af336b627cfc1993311dc84d49898b068437622dc8755379dc37dd0233313"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_warn_on_async_gen_function_test_pdb_can_be_rewritten.assert_result_ret_1": {"doc_hash": "c181b097c20be0476a8d7378da5cd313a5b4c11b1bd25d945e3fb76e4c7c9c76"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_tee_stdio_captures_and_live_prints_": {"doc_hash": "f1481df60158258e63c8e566d55d4cbc38a62c126756c7c58a2fd792fed3498d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_io_h": {"doc_hash": "e169df56fb946affcd566502922389c93c33c3e4c39b1dc1689188017d555565"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_test_excinfo_exconly_test_match_raises_error": {"doc_hash": "5b812d2f4525bb616c5960c78159cb390c34f72c46135650e6996cc3e56c07c9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo_TestFormattedExcinfo.test_repr_source_failing_fullsource": {"doc_hash": "fb8e4cabd4935ed5174a7ebde1dfc042979cf43ec737147d7326b1519817ccfe"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_traceback_with_invalid_cwd_TestFormattedExcinfo.test_repr_traceback_with_invalid_cwd.assert_raised_3": {"doc_hash": "f49364cb53bfd793a9b36015b380d4c52737ed053417a3795fcc1026b2a6baaa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_excinfo_addouterr_TestFormattedExcinfo.test_reprexcinfo_unicode": {"doc_hash": "fd0de8aab63c337d772d649973b66ba18e813b667bcd58c14bd6c6dc0d70da5a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_filenames_TestFormattedExcinfo.test_format_excinfo.assert_file_getvalue_": {"doc_hash": "e40d63115dbb6d5b450953c3860ce72a19db9f652e224fc79ac6545d3e58f213"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py__flake8_noqa_test_syntaxerror_rerepresentation": {"doc_hash": "83229cd1719fea19e40cf8088f9c69167d41c7dc3c3f8c8df958e765f6355a4a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_isparseable_TestAccesses.test_iter": {"doc_hash": "ee6663cbd70cb3448f1ead09dc5d16c543c6d8a9e2205bd7a12e97f513c08812"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_TestSourceParsingAndCompiling_TestSourceParsingAndCompiling.test_getstatementrange_bug2": {"doc_hash": "721409bc3a989fcd98ce7d1952d01832feb44c6e93219c0efd519181c4be6521"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_getstartingblock_singleline_test_compile_ast": {"doc_hash": "926bdf001c367d7dbd688dd521b2f40afc06b6f0384ada30201dfc515b8741c7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_findsource_fallback_test_getfslineno.if_hasattr_sys_pypy_ver": {"doc_hash": "af82944b4da502a84efb863994095771edb99c8cffaf8812f55f245c859dfbf6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_code_of_object_instance_with_call_test_single_line_finally": {"doc_hash": "217b4547550aed788f4e0c75b7c151b963c1902718086c3a68fbcaf120b8f987"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_issue55_": {"doc_hash": "40abc59457940dea80317b3049e8bbe17d59c029ef34b85c898b8a6812b25806"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_re_pytest_collection_modifyitems.yield": {"doc_hash": "8f223099dc56668d6572d2a3edfca96ed255d302382e64ced3190b055b176d80"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_tw_mock_testdir": {"doc_hash": "dd917ae83dd322ef84cbb1cf820fdf2c63fb5ebad8be75e82e1d861fc9f54fc4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_color_mapping_": {"doc_hash": "05b24879bd4c5e99ddb74ba5e2a829d900739147e35d7564d41bc3202c7d7b5c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_copy_test_pytest_collect_module_deprecated": {"doc_hash": "425c489a506161dc64779611c8c76e5cc5d48d560a62ebba418cd175c21cec24"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_test_terminal_reporter_writer_attr_test_terminal_reporter_writer_attr.None_3": {"doc_hash": "9501686f97b5b9e8b914bf282ad5b5d6eae7111fa3d675510f749e83af61077c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_test_external_plugins_integrated_": {"doc_hash": "890684575ef52f5becbaa77cc1063a9b85e3b4b646d8d2f61735ac6b06cd8306"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_unittest_asyncio.py__": {"doc_hash": "504864a51d5162097222f5d512d1ade049e45a5652ef505885a4ebfb65d6db8e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_unittest_asynctest.py__": {"doc_hash": "567976bb01d24dc6c0c438bb6b06c7e64448d3ab2028ee9fa4d732cd4a57b1cf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_1.py__": {"doc_hash": "22c189f2f6162617f14d8b89760e6863e209e2c70afeb2a68f6a981e4d26b26a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_2.py__": {"doc_hash": "e3b0431aeea5f50f1bad6a777ec2cbc1f1d1910d832712b586f675b424bd0417"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_pytest_test_exceptions.assert_s2_": {"doc_hash": "50f99752cffa4d5302dc5b7bae47e4965631070e2b2d56830ba8df871c6cb7a8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_test_baseexception_test_baseexception.None_5": {"doc_hash": "c89e139ec86b7232bfebf567db0d9b122b9e34e7463a3553e9d7b4e5cd8969bc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_test_buggy_builtin_repr_": {"doc_hash": "11e73076e2f90b6a47279a5ee2fb316c8db95834c49180162e0dafe84e515c87"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_io_win32": {"doc_hash": "7bc1a492ba2338130252d75a8f00fa3447b03074d377f0ea7aa310444af18941"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_TestTerminalWriter_TestTerminalWriter.test_attr_fullwidth": {"doc_hash": "a43cf054399efb5ba9dc06331db12a002ff341ed5645d9be2afd8f484a0eb777"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_test_attr_hasmarkup_test_should_do_markup_PY_COLORS_eq_0": {"doc_hash": "b29ecf7bc1f345d2bbe0bbb7d5ef48e28cc1d7cfc29963f6fa8d8791467e2867"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_TestTerminalWriterLineWidth_": {"doc_hash": "0905fc8717bbe0d0494612b404ec274703a98135bfb2f2a8df53c7f64953ac76"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_formatter.py_logging_test_coloredlogformatter.assert_output_dummyp": {"doc_hash": "3e86e599adf98a2be7e9feac890ebbf41945853e25ebb8bd48f676f522e0eaca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_formatter.py_test_multiline_message_": {"doc_hash": "3c1b32f87d18f6d08b30133f656c99e41efe17db7e85451744b6e3a244012bcd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_level_test_log_cli_level.None_1": {"doc_hash": "56f8b414c747760e64591643e652b7792ef777f2a572c3e8e9685de8e7d09cc0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_operator_TestApprox.test_repr_string": {"doc_hash": "cecb53dc611c804577e6e6851955ad6370b7f54e6075d1001b9ce8f612f5a83a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_repr_complex_numbers_TestApprox.test_repr_complex_numbers": {"doc_hash": "2471629b18889f5fb1144a15a6449d9166579a7b3b358f3abecc8eb1bd500197"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_overrides_indirect_dependency_fixture_TestFunction.test_pyfunc_call": {"doc_hash": "94c1de5667d72786d7b8e637ddf93dde1774ecb2a353890353a64f195c99144e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_multiple_parametrize_TestFunction.test_parametrize_xfail": {"doc_hash": "11076476af09ea62c00a7a3c49e7725781250cc41b06ad59802aafd0a6d6e680"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_passed_TestFunction.test_function_original_name": {"doc_hash": "301488f87edf11881c8cc186882c6f72681e124cb271391aed8cf36a499f916c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestTracebackCutting_TestTracebackCutting.test_traceback_filter_error_during_fixture_collection.result_stdout_fnmatch_lin": {"doc_hash": "a1eac743224dab78761121854185a8a001a8f6c82a9be8de50f1553dd48151a8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestTracebackCutting.test_filter_traceback_generated_code_TestTracebackCutting.test_filter_traceback_path_no_longer_valid.assert_filter_traceback_t": {"doc_hash": "52366ef6d48de9033a7a6a0894d92f6f02060c4bfdfc2380ca01724a11f2ce73"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages_TestFixtureUsages.test_invalid_scope": {"doc_hash": "5cb3e8b4ef56a8b18eeefc979bbc3ee9fa488ad4ec5f2fed0ddb4cea73381d60"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages.test_parameters_without_eq_semantics_TestFixtureUsages.test_usefixtures_marker": {"doc_hash": "1ef1ac3372df1ee68d8cfd3a47b93123437cb9d5aae097db6ef083d840dde502"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages.test_usefixtures_ini_TestFixtureUsages.test_setup_functions_as_fixtures.result_stdout_fnmatch_lin": {"doc_hash": "ab785ea72fdd6c7dc9bcfddb0137aa12486c088bb7c7b3c70f5a4e9a71fa8c0c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrized_fixture_teardown_order_TestFixtureMarker.test_parametrized_fixture_teardown_order.result_stdout_no_fnmatch_": {"doc_hash": "e96a0c3589dde00e303b66fcb9935f5cc83e05258e76f3e47c9fdf54c6967acd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestParameterizedSubRequest.test_non_relative_path_TestParameterizedSubRequest.test_non_relative_path.None_6": {"doc_hash": "7f653a7a8d1df299d5f8361f6aa5791d6e2af0674a4545363f756fdbaa7dea88"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_named_request_test_fixture_duplicated_arguments.None_1": {"doc_hash": "9adcc58f500c59984ebe71715a58329a4785406aac1e30ef92b3b66ced6f5f0f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_with_positionals_test_fixture_with_too_many_positionals": {"doc_hash": "5073c6084e187655d7a021943b5952f3dbe5276f88a7c85f126a2a46e1c52922"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_indirect_fixture_does_not_break_scope_test_fixture_parametrization_nparray": {"doc_hash": "899eb32b1f6c87417f828074bdb7f9cc9070286801a6aab09e8c54e7b645672e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_arg_ordering_": {"doc_hash": "0c5e22b2df716862e4b1796dc51c884a3db102a950a6c92856af2f7e933bb524"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_itertools_TestMetafunc.test_parametrize_error": {"doc_hash": "b0fbddc218d2a635df893b10f59a42706a651a6208237c0acfbbdda0bf786bbd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_error_iterator_TestMetafunc.test_parametrize_request_name": {"doc_hash": "0241419bfbcbddf470359ec63740fd8f1978babee188b7522f1e93913b177236"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_and_id_TestMetafunc.test_parametrize_with_userobjects": {"doc_hash": "6c823c842f33c25edf2763bddbe5d31a06fe92faaf564d85d3d240b4ca063ce2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idval_hypothesis_TestMetafunc.test_unicode_idval": {"doc_hash": "c052df2caa1d98af80d7f414f295ffa5c116dd781729848dd4ba9a39e26b6444"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_unicode_idval_with_config_TestMetafunc.test_unicode_idval_with_config.for_val_config_expected": {"doc_hash": "eb9c9c085374051eb71bc67973361d5301112a48d821922fb909e2b9c2efac3d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_bytes_idval_TestMetafunc.test_idmaker_with_bytes_regex": {"doc_hash": "e83aa1dd7b3e1d0556e5a2fd3203783bce79c143e85b7067d1b9acc80aebddb2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_ids_and_config_TestMetafunc.test_parametrize_ids_exception": {"doc_hash": "9b9ac1260decb19825548f3a2d65d2d5dae28eb35b4c7b85547a567af544e2b6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_ids_returns_non_string_TestMetafunc.test_parametrize_ids_returns_non_string.result_stdout_fnmatch_lin": {"doc_hash": "83f4db81776c38a395ba1f6ad0163fea981ee8bdeb623cc81835fbddc6197175"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_ids_TestMetafunc.test_parametrize_indirect_list_empty": {"doc_hash": "93a0dcefee60c5494dbb22b0803ee87c15710e353df62abec7157860403dffb2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_indirect_wrong_type_TestMetafunc.test_parametrize_indirect_list_functional.result_stdout_fnmatch_lin": {"doc_hash": "db4dc22f1c7f07eea73e7c9707428ea493fb1a1dca10260b4e39077477cbc008"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_indirect_list_error_TestMetafunc.test_parametrize_indirect_uses_no_fixture_error_indirect_list": {"doc_hash": "4397ce888263ed69ee534472d698fc93c2f9cdb57baa39e5c573f6fb1f1a837b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_argument_not_in_indirect_list_TestMetafunc.test_parametrize_twoargs": {"doc_hash": "aa449a98d1e6f8b2b6e263f131348872e23656151b3574efa4e907ce2f94f410"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_multiple_times_TestMetafunc.test_parametrize_CSV": {"doc_hash": "389526e5e77a0c9b2e3bd0f1a59d8bcce3887390869ec455441cdb3c9830ac01"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_class_scenarios_TestMetafunc.test_format_args": {"doc_hash": "203059ce107b36dcfc3843fd5cdf85372b285130a4947e24e4245c54ace28703"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_two_functions_TestMetafuncFunctional.test_issue28_setup_method_in_generate_tests": {"doc_hash": "c0cd5257d526f5222c85bc7c5c04ff28149ed8a7736acd7038125c6565f44e1c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_functional2_TestMetafuncFunctional.test_parametrize_with_ids": {"doc_hash": "8be30e944f1ec6aa52f1d7694f5e8b23314c859a5e7850e46b8052a2bb93094d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_without_ids_TestMetafuncFunctional.test_parametrized_ids_invalid_type": {"doc_hash": "bd10a8af9438508f9be34b545f470bfd9d5a0ea1b80600982d1885d63bd0aa3e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_with_identical_ids_get_unique_names_TestMetafuncFunctional.test_parametrize_scope_overrides.reprec_assertoutcome_pass": {"doc_hash": "5cf6982cf57dd7bf053fdf65f17a76bbb5f84ce1264bd922bdb7e78313de3ff8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_issue323_TestMetafuncFunctional.test_usefixtures_seen_in_generate_tests": {"doc_hash": "5a79c4fb530dae705e9ab1c3fa92ba391f7ba6390a611b77f0422d08661aeba4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_generate_tests_only_done_in_subdir_TestMetafuncFunctional.test_generate_tests_only_done_in_subdir": {"doc_hash": "de05e518eae5049b280c77764b58dc09ef4a6228ee72a6b649cb251169dbf992"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization_TestMarkersWithParametrization.test_xfail_with_arg": {"doc_hash": "71a7138fbb30e106d4a2b914e1280c47b48d6a555d6e2988fe35cc3fcc8dbb95"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_xfail_with_kwarg_TestMarkersWithParametrization.test_parametrize_ID_generation_string_int_works": {"doc_hash": "34bc1355219d211b8b5c7373693d4ffc0999bbd5aafdfac92ce8078a8407c1dd"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_marked_value_TestMarkersWithParametrization.test_parametrize_marked_value": {"doc_hash": "86713bc3071bbde6b12c6423f72212f88e1ddedc9557896e0b8aa85c6c6359c1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_pytest_make_parametrize_id_TestMarkersWithParametrization.test_parametrize_positional_args": {"doc_hash": "2c6020ed0e7b482d7b1171a814a9fa3264e31efa0f3f0cb6956f658156d17d11"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_iterator_TestMarkersWithParametrization.test_parametrize_iterator.result_stdout_fnmatch_lin": {"doc_hash": "6ae81b6ad5864205dc5bb32b6ef7f99fa4b81f246d261a7ea64f1f097e60d253"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_explicit_parameters_func_": {"doc_hash": "dcec39d96e922055b78c1f08689fdce4cb56386cdd450288db78e9e8a4d480ac"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_re_TestRaises.test_does_not_raise_does_raise": {"doc_hash": "680644cdf8cab8b7239fddddfe6bde12dafe76601c4eceedf7825fbf1d17279b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_raises_match_TestRaises.test_raises_match.None_3": {"doc_hash": "d7b1dadb9d76651c74b90ad262ebac010befbe6f8889e3ed0b4bb2341067c5c3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_match_failure_string_quoting_": {"doc_hash": "f47b2f6f2beaaea68f2eb8e2e56425a68fc8aa283e71123fba37696601ea8449"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_collections.abc_TestImportHookInstallation.test_conftest_assertion_rewrite.result_stdout_fnmatch_lin": {"doc_hash": "f070da8c4d87c2dee76b463a13c7c583b43c34a44757a63c17ee5f2c013f58b9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_rewrite_assertions_pytester_plugin_TestImportHookInstallation.test_rewrite_assertions_pytester_plugin.None_2": {"doc_hash": "e102b2b54e317185d4667b2a0d0a0f8ca659317275b415b888cb37061419497a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_pytest_plugins_rewrite_TestImportHookInstallation.test_pytest_plugins_rewrite_module_names_correctly": {"doc_hash": "1d8ce4c1b7af168ebff044a1d957b34938f9e4827f57a3e713407fc8ce04e1a1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_rewrite_ast_TestImportHookInstallation.test_register_assert_rewrite_checks_types": {"doc_hash": "862d9e1919536b70303591bf284c3913b1b525da50ea4463a8820b5c1ed9f8ea"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestBinReprIntegration_callequal": {"doc_hash": "24a87c6e249b3e6bc4f6d11e166b992ee8b7cf20185b4df89bd4a001b6977537"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_different_lengths_TestAssert_reprcompare.test_list_wrap_for_multiple_lines.None_1": {"doc_hash": "a259ad1fbfd9b0b11f5bfed9bfde3a2190e2b177099f4e7aa05688874b52b8be"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_wrap_for_width_rewrap_same_length_TestAssert_reprcompare.test_list_wrap_for_width_rewrap_same_length": {"doc_hash": "bd38674d58b22dc64c9245f2842d20362c4895ebd093d20bf7f0f7cf2cb5954d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_dont_wrap_strings_TestAssert_reprcompare.test_list_dont_wrap_strings": {"doc_hash": "315538c15982ea6c54a7dca512da93844d3b3987ed44c43a322834a32e192779"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_wrap_TestAssert_reprcompare.test_dict_wrap.None_1": {"doc_hash": "4ea3665804600cb1e73a370cfd5c358f76df0f7faafd0934d66f6131ba854732"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_TestAssert_reprcompare.test_dict_omitting_with_verbosity_2": {"doc_hash": "cd484ebdf32d30b0a4a4ffe8525c3c81a8c353e3dab34860ea303b6b4ab33e97"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_sequence_different_items_TestAssert_reprcompare.test_repr_verbose": {"doc_hash": "ffc5e92e09f58fca4379b0693b8103c21a56f40f3a716bdaf4caac085d7599d8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_bad_repr_TestAssert_reprcompare.test_mojibake": {"doc_hash": "3e558573284cb05ca3893324ad461b680d41c181e77c3d656540b2e7753ebbe3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_name_TestAssertionRewrite.test_name.if_verbose_1_": {"doc_hash": "331ea7d4b439bc7fd90832cd7cdabfbd5ed1faa389a8e37e54d6a07d334faa01"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_assertrepr_compare_same_width_TestAssertionRewrite.test_assertion_message_tuple": {"doc_hash": "458c584d4305e866a8873b4fe3ed4ea80009050ed67c7583520b1e758b95652e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_assertion_message_expr_TestAssertionRewrite.test_assertion_messages_bytes": {"doc_hash": "244b16ef21af25b57715196b97290cd16e8186970d884ca29021c9a59cbe77cb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_boolop_TestAssertionRewrite.test_boolop.None_2": {"doc_hash": "68262e4f71f1fe6a452fd62502280d06baab026728cbdc083d5b501724bf219f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails_TestAssertionRewriteHookDetails.test_write_pyc.assert_not__write_pyc_sta": {"doc_hash": "07b83c09bdadca47cda84cc701fb9b11925bedea659b05e2f49e7cf7bdd715da"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails.test_resources_provider_for_loader_TestAssertionRewriteHookDetails.test_reload_is_same.result_stdout_fnmatch_lin": {"doc_hash": "27b0a31ef9bf6dbd618f984a27d1911a824666c8dad6a761df0214d7b166024d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails.test_reload_reloads_TestAssertionRewriteHookDetails.test_get_data_support": {"doc_hash": "2b9ea35791d3123d97754247c0dac7dae1d774276e236bb9588d5ef72ccdafae"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_try_makedirs_test_try_makedirs.assert_exc_info_value_err": {"doc_hash": "69e5dd2ac01f41fc25c692bda8af04c28b300c9e7b311f2b02e59941a58027fc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestPyCacheDir_": {"doc_hash": "55876af56597b1f15aa5ee81443e382a44ffa0709876d431455809d0d934f74a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_os_TestNewAPI.test_cache_writefail_permissions": {"doc_hash": "3f22ec571dab4061b73f18e68f222d1d458fa2a7c5d4bb299b5f6b0351b47598"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewAPI.test_cache_failure_warns_TestNewAPI.test_cache_failure_warns": {"doc_hash": "a600d81e976d7a318ebbf056f4004bb9c4ecc0e3a094550eaaba929800712813"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewAPI.test_config_cache_TestNewAPI.test_custom_cache_dir_with_env_var": {"doc_hash": "b1767e07fc3e24c27d73b916956f574cc4c3321f8ec83325a5b6429fbec7035c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_difference_invocations_TestLastFailed.test_lastfailed_difference_invocations": {"doc_hash": "ae89db283f4da9c2d6b6200a0622c1d73a911d625c5def3d2eef0a74468bc616"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_capfdbinary_TestCaptureFixture.test_capsysbinary.result_stdout_fnmatch_lin": {"doc_hash": "e2da9dee43cc0b35ef87836359f0ba64d4ae6fd06803f922d29634050f9b7e24"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_partial_setup_failure_TestCaptureFixture.test_capture_and_logging": {"doc_hash": "dd44567afabb0114e6f49120d4825ffa580574ff5e493975bcce0413ff170158"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_fixture_use_by_other_fixtures_TestCaptureFixture.test_fixture_use_by_other_fixtures.None_3": {"doc_hash": "b40cfee012fd178674576499a6fbcf414fa3ba32e30d849cf10439308603b4aa"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureIO_lsof_check": {"doc_hash": "2d33b270e6ef166dd1794d2d2280318b1e4ee3f7cd7554d0eec5ef8744eab6a7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestFDCapture_TestFDCapture.test_writeorg": {"doc_hash": "fc297918d5a1adee72a3f05de928c5616133c239514e305508816f8e96bfd743"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestFDCapture.test_simple_resume_suspend_saved_fd": {"doc_hash": "442497d2ac4c865d60fd961808629cc71fcb2f6f12ac05e821d5812914521fc9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestTeeStdCapture_TestStdCaptureFD.test_many": {"doc_hash": "1aa529f6573ebafb2adcff7148ee4a072b12571af2aad03a82018f4cd98aa35e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_error_attribute_issue555_test_crash_on_closing_tmpfile_py27.result_stdout_no_fnmatch_": {"doc_hash": "57631eb24e624a53049d50e19b2e9acb540831bd739bf5824e4b36837b7845d8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_os_TestCollector.test_check_equality.assert_testdir_collect_by": {"doc_hash": "ff9abc61ccf6660bde03f1e61b926552a6c002c4807c8a6a795e74dd6cc6b5ca"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS_TestCollectFS.test_ignored_virtualenvs.None_1": {"doc_hash": "25738da56b9669626f360c57ade4a5f816cf41f8b4f5f475d71a69e0b1c47dd1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test_testpaths_ini_TestCollectFS.test_testpaths_ini.None_1": {"doc_hash": "219ed88bb4655105e2dcc2cc235211d3e88fcdd14f99b338778f326f38c1d3e3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectPluginHookRelay_TestCollectPluginHookRelay.test_pytest_collect_directory": {"doc_hash": "98eb24b5ba63f5e0012a012b602ad3ae6f5cccdf08a8dba515afa06a1f6f8076"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestNodekeywords_TestNodekeywords.test_keyword_matching_is_case_insensitive_by_default.for_expression_in_speci": {"doc_hash": "99858a247b5bf60413e7aad74c9e5ee3d029164da5cb925f1727f35523a96cab"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_COLLECTION_ERROR_PY_FILES_test_continue_on_collection_errors": {"doc_hash": "1abc417e6fb47763d43a727b2a1d4c3ad8d34f8f47ef4f89fc4f6dc976421641"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_continue_on_collection_errors_maxfail_test_fixture_scope_sibling_conftests.res_stdout_fnmatch_lines_": {"doc_hash": "0f870a77d7d4506bf83197cf823cded4dd864f68f89183345951b47d0d30fdf0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_init_tests_test_collect_init_tests.None_7": {"doc_hash": "895490fc923c35906b5cee9f5977b84c1ac56c79843fe467ba7e08272dcdb37c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_disable_plugin_autoload_test_disable_plugin_autoload.if_should_load_": {"doc_hash": "1130be5420e26670c1c8bf3211a31c0beca1f272e5beecb927ee1181d57d10b2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_plugin_loading_order_test_invalid_options_show_extra_information": {"doc_hash": "d99c0e820486c599fb05f8f0b81c0fd29177ff4508316355fd2b30778092d39b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_toolongargs_issue224_test_load_initial_conftest_last_ordering": {"doc_hash": "c2d9d10dfd751aeaec3710bcdd21b3ebfcc95c1557538b106f72541b1d29a96f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_get_plugin_specs_as_list_test_collect_pytest_prefix_bug": {"doc_hash": "e387b0697a60a8d480051ff948925c0bf7bac2553d7e37bd60721a2637d75395"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestRootdir_TestRootdir.test_with_arg_outside_cwd_without_inifile": {"doc_hash": "e5168a318dc4909ec17d8040fdc355b7a0c73d53433e0a4c92acf5dfccb6b345"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestRootdir.test_with_arg_outside_cwd_with_inifile_TestRootdir.test_with_existing_file_in_subdir": {"doc_hash": "d81f13b11c985a7e3a9a8fa7bcfdff3f0836442ac629137a3c1b40c80fed2a01"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_override_ini_usage_error_bad_style_TestOverrideIniArgs.test_override_ini_does_not_contain_paths": {"doc_hash": "550c04e55db83e0b7c846846bbea97ec990fe0f767d587e58eee67e0cf9969c6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_help_formatter_uses_py_get_terminal_width_test_config_does_not_load_blocked_plugin_from_args": {"doc_hash": "eda6e8bf375629640cb8d07cd1513d2346149671ba10ce2c27fd9ef4680504d6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_invocation_args_test_invocation_args": {"doc_hash": "8e1e3f7390fc216bb9660d318496112d341ccbec623279874b828c1bbc03ba3d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_os_custom_debugger_hook": {"doc_hash": "470f3adbc3a5ee933eb6e9f4e45f47a873c8412d78422512e1b1897293729586"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB_TestPDB.test_pdb_unittest_skip": {"doc_hash": "f6109dfeaa5cba8adbfdf88e6f6becb57c47088f61f92f95b4ffebe00181df16"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_print_captured_stdout_and_stderr_TestPDB.test_pdb_print_captured_logs_nologging": {"doc_hash": "16087845691794613fb71d777faf297196b8bbbe90292b5b3043cfc7627633a5"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_interaction_exception_TestPDB.test_pdb_set_trace_kwargs": {"doc_hash": "bf5b1c0e18883698d5da4a1e6211f28c5344bcca0aa253b7e69781199ea0784e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_set_trace_interception_TestPDB.test_pdb_interaction_doctest": {"doc_hash": "38692dd4cac732c9748167cdd728197dfa046d1f17d7e29eae98cdde5312d4cf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_doctest_set_trace_quit_TestPDB.test_pdb_interaction_capturing_twice.self_flush_child_": {"doc_hash": "7a715fabc5b07a451cfc43b497c2e221f92a54f7269e54aa8147a046ae6d0488"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_with_injected_do_debug_TestPDB.test_pdb_without_capture": {"doc_hash": "94b3da093d9e36d6699a8a9f8efe466c2258e0f28c3b8c0395a676bd93f353f2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_continue_with_recursive_debug_TestPDB.test_pdb_continue_with_recursive_debug.assert_1_passed_in_in": {"doc_hash": "b3c51d149906cb465a20726552f8547fd6487581cc358b1153ae2a8bb1cb8c05"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_used_outside_test_TestPDB.test_pdb_collection_failure_is_shown": {"doc_hash": "a5c69e48b40a19d6da4ebe90880af966c6fab85551bab4e624a52b7dbaca3bd8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_enter_leave_pdb_hooks_are_called_TestPDB.test_enter_leave_pdb_hooks_are_called.self_flush_child_": {"doc_hash": "2b5c5aab2547fb25bbb19fc9bdc060d2dc2ace7fde41a494d21279c8c67b64be"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_custom_cls_TestPDB.test_pdb_custom_cls_with_set_trace.self_flush_child_": {"doc_hash": "24559bff9c2d6fb27704e716667b092ed726475961a8a7bf681e742fc8d0e6a1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints_TestDebuggingBreakpoints.test_sys_breakpointhook_configure_and_unconfigure.result_stdout_fnmatch_lin": {"doc_hash": "03d20403258a4f0012250216420a4c7fe03b0207005809ed3d9b55f2725d59f1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints.test_pdb_custom_cls_TestDebuggingBreakpoints.test_environ_custom_class.result_stdout_fnmatch_lin": {"doc_hash": "9e58358bb0badfa8c44162c5d8a829a8c037584308f6ea4e178ab61ec4b0d1a1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints.test_sys_breakpoint_interception_TestDebuggingBreakpoints.test_pdb_not_altered": {"doc_hash": "3284f47bf4a0152f346d8ad8307d6b23a11eded7ce2f6a7f9ae1c63d539d5f51"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestTraceOption_TestTraceOption.test_trace_with_parametrize_handles_shared_fixtureinfo.TestPDB_flush_child_": {"doc_hash": "b7a6e0ad81cd39f5de22f5cbfb422388acf7048d61f5f8bf07a57348547c5735"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_trace_after_runpytest_test_quit_with_swallowed_SystemExit.TestPDB_flush_child_": {"doc_hash": "979436ac630ec97b2733d5c15b8cc3c598adfe479d354e3274a47962edccf6c7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_pdb_suspends_fixture_capturing_test_pdb_suspends_fixture_capturing.assert_PDB_continue_I": {"doc_hash": "5f4c0b825acae5c87e81f31835b5661208473b043895815dc4dbfebf10f2287d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_pdbcls_via_local_module_test_pdbcls_via_local_module.None_2": {"doc_hash": "555c9f31e887f7035e1fa58fad33afb017a773ff90f51d3f6d3481c386ad7551"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_raises_bdbquit_with_eoferror_": {"doc_hash": "001631a599f63af923ba8cf47583eb80b0e5458986f2a5cf27680706ccedca81"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_encoding_TestDoctests.test_doctest_unexpected_exception.result_stdout_fnmatch_lin": {"doc_hash": "a3512f63b1cb8c6d47ee0fa24064169da090779e34fce5cdb1dd2bedcf1ba498"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_outcomes_TestDoctests.test_docstring_partial_context_around_error.None_3": {"doc_hash": "70bcb76825b32dabbc59080b0469776569008fac23e33f1d61f21e7587b77514"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_docstring_full_context_around_error_TestDoctests.test_doctest_linedata_on_property.result_stdout_fnmatch_lin": {"doc_hash": "b549ac0824c69c059cfcd653b0a748c8e92ed1cde43cbc1721480be5e59d3258"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_no_linedata_on_overriden_property_TestDoctests.test_doctest_no_linedata_on_overriden_property.result_stdout_fnmatch_lin": {"doc_hash": "a482f3e93ef2bc608bdec9f6f801f6f43f6edc583655f632d89bf9e35a4713c0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_unex_importerror_only_txt_TestDoctests.test_txtfile_with_fixtures": {"doc_hash": "97d3bccbd95a7673fa875ccbabe871e426cafcd16df5938c8cb2b0471e782801"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_txtfile_with_usefixtures_in_ini_TestDoctests.test_non_ignored_whitespace": {"doc_hash": "410fdfe15dac24fabe21ae7095871428bd209e778d8bcd6d2322c24640d30128"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_ignored_whitespace_glob_TestDoctests.test_unicode_doctest": {"doc_hash": "112b02a758e37fe93f36633b6103fcb4a45eccdcb2425ca5758fc4f19aa725b8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_unicode_doctest_module_TestDoctests.test_invalid_setup_py": {"doc_hash": "9d194bf24a04c83bf217a615c7e229cc98567c507eeabfc52555de7af9d8cdb0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py___TESTCASES": {"doc_hash": "516d6d9e26e3b26fcb994b10b4f3b1ea365ff6f40ad5dd0219bd769ad267cb5e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py_TESTCASES.__TESTCASES._": {"doc_hash": "6041b27d05da432d6f6109128c37f2b39bcd8f6a45ad81d865e2526d135095db"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py_if_sys_version_info_2__": {"doc_hash": "1e1e7a6eb5beba673f453322665c6b96fc5fc3ae8ab63719e0a513829771129f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_test_timeout_test_timeout.assert_result_ret_0": {"doc_hash": "3e199fd8da3bfb724d3ceac265d881d350a685d54e1e5839b3fdec31547450f2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_test_cancel_timeout_on_hook_": {"doc_hash": "5a8978dce8825a32bf2e7b0f5f389ddc81be4ddbfc8148e989769853bc18086f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_internal_error_TestPython.test_failure_function.if_junit_logging_no_": {"doc_hash": "5dd20228302ea3d3c8a891c8def532af1cfd09ab3175dbba58beb334a44f4da8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_failure_verbose_message_TestPython.test_failure_escape.for_index_char_in_enumer": {"doc_hash": "263c766168fb591b8cc3c2fdf43ce9c3664620dab49e8f59cec6570bdcb925db"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_junit_prefixing_TestPython.test_xfailure_marker": {"doc_hash": "d20aee393ff2b2043600413e1647e4e592e571999f2945edd03a6e580f766f23"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_xfail_captures_output_once_TestPython.test_xfail_captures_output_once.if_junit_logging_in_log": {"doc_hash": "aefff4861fb20d1b2666924d56c8a0d6145ef4e4a660b0c3c9d346a2249a154d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_pass_captures_stdout_TestPython.test_pass_captures_stderr": {"doc_hash": "3bf87921affdab52b41bb8ebdca72fd7e32b13c1a2a34bc2a44bdb71afd2cdbb"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_captures_stdout_TestPython.test_setup_error_captures_stdout.if_junit_logging_syst": {"doc_hash": "0c050e6e8aa92c6d04b7226a7b9a90726ca85b1d84863053b8f24fbc300fa6e3"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_captures_stderr_TestPython.test_setup_error_captures_stderr.if_junit_logging_syst": {"doc_hash": "d67a3a5152f7362ef5752e5b6d06bfd6930832ef8092463ece2f36fc3735d683"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_avoid_double_stdout_TestPython.test_avoid_double_stdout.if_junit_logging_syst": {"doc_hash": "9a6944a4028099c15f885fbee2b915e389e5b20781bbbc344c35106d3a5fbb68"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_escaped_skipreason_issue3533_test_logging_passing_tests_disabled_does_not_log_test_output.None_3": {"doc_hash": "5503196a776498e6f15d4aae43cdfb6726c1fa0287460ae972d3eb730f348599"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_logging_passing_tests_disabled_logs_output_for_failing_test_issue5430_": {"doc_hash": "1a563d1250e2af5219ee1073c5905cd545d7e56355bf653a9c1d1c19d4a04ccc"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_main.py_from_typing_import_Option_": {"doc_hash": "1a7b91be082a4987e7975d38b995d26783570e1e346037cdbc94a71c0efe5c68"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_marker_without_description_test_mark_option.assert_passed_expected": {"doc_hash": "d0f8e91538723c714a67ecca8bfbd41e67ea8d19e28e74515465f00d16a7b5e6"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_mark_option_custom_test_keyword_option_custom.assert_passed_expected": {"doc_hash": "c1443d553f14136a272d65b36671d16c18703f434f7b57b2aa0879f70bb7bb71"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_keyword_option_considers_mark_test_parametrize_with_module": {"doc_hash": "2e0ac83d027371ddde6190a36f1bd6b4e9d25d66212e6ac6cdb167ed6c3b36d2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_keyword_option_wrong_arguments_test_keyword_option_wrong_arguments.assert_expected_error_in_": {"doc_hash": "0d7d25fe56930fcff671155d80bd0dd90a38cd94a4a4919e5a4796442834291f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional.test_mark_with_wrong_marker_TestFunctional.test_keyword_added_for_session.reprec_assertoutcome_pass": {"doc_hash": "497f5499364077a2a235799187cbef5df96917fb87fdb97dc4ffe0d44f1a1566"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional.assert_markers_TestFunctional.test_mark_from_parameters": {"doc_hash": "199df0c1988b29c513d1c97041e1f28e1f65d0de44417089d6a8a4dcac02b158"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parameterset_for_parametrize_bad_markname_test_mark_expressions_no_smear._assert_skipped_k_fai": {"doc_hash": "e71f4ccc5df0574160fdb065a171b9073d4e646b65f42679dc435b9129f74c3a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_addmarker_order_test_markers_from_parametrize.result_assert_outcomes_pa": {"doc_hash": "83567824e77cdcb58f69b0030dd28041a1083ac936ca6704ac2c00d31fb2c2d9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_pytest_param_id_requires_string_": {"doc_hash": "dfad38a5e2747d936aed8ae814547740c715f05ef42ef955165763b424476631"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_pytest_test_basic.assert_evaluate_expr_mat": {"doc_hash": "2af8f01876456c2b6516112456ce6f892ceb884164d423c2f55937943ae3d8ce"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_test_syntax_oddeties_test_syntax_errors.assert_excinfo_value_mess": {"doc_hash": "2b3ab0640c4a9c63fc5ad43b6500f3307221cf9c3c17e25d0f54f61e971ae2f8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_test_valid_idents_": {"doc_hash": "b63b087a3da502c1f552b3a6d0173da7422378a513590ca5b32d7d709349995f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_meta.py___": {"doc_hash": "2c1f8a716032a2737819de1ba4fe0a50f6ec661f814212dc42625cfd90c083e9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_setup_teardown_linking_issue265_test_skip_test_with_unicode": {"doc_hash": "cfa393c507cb1d38efb49e7aa0ca3b6c9bc3b6757f88388681eae3c9e594fac8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_raises_": {"doc_hash": "8fa814285736317339da535cdf0fa46ceec02da4cfbf6b3674685b7d74b6f793"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginInteractions.test_hook_tracing_TestPytestPluginInteractions.test_hook_tracing.try_": {"doc_hash": "7a1942f6262f30bfa26ae70a1402d3ba19d086931b87a11387fcff38ef424f09"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginInteractions.test_hook_proxy_test_importplugin_error_message": {"doc_hash": "c9b3c2bd1ef63e719a083d998a576845a73367b81c44b50a88198b3f69e5358d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_parseconfig_make_holder": {"doc_hash": "e76cd1737e9cf3777bba2f01c7ddaf023e23a48236041a54fdade90b175a27d2"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_hookrecorder_basic_test_makepyfile_utf8": {"doc_hash": "55d2f300bf7a7b379454c30dc38c069908ed4a38cc96b7eafe25ceb34e7d6726"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_testdir_subprocess_test_testdir_run_timeout_expires": {"doc_hash": "f85bf87978459585eb272b405376cacf2369152d7dd62ea3c6d6758ba2586840"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_with_nonlist_test_linematcher_with_nonlist": {"doc_hash": "0f44d8a1c0562fb87d7d846a65ae11805e8bf28da3e14aeaa88df8c44abdd397"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_match_failure_test_linematcher_consecutive": {"doc_hash": "f2b2bf977d32411e3eb1c1925e3e94ac1e247f3a2331ee20535108d21ae9c882"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_no_matching_test_linematcher_no_matching._bad_pattern_does_not_ma": {"doc_hash": "7bb94382ab8ba8257c98f28ed3295acd85e1b1fdc7b13824e446eada3fc943e7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_no_matching_after_match_test_popen_stdin_bytes": {"doc_hash": "1ec8c0f3004bf4e8c1b40b22211bfe4ea345f6d5cc62293d4eae14fe6fbe9d7f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_popen_default_stdin_stderr_and_stdin_None_test_popen_default_stdin_stderr_and_stdin_None.assert_result_ret_0": {"doc_hash": "1a6aa4f4138e483b7b40000ef6cf8d6ba7d0520cf082779da4cdc5d5ab636774"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_spawn_uses_tmphome_": {"doc_hash": "2c35dc81ada81258ce3da2f25352b2e274ebd1589586d55a079f7afb8df0286c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_sys_TestReportSerialization.test_xdist_longrepr_to_str_issue_241": {"doc_hash": "594281b2802e1dbc400529ae789fff963e90074e57393a22448eef116890a571"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_chained_exceptions_no_reprcrash_TestReportSerialization.test_chained_exceptions_no_reprcrash.loaded_report_longrepr_to": {"doc_hash": "6413288fe63c4e702d0823d256261d5f77af6499ce2d6a9cce1fa0ea32aa28ec"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_test_generic_test_no_resultlog_on_slaves": {"doc_hash": "8c901851c4a48226a73b9c52e305aac80c311c3bc9b580089964fa7595aa072f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_test_unknown_teststatus_": {"doc_hash": "3966876f7e550794e2e85338f1c861161c982df3c0ba475ecd16f84ecbb64d9c"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_TestExecutionNonForked_test_report_extra_parameters": {"doc_hash": "f717a1ef5b838fab0b161bc38ae73a5afc3990ff95525d4a8acf9edb71c04204"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_callinfo_test_callinfo": {"doc_hash": "1bd505bba151d1d8bd38b0837f22614003a7565e65d8154f32ec4d81a62b6eab"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_importorskip_test_importorskip.try_.except_pytest_skip_Except": {"doc_hash": "4efe268112e1532f90771b0b7218e1869854049b768fa007626bd9235295aab8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_importorskip_imports_last_module_part_test_failure_in_setup": {"doc_hash": "a29a722a02784cb54eb46bed15ba659dbae05e64457cff77453a83f9e1da800d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_makereport_getsource_test_makereport_getsource_dynamic_code.result_stdout_fnmatch_lin": {"doc_hash": "ff08c3afc839e14378184f6cf40bbf2c9757268a73ca1256fb12a6e7728ea52a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_store_except_info_on_error_test_store_except_info_on_error.None_6": {"doc_hash": "1764d3366fe2ff53e78c15d2a2b9ff6d82d6491a117c8468741d5f32299fccc0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py_test_method_setup_test_setup_funcarg_setup_when_outer_scope_fails.result_stdout_no_fnmatch_": {"doc_hash": "a4f464830c07485ae8682c80efb86fbea315455a7cbb70b14c7b105440584ca8"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_broken_repr_SessionTests.test_broken_repr.assert_out_find_reprex": {"doc_hash": "a3f1b38eee8619748f268247c7a7e53f331c108a4b5a8203e62d1bc9c671f82d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_pytest_test_show_fixtures_with_autouse": {"doc_hash": "e6886bba16000549e0b70826d4a5e41347a131f8cca649cdba474531510cdfa7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_test_show_fixtures_with_parameters_test_capturing": {"doc_hash": "9c255691bd78db867e4256efc8b3cc32182be936c959eaf721a00b59a7952a57"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_test_show_fixtures_and_execute_test_": {"doc_hash": "4e6646303b92682c6f77cf340b7b4b3f42b68cde0dd5a4cf92e878032ad15478"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setupplan.py_test_show_fixtures_and_test_test_show_multi_test_fixture_setup_and_teardown_correctly_simple.assert_teardown_count_": {"doc_hash": "b2fc3d408623e404bacca357e322e5539d8816c0585128f9ddca7924d9ebb904"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setupplan.py_test_show_multi_test_fixture_setup_and_teardown_same_as_setup_show_": {"doc_hash": "d7d6fca5f9fd7cec814009bcbc768a5b5cb46f73774542fa74e219d42d5e253b"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_store.py_pytest_": {"doc_hash": "db19edb3a1e36ebf3dd281861ea997b84b0f1b0912926bbee48bfeda0b90e899"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_report_collect_after_half_a_second_TestTerminal.test_report_collect_after_half_a_second.assert_x1b_32m_x1b_1m": {"doc_hash": "33002827d3f03e64128ea6db82052466219c25aef713833c2f3accc8ab2d6bd9"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_itemreport_subclasses_show_subclassed_file_TestTerminal.test_itemreport_subclasses_show_subclassed_file.None_3": {"doc_hash": "ae1a7ecb3d9fd14421c84c83ceb925e8f1cdefd7462b59b48e38d8633c37f7f0"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_itemreport_directclasses_not_shown_as_subclasses_TestTerminal.test_keyboard_interrupt.None_2": {"doc_hash": "00708e2f55ec2584f31e5868542429b84e50c7c48ed6a1cf4525b69d1e61cd5d"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_keyboard_in_sessionstart_TestTerminal.test_report_teststatus_explicit_markup": {"doc_hash": "f834fdb734fdb9f079640388ee0998f1fe3253937c4c712d03a5f9c534c2fc67"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_showlocals_TestTerminalFunctional.test_more_quiet_reporting": {"doc_hash": "85932f96ded46d6118639d556134467ef5943101c94f5e4fefbd70f3339837bf"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_report_collectionfinish_hook_TestTerminalFunctional.test_summary_s_alias": {"doc_hash": "8b267c36930370918c20e19f9fc0140bdacaabb2f4f8e98c2db8bedc7e0a394a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_color_yes_test_color_yes.None_2": {"doc_hash": "a89314fdc03776c44994cdf4efe97aa126a1d100008ceb2417a0fdc431ae694e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_color_no_test_color_yes_collection_on_non_atty": {"doc_hash": "17e67e3296b23dc3a1897eb656b2392dd4832780b7082737c2d26d25b3355964"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_getreportopt_test_getreportopt.None_14": {"doc_hash": "5a740fca88fd6091134ef98774fe9c0754d847b5c43ae3be787ad33ae0293bff"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting_TestGenericReporting.test_maxfailures_with_interrupted": {"doc_hash": "0355f94e703d8547fac2196f12aafe596b1bc408e64bb57714129541806c481f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_tb_option_TestGenericReporting.test_tb_option.for_tbopt_in_long_sh": {"doc_hash": "44bc671de22de54c12c54614184a4d398014c9615ec00feb5a096a34b5fe44e1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_terminal_summary_warnings_are_displayed_tr": {"doc_hash": "42ebc498e81c8fa649f0e2e261cdb73c4f599bffe09f0f877a172df32093668a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle_TestProgressOutputStyle.test_normal": {"doc_hash": "15b2e8340bbd2387819580b22699bc8a3abe0718f4a28e524c89e629283d1347"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_colored_progress_TestProgressOutputStyle.test_colored_progress.None_3": {"doc_hash": "cf574a5a6027e8932a30598c06ae1065236ca65c1936d66312edfd600643a466"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_count_TestProgressOutputStyle.test_xdist_normal_count": {"doc_hash": "91757c7a7225edb673d07789ee9ff0c63d658a574ee53cea00a84448f7d63c28"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_xdist_verbose_TestProgressOutputStyle.test_capture_no": {"doc_hash": "561aaf78f1b1e1d2bf9d9e2fa81dffb813526b6bde6c7a36f2aa31562a39deee"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_line_with_reprcrash_test_line_with_reprcrash.None_21": {"doc_hash": "60b7ad023516bfc205f991984037e2c84392d60195d974e412e1ea76f45c2a63"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_format_session_duration_test_via_exec": {"doc_hash": "835ba2ceaaf6bf0f6de8eb2a06fc7326c1b333901e88dc5682730097ae86ea5e"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestCodeHighlight_": {"doc_hash": "0251c9e18a2eb0df3f9852017c53cb2a26390fd7d2d765021fe0759fe23fd5ad"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_os_test_mktemp": {"doc_hash": "529343e5c01ab863de45d588bb18f305cd4c8b86832ac0d72e7ccf50d0997156"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_test_tmpdir_always_is_realpath_break_getuser": {"doc_hash": "2f36a5a9ea7c0bb9476ac01c49fd97635dad5248b63f5a6a1fbbce298fb0bd09"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_test_tmpdir_fallback_uid_not_found_test_get_user": {"doc_hash": "631bad35d8dd1bb4a69f607665ef958959348960421b0b7064b42ad9a0d5c551"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_non_unittest_no_setupclass_support_test_unittest_raise_skip_issue748": {"doc_hash": "438b31b7eff71c2e09f477d2ab431570e6678c9d053236296ccb71bc3e435b67"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_skip_issue1169_test_usefixtures_marker_on_unittest.result_assert_outcomes_pa": {"doc_hash": "293b7ea2b9cbc80ffc0dc32e3acfe6b8dd3085ed99e239f184fe44aca5717a86"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_handles_init_exceptions_test_trace.assert_result_ret_0": {"doc_hash": "c3820dac01dce9a302f241f75acb62e4e9107ec280f8ce138bd51118c7148cd4"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_pdb_teardown_called_": {"doc_hash": "f4ac6b22e23fb3680a37487b38433c77b0c4042c35d93643ad9f82a68bb9f5f7"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_os_test_as_errors": {"doc_hash": "89c8d56770cd9314425408e0a65e0c7ad0cc381d6ebeced33016789673ee0968"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_deprecation_warning_as_error_test_warnings_checker_twice": {"doc_hash": "dd1a16e8d56bfb6fbc4f6d0a4fd92f6a668131c5a4daa0fe0c00d5da29798829"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_group_warnings_by_message_test_group_warnings_by_message.result_stdout_fnmatch_lin": {"doc_hash": "f378b9ec5e382a88751c31756e9fc4cc0e783febe0b2a70c9c4cd96ec2c65567"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_group_warnings_by_message_summary_test_pytest_configure_warning": {"doc_hash": "bef5f8d794ce0ec89c4d5132b5ebb3b897b66f305a00da7cec6e52668a900f8f"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel_TestStackLevel.test_issue4445_rewrite": {"doc_hash": "203e9de1c42bfec4f723c7b32fa9032e0d0daf1316a3019cd27731a51835ce7a"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel.test_issue4445_preparse_TestStackLevel.test_issue4445_import_plugin": {"doc_hash": "eb3361787924bc49ff12a3a10e55617a83014c990c3d4206e9a56d20edc88aa1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel.test_issue4445_resultlog_": {"doc_hash": "dba5fac8fbd50b02b13053a4328d1671640b19bf1e9b2939ad7195dc3f7b7fd3"}}, "docstore/data": {"/tmp/repos/swe-bench_pytest-dev__pytest/bench/bench.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/bench/bench.py__", "embedding": null, "metadata": {"file_path": "bench/bench.py", "file_name": "bench.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 14, "span_ids": ["imports"], "tokens": 98}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\n\nif __name__ == \"__main__\":\n    import cProfile\n    import pytest  # NOQA\n    import pstats\n\n    script = sys.argv[1:] if len(sys.argv) > 1 else [\"empty.py\"]\n    cProfile.run(\"pytest.cmdline.main(%r)\" % script, \"prof\")\n    p = pstats.Stats(\"prof\")\n    p.strip_dirs()\n    p.sort_stats(\"cumulative\")\n    print(p.print_stats(500))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/bench_argcomplete.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/bench/bench_argcomplete.py__", "embedding": null, "metadata": {"file_path": "bench/bench_argcomplete.py", "file_name": "bench_argcomplete.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 20, "span_ids": ["docstring"], "tokens": 172}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# 10000 iterations, just for relative comparison\n#                      2.7.5     3.3.2\n# FilesCompleter       75.1109   69.2116\n# FastFilesCompleter    0.7383    1.0760\nimport timeit\n\nimports = [\n    \"from argcomplete.completers import FilesCompleter as completer\",\n    \"from _pytest._argcomplete import FastFilesCompleter as completer\",\n]\n\ncount = 1000  # only a few seconds\nsetup = \"%s\\nfc = completer()\"\nrun = 'fc(\"/d\")'\n\n\nif __name__ == \"__main__\":\n    print(timeit.timeit(run, setup=setup % imports[0], number=count))\n    print(timeit.timeit(run, setup=setup % imports[1], number=count))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/empty.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/bench/empty.py__", "embedding": null, "metadata": {"file_path": "bench/empty.py", "file_name": "empty.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 3, "span_ids": ["impl"], "tokens": 22}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "for i in range(1000):\n    exec(\"def test_func_%d(): pass\" % i)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/manyparam.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/bench/manyparam.py__", "embedding": null, "metadata": {"file_path": "bench/manyparam.py", "file_name": "manyparam.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 15, "span_ids": ["foo", "imports", "test_it", "test_it2"], "tokens": 37}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture(scope=\"module\", params=range(966))\ndef foo(request):\n    return request.param\n\n\ndef test_it(foo):\n    pass\n\n\ndef test_it2(foo):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/bench/skip.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/bench/skip.py__", "embedding": null, "metadata": {"file_path": "bench/skip.py", "file_name": "skip.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 10, "span_ids": ["imports", "test_foo"], "tokens": 33}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\nSKIP = True\n\n\n@pytest.mark.parametrize(\"x\", range(5000))\ndef test_foo(x):\n    if SKIP:\n        pytest.skip(\"heh\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conftest.py__", "embedding": null, "metadata": {"file_path": "doc/en/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 2, "span_ids": ["impl"], "tokens": 7}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "collect_ignore = [\"conf.py\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py_test_attribute_test_dynamic_compile_shows_nicely": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py_test_attribute_test_dynamic_compile_shows_nicely", "embedding": null, "metadata": {"file_path": "doc/en/example/assertion/failure_demo.py", "file_name": "failure_demo.py", "file_type": "text/x-python", "category": "implementation", "start_line": 124, "end_line": 203, "span_ids": ["TestRaises", "TestRaises.func1", "TestRaises.test_raise", "TestRaises.test_raises", "TestRaises.test_raises_doesnt", "TestRaises.test_reinterpret_fails_with_print_for_the_fun_of_it", "TestRaises.test_some_error", "TestRaises.test_tupleerror", "globf", "impl", "test_attribute", "test_attribute_failure", "test_attribute_instance", "test_attribute_multiple", "test_dynamic_compile_shows_nicely"], "tokens": 402}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_attribute():\n    class Foo:\n        b = 1\n\n    i = Foo()\n    assert i.b == 2\n\n\ndef test_attribute_instance():\n    class Foo:\n        b = 1\n\n    assert Foo().b == 2\n\n\ndef test_attribute_failure():\n    class Foo:\n        def _get_b(self):\n            raise Exception(\"Failed to get attrib\")\n\n        b = property(_get_b)\n\n    i = Foo()\n    assert i.b == 2\n\n\ndef test_attribute_multiple():\n    class Foo:\n        b = 1\n\n    class Bar:\n        b = 2\n\n    assert Foo().b == Bar().b\n\n\ndef globf(x):\n    return x + 1\n\n\nclass TestRaises:\n    def test_raises(self):\n        s = \"qwe\"\n        raises(TypeError, int, s)\n\n    def test_raises_doesnt(self):\n        raises(OSError, int, \"3\")\n\n    def test_raise(self):\n        raise ValueError(\"demo error\")\n\n    def test_tupleerror(self):\n        a, b = [1]  # NOQA\n\n    def test_reinterpret_fails_with_print_for_the_fun_of_it(self):\n        items = [1, 2, 3]\n        print(\"items is {!r}\".format(items))\n        a, b = items.pop()\n\n    def test_some_error(self):\n        if namenotexi:  # NOQA\n            pass\n\n    def func1(self):\n        assert 41 == 42\n\n\n# thanks to Matthew Scott for this test\ndef test_dynamic_compile_shows_nicely():\n    import importlib.util\n    import sys\n\n    src = \"def foo():\\n assert 1 == 0\\n\"\n    name = \"abc-123\"\n    spec = importlib.util.spec_from_loader(name, loader=None)\n    module = importlib.util.module_from_spec(spec)\n    code = _pytest._code.compile(src, name, \"exec\")\n    exec(code, module.__dict__)\n    sys.modules[name] = module\n    module.foo()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py_TestMoreErrors_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py_TestMoreErrors_", "embedding": null, "metadata": {"file_path": "doc/en/example/assertion/failure_demo.py", "file_name": "failure_demo.py", "file_type": "text/x-python", "category": "implementation", "start_line": 206, "end_line": 283, "span_ids": ["TestCustomAssertMsg", "TestCustomAssertMsg.test_custom_repr", "TestCustomAssertMsg.test_multiline", "TestCustomAssertMsg.test_single_line", "TestMoreErrors", "TestMoreErrors.test_compare", "TestMoreErrors.test_complex_error", "TestMoreErrors.test_global_func", "TestMoreErrors.test_instance", "TestMoreErrors.test_startswith", "TestMoreErrors.test_startswith_nested", "TestMoreErrors.test_try_finally", "TestMoreErrors.test_z1_unpack_error", "TestMoreErrors.test_z2_type_error"], "tokens": 373}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMoreErrors:\n    def test_complex_error(self):\n        def f():\n            return 44\n\n        def g():\n            return 43\n\n        somefunc(f(), g())\n\n    def test_z1_unpack_error(self):\n        items = []\n        a, b = items\n\n    def test_z2_type_error(self):\n        items = 3\n        a, b = items\n\n    def test_startswith(self):\n        s = \"123\"\n        g = \"456\"\n        assert s.startswith(g)\n\n    def test_startswith_nested(self):\n        def f():\n            return \"123\"\n\n        def g():\n            return \"456\"\n\n        assert f().startswith(g())\n\n    def test_global_func(self):\n        assert isinstance(globf(42), float)\n\n    def test_instance(self):\n        self.x = 6 * 7\n        assert self.x != 42\n\n    def test_compare(self):\n        assert globf(10) < 5\n\n    def test_try_finally(self):\n        x = 1\n        try:\n            assert x == 0\n        finally:\n            x = 0\n\n\nclass TestCustomAssertMsg:\n    def test_single_line(self):\n        class A:\n            a = 1\n\n        b = 2\n        assert A.a == b, \"A.a appears not to be b\"\n\n    def test_multiline(self):\n        class A:\n            a = 1\n\n        b = 2\n        assert (\n            A.a == b\n        ), \"A.a appears not to be b\\nor does not appear to be b\\none of those\"\n\n    def test_custom_repr(self):\n        class JSON:\n            a = 1\n\n            def __repr__(self):\n                return \"This is JSON\\n{\\n  'foo': 'bar'\\n}\"\n\n        a = JSON()\n        b = 2\n        assert a.a == b, a", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/global_testmodule_config/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/global_testmodule_config/conftest.py__", "embedding": null, "metadata": {"file_path": "doc/en/example/assertion/global_testmodule_config/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 15, "span_ids": ["imports", "pytest_runtest_setup"], "tokens": 79}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import py\n\nimport pytest\n\nmydir = py.path.local(__file__).dirpath()\n\n\ndef pytest_runtest_setup(item):\n    if isinstance(item, pytest.Function):\n        if not item.fspath.relto(mydir):\n            return\n        mod = item.getparent(pytest.Module).obj\n        if hasattr(mod, \"hello\"):\n            print(\"mod.hello {!r}\".format(mod.hello))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/global_testmodule_config/test_hello_world.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/global_testmodule_config/test_hello_world.py__", "embedding": null, "metadata": {"file_path": "doc/en/example/assertion/global_testmodule_config/test_hello_world.py", "file_name": "test_hello_world.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 6, "span_ids": ["impl", "test_func"], "tokens": 11}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "hello = \"world\"\n\n\ndef test_func():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/test_failures.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/test_failures.py__", "embedding": null, "metadata": {"file_path": "doc/en/example/assertion/test_failures.py", "file_name": "test_failures.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 14, "span_ids": ["imports", "test_failure_demo_fails_properly"], "tokens": 104}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import py\n\nfailure_demo = py.path.local(__file__).dirpath(\"failure_demo.py\")\npytest_plugins = (\"pytester\",)\n\n\ndef test_failure_demo_fails_properly(testdir):\n    target = testdir.tmpdir.join(failure_demo.basename)\n    failure_demo.copy(target)\n    failure_demo.copy(testdir.tmpdir.join(failure_demo.basename))\n    result = testdir.runpytest(target, syspathinsert=True)\n    result.stdout.fnmatch_lines([\"*44 failed*\"])\n    assert result.ret != 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/conftest.py__", "embedding": null, "metadata": {"file_path": "doc/en/example/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 2, "span_ids": ["impl"], "tokens": 7}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "collect_ignore = [\"nonpython\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/pythoncollection.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/pythoncollection.py__", "embedding": null, "metadata": {"file_path": "doc/en/example/pythoncollection.py", "file_name": "pythoncollection.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 15, "span_ids": ["TestClass", "TestClass.test_anothermethod", "TestClass.test_method", "docstring", "test_function"], "tokens": 40}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# run this with $ pytest --collect-only test_collectonly.py\n#\n\n\ndef test_function():\n    pass\n\n\nclass TestClass:\n    def test_method(self):\n        pass\n\n    def test_anothermethod(self):\n        pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/xfail_demo.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/xfail_demo.py__", "embedding": null, "metadata": {"file_path": "doc/en/example/xfail_demo.py", "file_name": "xfail_demo.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 39, "span_ids": ["imports", "test_hello", "test_hello2", "test_hello3", "test_hello4", "test_hello5", "test_hello6", "test_hello7"], "tokens": 136}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\nxfail = pytest.mark.xfail\n\n\n@xfail\ndef test_hello():\n    assert 0\n\n\n@xfail(run=False)\ndef test_hello2():\n    assert 0\n\n\n@xfail(\"hasattr(os, 'sep')\")\ndef test_hello3():\n    assert 0\n\n\n@xfail(reason=\"bug 110\")\ndef test_hello4():\n    assert 0\n\n\n@xfail('pytest.__version__[0] != \"17\"')\ndef test_hello5():\n    assert 0\n\n\ndef test_hello6():\n    pytest.xfail(\"reason\")\n\n\n@xfail(raises=IndexError)\ndef test_hello7():\n    x = []\n    x[1] = 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/extra/setup-py.test/setup.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/extra/setup-py.test/setup.py__", "embedding": null, "metadata": {"file_path": "extra/setup-py.test/setup.py", "file_name": "setup.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 12, "span_ids": ["imports"], "tokens": 76}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\nfrom distutils.core import setup\n\nif __name__ == \"__main__\":\n    if \"sdist\" not in sys.argv[1:]:\n        raise ValueError(\"please use 'pytest' pypi package instead of 'py.test'\")\n    setup(\n        name=\"py.test\",\n        version=\"0.0\",\n        description=\"please use 'pytest' for installation\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release.py_regen_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release.py_regen_", "embedding": null, "metadata": {"file_path": "scripts/release.py", "file_name": "release.py", "file_type": "text/x-python", "category": "implementation", "start_line": 68, "end_line": 125, "span_ids": ["changelog", "check_links", "fix_formatting", "impl", "main", "pre_release", "regen"], "tokens": 416}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def regen():\n    \"\"\"Call regendoc tool to update examples and pytest output in the docs.\"\"\"\n    print(f\"{Fore.CYAN}[generate.regen] {Fore.RESET}Updating docs\")\n    check_call([\"tox\", \"-e\", \"regen\"])\n\n\ndef fix_formatting():\n    \"\"\"Runs pre-commit in all files to ensure they are formatted correctly\"\"\"\n    print(\n        f\"{Fore.CYAN}[generate.fix linting] {Fore.RESET}Fixing formatting using pre-commit\"\n    )\n    call([\"pre-commit\", \"run\", \"--all-files\"])\n\n\ndef check_links():\n    \"\"\"Runs sphinx-build to check links\"\"\"\n    print(f\"{Fore.CYAN}[generate.check_links] {Fore.RESET}Checking links\")\n    check_call([\"tox\", \"-e\", \"docs-checklinks\"])\n\n\ndef pre_release(version, *, skip_check_links):\n    \"\"\"Generates new docs, release announcements and creates a local tag.\"\"\"\n    announce(version)\n    regen()\n    changelog(version, write_out=True)\n    fix_formatting()\n    if not skip_check_links:\n        check_links()\n\n    msg = \"Preparing release version {}\".format(version)\n    check_call([\"git\", \"commit\", \"-a\", \"-m\", msg])\n\n    print()\n    print(f\"{Fore.CYAN}[generate.pre_release] {Fore.GREEN}All done!\")\n    print()\n    print(\"Please push your branch and open a PR.\")\n\n\ndef changelog(version, write_out=False):\n    if write_out:\n        addopts = []\n    else:\n        addopts = [\"--draft\"]\n    check_call([\"towncrier\", \"--yes\", \"--version\", version] + addopts)\n\n\ndef main():\n    init(autoreset=True)\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"version\", help=\"Release version\")\n    parser.add_argument(\"--skip-check-links\", action=\"store_true\", default=False)\n    options = parser.parse_args()\n    pre_release(options.version, skip_check_links=options.skip_check_links)\n\n\nif __name__ == \"__main__\":\n    main()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/__init__.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/__init__.py__", "embedding": null, "metadata": {"file_path": "src/_pytest/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 9, "span_ids": ["impl"], "tokens": 56}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "__all__ = [\"__version__\"]\n\ntry:\n    from ._version import version as __version__\nexcept ImportError:\n    # broken installation, we don't even try\n    # unknown only works because we do poor mans version compare\n    __version__ = \"unknown\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/__init__.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/__init__.py__", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 23, "span_ids": ["docstring"], "tokens": 117}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Python inspection/code generation API.\"\"\"\nfrom .code import Code\nfrom .code import ExceptionInfo\nfrom .code import filter_traceback\nfrom .code import Frame\nfrom .code import getfslineno\nfrom .code import getrawcode\nfrom .code import Traceback\nfrom .source import compile_ as compile\nfrom .source import Source\n\n__all__ = [\n    \"Code\",\n    \"ExceptionInfo\",\n    \"filter_traceback\",\n    \"Frame\",\n    \"getfslineno\",\n    \"getrawcode\",\n    \"Traceback\",\n    \"compile\",\n    \"Source\",\n]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Frame_Frame.getargs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Frame_Frame.getargs", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 120, "end_line": 178, "span_ids": ["Frame", "Frame.__init__", "Frame.eval", "Frame.exec_", "Frame.getargs", "Frame.is_true", "Frame.repr", "Frame.statement"], "tokens": 402}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Frame:\n    \"\"\"Wrapper around a Python frame holding f_locals and f_globals\n    in which expressions can be evaluated.\"\"\"\n\n    def __init__(self, frame: FrameType) -> None:\n        self.lineno = frame.f_lineno - 1\n        self.f_globals = frame.f_globals\n        self.f_locals = frame.f_locals\n        self.raw = frame\n        self.code = Code(frame.f_code)\n\n    @property\n    def statement(self) -> \"Source\":\n        \"\"\" statement this frame is at \"\"\"\n        if self.code.fullsource is None:\n            return Source(\"\")\n        return self.code.fullsource.getstatement(self.lineno)\n\n    def eval(self, code, **vars):\n        \"\"\" evaluate 'code' in the frame\n\n            'vars' are optional additional local variables\n\n            returns the result of the evaluation\n        \"\"\"\n        f_locals = self.f_locals.copy()\n        f_locals.update(vars)\n        return eval(code, self.f_globals, f_locals)\n\n    def exec_(self, code, **vars) -> None:\n        \"\"\" exec 'code' in the frame\n\n            'vars' are optional; additional local variables\n        \"\"\"\n        f_locals = self.f_locals.copy()\n        f_locals.update(vars)\n        exec(code, self.f_globals, f_locals)\n\n    def repr(self, object: object) -> str:\n        \"\"\" return a 'safe' (non-recursive, one-line) string repr for 'object'\n        \"\"\"\n        return saferepr(object)\n\n    def is_true(self, object):\n        return object\n\n    def getargs(self, var: bool = False):\n        \"\"\" return a list of tuples (name, value) for all arguments\n\n            if 'var' is set True also include the variable and keyword\n            arguments when present\n        \"\"\"\n        retval = []\n        for arg in self.code.getargs(var):\n            try:\n                retval.append((arg, self.f_locals[arg]))\n            except KeyError:\n                pass  # this can occur when using Psyco\n        return retval", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_TracebackEntry_TracebackEntry.name": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_TracebackEntry_TracebackEntry.name", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 181, "end_line": 287, "span_ids": ["TracebackEntry", "TracebackEntry.__init__", "TracebackEntry.__repr__", "TracebackEntry.__str__", "TracebackEntry.frame", "TracebackEntry.getfirstlinesource", "TracebackEntry.getsource", "TracebackEntry.ishidden", "TracebackEntry.locals", "TracebackEntry.name", "TracebackEntry.path", "TracebackEntry.relline", "TracebackEntry.set_repr_style", "TracebackEntry.statement", "TracebackEntry:5"], "tokens": 764}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TracebackEntry:\n    \"\"\" a single entry in a traceback \"\"\"\n\n    _repr_style = None  # type: Optional[Literal[\"short\", \"long\"]]\n    exprinfo = None\n\n    def __init__(self, rawentry: TracebackType, excinfo=None) -> None:\n        self._excinfo = excinfo\n        self._rawentry = rawentry\n        self.lineno = rawentry.tb_lineno - 1\n\n    def set_repr_style(self, mode: \"Literal['short', 'long']\") -> None:\n        assert mode in (\"short\", \"long\")\n        self._repr_style = mode\n\n    @property\n    def frame(self) -> Frame:\n        return Frame(self._rawentry.tb_frame)\n\n    @property\n    def relline(self) -> int:\n        return self.lineno - self.frame.code.firstlineno\n\n    def __repr__(self) -> str:\n        return \"<TracebackEntry %s:%d>\" % (self.frame.code.path, self.lineno + 1)\n\n    @property\n    def statement(self) -> \"Source\":\n        \"\"\" _pytest._code.Source object for the current statement \"\"\"\n        source = self.frame.code.fullsource\n        assert source is not None\n        return source.getstatement(self.lineno)\n\n    @property\n    def path(self):\n        \"\"\" path to the source code \"\"\"\n        return self.frame.code.path\n\n    @property\n    def locals(self) -> Dict[str, Any]:\n        \"\"\" locals of underlying frame \"\"\"\n        return self.frame.f_locals\n\n    def getfirstlinesource(self) -> int:\n        return self.frame.code.firstlineno\n\n    def getsource(self, astcache=None) -> Optional[\"Source\"]:\n        \"\"\" return failing source code. \"\"\"\n        # we use the passed in astcache to not reparse asttrees\n        # within exception info printing\n        source = self.frame.code.fullsource\n        if source is None:\n            return None\n        key = astnode = None\n        if astcache is not None:\n            key = self.frame.code.path\n            if key is not None:\n                astnode = astcache.get(key, None)\n        start = self.getfirstlinesource()\n        try:\n            astnode, _, end = getstatementrange_ast(\n                self.lineno, source, astnode=astnode\n            )\n        except SyntaxError:\n            end = self.lineno + 1\n        else:\n            if key is not None:\n                astcache[key] = astnode\n        return source[start:end]\n\n    source = property(getsource)\n\n    def ishidden(self):\n        \"\"\" return True if the current frame has a var __tracebackhide__\n            resolving to True.\n\n            If __tracebackhide__ is a callable, it gets called with the\n            ExceptionInfo instance and can decide whether to hide the traceback.\n\n            mostly for internal use\n        \"\"\"\n        f = self.frame\n        tbh = f.f_locals.get(\n            \"__tracebackhide__\", f.f_globals.get(\"__tracebackhide__\", False)\n        )\n        if tbh and callable(tbh):\n            return tbh(None if self._excinfo is None else self._excinfo())\n        return tbh\n\n    def __str__(self) -> str:\n        try:\n            fn = str(self.path)\n        except py.error.Error:\n            fn = \"???\"\n        name = self.frame.code.name\n        try:\n            line = str(self.statement).lstrip()\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            line = \"???\"\n        return \"  File %r:%d in %s\\n  %s\\n\" % (fn, self.lineno + 1, name, line)\n\n    @property\n    def name(self) -> str:\n        \"\"\" co_name of underlying code \"\"\"\n        return self.frame.code.raw.co_name", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback.__getitem___Traceback.getcrashentry": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback.__getitem___Traceback.getcrashentry", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 346, "end_line": 384, "span_ids": ["Traceback.__getitem__", "Traceback.__getitem___2", "Traceback.__getitem___3", "Traceback.filter", "Traceback.getcrashentry"], "tokens": 324}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Traceback(List[TracebackEntry]):\n\n    @overload\n    def __getitem__(self, key: int) -> TracebackEntry:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Traceback\":  # noqa: F811\n        raise NotImplementedError()\n\n    def __getitem__(  # noqa: F811\n        self, key: Union[int, slice]\n    ) -> Union[TracebackEntry, \"Traceback\"]:\n        if isinstance(key, slice):\n            return self.__class__(super().__getitem__(key))\n        else:\n            return super().__getitem__(key)\n\n    def filter(\n        self, fn: Callable[[TracebackEntry], bool] = lambda x: not x.ishidden()\n    ) -> \"Traceback\":\n        \"\"\" return a Traceback instance with certain items removed\n\n            fn is a function that gets a single argument, a TracebackEntry\n            instance, and should return True when the item should be added\n            to the Traceback, False when not\n\n            by default this removes all the TracebackEntries which are hidden\n            (see ishidden() above)\n        \"\"\"\n        return Traceback(filter(fn, self), self._excinfo)\n\n    def getcrashentry(self) -> TracebackEntry:\n        \"\"\" return last non-hidden traceback entry that lead\n        to the exception of a traceback.\n        \"\"\"\n        for i in range(-1, -len(self) - 1, -1):\n            entry = self[i]\n            if not entry.ishidden():\n                return entry\n        return self[-1]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo_FormattedExcinfo.repr_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo_FormattedExcinfo.repr_args", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 647, "end_line": 691, "span_ids": ["FormattedExcinfo", "FormattedExcinfo._getentrysource", "FormattedExcinfo._getindent", "FormattedExcinfo.repr_args"], "tokens": 343}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass FormattedExcinfo:\n    \"\"\" presenting information about failing Functions and Generators. \"\"\"\n\n    # for traceback entries\n    flow_marker = \">\"\n    fail_marker = \"E\"\n\n    showlocals = attr.ib(type=bool, default=False)\n    style = attr.ib(type=\"_TracebackStyle\", default=\"long\")\n    abspath = attr.ib(type=bool, default=True)\n    tbfilter = attr.ib(type=bool, default=True)\n    funcargs = attr.ib(type=bool, default=False)\n    truncate_locals = attr.ib(type=bool, default=True)\n    chain = attr.ib(type=bool, default=True)\n    astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)\n\n    def _getindent(self, source: \"Source\") -> int:\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))\n\n    def _getentrysource(self, entry: TracebackEntry) -> Optional[\"Source\"]:\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source\n\n    def repr_args(self, entry: TracebackEntry) -> Optional[\"ReprFuncArgs\"]:\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)\n        return None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.get_source_FormattedExcinfo.get_exconly": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.get_source_FormattedExcinfo.get_exconly", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 693, "end_line": 733, "span_ids": ["FormattedExcinfo.get_exconly", "FormattedExcinfo.get_source"], "tokens": 341}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass FormattedExcinfo:\n\n    def get_source(\n        self,\n        source: \"Source\",\n        line_index: int = -1,\n        excinfo: Optional[ExceptionInfo] = None,\n        short: bool = False,\n    ) -> List[str]:\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines\n\n    def get_exconly(\n        self, excinfo: ExceptionInfo, indent: int = 4, markall: bool = False\n    ) -> List[str]:\n        lines = []\n        indentstr = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indentstr[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indentstr\n        return lines", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo._truncate_recursive_traceback_FormattedExcinfo._truncate_recursive_traceback.return_traceback_extrali": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo._truncate_recursive_traceback_FormattedExcinfo._truncate_recursive_traceback.return_traceback_extrali", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 819, "end_line": 858, "span_ids": ["FormattedExcinfo._truncate_recursive_traceback"], "tokens": 378}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass FormattedExcinfo:\n\n    def _truncate_recursive_traceback(\n        self, traceback: Traceback\n    ) -> Tuple[Traceback, Optional[str]]:\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )  # type: Optional[str]\n            # Type ignored because adding two instaces of a List subtype\n            # currently incorrectly has type List instead of the subtype.\n            traceback = traceback[:max_frames] + traceback[-max_frames:]  # type: ignore\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_getstatementrange_ast_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_getstatementrange_ast_", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/source.py", "file_name": "source.py", "file_type": "text/x-python", "category": "implementation", "start_line": 346, "end_line": 391, "span_ids": ["getstatementrange_ast"], "tokens": 379}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def getstatementrange_ast(\n    lineno: int,\n    source: Source,\n    assertion: bool = False,\n    astnode: Optional[ast.AST] = None,\n) -> Tuple[ast.AST, int, int]:\n    if astnode is None:\n        content = str(source)\n        # See #4260:\n        # don't produce duplicate warnings when compiling source to find ast\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            astnode = ast.parse(content, \"source\", \"exec\")\n\n    start, end = get_statement_startend2(lineno, astnode)\n    # we need to correct the end:\n    # - ast-parsing strips comments\n    # - there might be empty lines\n    # - we might have lesser indented code blocks at the end\n    if end is None:\n        end = len(source.lines)\n\n    if end > start + 1:\n        # make sure we don't span differently indented code blocks\n        # by using the BlockFinder helper used which inspect.getsource() uses itself\n        block_finder = inspect.BlockFinder()\n        # if we start with an indented line, put blockfinder to \"started\" mode\n        block_finder.started = source.lines[start][0].isspace()\n        it = ((x + \"\\n\") for x in source.lines[start:end])\n        try:\n            for tok in tokenize.generate_tokens(lambda: next(it)):\n                block_finder.tokeneater(*tok)\n        except (inspect.EndOfBlock, IndentationError):\n            end = block_finder.last + start\n        except Exception:\n            pass\n\n    # the end might still point to a comment or empty line, correct it\n    while end:\n        line = source.lines[end - 1].lstrip()\n        if line.startswith(\"#\") or not line:\n            end -= 1\n        else:\n            break\n    return astnode, start, end", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook._early_rewrite_bailout_AssertionRewritingHook._early_rewrite_bailout.return_True": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook._early_rewrite_bailout_AssertionRewritingHook._early_rewrite_bailout.return_True", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 154, "end_line": 191, "span_ids": ["AssertionRewritingHook._early_rewrite_bailout"], "tokens": 356}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def _early_rewrite_bailout(self, name, state):\n        \"\"\"This is a fast way to get out of rewriting modules.\n\n        Profiling has shown that the call to PathFinder.find_spec (inside of\n        the find_spec from this class) is a major slowdown, so, this method\n        tries to filter what we're sure won't be rewritten before getting to\n        it.\n        \"\"\"\n        if self.session is not None and not self._session_paths_checked:\n            self._session_paths_checked = True\n            for path in self.session._initialpaths:\n                # Make something as c:/projects/my_project/path.py ->\n                #     ['c:', 'projects', 'my_project', 'path.py']\n                parts = str(path).split(os.path.sep)\n                # add 'path' to basenames to be checked.\n                self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])\n\n        # Note: conftest already by default in _basenames_to_check_rewrite.\n        parts = name.split(\".\")\n        if parts[-1] in self._basenames_to_check_rewrite:\n            return False\n\n        # For matching the name it must be as if it was a filename.\n        path = PurePath(os.path.sep.join(parts) + \".py\")\n\n        for pat in self.fnpats:\n            # if the pattern contains subdirectories (\"tests/**.py\" for example) we can't bail out based\n            # on the name alone because we need to match against the full path\n            if os.path.dirname(pat):\n                return False\n            if fnmatch_ex(pat, path):\n                return False\n\n        if self._is_marked_for_rewrite(name, state):\n            return False\n\n        state.trace(\"early skip of rewriting module: {}\".format(name))\n        return True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.run_AssertionRewriter.run.while_nodes_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.run_AssertionRewriter.run.while_nodes_", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 582, "end_line": 645, "span_ids": ["AssertionRewriter.run"], "tokens": 438}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(\"builtins\", \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]  # type: List[ast.AST]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []  # type: List\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/truncate.py__truncate_explanation_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/truncate.py__truncate_explanation_", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/truncate.py", "file_name": "truncate.py", "file_type": "text/x-python", "category": "implementation", "start_line": 37, "end_line": 96, "span_ids": ["_truncate_by_char_count", "_truncate_explanation"], "tokens": 488}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _truncate_explanation(input_lines, max_lines=None, max_chars=None):\n    \"\"\"\n    Truncate given list of strings that makes up the assertion explanation.\n\n    Truncates to either 8 lines, or 640 characters - whichever the input reaches\n    first. The remaining lines will be replaced by a usage message.\n    \"\"\"\n\n    if max_lines is None:\n        max_lines = DEFAULT_MAX_LINES\n    if max_chars is None:\n        max_chars = DEFAULT_MAX_CHARS\n\n    # Check if truncation required\n    input_char_count = len(\"\".join(input_lines))\n    if len(input_lines) <= max_lines and input_char_count <= max_chars:\n        return input_lines\n\n    # Truncate first to max_lines, and then truncate to max_chars if max_chars\n    # is exceeded.\n    truncated_explanation = input_lines[:max_lines]\n    truncated_explanation = _truncate_by_char_count(truncated_explanation, max_chars)\n\n    # Add ellipsis to final line\n    truncated_explanation[-1] = truncated_explanation[-1] + \"...\"\n\n    # Append useful message to explanation\n    truncated_line_count = len(input_lines) - len(truncated_explanation)\n    truncated_line_count += 1  # Account for the part-truncated final line\n    msg = \"...Full output truncated\"\n    if truncated_line_count == 1:\n        msg += \" ({} line hidden)\".format(truncated_line_count)\n    else:\n        msg += \" ({} lines hidden)\".format(truncated_line_count)\n    msg += \", {}\".format(USAGE_MSG)\n    truncated_explanation.extend([\"\", str(msg)])\n    return truncated_explanation\n\n\ndef _truncate_by_char_count(input_lines, max_chars):\n    # Check if truncation required\n    if len(\"\".join(input_lines)) <= max_chars:\n        return input_lines\n\n    # Find point at which input length exceeds total allowed length\n    iterated_char_count = 0\n    for iterated_index, input_line in enumerate(input_lines):\n        if iterated_char_count + len(input_line) > max_chars:\n            break\n        iterated_char_count += len(input_line)\n\n    # Create truncated explanation with modified final line\n    truncated_result = input_lines[:iterated_index]\n    final_line = input_lines[iterated_index]\n    if final_line:\n        final_line_truncate_point = max_chars - iterated_char_count\n        final_line = final_line[:final_line_truncate_point]\n    truncated_result.append(final_line)\n    return truncated_result", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__format_lines_isiterable": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__format_lines_isiterable", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 64, "end_line": 128, "span_ids": ["_format_lines", "isattrs", "isdatacls", "isdict", "isiterable", "issequence", "isset", "istext"], "tokens": 437}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _format_lines(lines: Sequence[str]) -> List[str]:\n    \"\"\"Format the individual lines\n\n    This will replace the '{', '}' and '~' characters of our mini\n    formatting language with the proper 'where ...', 'and ...' and ' +\n    ...' text, taking care of indentation along the way.\n\n    Return a list of formatted lines.\n    \"\"\"\n    result = list(lines[:1])\n    stack = [0]\n    stackcnt = [0]\n    for line in lines[1:]:\n        if line.startswith(\"{\"):\n            if stackcnt[-1]:\n                s = \"and   \"\n            else:\n                s = \"where \"\n            stack.append(len(result))\n            stackcnt[-1] += 1\n            stackcnt.append(0)\n            result.append(\" +\" + \"  \" * (len(stack) - 1) + s + line[1:])\n        elif line.startswith(\"}\"):\n            stack.pop()\n            stackcnt.pop()\n            result[stack[-1]] += line[1:]\n        else:\n            assert line[0] in [\"~\", \">\"]\n            stack[-1] += 1\n            indent = len(stack) if line.startswith(\"~\") else len(stack) - 1\n            result.append(\"  \" * indent + line[1:])\n    assert len(stack) == 1\n    return result\n\n\ndef issequence(x: Any) -> bool:\n    return isinstance(x, collections.abc.Sequence) and not isinstance(x, str)\n\n\ndef istext(x: Any) -> bool:\n    return isinstance(x, str)\n\n\ndef isdict(x: Any) -> bool:\n    return isinstance(x, dict)\n\n\ndef isset(x: Any) -> bool:\n    return isinstance(x, (set, frozenset))\n\n\ndef isdatacls(obj: Any) -> bool:\n    return getattr(obj, \"__dataclass_fields__\", None) is not None\n\n\ndef isattrs(obj: Any) -> bool:\n    return getattr(obj, \"__attrs_attrs__\", None) is not None\n\n\ndef isiterable(obj: Any) -> bool:\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py_assertrepr_compare_assertrepr_compare.return_summary_explan": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py_assertrepr_compare_assertrepr_compare.return_summary_explan", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 131, "end_line": 187, "span_ids": ["assertrepr_compare"], "tokens": 500}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def assertrepr_compare(config, op: str, left: Any, right: Any) -> Optional[List[str]]:\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    verbose = config.getoption(\"verbose\")\n    if verbose > 1:\n        left_repr = safeformat(left)\n        right_repr = safeformat(right)\n    else:\n        # XXX: \"15 chars indentation\" is wrong\n        #      (\"E       AssertionError: assert \"); should use term width.\n        maxsize = (\n            80 - 15 - len(op) - 2\n        ) // 2  # 15 chars indentation, 1 space around op\n        left_repr = saferepr(left, maxsize=maxsize)\n        right_repr = saferepr(right, maxsize=maxsize)\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed: {}.\".format(\n                _pytest._code.ExceptionInfo.from_current()._getreprcrash()\n            ),\n            \" Probably an object has a faulty __repr__.)\",\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__diff_text__diff_text.return_explanation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__diff_text__diff_text.return_explanation", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 190, "end_line": 235, "span_ids": ["_diff_text"], "tokens": 377}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _diff_text(left: str, right: str, verbose: int = 0) -> List[str]:\n    \"\"\"Return the explanation for the diff between text.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []  # type: List[str]\n\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    # \"right\" is the expected base against which we compare \"left\",\n    # see https://github.com/pytest-dev/pytest/issues/3333\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(right.splitlines(keepends), left.splitlines(keepends))\n    ]\n    return explanation", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_cls_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_cls_", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 408, "end_line": 464, "span_ids": ["_compare_eq_cls", "_notin_text"], "tokens": 428}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _compare_eq_cls(\n    left: Any,\n    right: Any,\n    verbose: int,\n    type_fns: Tuple[Callable[[Any], bool], Callable[[Any], bool]],\n) -> List[str]:\n    isdatacls, isattrs = type_fns\n    if isdatacls(left):\n        all_fields = left.__dataclass_fields__\n        fields_to_check = [field for field, info in all_fields.items() if info.compare]\n    elif isattrs(left):\n        all_fields = left.__attrs_attrs__\n        fields_to_check = [\n            field.name for field in all_fields if getattr(field, ATTRS_EQ_FIELD)\n        ]\n\n    same = []\n    diff = []\n    for field in fields_to_check:\n        if getattr(left, field) == getattr(right, field):\n            same.append(field)\n        else:\n            diff.append(field)\n\n    explanation = []\n    if same and verbose < 2:\n        explanation.append(\"Omitting %s identical items, use -vv to show\" % len(same))\n    elif same:\n        explanation += [\"Matching attributes:\"]\n        explanation += pprint.pformat(same).splitlines()\n    if diff:\n        explanation += [\"Differing attributes:\"]\n        for field in diff:\n            explanation += [\n                (\"%s: %r != %r\") % (field, getattr(left, field), getattr(right, field))\n            ]\n    return explanation\n\n\ndef _notin_text(term: str, text: str, verbose: int = 0) -> List[str]:\n    index = text.find(term)\n    head = text[:index]\n    tail = text[index + len(term) :]\n    correct_text = head + tail\n    diff = _diff_text(text, correct_text, verbose)\n    newdiff = [\"%s is contained here:\" % saferepr(term, maxsize=42)]\n    for line in diff:\n        if line.startswith(\"Skipping\"):\n            continue\n        if line.startswith(\"- \"):\n            continue\n        if line.startswith(\"+ \"):\n            newdiff.append(\"  \" + line[2:])\n        else:\n            newdiff.append(line)\n    return newdiff", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_Cache_Cache.get": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_Cache_Cache.get", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 49, "end_line": 125, "span_ids": ["Cache", "Cache._getvaluepath", "Cache.cache_dir_from_config", "Cache.clear_cache", "Cache.for_config", "Cache.get", "Cache.makedir", "Cache.warn"], "tokens": 602}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass Cache:\n    _cachedir = attr.ib(repr=False)\n    _config = attr.ib(repr=False)\n\n    # sub-directory under cache-dir for directories created by \"makedir\"\n    _CACHE_PREFIX_DIRS = \"d\"\n\n    # sub-directory under cache-dir for values created by \"set\"\n    _CACHE_PREFIX_VALUES = \"v\"\n\n    @classmethod\n    def for_config(cls, config):\n        cachedir = cls.cache_dir_from_config(config)\n        if config.getoption(\"cacheclear\") and cachedir.is_dir():\n            cls.clear_cache(cachedir)\n        return cls(cachedir, config)\n\n    @classmethod\n    def clear_cache(cls, cachedir: Path):\n        \"\"\"Clears the sub-directories used to hold cached directories and values.\"\"\"\n        for prefix in (cls._CACHE_PREFIX_DIRS, cls._CACHE_PREFIX_VALUES):\n            d = cachedir / prefix\n            if d.is_dir():\n                rm_rf(d)\n\n    @staticmethod\n    def cache_dir_from_config(config):\n        return resolve_from_str(config.getini(\"cache_dir\"), config.rootdir)\n\n    def warn(self, fmt, **args):\n        import warnings\n        from _pytest.warning_types import PytestCacheWarning\n\n        warnings.warn(\n            PytestCacheWarning(fmt.format(**args) if args else fmt),\n            self._config.hook,\n            stacklevel=3,\n        )\n\n    def makedir(self, name):\n        \"\"\" return a directory path object with the given name.  If the\n        directory does not yet exist, it will be created.  You can use it\n        to manage files likes e. g. store/retrieve database\n        dumps across test sessions.\n\n        :param name: must be a string not containing a ``/`` separator.\n             Make sure the name contains your plugin or application\n             identifiers to prevent clashes with other cache users.\n        \"\"\"\n        name = Path(name)\n        if len(name.parts) > 1:\n            raise ValueError(\"name is not allowed to contain path separators\")\n        res = self._cachedir.joinpath(self._CACHE_PREFIX_DIRS, name)\n        res.mkdir(exist_ok=True, parents=True)\n        return py.path.local(res)\n\n    def _getvaluepath(self, key):\n        return self._cachedir.joinpath(self._CACHE_PREFIX_VALUES, Path(key))\n\n    def get(self, key, default):\n        \"\"\" return cached value for the given key.  If no value\n        was yet cached or the value cannot be read, the specified\n        default is returned.\n\n        :param key: must be a ``/`` separated value. Usually the first\n             name is the name of your plugin or your application.\n        :param default: must be provided in case of a cache-miss or\n             invalid cache values.\n\n        \"\"\"\n        path = self._getvaluepath(key)\n        try:\n            with path.open(\"r\") as f:\n                return json.load(f)\n        except (ValueError, OSError):\n            return default", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_Cache.set_Cache._ensure_supporting_files": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_Cache.set_Cache._ensure_supporting_files", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 127, "end_line": 167, "span_ids": ["Cache._ensure_supporting_files", "Cache.set"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass Cache:\n\n    def set(self, key, value):\n        \"\"\" save value for the given key.\n\n        :param key: must be a ``/`` separated value. Usually the first\n             name is the name of your plugin or your application.\n        :param value: must be of any combination of basic\n               python types, including nested types\n               like e. g. lists of dictionaries.\n        \"\"\"\n        path = self._getvaluepath(key)\n        try:\n            if path.parent.is_dir():\n                cache_dir_exists_already = True\n            else:\n                cache_dir_exists_already = self._cachedir.exists()\n                path.parent.mkdir(exist_ok=True, parents=True)\n        except OSError:\n            self.warn(\"could not create cache path {path}\", path=path)\n            return\n        if not cache_dir_exists_already:\n            self._ensure_supporting_files()\n        data = json.dumps(value, indent=2, sort_keys=True)\n        try:\n            f = path.open(\"w\")\n        except OSError:\n            self.warn(\"cache could not write path {path}\", path=path)\n        else:\n            with f:\n                f.write(data)\n\n    def _ensure_supporting_files(self):\n        \"\"\"Create supporting files in the cache dir that are not really part of the cache.\"\"\"\n        readme_path = self._cachedir / \"README.md\"\n        readme_path.write_text(README_CONTENT)\n\n        gitignore_path = self._cachedir.joinpath(\".gitignore\")\n        msg = \"# Created by pytest automatically.\\n*\\n\"\n        gitignore_path.write_text(msg, encoding=\"UTF-8\")\n\n        cachedir_tag_path = self._cachedir.joinpath(\"CACHEDIR.TAG\")\n        cachedir_tag_path.write_bytes(CACHEDIR_TAG_CONTENT)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPlugin_LFPlugin.pytest_collectreport": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPlugin_LFPlugin.pytest_collectreport", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 226, "end_line": 270, "span_ids": ["LFPlugin", "LFPlugin.__init__", "LFPlugin.get_last_failed_paths", "LFPlugin.pytest_collectreport", "LFPlugin.pytest_report_collectionfinish", "LFPlugin.pytest_runtest_logreport"], "tokens": 427}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LFPlugin:\n    \"\"\" Plugin which implements the --lf (run last-failing) option \"\"\"\n\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        active_keys = \"lf\", \"failedfirst\"\n        self.active = any(config.getoption(key) for key in active_keys)\n        assert config.cache\n        self.lastfailed = config.cache.get(\n            \"cache/lastfailed\", {}\n        )  # type: Dict[str, bool]\n        self._previously_failed_count = None\n        self._report_status = None\n        self._skipped_files = 0  # count skipped files during collection due to --lf\n\n        if config.getoption(\"lf\"):\n            self._last_failed_paths = self.get_last_failed_paths()\n            config.pluginmanager.register(\n                LFPluginCollWrapper(self), \"lfplugin-collwrapper\"\n            )\n\n    def get_last_failed_paths(self) -> Set[Path]:\n        \"\"\"Returns a set with all Paths()s of the previously failed nodeids.\"\"\"\n        rootpath = Path(str(self.config.rootdir))\n        result = {rootpath / nodeid.split(\"::\")[0] for nodeid in self.lastfailed}\n        return {x for x in result if x.exists()}\n\n    def pytest_report_collectionfinish(self):\n        if self.active and self.config.getoption(\"verbose\") >= 0:\n            return \"run-last-failure: %s\" % self._report_status\n\n    def pytest_runtest_logreport(self, report):\n        if (report.when == \"call\" and report.passed) or report.skipped:\n            self.lastfailed.pop(report.nodeid, None)\n        elif report.failed:\n            self.lastfailed[report.nodeid] = True\n\n    def pytest_collectreport(self, report):\n        passed = report.outcome in (\"passed\", \"skipped\")\n        if passed:\n            if report.nodeid in self.lastfailed:\n                self.lastfailed.pop(report.nodeid)\n                self.lastfailed.update((item.nodeid, True) for item in report.result)\n        else:\n            self.lastfailed[report.nodeid] = True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPlugin.pytest_collection_modifyitems_LFPlugin.pytest_sessionfinish": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPlugin.pytest_collection_modifyitems_LFPlugin.pytest_sessionfinish", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 272, "end_line": 326, "span_ids": ["LFPlugin.pytest_collection_modifyitems", "LFPlugin.pytest_sessionfinish"], "tokens": 480}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LFPlugin:\n\n    def pytest_collection_modifyitems(self, session, config, items):\n        if not self.active:\n            return\n\n        if self.lastfailed:\n            previously_failed = []\n            previously_passed = []\n            for item in items:\n                if item.nodeid in self.lastfailed:\n                    previously_failed.append(item)\n                else:\n                    previously_passed.append(item)\n            self._previously_failed_count = len(previously_failed)\n\n            if not previously_failed:\n                # Running a subset of all tests with recorded failures\n                # only outside of it.\n                self._report_status = \"%d known failures not in selected tests\" % (\n                    len(self.lastfailed),\n                )\n            else:\n                if self.config.getoption(\"lf\"):\n                    items[:] = previously_failed\n                    config.hook.pytest_deselected(items=previously_passed)\n                else:  # --failedfirst\n                    items[:] = previously_failed + previously_passed\n\n                noun = \"failure\" if self._previously_failed_count == 1 else \"failures\"\n                suffix = \" first\" if self.config.getoption(\"failedfirst\") else \"\"\n                self._report_status = \"rerun previous {count} {noun}{suffix}\".format(\n                    count=self._previously_failed_count, suffix=suffix, noun=noun\n                )\n\n            if self._skipped_files > 0:\n                files_noun = \"file\" if self._skipped_files == 1 else \"files\"\n                self._report_status += \" (skipped {files} {files_noun})\".format(\n                    files=self._skipped_files, files_noun=files_noun\n                )\n        else:\n            self._report_status = \"no previously failed tests, \"\n            if self.config.getoption(\"last_failed_no_failures\") == \"none\":\n                self._report_status += \"deselecting all items.\"\n                config.hook.pytest_deselected(items=items[:])\n                items[:] = []\n            else:\n                self._report_status += \"not deselecting items.\"\n\n    def pytest_sessionfinish(self, session):\n        config = self.config\n        if config.getoption(\"cacheshow\") or hasattr(config, \"slaveinput\"):\n            return\n\n        saved_lastfailed = config.cache.get(\"cache/lastfailed\", {})\n        if saved_lastfailed != self.lastfailed:\n            config.cache.set(\"cache/lastfailed\", self.lastfailed)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_NFPlugin_NFPlugin.pytest_sessionfinish": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_NFPlugin_NFPlugin.pytest_sessionfinish", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 329, "end_line": 364, "span_ids": ["NFPlugin", "NFPlugin.__init__", "NFPlugin._get_increasing_order", "NFPlugin.pytest_collection_modifyitems", "NFPlugin.pytest_sessionfinish"], "tokens": 310}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class NFPlugin:\n    \"\"\" Plugin which implements the --nf (run new-first) option \"\"\"\n\n    def __init__(self, config):\n        self.config = config\n        self.active = config.option.newfirst\n        self.cached_nodeids = set(config.cache.get(\"cache/nodeids\", []))\n\n    def pytest_collection_modifyitems(\n        self, session: Session, config: Config, items: List[nodes.Item]\n    ) -> None:\n        if self.active:\n            new_items = order_preserving_dict()  # type: Dict[str, nodes.Item]\n            other_items = order_preserving_dict()  # type: Dict[str, nodes.Item]\n            for item in items:\n                if item.nodeid not in self.cached_nodeids:\n                    new_items[item.nodeid] = item\n                else:\n                    other_items[item.nodeid] = item\n\n            items[:] = self._get_increasing_order(\n                new_items.values()\n            ) + self._get_increasing_order(other_items.values())\n            self.cached_nodeids.update(new_items)\n        else:\n            self.cached_nodeids.update(item.nodeid for item in items)\n\n    def _get_increasing_order(self, items):\n        return sorted(items, key=lambda item: item.fspath.mtime(), reverse=True)\n\n    def pytest_sessionfinish(self, session):\n        config = self.config\n        if config.getoption(\"cacheshow\") or hasattr(config, \"slaveinput\"):\n            return\n\n        config.cache.set(\"cache/nodeids\", sorted(self.cached_nodeids))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_pytest_addoption_pytest_addoption.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_pytest_addoption_pytest_addoption.None_6", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 303, "end_line": 358, "span_ids": ["pytest_addoption"], "tokens": 400}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--lf\",\n        \"--last-failed\",\n        action=\"store_true\",\n        dest=\"lf\",\n        help=\"rerun only the tests that failed \"\n        \"at the last run (or all if none failed)\",\n    )\n    group.addoption(\n        \"--ff\",\n        \"--failed-first\",\n        action=\"store_true\",\n        dest=\"failedfirst\",\n        help=\"run all tests but run the last failures first.  \"\n        \"This may re-order tests and thus lead to \"\n        \"repeated fixture setup/teardown\",\n    )\n    group.addoption(\n        \"--nf\",\n        \"--new-first\",\n        action=\"store_true\",\n        dest=\"newfirst\",\n        help=\"run tests from new files first, then the rest of the tests \"\n        \"sorted by file mtime\",\n    )\n    group.addoption(\n        \"--cache-show\",\n        action=\"append\",\n        nargs=\"?\",\n        dest=\"cacheshow\",\n        help=(\n            \"show cache contents, don't perform collection or tests. \"\n            \"Optional argument: glob (default: '*').\"\n        ),\n    )\n    group.addoption(\n        \"--cache-clear\",\n        action=\"store_true\",\n        dest=\"cacheclear\",\n        help=\"remove all cache contents at start of test run.\",\n    )\n    cache_dir_default = \".pytest_cache\"\n    if \"TOX_ENV_DIR\" in os.environ:\n        cache_dir_default = os.path.join(os.environ[\"TOX_ENV_DIR\"], cache_dir_default)\n    parser.addini(\"cache_dir\", default=cache_dir_default, help=\"cache directory path.\")\n    group.addoption(\n        \"--lfnf\",\n        \"--last-failed-no-failures\",\n        action=\"store\",\n        dest=\"last_failed_no_failures\",\n        choices=(\"all\", \"none\"),\n        default=\"all\",\n        help=\"which tests to run with no previously (known) failures.\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_pytest_cmdline_main_pytest_report_header": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_pytest_cmdline_main_pytest_report_header", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 425, "end_line": 466, "span_ids": ["cache", "pytest_cmdline_main", "pytest_configure", "pytest_report_header"], "tokens": 291}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_cmdline_main(config):\n    if config.option.cacheshow:\n        from _pytest.main import wrap_session\n\n        return wrap_session(config, cacheshow)\n\n\n@pytest.hookimpl(tryfirst=True)\ndef pytest_configure(config: Config) -> None:\n    config.cache = Cache.for_config(config)\n    config.pluginmanager.register(LFPlugin(config), \"lfplugin\")\n    config.pluginmanager.register(NFPlugin(config), \"nfplugin\")\n\n\n@pytest.fixture\ndef cache(request):\n    \"\"\"\n    Return a cache object that can persist state between testing sessions.\n\n    cache.get(key, default)\n    cache.set(key, value)\n\n    Keys must be a ``/`` separated value, where the first part is usually the\n    name of your plugin or application to avoid clashes with other cache users.\n\n    Values can be any object handled by the json stdlib module.\n    \"\"\"\n    return request.config.cache\n\n\ndef pytest_report_header(config):\n    \"\"\"Display cachedir with --cache-show and if non-default.\"\"\"\n    if config.option.verbose > 0 or config.getini(\"cache_dir\") != \".pytest_cache\":\n        cachedir = config.cache._cachedir\n        # TODO: evaluate generating upward relative paths\n        # starting with .., ../.. if sensible\n\n        try:\n            displaypath = cachedir.relative_to(config.rootdir)\n        except ValueError:\n            displaypath = cachedir\n        return \"cachedir: {}\".format(displaypath)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_cacheshow_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_cacheshow_", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 469, "end_line": 507, "span_ids": ["cacheshow"], "tokens": 320}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def cacheshow(config, session):\n    from pprint import pformat\n\n    tw = TerminalWriter()\n    tw.line(\"cachedir: \" + str(config.cache._cachedir))\n    if not config.cache._cachedir.is_dir():\n        tw.line(\"cache is empty\")\n        return 0\n\n    glob = config.option.cacheshow[0]\n    if glob is None:\n        glob = \"*\"\n\n    dummy = object()\n    basedir = config.cache._cachedir\n    vdir = basedir / Cache._CACHE_PREFIX_VALUES\n    tw.sep(\"-\", \"cache values for %r\" % glob)\n    for valpath in sorted(x for x in vdir.rglob(glob) if x.is_file()):\n        key = valpath.relative_to(vdir)\n        val = config.cache.get(key, dummy)\n        if val is dummy:\n            tw.line(\"%s contains unreadable content, will be ignored\" % key)\n        else:\n            tw.line(\"%s contains:\" % key)\n            for line in pformat(val).splitlines():\n                tw.line(\"  \" + line)\n\n    ddir = basedir / Cache._CACHE_PREFIX_DIRS\n    if ddir.is_dir():\n        contents = sorted(ddir.rglob(glob))\n        tw.sep(\"-\", \"cache directories for %r\" % glob)\n        for p in contents:\n            # if p.check(dir=1):\n            #    print(\"%s/\" % p.relto(basedir))\n            if p.is_file():\n                key = p.relative_to(basedir)\n                tw.line(\"{} is a file of length {:d}\".format(key, p.stat().st_size))\n    return 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager_CaptureManager._Fixture_Control_it_s_j": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager_CaptureManager._Fixture_Control_it_s_j", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 84, "end_line": 153, "span_ids": ["CaptureManager", "CaptureManager.__init__", "CaptureManager.__repr__", "CaptureManager.is_capturing", "CaptureManager.is_globally_capturing", "CaptureManager.read_global_capture", "CaptureManager.resume", "CaptureManager.resume_global_capture", "CaptureManager.start_global_capturing", "CaptureManager.stop_global_capturing", "CaptureManager.suspend", "CaptureManager.suspend_global_capture", "CaptureManager:3", "CaptureManager:4"], "tokens": 612}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class CaptureManager:\n    \"\"\"\n    Capture plugin, manages that the appropriate capture method is enabled/disabled during collection and each\n    test phase (setup, call, teardown). After each of those points, the captured output is obtained and\n    attached to the collection/runtest report.\n\n    There are two levels of capture:\n    * global: which is enabled by default and can be suppressed by the ``-s`` option. This is always enabled/disabled\n      during collection and each test phase.\n    * fixture: when a test function or one of its fixture depend on the ``capsys`` or ``capfd`` fixtures. In this\n      case special handling is needed to ensure the fixtures take precedence over the global capture.\n    \"\"\"\n\n    def __init__(self, method: \"_CaptureMethod\") -> None:\n        self._method = method\n        self._global_capturing = None\n        self._capture_fixture = None  # type: Optional[CaptureFixture]\n\n    def __repr__(self):\n        return \"<CaptureManager _method={!r} _global_capturing={!r} _capture_fixture={!r}>\".format(\n            self._method, self._global_capturing, self._capture_fixture\n        )\n\n    def is_capturing(self):\n        if self.is_globally_capturing():\n            return \"global\"\n        if self._capture_fixture:\n            return \"fixture %s\" % self._capture_fixture.request.fixturename\n        return False\n\n    # Global capturing control\n\n    def is_globally_capturing(self):\n        return self._method != \"no\"\n\n    def start_global_capturing(self):\n        assert self._global_capturing is None\n        self._global_capturing = _get_multicapture(self._method)\n        self._global_capturing.start_capturing()\n\n    def stop_global_capturing(self):\n        if self._global_capturing is not None:\n            self._global_capturing.pop_outerr_to_orig()\n            self._global_capturing.stop_capturing()\n            self._global_capturing = None\n\n    def resume_global_capture(self):\n        # During teardown of the python process, and on rare occasions, capture\n        # attributes can be `None` while trying to resume global capture.\n        if self._global_capturing is not None:\n            self._global_capturing.resume_capturing()\n\n    def suspend_global_capture(self, in_=False):\n        cap = getattr(self, \"_global_capturing\", None)\n        if cap is not None:\n            cap.suspend_capturing(in_=in_)\n\n    def suspend(self, in_=False):\n        # Need to undo local capsys-et-al if it exists before disabling global capture.\n        self.suspend_fixture()\n        self.suspend_global_capture(in_)\n\n    def resume(self):\n        self.resume_global_capture()\n        self.resume_fixture()\n\n    def read_global_capture(self):\n        return self._global_capturing.readouterr()\n\n    # Fixture Control (it's just forwarding, think about removing this later)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager.activate_fixture_CaptureManager.pytest_internalerror": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager.activate_fixture_CaptureManager.pytest_internalerror", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 184, "end_line": 267, "span_ids": ["CaptureManager.activate_fixture", "CaptureManager.deactivate_fixture", "CaptureManager.global_and_fixture_disabled", "CaptureManager.item_capture", "CaptureManager.pytest_internalerror", "CaptureManager.pytest_keyboard_interrupt", "CaptureManager.pytest_make_collect_report", "CaptureManager.pytest_runtest_call", "CaptureManager.pytest_runtest_setup", "CaptureManager.pytest_runtest_teardown", "CaptureManager.resume_fixture", "CaptureManager.suspend_fixture", "CaptureManager:5", "CaptureManager:6"], "tokens": 520}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class CaptureManager:\n\n    def activate_fixture(self):\n        \"\"\"If the current item is using ``capsys`` or ``capfd``, activate them so they take precedence over\n        the global capture.\n        \"\"\"\n        if self._capture_fixture:\n            self._capture_fixture._start()\n\n    def deactivate_fixture(self):\n        \"\"\"Deactivates the ``capsys`` or ``capfd`` fixture of this item, if any.\"\"\"\n        if self._capture_fixture:\n            self._capture_fixture.close()\n\n    def suspend_fixture(self):\n        if self._capture_fixture:\n            self._capture_fixture._suspend()\n\n    def resume_fixture(self):\n        if self._capture_fixture:\n            self._capture_fixture._resume()\n\n    # Helper context managers\n\n    @contextlib.contextmanager\n    def global_and_fixture_disabled(self):\n        \"\"\"Context manager to temporarily disable global and current fixture capturing.\"\"\"\n        self.suspend()\n        try:\n            yield\n        finally:\n            self.resume()\n\n    @contextlib.contextmanager\n    def item_capture(self, when, item):\n        self.resume_global_capture()\n        self.activate_fixture()\n        try:\n            yield\n        finally:\n            self.deactivate_fixture()\n            self.suspend_global_capture(in_=False)\n\n        out, err = self.read_global_capture()\n        item.add_report_section(when, \"stdout\", out)\n        item.add_report_section(when, \"stderr\", err)\n\n    # Hooks\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_make_collect_report(self, collector):\n        if isinstance(collector, pytest.File):\n            self.resume_global_capture()\n            outcome = yield\n            self.suspend_global_capture()\n            out, err = self.read_global_capture()\n            rep = outcome.get_result()\n            if out:\n                rep.sections.append((\"Captured stdout\", out))\n            if err:\n                rep.sections.append((\"Captured stderr\", err))\n        else:\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self.item_capture(\"setup\", item):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self.item_capture(\"call\", item):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self.item_capture(\"teardown\", item):\n            yield\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_keyboard_interrupt(self, excinfo):\n        self.stop_global_capturing()\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_internalerror(self, excinfo):\n        self.stop_global_capturing()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_MultiCapture_NoCapture.__init__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_MultiCapture_NoCapture.__init__", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 420, "end_line": 502, "span_ids": ["MultiCapture", "MultiCapture.__init__", "MultiCapture.__repr__", "MultiCapture.pop_outerr_to_orig", "MultiCapture.readouterr", "MultiCapture.resume_capturing", "MultiCapture.start_capturing", "MultiCapture.stop_capturing", "MultiCapture.suspend_capturing", "NoCapture"], "tokens": 523}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MultiCapture:\n    out = err = in_ = None\n    _state = None\n    _in_suspended = False\n\n    def __init__(self, out=True, err=True, in_=True, Capture=None):\n        if in_:\n            self.in_ = Capture(0)\n        if out:\n            self.out = Capture(1)\n        if err:\n            self.err = Capture(2)\n\n    def __repr__(self):\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self):\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n            self.err.writeorg(err)\n        return out, err\n\n    def suspend_capturing(self, in_=False):\n        self._state = \"suspended\"\n        if self.out:\n            self.out.suspend()\n        if self.err:\n            self.err.suspend()\n        if in_ and self.in_:\n            self.in_.suspend()\n            self._in_suspended = True\n\n    def resume_capturing(self):\n        self._state = \"resumed\"\n        if self.out:\n            self.out.resume()\n        if self.err:\n            self.err.resume()\n        if self._in_suspended:\n            self.in_.resume()\n            self._in_suspended = False\n\n    def stop_capturing(self):\n        \"\"\" stop capturing and reset capturing streams \"\"\"\n        if self._state == \"stopped\":\n            raise ValueError(\"was already stopped\")\n        self._state = \"stopped\"\n        if self.out:\n            self.out.done()\n        if self.err:\n            self.err.done()\n        if self.in_:\n            self.in_.done()\n\n    def readouterr(self) -> CaptureResult:\n        if self.out:\n            out = self.out.snap()\n        else:\n            out = \"\"\n        if self.err:\n            err = self.err.snap()\n        else:\n            err = \"\"\n        return CaptureResult(out, err)\n\n\nclass NoCapture:\n    EMPTY_BUFFER = None\n    __init__ = start = done = suspend = resume = lambda *args: None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_FDCaptureBinary_FDCaptureBinary.writeorg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_FDCaptureBinary_FDCaptureBinary.writeorg", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 505, "end_line": 591, "span_ids": ["FDCaptureBinary", "FDCaptureBinary.__init__", "FDCaptureBinary.__repr__", "FDCaptureBinary._done", "FDCaptureBinary._start", "FDCaptureBinary.resume", "FDCaptureBinary.snap", "FDCaptureBinary.suspend", "FDCaptureBinary.writeorg"], "tokens": 606}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FDCaptureBinary:\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces `bytes`\n    \"\"\"\n\n    EMPTY_BUFFER = b\"\"\n    _state = None\n\n    def __init__(self, targetfd, tmpfile=None):\n        self.targetfd = targetfd\n        try:\n            self.targetfd_save = os.dup(self.targetfd)\n        except OSError:\n            self.start = lambda: None\n            self.done = lambda: None\n        else:\n            self.start = self._start\n            self.done = self._done\n            if targetfd == 0:\n                assert not tmpfile, \"cannot set tmpfile with stdin\"\n                tmpfile = open(os.devnull)\n                self.syscapture = SysCapture(targetfd)\n            else:\n                if tmpfile is None:\n                    tmpfile = EncodedFile(\n                        TemporaryFile(buffering=0),\n                        encoding=\"utf-8\",\n                        errors=\"replace\",\n                        write_through=True,\n                    )\n                if targetfd in patchsysdict:\n                    self.syscapture = SysCapture(targetfd, tmpfile)\n                else:\n                    self.syscapture = NoCapture()\n            self.tmpfile = tmpfile\n            self.tmpfile_fd = tmpfile.fileno()\n\n    def __repr__(self):\n        return \"<{} {} oldfd={} _state={!r} tmpfile={}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            getattr(self, \"targetfd_save\", \"<UNSET>\"),\n            self._state,\n            hasattr(self, \"tmpfile\") and repr(self.tmpfile) or \"<UNSET>\",\n        )\n\n    def _start(self):\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        try:\n            os.fstat(self.targetfd_save)\n        except (AttributeError, OSError):\n            raise ValueError(\"saved filedescriptor not valid anymore\")\n        os.dup2(self.tmpfile_fd, self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def _done(self):\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        targetfd_save = self.__dict__.pop(\"targetfd_save\")\n        os.dup2(targetfd_save, self.targetfd)\n        os.close(targetfd_save)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self):\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self):\n        self.syscapture.resume()\n        os.dup2(self.tmpfile_fd, self.targetfd)\n        self._state = \"resumed\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        os.write(self.targetfd_save, data)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py__readline_workaround__readline_workaround": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py__readline_workaround__readline_workaround", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 757, "end_line": 779, "span_ids": ["_readline_workaround"], "tokens": 220}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _readline_workaround():\n    \"\"\"\n    Ensure readline is imported so that it attaches to the correct stdio\n    handles on Windows.\n\n    Pdb uses readline support where available--when not running from the Python\n    prompt, the readline module is not imported until running the pdb REPL.  If\n    running pytest with the --pdb option this means the readline module is not\n    imported until after I/O capture has been started.\n\n    This is a problem for pyreadline, which is often used to implement readline\n    support on Windows, as it does not attach to the correct handles for stdout\n    and/or stdin if they have been redirected by the FDCapture mechanism.  This\n    workaround ensures that readline is imported before I/O capture is setup so\n    that it can attach to the actual stdin/out for the console.\n\n    See https://github.com/pytest-dev/pytest/pull/1281\n    \"\"\"\n    if sys.platform.startswith(\"win32\"):\n        try:\n            import readline  # noqa: F401\n        except ImportError:\n            pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py__py36_windowsconsoleio_workaround_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py__py36_windowsconsoleio_workaround_", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 770, "end_line": 826, "span_ids": ["_py36_windowsconsoleio_workaround"], "tokens": 452}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _py36_windowsconsoleio_workaround(stream):\n    \"\"\"\n    Python 3.6 implemented unicode console handling for Windows. This works\n    by reading/writing to the raw console handle using\n    ``{Read,Write}ConsoleW``.\n\n    The problem is that we are going to ``dup2`` over the stdio file\n    descriptors when doing ``FDCapture`` and this will ``CloseHandle`` the\n    handles used by Python to write to the console. Though there is still some\n    weirdness and the console handle seems to only be closed randomly and not\n    on the first call to ``CloseHandle``, or maybe it gets reopened with the\n    same handle value when we suspend capturing.\n\n    The workaround in this case will reopen stdio with a different fd which\n    also means a different handle by replicating the logic in\n    \"Py_lifecycle.c:initstdio/create_stdio\".\n\n    :param stream: in practice ``sys.stdout`` or ``sys.stderr``, but given\n        here as parameter for unittesting purposes.\n\n    See https://github.com/pytest-dev/py/issues/103\n    \"\"\"\n    if (\n        not sys.platform.startswith(\"win32\")\n        or sys.version_info[:2] < (3, 6)\n        or hasattr(sys, \"pypy_version_info\")\n    ):\n        return\n\n    # bail out if ``stream`` doesn't seem like a proper ``io`` stream (#2666)\n    if not hasattr(stream, \"buffer\"):\n        return\n\n    buffered = hasattr(stream.buffer, \"raw\")\n    raw_stdout = stream.buffer.raw if buffered else stream.buffer\n\n    if not isinstance(raw_stdout, io._WindowsConsoleIO):\n        return\n\n    def _reopen_stdio(f, mode):\n        if not buffered and mode[0] == \"w\":\n            buffering = 0\n        else:\n            buffering = -1\n\n        return io.TextIOWrapper(\n            open(os.dup(f.fileno()), mode, buffering),\n            f.encoding,\n            f.errors,\n            f.newlines,\n            f.line_buffering,\n        )\n\n    sys.stdin = _reopen_stdio(sys.stdin, \"rb\")\n    sys.stdout = _reopen_stdio(sys.stdout, \"wb\")\n    sys.stderr = _reopen_stdio(sys.stderr, \"wb\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_main_main.try_.except_UsageError_as_e_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_main_main.try_.except_UsageError_as_e_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 95, "end_line": 137, "span_ids": ["main"], "tokens": 313}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def main(args=None, plugins=None) -> Union[int, ExitCode]:\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return ExitCode.USAGE_ERROR\n        else:\n            try:\n                ret = config.hook.pytest_cmdline_main(\n                    config=config\n                )  # type: Union[ExitCode, int]\n                try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.parse_hookimpl_opts_PytestPluginManager.parse_hookimpl_opts.return_opts": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.parse_hookimpl_opts_PytestPluginManager.parse_hookimpl_opts.return_opts", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 267, "end_line": 294, "span_ids": ["PytestPluginManager.parse_hookimpl_opts"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.parse_hookspec_opts_PytestPluginManager.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.parse_hookspec_opts_PytestPluginManager.None_3", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 296, "end_line": 359, "span_ids": ["PytestPluginManager.getplugin", "PytestPluginManager.hasplugin", "PytestPluginManager.parse_hookspec_opts", "PytestPluginManager.pytest_configure", "PytestPluginManager.register", "PytestPluginManager:3"], "tokens": 477}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                    \"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook.pytest_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is registered.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._set_initial_conftests_PytestPluginManager._set_initial_conftests.if_not_foundanchor_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._set_initial_conftests_PytestPluginManager._set_initial_conftests.if_not_foundanchor_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 371, "end_line": 400, "span_ids": ["PytestPluginManager._set_initial_conftests"], "tokens": 257}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            current.join(namespace.confcutdir, abs=True)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._checkversion_Config.parse": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._checkversion_Config.parse", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1049, "end_line": 1088, "span_ids": ["Config._checkversion", "Config.parse"], "tokens": 309}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Config:\n\n    def _checkversion(self):\n        import pytest\n\n        minver = self.inicfg.get(\"minversion\", None)\n        if minver:\n            if Version(minver) > Version(pytest.__version__):\n                raise pytest.UsageError(\n                    \"%s:%d: requires pytest-%s, actual pytest-%s'\"\n                    % (\n                        self.inicfg.config.path,\n                        self.inicfg.lineof(\"minversion\"),\n                        minver,\n                        pytest.__version__,\n                    )\n                )\n\n    def parse(self, args: List[str], addopts: bool = True) -> None:\n        # parse given cmdline arguments into this config object.\n        assert not hasattr(\n            self, \"args\"\n        ), \"can only parse cmdline args at most once per Config object\"\n        self.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=self.pluginmanager)\n        )\n        self._preparse(args, addopts=addopts)\n        # XXX deprecated hook:\n        self.hook.pytest_cmdline_preparse(config=self, args=args)\n        self._parser.after_preparse = True  # type: ignore\n        try:\n            args = self._parser.parse_setoption(\n                args, self.option, namespace=self.option\n            )\n            if not args:\n                if self.invocation_dir == self.rootdir:\n                    args = self.getini(\"testpaths\")\n                if not args:\n                    args = [str(self.invocation_dir)]\n            self.args = args\n        except PrintHelp:\n            pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config.addinivalue_line_Config._getini.if_type_pathlist_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config.addinivalue_line_Config._getini.if_type_pathlist_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1090, "end_line": 1138, "span_ids": ["Config._getini", "Config.addinivalue_line", "Config.getini"], "tokens": 418}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Config:\n\n    def addinivalue_line(self, name, line):\n        \"\"\" add a line to an ini-file option. The option must have been\n        declared but might not yet be set in which case the line becomes the\n        the first line in its value. \"\"\"\n        x = self.getini(name)\n        assert isinstance(x, list)\n        x.append(line)  # modifies the cached list inline\n\n    def getini(self, name: str):\n        \"\"\" return configuration value from an :ref:`ini file <inifiles>`. If the\n        specified name hasn't been registered through a prior\n        :py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`\n        call (usually from a plugin), a ValueError is raised. \"\"\"\n        try:\n            return self._inicache[name]\n        except KeyError:\n            self._inicache[name] = val = self._getini(name)\n            return val\n\n    def _getini(self, name: str) -> Any:\n        try:\n            description, type, default = self._parser._inidict[name]\n        except KeyError:\n            raise ValueError(\"unknown configuration value: {!r}\".format(name))\n        value = self._get_override_ini_value(name)\n        if value is None:\n            try:\n                value = self.inicfg[name]\n            except KeyError:\n                if default is not None:\n                    return default\n                if type is None:\n                    return \"\"\n                return []\n        if type == \"pathlist\":\n            dp = py.path.local(self.inicfg.config.path).dirpath()\n            values = []\n            for relpath in shlex.split(value):\n                values.append(dp.join(relpath, abs=True))\n            return values\n        elif type == \"args\":\n            return shlex.split(value)\n        elif type == \"linelist\":\n            return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n        elif type == \"bool\":\n            return bool(_strtobool(value.strip()))\n        else:\n            assert type is None\n            return value", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._getconftest_pathlist_Config.getvalueorskip": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._getconftest_pathlist_Config.getvalueorskip", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1140, "end_line": 1203, "span_ids": ["Config._get_override_ini_value", "Config._getconftest_pathlist", "Config.getoption", "Config.getvalue", "Config.getvalueorskip"], "tokens": 531}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Config:\n\n    def _getconftest_pathlist(self, name, path):\n        try:\n            mod, relroots = self.pluginmanager._rget_with_confmod(name, path)\n        except KeyError:\n            return None\n        modpath = py.path.local(mod.__file__).dirpath()\n        values = []\n        for relroot in relroots:\n            if not isinstance(relroot, py.path.local):\n                relroot = relroot.replace(\"/\", py.path.local.sep)\n                relroot = modpath.join(relroot, abs=True)\n            values.append(relroot)\n        return values\n\n    def _get_override_ini_value(self, name: str) -> Optional[str]:\n        value = None\n        # override_ini is a list of \"ini=value\" options\n        # always use the last item if multiple values are set for same ini-name,\n        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2\n        for ini_config in self._override_ini:\n            try:\n                key, user_ini_value = ini_config.split(\"=\", 1)\n            except ValueError:\n                raise UsageError(\n                    \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n                        ini_config\n                    )\n                )\n            else:\n                if key == name:\n                    value = user_ini_value\n        return value\n\n    def getoption(self, name: str, default=notset, skip: bool = False):\n        \"\"\" return command line option value.\n\n        :arg name: name of the option.  You may also specify\n            the literal ``--OPT`` option instead of the \"dest\" option name.\n        :arg default: default value if no option of that name exists.\n        :arg skip: if True raise pytest.skip if option does not exists\n            or has a None value.\n        \"\"\"\n        name = self._opt2dest.get(name, name)\n        try:\n            val = getattr(self.option, name)\n            if val is None and skip:\n                raise AttributeError(name)\n            return val\n        except AttributeError:\n            if default is not notset:\n                return default\n            if skip:\n                import pytest\n\n                pytest.skip(\"no {!r} option found\".format(name))\n            raise ValueError(\"no option named {!r}\".format(name))\n\n    def getvalue(self, name, path=None):\n        \"\"\" (deprecated, use getoption()) \"\"\"\n        return self.getoption(name)\n\n    def getvalueorskip(self, name, path=None):\n        \"\"\" (deprecated, use getoption(skip=True)) \"\"\"\n        return self.getoption(name, skip=True)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__assertion_supported_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__assertion_supported_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1206, "end_line": 1262, "span_ids": ["_assertion_supported", "_strtobool", "_warn_about_missing_assertion", "create_terminal_writer"], "tokens": 428}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _assertion_supported():\n    try:\n        assert False\n    except AssertionError:\n        return True\n    else:\n        return False\n\n\ndef _warn_about_missing_assertion(mode):\n    if not _assertion_supported():\n        if mode == \"plain\":\n            sys.stderr.write(\n                \"WARNING: ASSERTIONS ARE NOT EXECUTED\"\n                \" and FAILING TESTS WILL PASS.  Are you\"\n                \" using python -O?\"\n            )\n        else:\n            sys.stderr.write(\n                \"WARNING: assertions not in test modules or\"\n                \" plugins will be ignored\"\n                \" because assert statements are not executed \"\n                \"by the underlying Python interpreter \"\n                \"(are you using python -O?)\\n\"\n            )\n\n\ndef create_terminal_writer(config: Config, *args, **kwargs) -> TerminalWriter:\n    \"\"\"Create a TerminalWriter instance configured according to the options\n    in the config object. Every code which requires a TerminalWriter object\n    and has access to a config object should use this function.\n    \"\"\"\n    tw = TerminalWriter(*args, **kwargs)\n    if config.option.color == \"yes\":\n        tw.hasmarkup = True\n    if config.option.color == \"no\":\n        tw.hasmarkup = False\n    return tw\n\n\ndef _strtobool(val):\n    \"\"\"Convert a string representation of truth to true (1) or false (0).\n\n    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n    'val' is anything else.\n\n    .. note:: copied from distutils.util\n    \"\"\"\n    val = val.lower()\n    if val in (\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"):\n        return 1\n    elif val in (\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"):\n        return 0\n    else:\n        raise ValueError(\"invalid truth value {!r}\".format(val))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Argument._set_opt_strings_Argument.__repr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Argument._set_opt_strings_Argument.__repr__", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 291, "end_line": 330, "span_ids": ["Argument.__repr__", "Argument._set_opt_strings"], "tokens": 354}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Argument:\n\n    def _set_opt_strings(self, opts: Sequence[str]) -> None:\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)\n\n    def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_OptionGroup_OptionGroup._addoption_instance": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_OptionGroup_OptionGroup._addoption_instance", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 333, "end_line": 369, "span_ids": ["OptionGroup", "OptionGroup.__init__", "OptionGroup._addoption", "OptionGroup._addoption_instance", "OptionGroup.addoption"], "tokens": 350}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class OptionGroup:\n    def __init__(\n        self, name: str, description: str = \"\", parser: Optional[Parser] = None\n    ) -> None:\n        self.name = name\n        self.description = description\n        self.options = []  # type: List[Argument]\n        self.parser = parser\n\n    def addoption(self, *optnames: str, **attrs: Any) -> None:\n        \"\"\" add an option to this group.\n\n        if a shortened version of a long option is specified it will\n        be suppressed in the help. addoption('--twowords', '--two-words')\n        results in help showing '--two-words' only, but --twowords gets\n        accepted **and** the automatic destination is in args.twowords\n        \"\"\"\n        conflict = set(optnames).intersection(\n            name for opt in self.options for name in opt.names()\n        )\n        if conflict:\n            raise ValueError(\"option names %s already added\" % conflict)\n        option = Argument(*optnames, **attrs)\n        self._addoption_instance(option, shortupper=False)\n\n    def _addoption(self, *optnames: str, **attrs: Any) -> None:\n        option = Argument(*optnames, **attrs)\n        self._addoption_instance(option, shortupper=True)\n\n    def _addoption_instance(self, option: \"Argument\", shortupper: bool = False) -> None:\n        if not shortupper:\n            for opt in option._short_opts:\n                if opt[0] == \"-\" and opt[1].islower():\n                    raise ValueError(\"lowercase shortoptions reserved\")\n        if self.parser:\n            self.parser.processoption(option)\n        self.options.append(option)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_DropShorterLongHelpFormatter_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_DropShorterLongHelpFormatter_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 459, "end_line": 512, "span_ids": ["DropShorterLongHelpFormatter", "DropShorterLongHelpFormatter.__init__", "DropShorterLongHelpFormatter._format_action_invocation"], "tokens": 533}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class DropShorterLongHelpFormatter(argparse.HelpFormatter):\n    \"\"\"shorten help for long options that differ only in extra hyphens\n\n    - collapse **long** options that are the same except for extra hyphens\n    - shortcut if there are only two options and one of them is a short one\n    - cache result on action object as this is called at least 2 times\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Use more accurate terminal width via pylib.\"\"\"\n        if \"width\" not in kwargs:\n            kwargs[\"width\"] = _pytest._io.get_terminal_width()\n        super().__init__(*args, **kwargs)\n\n    def _format_action_invocation(self, action: argparse.Action) -> str:\n        orgstr = argparse.HelpFormatter._format_action_invocation(self, action)\n        if orgstr and orgstr[0] != \"-\":  # only optional arguments\n            return orgstr\n        res = getattr(\n            action, \"_formatted_action_invocation\", None\n        )  # type: Optional[str]\n        if res:\n            return res\n        options = orgstr.split(\", \")\n        if len(options) == 2 and (len(options[0]) == 2 or len(options[1]) == 2):\n            # a shortcut for '-h, --help' or '--abc', '-a'\n            action._formatted_action_invocation = orgstr  # type: ignore\n            return orgstr\n        return_list = []\n        short_long = {}  # type: Dict[str, str]\n        for option in options:\n            if len(option) == 2 or option[2] == \" \":\n                continue\n            if not option.startswith(\"--\"):\n                raise ArgumentError(\n                    'long optional argument without \"--\": [%s]' % (option), option\n                )\n            xxoption = option[2:]\n            shortened = xxoption.replace(\"-\", \"\")\n            if shortened not in short_long or len(short_long[shortened]) < len(\n                xxoption\n            ):\n                short_long[shortened] = xxoption\n        # now short_long has been filled out to the longest with dashes\n        # **and** we keep the right option ordering from add_argument\n        for option in options:\n            if len(option) == 2 or option[2] == \" \":\n                return_list.append(option)\n            if option[2:] == short_long.get(option.replace(\"-\", \"\")):\n                return_list.append(option.replace(\" \", \"=\", 1))\n        formatted_action_invocation = \", \".join(return_list)\n        action._formatted_action_invocation = formatted_action_invocation  # type: ignore\n        return formatted_action_invocation", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/exceptions.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/exceptions.py__", "embedding": null, "metadata": {"file_path": "src/_pytest/config/exceptions.py", "file_name": "exceptions.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 10, "span_ids": ["PrintHelp", "UsageError"], "tokens": 41}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class UsageError(Exception):\n    \"\"\" error in pytest usage or invocation\"\"\"\n\n\nclass PrintHelp(Exception):\n    \"\"\"Raised when pytest should print it's help to skip the rest of the\n    argument parsing and validation.\"\"\"\n\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_determine_setup_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_determine_setup_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/findpaths.py", "file_name": "findpaths.py", "file_type": "text/x-python", "category": "implementation", "start_line": 114, "end_line": 168, "span_ids": ["determine_setup"], "tokens": 474}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def determine_setup(\n    inifile: Optional[str],\n    args: List[str],\n    rootdir_cmd_arg: Optional[str] = None,\n    config: Optional[\"Config\"] = None,\n) -> Tuple[py.path.local, Optional[str], Any]:\n    dirs = get_dirs_from_args(args)\n    if inifile:\n        iniconfig = py.iniconfig.IniConfig(inifile)\n        is_cfg_file = str(inifile).endswith(\".cfg\")\n        sections = [\"tool:pytest\", \"pytest\"] if is_cfg_file else [\"pytest\"]\n        for section in sections:\n            try:\n                inicfg = iniconfig[\n                    section\n                ]  # type: Optional[py.iniconfig._SectionWrapper]\n                if is_cfg_file and section == \"pytest\" and config is not None:\n                    fail(\n                        CFG_PYTEST_SECTION.format(filename=str(inifile)), pytrace=False\n                    )\n                break\n            except KeyError:\n                inicfg = None\n        if rootdir_cmd_arg is None:\n            rootdir = get_common_ancestor(dirs)\n    else:\n        ancestor = get_common_ancestor(dirs)\n        rootdir, inifile, inicfg = getcfg([ancestor], config=config)\n        if rootdir is None and rootdir_cmd_arg is None:\n            for possible_rootdir in ancestor.parts(reverse=True):\n                if possible_rootdir.join(\"setup.py\").exists():\n                    rootdir = possible_rootdir\n                    break\n            else:\n                if dirs != [ancestor]:\n                    rootdir, inifile, inicfg = getcfg(dirs, config=config)\n                if rootdir is None:\n                    if config is not None:\n                        cwd = config.invocation_dir\n                    else:\n                        cwd = py.path.local()\n                    rootdir = get_common_ancestor([cwd, ancestor])\n                    is_fs_root = os.path.splitdrive(str(rootdir))[1] == \"/\"\n                    if is_fs_root:\n                        rootdir = ancestor\n    if rootdir_cmd_arg:\n        rootdir = py.path.local(os.path.expandvars(rootdir_cmd_arg))\n        if not rootdir.isdir():\n            raise UsageError(\n                \"Directory '{}' not found. Check your '--rootdir' option.\".format(\n                    rootdir\n                )\n            )\n    return rootdir, inifile, inicfg or {}", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_PdbInvoke_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_PdbInvoke_", "embedding": null, "metadata": {"file_path": "src/_pytest/debugging.py", "file_name": "debugging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 257, "end_line": 351, "span_ids": ["PdbInvoke", "PdbInvoke.pytest_exception_interact", "PdbInvoke.pytest_internalerror", "PdbTrace", "PdbTrace.pytest_pyfunc_call", "_enter_pdb", "_postmortem_traceback", "maybe_wrap_pytest_function_for_tracing", "post_mortem", "wrap_pytest_function_for_tracing"], "tokens": 738}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PdbInvoke:\n    def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)\n\n    def pytest_internalerror(self, excrepr, excinfo):\n        tb = _postmortem_traceback(excinfo)\n        post_mortem(tb)\n\n\nclass PdbTrace:\n    @hookimpl(hookwrapper=True)\n    def pytest_pyfunc_call(self, pyfuncitem):\n        wrap_pytest_function_for_tracing(pyfuncitem)\n        yield\n\n\ndef wrap_pytest_function_for_tracing(pyfuncitem):\n    \"\"\"Changes the python function object of the given Function item by a wrapper which actually\n    enters pdb before calling the python function itself, effectively leaving the user\n    in the pdb prompt in the first statement of the function.\n    \"\"\"\n    _pdb = pytestPDB._init_pdb(\"runcall\")\n    testfunction = pyfuncitem.obj\n\n    # we can't just return `partial(pdb.runcall, testfunction)` because (on\n    # python < 3.7.4) runcall's first param is `func`, which means we'd get\n    # an exception if one of the kwargs to testfunction was called `func`\n    @functools.wraps(testfunction)\n    def wrapper(*args, **kwargs):\n        func = functools.partial(testfunction, *args, **kwargs)\n        _pdb.runcall(func)\n\n    pyfuncitem.obj = wrapper\n\n\ndef maybe_wrap_pytest_function_for_tracing(pyfuncitem):\n    \"\"\"Wrap the given pytestfunct item for tracing support if --trace was given in\n    the command line\"\"\"\n    if pyfuncitem.config.getvalue(\"trace\"):\n        wrap_pytest_function_for_tracing(pyfuncitem)\n\n\ndef _enter_pdb(node, excinfo, rep):\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True\n    post_mortem(tb)\n    return rep\n\n\ndef _postmortem_traceback(excinfo):\n    from doctest import UnexpectedException\n\n    if isinstance(excinfo.value, UnexpectedException):\n        # A doctest.UnexpectedException is not useful for post_mortem.\n        # Use the underlying exception instead:\n        return excinfo.value.exc_info[2]\n    else:\n        return excinfo._excinfo[2]\n\n\ndef post_mortem(t):\n    p = pytestPDB._init_pdb(\"post_mortem\")\n    p.reset()\n    p.interaction(None, t)\n    if p.quitting:\n        outcomes.exit(\"Quitting debugger\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_runner_class__get_runner": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_runner_class__get_runner", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 156, "end_line": 211, "span_ids": ["_get_runner", "_init_runner_class"], "tokens": 440}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _init_runner_class() -> \"Type[doctest.DocTestRunner]\":\n    import doctest\n\n    class PytestDoctestRunner(doctest.DebugRunner):\n        \"\"\"\n        Runner to collect failures.  Note that the out variable in this case is\n        a list instead of a stdout-like object\n        \"\"\"\n\n        def __init__(\n            self, checker=None, verbose=None, optionflags=0, continue_on_failure=True\n        ):\n            doctest.DebugRunner.__init__(\n                self, checker=checker, verbose=verbose, optionflags=optionflags\n            )\n            self.continue_on_failure = continue_on_failure\n\n        def report_failure(self, out, test, example, got):\n            failure = doctest.DocTestFailure(test, example, got)\n            if self.continue_on_failure:\n                out.append(failure)\n            else:\n                raise failure\n\n        def report_unexpected_exception(self, out, test, example, exc_info):\n            if isinstance(exc_info[1], OutcomeException):\n                raise exc_info[1]\n            if isinstance(exc_info[1], bdb.BdbQuit):\n                outcomes.exit(\"Quitting debugger\")\n            failure = doctest.UnexpectedException(test, example, exc_info)\n            if self.continue_on_failure:\n                out.append(failure)\n            else:\n                raise failure\n\n    return PytestDoctestRunner\n\n\ndef _get_runner(\n    checker: Optional[\"doctest.OutputChecker\"] = None,\n    verbose: Optional[bool] = None,\n    optionflags: int = 0,\n    continue_on_failure: bool = True,\n) -> \"doctest.DocTestRunner\":\n    # We need this in order to do a lazy import on doctest\n    global RUNNER_CLASS\n    if RUNNER_CLASS is None:\n        RUNNER_CLASS = _init_runner_class()\n    # Type ignored because the continue_on_failure argument is only defined on\n    # PytestDoctestRunner, which is lazily defined so can't be used as a type.\n    return RUNNER_CLASS(  # type: ignore\n        checker=checker,\n        verbose=verbose,\n        optionflags=optionflags,\n        continue_on_failure=continue_on_failure,\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestItem_DoctestItem._disable_output_capturing_for_darwin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestItem_DoctestItem._disable_output_capturing_for_darwin", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 214, "end_line": 261, "span_ids": ["DoctestItem", "DoctestItem.__init__", "DoctestItem._disable_output_capturing_for_darwin", "DoctestItem.from_parent", "DoctestItem.runtest", "DoctestItem.setup"], "tokens": 400}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class DoctestItem(pytest.Item):\n    def __init__(self, name, parent, runner=None, dtest=None):\n        super().__init__(name, parent)\n        self.runner = runner\n        self.dtest = dtest\n        self.obj = None\n        self.fixture_request = None\n\n    @classmethod\n    def from_parent(  # type: ignore\n        cls, parent: \"Union[DoctestTextfile, DoctestModule]\", *, name, runner, dtest\n    ):\n        # incompatible signature due to to imposed limits on sublcass\n        \"\"\"\n        the public named constructor\n        \"\"\"\n        return super().from_parent(name=name, parent=parent, runner=runner, dtest=dtest)\n\n    def setup(self):\n        if self.dtest is not None:\n            self.fixture_request = _setup_fixtures(self)\n            globs = dict(getfixture=self.fixture_request.getfixturevalue)\n            for name, value in self.fixture_request.getfixturevalue(\n                \"doctest_namespace\"\n            ).items():\n                globs[name] = value\n            self.dtest.globs.update(globs)\n\n    def runtest(self) -> None:\n        _check_all_skipped(self.dtest)\n        self._disable_output_capturing_for_darwin()\n        failures = []  # type: List[doctest.DocTestFailure]\n        self.runner.run(self.dtest, out=failures)\n        if failures:\n            raise MultipleDoctestFailures(failures)\n\n    def _disable_output_capturing_for_darwin(self):\n        \"\"\"\n        Disable output capturing. Otherwise, stdout is lost to doctest (#985)\n        \"\"\"\n        if platform.system() != \"Darwin\":\n            return\n        capman = self.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stderr.write(err)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestItem.repr_failure_DoctestItem.reportinfo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestItem.repr_failure_DoctestItem.reportinfo", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 263, "end_line": 326, "span_ids": ["DoctestItem.reportinfo", "DoctestItem.repr_failure"], "tokens": 529}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class DoctestItem(pytest.Item):\n\n    def repr_failure(self, excinfo):\n        import doctest\n\n        failures = (\n            None\n        )  # type: Optional[List[Union[doctest.DocTestFailure, doctest.UnexpectedException]]]\n        if excinfo.errisinstance((doctest.DocTestFailure, doctest.UnexpectedException)):\n            failures = [excinfo.value]\n        elif excinfo.errisinstance(MultipleDoctestFailures):\n            failures = excinfo.value.failures\n\n        if failures is not None:\n            reprlocation_lines = []\n            for failure in failures:\n                example = failure.example\n                test = failure.test\n                filename = test.filename\n                if test.lineno is None:\n                    lineno = None\n                else:\n                    lineno = test.lineno + example.lineno + 1\n                message = type(failure).__name__\n                reprlocation = ReprFileLocation(filename, lineno, message)\n                checker = _get_checker()\n                report_choice = _get_report_choice(\n                    self.config.getoption(\"doctestreport\")\n                )\n                if lineno is not None:\n                    assert failure.test.docstring is not None\n                    lines = failure.test.docstring.splitlines(False)\n                    # add line numbers to the left of the error message\n                    assert test.lineno is not None\n                    lines = [\n                        \"%03d %s\" % (i + test.lineno + 1, x)\n                        for (i, x) in enumerate(lines)\n                    ]\n                    # trim docstring error lines to 10\n                    lines = lines[max(example.lineno - 9, 0) : example.lineno + 1]\n                else:\n                    lines = [\n                        \"EXAMPLE LOCATION UNKNOWN, not showing all tests of that example\"\n                    ]\n                    indent = \">>>\"\n                    for line in example.source.splitlines():\n                        lines.append(\"??? {} {}\".format(indent, line))\n                        indent = \"...\"\n                if isinstance(failure, doctest.DocTestFailure):\n                    lines += checker.output_difference(\n                        example, failure.got, report_choice\n                    ).split(\"\\n\")\n                else:\n                    inner_excinfo = ExceptionInfo(failure.exc_info)\n                    lines += [\"UNEXPECTED EXCEPTION: %s\" % repr(inner_excinfo.value)]\n                    lines += [\n                        x.strip(\"\\n\")\n                        for x in traceback.format_exception(*failure.exc_info)\n                    ]\n                reprlocation_lines.append((reprlocation, lines))\n            return ReprFailDoctest(reprlocation_lines)\n        else:\n            return super().repr_failure(excinfo)\n\n    def reportinfo(self) -> Tuple[py.path.local, int, str]:\n        return self.fspath, self.dtest.lineno, \"[doctest] %s\" % self.name", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_add_funcarg_pseudo_fixture_def_add_funcarg_pseudo_fixture_def.for_argname_valuelist_in.if_node_and_argname_in_no": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_add_funcarg_pseudo_fixture_def_add_funcarg_pseudo_fixture_def.for_argname_valuelist_in.if_node_and_argname_in_no", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 113, "end_line": 168, "span_ids": ["add_funcarg_pseudo_fixture_def"], "tokens": 579}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:\n        return  # this function call does not have direct parametrization\n    # collect funcargs of all callspecs into a list of values\n    arg2params = {}\n    arg2scope = {}\n    for callspec in metafunc._calls:\n        for argname, argvalue in callspec.funcargs.items():\n            assert argname not in callspec.params\n            callspec.params[argname] = argvalue\n            arg2params_list = arg2params.setdefault(argname, [])\n            callspec.indices[argname] = len(arg2params_list)\n            arg2params_list.append(argvalue)\n            if argname not in arg2scope:\n                scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n                arg2scope[argname] = scopes[scopenum]\n        callspec.funcargs.clear()\n\n    # register artificial FixtureDef's so that later at test execution\n    # time we can rely on a proper FixtureDef to exist for fixture setup.\n    arg2fixturedefs = metafunc._arg2fixturedefs\n    for argname, valuelist in arg2params.items():\n        # if we have a scope that is higher than function we need\n        # to make sure we only ever create an according fixturedef on\n        # a per-scope basis. We thus store and cache the fixturedef on the\n        # node related to the scope.\n        scope = arg2scope[argname]\n        node = None\n        if scope != \"function\":\n            node = get_scope_node(collector, scope)\n            if node is None:\n                assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n                # use module-level collector for class-scope (for now)\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n                get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node is not None:\n                node._name2pseudofixturedef[argname] = fixturedef", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_getfixturemarker_get_parametrized_fixture_keys": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_getfixturemarker_get_parametrized_fixture_keys", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 171, "end_line": 205, "span_ids": ["get_parametrized_fixture_keys", "getfixturemarker"], "tokens": 326}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise errors like request (from flask import request)\n        # we don't expect them to be fixture functions\n        return None\n\n\ndef get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenum < scopenum_function  # function\n    try:\n        cs = item.callspec\n    except AttributeError:\n        pass\n    else:\n        # cs.indices.items() is random order of argnames.  Need to\n        # sort this so that different calls to\n        # get_parametrized_fixture_keys will be deterministic.\n        for argname, param_index in sorted(cs.indices.items()):\n            if cs._arg2scopenum[argname] != scopenum:\n                continue\n            if scopenum == 0:  # session\n                key = (argname, param_index)\n            elif scopenum == 1:  # package\n                key = (argname, param_index, item.fspath.dirpath())\n            elif scopenum == 2:  # module\n                key = (argname, param_index, item.fspath)\n            elif scopenum == 3:  # class\n                key = (argname, param_index, item.fspath, item.cls)\n            yield key", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py__algorithm_for_sorting_o_fix_cache_order": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py__algorithm_for_sorting_o_fix_cache_order", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 210, "end_line": 237, "span_ids": ["fix_cache_order", "impl:10", "reorder_items"], "tokens": 268}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# algorithm for sorting on a per-parametrized resource setup basis\n# it is called for scopenum==0 (session) first and performs sorting\n# down to the lower scopes such as to minimize number of \"high scope\"\n# setups and teardowns\n\n\ndef reorder_items(items):\n    argkeys_cache = {}\n    items_by_argkey = {}\n    for scopenum in range(0, scopenum_function):\n        argkeys_cache[scopenum] = d = {}\n        items_by_argkey[scopenum] = item_d = defaultdict(deque)\n        for item in items:\n            keys = order_preserving_dict.fromkeys(\n                get_parametrized_fixture_keys(item, scopenum)\n            )\n            if keys:\n                d[item] = keys\n                for key in keys:\n                    item_d[key].append(item)\n    items = order_preserving_dict.fromkeys(items)\n    return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))\n\n\ndef fix_cache_order(item, argkeys_cache, items_by_argkey):\n    for scopenum in range(0, scopenum_function):\n        for key in argkeys_cache[scopenum].get(item, []):\n            items_by_argkey[scopenum][key].appendleft(item)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FuncFixtureInfo_FuncFixtureInfo.prune_dependency_tree.self_names_closure_s": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FuncFixtureInfo_FuncFixtureInfo.prune_dependency_tree.self_names_closure_s", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 297, "end_line": 333, "span_ids": ["FuncFixtureInfo", "FuncFixtureInfo.prune_dependency_tree"], "tokens": 357}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(slots=True)\nclass FuncFixtureInfo:\n    # original function argument names\n    argnames = attr.ib(type=tuple)\n    # argnames that function immediately requires. These include argnames +\n    # fixture names specified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest._compute_fixture_value_FixtureRequest._compute_fixture_value.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest._compute_fixture_value_FixtureRequest._compute_fixture_value.None_1", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 524, "end_line": 592, "span_ids": ["FixtureRequest._compute_fixture_value"], "tokens": 589}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureRequest:\n\n    def _compute_fixture_value(self, fixturedef: \"FixtureDef\") -> None:\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = py.path.local(frameinfo.filename)\n                source_lineno = frameinfo.lineno\n                rel_source_path = source_path.relto(funcitem.config.rootdir)\n                if rel_source_path:\n                    source_path_str = rel_source_path\n                else:\n                    source_path_str = str(source_path)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path_str,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest._schedule_finalizers_FixtureRequest.__repr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest._schedule_finalizers_FixtureRequest.__repr__", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 594, "end_line": 641, "span_ids": ["FixtureRequest.__repr__", "FixtureRequest._check_scope", "FixtureRequest._factorytraceback", "FixtureRequest._getscopeitem", "FixtureRequest._schedule_finalizers"], "tokens": 432}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureRequest:\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_SubRequest_scope2index": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_SubRequest_scope2index", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 624, "end_line": 679, "span_ids": ["SubRequest", "SubRequest.__init__", "SubRequest.__repr__", "SubRequest._schedule_finalizers", "SubRequest.addfinalizer", "impl:12", "scope2index", "scopemismatch"], "tokens": 442}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class SubRequest(FixtureRequest):\n    \"\"\" a sub request for handling getting a fixture from a\n    test function/fixture. \"\"\"\n\n    def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager\n\n    def __repr__(self):\n        return \"<SubRequest {!r} for {!r}>\".format(self.fixturename, self._pyfuncitem)\n\n    def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.fixturenames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super()._schedule_finalizers(fixturedef, subrequest)\n\n\nscopes = \"session package module class function\".split()\nscopenum_function = scopes.index(\"function\")\n\n\ndef scopemismatch(currentscope, newscope):\n    return scopes.index(newscope) > scopes.index(currentscope)\n\n\ndef scope2index(scope, descr, where=None):\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\n    \"\"\"\n    try:\n        return scopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, \"from {} \".format(where) if where else \"\", scope\n            ),\n            pytrace=False,\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureLookupError_FixtureLookupError.formatrepr.return_FixtureLookupError": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureLookupError_FixtureLookupError.formatrepr.return_FixtureLookupError", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 702, "end_line": 753, "span_ids": ["FixtureLookupError", "FixtureLookupError.__init__", "FixtureLookupError.formatrepr"], "tokens": 468}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg\n\n    def formatrepr(self) -> \"FixtureLookupErrorRepr\":\n        tblines = []  # type: List[str]\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (OSError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file {}, line {}\".format(fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureLookupErrorRepr_FixtureLookupErrorRepr.toterminal": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureLookupErrorRepr_FixtureLookupErrorRepr.toterminal", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 756, "end_line": 780, "span_ids": ["FixtureLookupErrorRepr", "FixtureLookupErrorRepr.__init__", "FixtureLookupErrorRepr.toterminal"], "tokens": 217}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureDef.execute_FixtureDef.__repr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureDef.execute_FixtureDef.__repr__", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 900, "end_line": 933, "span_ids": ["FixtureDef.__repr__", "FixtureDef.cache_key", "FixtureDef.execute"], "tokens": 299}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureDef:\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = self.cache_key(request)\n        if self.cached_result is not None:\n            result, cache_key, err = self.cached_result\n            # note: comparison with `==` can fail (or be expensive) for e.g.\n            # numpy arrays (#6497)\n            if my_cache_key is cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert self.cached_result is None\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def cache_key(self, request):\n        return request.param_index if not hasattr(request, \"param\") else request.param\n\n    def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.getfixtureclosure_FixtureManager.getfixtureclosure.return_initialnames_fixt": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.getfixtureclosure_FixtureManager.getfixtureclosure.return_initialnames_fixt", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1198, "end_line": 1244, "span_ids": ["FixtureManager.getfixtureclosure"], "tokens": 367}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureManager:\n\n    def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.pytest_generate_tests_FixtureManager.pytest_collection_modifyitems": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.pytest_generate_tests_FixtureManager.pytest_collection_modifyitems", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1246, "end_line": 1278, "span_ids": ["FixtureManager.pytest_collection_modifyitems", "FixtureManager.pytest_generate_tests"], "tokens": 233}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureManager:\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.parsefactories_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.parsefactories_", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1401, "end_line": 1486, "span_ids": ["FixtureManager._matchfactories", "FixtureManager.getfixturedefs", "FixtureManager.parsefactories", "get_use_fixtures_for_node"], "tokens": 619}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureManager:\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        from _pytest import nodes\n\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef\n\n\ndef get_use_fixtures_for_node(node) -> Tuple[str, ...]:\n    \"\"\"Returns the names of all the usefixtures() marks on the given node\"\"\"\n    return tuple(\n        str(name)\n        for mark in node.iter_markers(name=\"usefixtures\")\n        for name in mark.args\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_pytest_addoption_pytest_addoption.None_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_pytest_addoption_pytest_addoption.None_5", "embedding": null, "metadata": {"file_path": "src/_pytest/helpconfig.py", "file_name": "helpconfig.py", "file_type": "text/x-python", "category": "implementation", "start_line": 39, "end_line": 84, "span_ids": ["pytest_addoption"], "tokens": 294}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_addoption(parser):\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--version\",\n        \"-V\",\n        action=\"store_true\",\n        help=\"display pytest version and information about plugins.\",\n    )\n    group._addoption(\n        \"-h\",\n        \"--help\",\n        action=HelpAction,\n        dest=\"help\",\n        help=\"show help message and configuration info\",\n    )\n    group._addoption(\n        \"-p\",\n        action=\"append\",\n        dest=\"plugins\",\n        default=[],\n        metavar=\"name\",\n        help=\"early-load given plugin module name or entry point (multi-allowed). \"\n        \"To avoid loading of plugins, use the `no:` prefix, e.g. \"\n        \"`no:doctest`.\",\n    )\n    group.addoption(\n        \"--traceconfig\",\n        \"--trace-config\",\n        action=\"store_true\",\n        default=False,\n        help=\"trace considerations of conftest.py files.\",\n    )\n    group.addoption(\n        \"--debug\",\n        action=\"store_true\",\n        dest=\"debug\",\n        default=False,\n        help=\"store internal tracing debug information in 'pytestdebug.log'.\",\n    )\n    group._addoption(\n        \"-o\",\n        \"--override-ini\",\n        dest=\"override_ini\",\n        action=\"append\",\n        help='override ini option with \"option=value\" style, e.g. `-o xfail_strict=True -o cache_dir=cache`.',\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_pytest_cmdline_parse_pytest_cmdline_main": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_pytest_cmdline_parse_pytest_cmdline_main", "embedding": null, "metadata": {"file_path": "src/_pytest/helpconfig.py", "file_name": "helpconfig.py", "file_type": "text/x-python", "category": "implementation", "start_line": 87, "end_line": 138, "span_ids": ["pytest_cmdline_main", "pytest_cmdline_parse", "showversion"], "tokens": 334}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.hookimpl(hookwrapper=True)\ndef pytest_cmdline_parse():\n    outcome = yield\n    config = outcome.get_result()\n    if config.option.debug:\n        path = os.path.abspath(\"pytestdebug.log\")\n        debugfile = open(path, \"w\")\n        debugfile.write(\n            \"versions pytest-%s, py-%s, \"\n            \"python-%s\\ncwd=%s\\nargs=%s\\n\\n\"\n            % (\n                pytest.__version__,\n                py.__version__,\n                \".\".join(map(str, sys.version_info)),\n                os.getcwd(),\n                config.invocation_params.args,\n            )\n        )\n        config.trace.root.setwriter(debugfile.write)\n        undo_tracing = config.pluginmanager.enable_tracing()\n        sys.stderr.write(\"writing pytestdebug information to %s\\n\" % path)\n\n        def unset_tracing():\n            debugfile.close()\n            sys.stderr.write(\"wrote pytestdebug information to %s\\n\" % debugfile.name)\n            config.trace.root.setwriter(None)\n            undo_tracing()\n\n        config.add_cleanup(unset_tracing)\n\n\ndef showversion(config):\n    sys.stderr.write(\n        \"This is pytest version {}, imported from {}\\n\".format(\n            pytest.__version__, pytest.__file__\n        )\n    )\n    plugininfo = getpluginversioninfo(config)\n    if plugininfo:\n        for line in plugininfo:\n            sys.stderr.write(line + \"\\n\")\n\n\ndef pytest_cmdline_main(config):\n    if config.option.version:\n        showversion(config)\n        return 0\n    elif config.option.help:\n        config._do_configure()\n        showhelp(config)\n        config._ensure_unconfigure()\n        return 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_showhelp_showhelp.return": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_showhelp_showhelp.return", "embedding": null, "metadata": {"file_path": "src/_pytest/helpconfig.py", "file_name": "helpconfig.py", "file_type": "text/x-python", "category": "implementation", "start_line": 139, "end_line": 206, "span_ids": ["showhelp"], "tokens": 516}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def showhelp(config):\n    import textwrap\n\n    reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n    tw = reporter._tw\n    tw.write(config._parser.optparser.format_help())\n    tw.line()\n    tw.line(\n        \"[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:\"\n    )\n    tw.line()\n\n    columns = tw.fullwidth  # costly call\n    indent_len = 24  # based on argparse's max_help_position=24\n    indent = \" \" * indent_len\n    for name in config._parser._ininames:\n        help, type, default = config._parser._inidict[name]\n        if type is None:\n            type = \"string\"\n        spec = \"{} ({}):\".format(name, type)\n        tw.write(\"  %s\" % spec)\n        spec_len = len(spec)\n        if spec_len > (indent_len - 3):\n            # Display help starting at a new line.\n            tw.line()\n            helplines = textwrap.wrap(\n                help,\n                columns,\n                initial_indent=indent,\n                subsequent_indent=indent,\n                break_on_hyphens=False,\n            )\n\n            for line in helplines:\n                tw.line(line)\n        else:\n            # Display help starting after the spec, following lines indented.\n            tw.write(\" \" * (indent_len - spec_len - 2))\n            wrapped = textwrap.wrap(help, columns - indent_len, break_on_hyphens=False)\n\n            tw.line(wrapped[0])\n            for line in wrapped[1:]:\n                tw.line(indent + line)\n\n    tw.line()\n    tw.line(\"environment variables:\")\n    vars = [\n        (\"PYTEST_ADDOPTS\", \"extra command line options\"),\n        (\"PYTEST_PLUGINS\", \"comma-separated plugins to load during startup\"),\n        (\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"set to disable plugin auto-loading\"),\n        (\"PYTEST_DEBUG\", \"set to enable debug tracing of pytest's internals\"),\n    ]\n    for name, help in vars:\n        tw.line(\"  {:<24} {}\".format(name, help))\n    tw.line()\n    tw.line()\n\n    tw.line(\"to see available markers type: pytest --markers\")\n    tw.line(\"to see available fixtures type: pytest --fixtures\")\n    tw.line(\n        \"(shown according to specified file_or_dir or current dir \"\n        \"if not specified; fixtures with leading '_' are only shown \"\n        \"with the '-v' option\"\n    )\n\n    for warningreport in reporter.stats.get(\"warnings\", []):\n        tw.line(\"warning : \" + warningreport.message, red=True)\n    return", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_conftest_options_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py_conftest_options_", "embedding": null, "metadata": {"file_path": "src/_pytest/helpconfig.py", "file_name": "helpconfig.py", "file_type": "text/x-python", "category": "implementation", "start_line": 209, "end_line": 245, "span_ids": ["getpluginversioninfo", "impl", "pytest_report_header"], "tokens": 250}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "conftest_options = [(\"pytest_plugins\", \"list of plugin names to load\")]\n\n\ndef getpluginversioninfo(config):\n    lines = []\n    plugininfo = config.pluginmanager.list_plugin_distinfo()\n    if plugininfo:\n        lines.append(\"setuptools registered plugins:\")\n        for plugin, dist in plugininfo:\n            loc = getattr(plugin, \"__file__\", repr(plugin))\n            content = \"{}-{} at {}\".format(dist.project_name, dist.version, loc)\n            lines.append(\"  \" + content)\n    return lines\n\n\ndef pytest_report_header(config):\n    lines = []\n    if config.option.debug or config.option.traceconfig:\n        lines.append(\n            \"using: pytest-{} pylib-{}\".format(pytest.__version__, py.__version__)\n        )\n\n        verinfo = getpluginversioninfo(config)\n        if verinfo:\n            lines.extend(verinfo)\n\n    if config.option.traceconfig:\n        lines.append(\"active plugins:\")\n        items = config.pluginmanager.list_name_plugin()\n        for name, plugin in items:\n            if hasattr(plugin, \"__file__\"):\n                r = plugin.__file__\n            else:\n                r = repr(plugin)\n            lines.append(\"    {:<20}: {}\".format(name, r))\n    return lines", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter__NodeReporter.record_testreport.self.attrs_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter__NodeReporter.record_testreport.self.attrs_6", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 84, "end_line": 147, "span_ids": ["_NodeReporter", "_NodeReporter.__init__", "_NodeReporter.add_attribute", "_NodeReporter.add_property", "_NodeReporter.append", "_NodeReporter.make_properties_node", "_NodeReporter.record_testreport"], "tokens": 421}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class _NodeReporter:\n    def __init__(self, nodeid, xml):\n        self.id = nodeid\n        self.xml = xml\n        self.add_stats = self.xml.add_stats\n        self.family = self.xml.family\n        self.duration = 0\n        self.properties = []\n        self.nodes = []\n        self.testcase = None\n        self.attrs = {}\n\n    def append(self, node):\n        self.xml.add_stats(type(node).__name__)\n        self.nodes.append(node)\n\n    def add_property(self, name, value):\n        self.properties.append((str(name), bin_xml_escape(value)))\n\n    def add_attribute(self, name, value):\n        self.attrs[str(name)] = bin_xml_escape(value)\n\n    def make_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.properties\n                ]\n            )\n        return \"\"\n\n    def record_testreport(self, testreport):\n        assert not self.testcase\n        names = mangle_test_address(testreport.nodeid)\n        existing_attrs = self.attrs\n        classnames = names[:-1]\n        if self.xml.prefix:\n            classnames.insert(0, self.xml.prefix)\n        attrs = {\n            \"classname\": \".\".join(classnames),\n            \"name\": bin_xml_escape(names[-1]),\n            \"file\": testreport.location[0],\n        }\n        if testreport.location[1] is not None:\n            attrs[\"line\"] = testreport.location[1]\n        if hasattr(testreport, \"url\"):\n            attrs[\"url\"] = testreport.url\n        self.attrs = attrs\n        self.attrs.update(existing_attrs)  # restore any user-defined attributes\n\n        # Preserve legacy testcase behavior\n        if self.family == \"xunit1\":\n            return\n\n        # Filter out attributes not permitted by this test family.\n        # Including custom attributes because they are not valid here.\n        temp_attrs = {}\n        for key in self.attrs.keys():\n            if key in families[self.family][\"testcase\"]:\n                temp_attrs[key] = self.attrs[key]\n        self.attrs = temp_attrs", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__warn_incompatibility_with_xunit2__check_record_param_type": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__warn_incompatibility_with_xunit2__check_record_param_type", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 263, "end_line": 333, "span_ids": ["_check_record_param_type", "_warn_incompatibility_with_xunit2", "record_property", "record_xml_attribute"], "tokens": 499}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _warn_incompatibility_with_xunit2(request, fixture_name):\n    \"\"\"Emits a PytestWarning about the given fixture being incompatible with newer xunit revisions\"\"\"\n    from _pytest.warning_types import PytestWarning\n\n    xml = request.config._store.get(xml_key, None)\n    if xml is not None and xml.family not in (\"xunit1\", \"legacy\"):\n        request.node.warn(\n            PytestWarning(\n                \"{fixture_name} is incompatible with junit_family '{family}' (use 'legacy' or 'xunit1')\".format(\n                    fixture_name=fixture_name, family=xml.family\n                )\n            )\n        )\n\n\n@pytest.fixture\ndef record_property(request):\n    \"\"\"Add an extra properties the calling test.\n    User properties become part of the test report and are available to the\n    configured reporters, like JUnit XML.\n    The fixture is callable with ``(name, value)``, with value being automatically\n    xml-encoded.\n\n    Example::\n\n        def test_function(record_property):\n            record_property(\"example_key\", 1)\n    \"\"\"\n    _warn_incompatibility_with_xunit2(request, \"record_property\")\n\n    def append_property(name, value):\n        request.node.user_properties.append((name, value))\n\n    return append_property\n\n\n@pytest.fixture\ndef record_xml_attribute(request):\n    \"\"\"Add extra xml attributes to the tag for the calling test.\n    The fixture is callable with ``(name, value)``, with value being\n    automatically xml-encoded\n    \"\"\"\n    from _pytest.warning_types import PytestExperimentalApiWarning\n\n    request.node.warn(\n        PytestExperimentalApiWarning(\"record_xml_attribute is an experimental feature\")\n    )\n\n    _warn_incompatibility_with_xunit2(request, \"record_xml_attribute\")\n\n    # Declare noop\n    def add_attr_noop(name, value):\n        pass\n\n    attr_func = add_attr_noop\n\n    xml = request.config._store.get(xml_key, None)\n    if xml is not None:\n        node_reporter = xml.node_reporter(request.node.nodeid)\n        attr_func = node_reporter.add_attribute\n\n    return attr_func\n\n\ndef _check_record_param_type(param, v):\n    \"\"\"Used by record_testsuite_property to check that the given parameter name is of the proper\n    type\"\"\"\n    __tracebackhide__ = True\n    if not isinstance(v, str):\n        msg = \"{param} parameter needs to be a string, but {g} given\"\n        raise TypeError(msg.format(param=param, g=type(v).__name__))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_record_testsuite_property_record_testsuite_property.return_record_func": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_record_testsuite_property_record_testsuite_property.return_record_func", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 336, "end_line": 363, "span_ids": ["record_testsuite_property"], "tokens": 240}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.fixture(scope=\"session\")\ndef record_testsuite_property(request):\n    \"\"\"\n    Records a new ``<property>`` tag as child of the root ``<testsuite>``. This is suitable to\n    writing global information regarding the entire test suite, and is compatible with ``xunit2`` JUnit family.\n\n    This is a ``session``-scoped fixture which is called with ``(name, value)``. Example:\n\n    .. code-block:: python\n\n        def test_foo(record_testsuite_property):\n            record_testsuite_property(\"ARCH\", \"PPC\")\n            record_testsuite_property(\"STORAGE_TYPE\", \"CEPH\")\n\n    ``name`` must be a string, ``value`` will be converted to a string and properly xml-escaped.\n    \"\"\"\n\n    __tracebackhide__ = True\n\n    def record_func(name, value):\n        \"\"\"noop function in case --junitxml was not passed in the command-line\"\"\"\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n\n    xml = request.config._store.get(xml_key, None)\n    if xml is not None:\n        record_func = xml.add_global_property  # noqa\n    return record_func", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_pytest_configure_mangle_test_address": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_pytest_configure_mangle_test_address", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 411, "end_line": 450, "span_ids": ["mangle_test_address", "pytest_configure", "pytest_unconfigure"], "tokens": 316}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_configure(config):\n    xmlpath = config.option.xmlpath\n    # prevent opening xmllog on slave nodes (xdist)\n    if xmlpath and not hasattr(config, \"slaveinput\"):\n        junit_family = config.getini(\"junit_family\")\n        if not junit_family:\n            _issue_warning_captured(deprecated.JUNIT_XML_DEFAULT_FAMILY, config.hook, 2)\n            junit_family = \"xunit1\"\n        config._store[xml_key] = LogXML(\n            xmlpath,\n            config.option.junitprefix,\n            config.getini(\"junit_suite_name\"),\n            config.getini(\"junit_logging\"),\n            config.getini(\"junit_duration_report\"),\n            junit_family,\n            config.getini(\"junit_log_passing_tests\"),\n        )\n        config.pluginmanager.register(config._store[xml_key])\n\n\ndef pytest_unconfigure(config):\n    xml = config._store.get(xml_key, None)\n    if xml:\n        del config._store[xml_key]\n        config.pluginmanager.unregister(xml)\n\n\ndef mangle_test_address(address):\n    path, possible_open_bracket, params = address.partition(\"[\")\n    names = path.split(\"::\")\n    try:\n        names.remove(\"()\")\n    except ValueError:\n        pass\n    # convert file path to dotted path\n    names[0] = names[0].replace(nodes.SEP, \".\")\n    names[0] = _py_ext_re.sub(\"\", names[0])\n    # put any params back\n    names[-1] += possible_open_bracket + params\n    return names", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML_LogXML._opentestcase": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML_LogXML._opentestcase", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 468, "end_line": 533, "span_ids": ["LogXML", "LogXML.__init__", "LogXML._opentestcase", "LogXML.add_stats", "LogXML.finalize", "LogXML.node_reporter"], "tokens": 449}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breaks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML.pytest_runtest_logreport_LogXML.pytest_runtest_logreport.if_report_when_teardo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML.pytest_runtest_logreport_LogXML.pytest_runtest_logreport.if_report_when_teardo", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 520, "end_line": 606, "span_ids": ["LogXML.pytest_runtest_logreport"], "tokens": 625}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LogXML:\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n                if not self.log_passing_tests:\n                    reporter.write_captured_output(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML.update_testcase_duration_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_LogXML.update_testcase_duration_", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 621, "end_line": 696, "span_ids": ["LogXML._get_global_properties_node", "LogXML.add_global_property", "LogXML.pytest_collectreport", "LogXML.pytest_internalerror", "LogXML.pytest_sessionfinish", "LogXML.pytest_sessionstart", "LogXML.pytest_terminal_summary", "LogXML.update_testcase_duration"], "tokens": 580}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LogXML:\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n            timestamp=datetime.fromtimestamp(self.suite_start_time).isoformat(),\n            hostname=platform.node(),\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_catching_logs_LogCaptureHandler.reset": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_catching_logs_LogCaptureHandler.reset", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 271, "end_line": 314, "span_ids": ["LogCaptureHandler", "LogCaptureHandler.__init__", "LogCaptureHandler.emit", "LogCaptureHandler.reset", "catching_logs"], "tokens": 280}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@contextmanager\ndef catching_logs(handler, formatter=None, level=None):\n    \"\"\"Context manager that prepares the whole logging machinery properly.\"\"\"\n    root_logger = logging.getLogger()\n\n    if formatter is not None:\n        handler.setFormatter(formatter)\n    if level is not None:\n        handler.setLevel(level)\n\n    # Adding the same handler twice would confuse logging system.\n    # Just don't do that.\n    add_new_handler = handler not in root_logger.handlers\n\n    if add_new_handler:\n        root_logger.addHandler(handler)\n    if level is not None:\n        orig_level = root_logger.level\n        root_logger.setLevel(min(orig_level, level))\n    try:\n        yield handler\n    finally:\n        if level is not None:\n            root_logger.setLevel(orig_level)\n        if add_new_handler:\n            root_logger.removeHandler(handler)\n\n\nclass LogCaptureHandler(logging.StreamHandler):\n    \"\"\"A logging handler that stores log records and the log text.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Creates a new log handler.\"\"\"\n        logging.StreamHandler.__init__(self, StringIO())\n        self.records = []  # type: List[logging.LogRecord]\n\n    def emit(self, record: logging.LogRecord) -> None:\n        \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n        self.records.append(record)\n        logging.StreamHandler.emit(self, record)\n\n    def reset(self) -> None:\n        self.records = []\n        self.stream = StringIO()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_caplog_pytest_configure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_caplog_pytest_configure", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 436, "end_line": 479, "span_ids": ["caplog", "get_log_level_for_setting", "impl:4", "pytest_configure"], "tokens": 331}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.fixture\ndef caplog(request):\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    yield result\n    result._finalize()\n\n\ndef get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:\n    for setting_name in setting_names:\n        log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return None\n\n    if isinstance(log_level, str):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin.set_log_path_LoggingPlugin._runtest_for": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin.set_log_path_LoggingPlugin._runtest_for", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 577, "end_line": 625, "span_ids": ["LoggingPlugin._log_cli_enabled", "LoggingPlugin._runtest_for", "LoggingPlugin.pytest_collection", "LoggingPlugin.set_log_path"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LoggingPlugin:\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self) -> Generator[None, None, None]:\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin._runtest_for_main_LoggingPlugin._runtest_for_main.with_catching_logs_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin._runtest_for_main_LoggingPlugin._runtest_for_main.with_catching_logs_", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 627, "end_line": 656, "span_ids": ["LoggingPlugin._runtest_for_main"], "tokens": 293}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LoggingPlugin:\n\n    @contextmanager\n    def _runtest_for_main(\n        self, item: nodes.Item, when: str\n    ) -> Generator[None, None, None]:\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}  # type: ignore[attr-defined]  # noqa: F821\n            item.catch_log_handlers[when] = log_handler  # type: ignore[attr-defined]  # noqa: F821\n            item.catch_log_handler = log_handler  # type: ignore[attr-defined]  # noqa: F821\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler  # type: ignore[attr-defined]  # noqa: F821\n                    del item.catch_log_handlers  # type: ignore[attr-defined]  # noqa: F821\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin.pytest_runtest_setup_LoggingPlugin.pytest_runtestloop": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin.pytest_runtest_setup_LoggingPlugin.pytest_runtestloop", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 563, "end_line": 641, "span_ids": ["LoggingPlugin.pytest_runtest_call", "LoggingPlugin.pytest_runtest_logfinish", "LoggingPlugin.pytest_runtest_logreport", "LoggingPlugin.pytest_runtest_logstart", "LoggingPlugin.pytest_runtest_setup", "LoggingPlugin.pytest_runtest_teardown", "LoggingPlugin.pytest_runtestloop", "LoggingPlugin.pytest_sessionfinish", "LoggingPlugin.pytest_sessionstart"], "tokens": 544}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LoggingPlugin:\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n\n        if session.config.option.collectonly:\n            yield\n            return\n\n        if self._log_cli_enabled() and self._config.getoption(\"verbose\") < 1:\n            # setting verbose flag is needed to avoid messy test progress output\n            self._config.option.verbose = 1\n\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py__LiveLoggingStreamHandler_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py__LiveLoggingStreamHandler_", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 644, "end_line": 693, "span_ids": ["_LiveLoggingStreamHandler", "_LiveLoggingStreamHandler.__init__", "_LiveLoggingStreamHandler.emit", "_LiveLoggingStreamHandler.reset", "_LiveLoggingStreamHandler.set_when"], "tokens": 398}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class _LiveLoggingStreamHandler(logging.StreamHandler):\n    \"\"\"\n    Custom StreamHandler used by the live logging feature: it will write a newline before the first log message\n    in each test.\n\n    During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured\n    and won't appear in the terminal.\n    \"\"\"\n\n    def __init__(self, terminal_reporter, capture_manager):\n        \"\"\"\n        :param _pytest.terminal.TerminalReporter terminal_reporter:\n        :param _pytest.capture.CaptureManager capture_manager:\n        \"\"\"\n        logging.StreamHandler.__init__(self, stream=terminal_reporter)\n        self.capture_manager = capture_manager\n        self.reset()\n        self.set_when(None)\n        self._test_outcome_written = False\n\n    def reset(self):\n        \"\"\"Reset the handler; should be called before the start of each test\"\"\"\n        self._first_record_emitted = False\n\n    def set_when(self, when):\n        \"\"\"Prepares for the given test phase (setup/call/teardown)\"\"\"\n        self._when = when\n        self._section_name_shown = False\n        if when == \"start\":\n            self._test_outcome_written = False\n\n    def emit(self, record):\n        ctx_manager = (\n            self.capture_manager.global_and_fixture_disabled()\n            if self.capture_manager\n            else nullcontext()\n        )\n        with ctx_manager:\n            if not self._first_record_emitted:\n                self.stream.write(\"\\n\")\n                self._first_record_emitted = True\n            elif self._when in (\"teardown\", \"finish\"):\n                if not self._test_outcome_written:\n                    self._test_outcome_written = True\n                    self.stream.write(\"\\n\")\n            if not self._section_name_shown and self._when:\n                self.stream.section(\"live log \" + self._when, sep=\"-\", bold=True)\n                self._section_name_shown = True\n            logging.StreamHandler.emit(self, record)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_cmdline_main__in_venv": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_cmdline_main__in_venv", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 239, "end_line": 294, "span_ids": ["_in_venv", "_main", "pytest_cmdline_main", "pytest_collection", "pytest_runtestloop"], "tokens": 402}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_cmdline_main(config):\n    return wrap_session(config, _main)\n\n\ndef _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates for fname in bindir.listdir()])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session_Session.perform_collect": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session_Session.perform_collect", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 368, "end_line": 460, "span_ids": ["Session", "Session.__init__", "Session.__repr__", "Session._node_location_to_relpath", "Session.from_config", "Session.gethookproxy", "Session.isinitpath", "Session.perform_collect", "Session.pytest_collectstart", "Session.pytest_runtest_logreport", "Session:7"], "tokens": 746}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._perform_collect_Session.collect": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._perform_collect_Session.collect", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 462, "end_line": 509, "span_ids": ["Session._perform_collect", "Session.collect"], "tokens": 415}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Session(nodes.FSCollector):\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._matchnodes_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._matchnodes_", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 637, "end_line": 686, "span_ids": ["Session._matchnodes", "Session.genitems"], "tokens": 404}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Session(nodes.FSCollector):\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py_pytest_addoption_pytest_addoption.parser_addini_EMPTY_PARAM": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py_pytest_addoption_pytest_addoption.parser_addini_EMPTY_PARAM", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 44, "end_line": 83, "span_ids": ["pytest_addoption"], "tokens": 345}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywords are matched to classes and functions \"\n        \"containing extra names in their 'extra_keyword_matches' set, \"\n        \"as well as functions which have names assigned directly to them. \"\n        \"The matching is case-insensitive.\",\n    )\n\n    group._addoption(\n        \"-m\",\n        action=\"store\",\n        dest=\"markexpr\",\n        default=\"\",\n        metavar=\"MARKEXPR\",\n        help=\"only run tests matching given mark expression.  \"\n        \"example: -m 'mark1 and not mark2'.\",\n    )\n\n    group.addoption(\n        \"--markers\",\n        action=\"store_true\",\n        help=\"show markers (builtin, plugin and per-project ones).\",\n    )\n\n    parser.addini(\"markers\", \"markers for test functions\", \"linelist\")\n    parser.addini(EMPTY_PARAMETERSET_OPTION, \"default marker for empty parametersets\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py_pytest_cmdline_main_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py_pytest_cmdline_main_", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 86, "end_line": 169, "span_ids": ["deselect_by_keyword", "deselect_by_mark", "pytest_cmdline_main", "pytest_collection_modifyitems", "pytest_configure", "pytest_unconfigure"], "tokens": 528}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookimpl(tryfirst=True)\ndef pytest_cmdline_main(config):\n    import _pytest.config\n\n    if config.option.markers:\n        config._do_configure()\n        tw = _pytest.config.create_terminal_writer(config)\n        for line in config.getini(\"markers\"):\n            parts = line.split(\":\", 1)\n            name = parts[0]\n            rest = parts[1] if len(parts) == 2 else \"\"\n            tw.write(\"@pytest.mark.%s:\" % name, bold=True)\n            tw.line(rest)\n            tw.line()\n        config._ensure_unconfigure()\n        return 0\n\n\ndef deselect_by_keyword(items, config):\n    keywordexpr = config.option.keyword.lstrip()\n    if not keywordexpr:\n        return\n\n    if keywordexpr.startswith(\"-\"):\n        keywordexpr = \"not \" + keywordexpr[1:]\n    selectuntil = False\n    if keywordexpr[-1:] == \":\":\n        selectuntil = True\n        keywordexpr = keywordexpr[:-1]\n\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if keywordexpr and not matchkeyword(colitem, keywordexpr):\n            deselected.append(colitem)\n        else:\n            if selectuntil:\n                keywordexpr = None\n            remaining.append(colitem)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\ndef deselect_by_mark(items, config):\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    remaining = []\n    deselected = []\n    for item in items:\n        if matchmark(item, matchexpr):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\ndef pytest_collection_modifyitems(items, config):\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)\n\n\ndef pytest_configure(config):\n    config._store[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageError(\n            \"{!s} must be one of skip, xfail or fail_at_collect\"\n            \" but it is {!r}\".format(EMPTY_PARAMETERSET_OPTION, empty_parameterset)\n        )\n\n\ndef pytest_unconfigure(config):\n    MARK_GEN._config = config._store.get(old_mark_config_key, None)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/evaluate.py_MarkEvaluator._istrue_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/evaluate.py_MarkEvaluator._istrue_", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/evaluate.py", "file_name": "evaluate.py", "file_type": "text/x-python", "category": "implementation", "start_line": 71, "end_line": 124, "span_ids": ["MarkEvaluator._istrue", "MarkEvaluator.get", "MarkEvaluator.getexplanation"], "tokens": 321}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MarkEvaluator:\n\n    def _istrue(self):\n        if hasattr(self, \"result\"):\n            return self.result\n        self._marks = self._get_marks()\n\n        if self._marks:\n            self.result = False\n            for mark in self._marks:\n                self._mark = mark\n                if \"condition\" in mark.kwargs:\n                    args = (mark.kwargs[\"condition\"],)\n                else:\n                    args = mark.args\n\n                for expr in args:\n                    self.expr = expr\n                    if isinstance(expr, str):\n                        d = self._getglobals()\n                        result = cached_eval(self.item.config, expr, d)\n                    else:\n                        if \"reason\" not in mark.kwargs:\n                            # XXX better be checked at collection time\n                            msg = (\n                                \"you need to specify reason=STRING \"\n                                \"when using booleans as conditions.\"\n                            )\n                            fail(msg)\n                        result = bool(expr)\n                    if result:\n                        self.result = True\n                        self.reason = mark.kwargs.get(\"reason\", None)\n                        self.expr = expr\n                        return self.result\n\n                if not args:\n                    self.result = True\n                    self.reason = mark.kwargs.get(\"reason\", None)\n                    return self.result\n        return False\n\n    def get(self, attr, default=None):\n        if self._mark is None:\n            return default\n        return self._mark.kwargs.get(attr, default)\n\n    def getexplanation(self):\n        expl = getattr(self, \"reason\", None) or self.get(\"reason\", None)\n        if not expl:\n            if not hasattr(self, \"expr\"):\n                return \"\"\n            else:\n                return \"condition: \" + str(self.expr)\n        return expl", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MarkDecorator_MarkDecorator.__call__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MarkDecorator_MarkDecorator.__call__", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 192, "end_line": 271, "span_ids": ["MarkDecorator", "MarkDecorator.__call__", "MarkDecorator.__repr__", "MarkDecorator.args", "MarkDecorator.kwargs", "MarkDecorator.markname", "MarkDecorator.name", "MarkDecorator.with_args"], "tokens": 602}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n\n    MarkDecorators are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a MarkDecorator is called it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       MarkDecorator.\n\n    3. When called in any other case, it returns a new MarkDecorator instance\n       with the original MarkDecorator's content updated with the arguments\n       passed to this call.\n\n    Note: The rules above prevent MarkDecorators from storing only a single\n    function or class reference as their positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    \"\"\"\n\n    mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name\n\n    @property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args\n\n    @property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs\n\n    @property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)\n\n    def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)\n\n    def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))\n\n    def __call__(self, *args: object, **kwargs: object):\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_get_unpacked_marks_store_mark": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_get_unpacked_marks_store_mark", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 274, "end_line": 308, "span_ids": ["get_unpacked_marks", "normalize_mark_list", "store_mark"], "tokens": 274}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def get_unpacked_marks(obj):\n    \"\"\"\n    obtain the unpacked marks that are stored on an object\n    \"\"\"\n    mark_list = getattr(obj, \"pytestmark\", [])\n    if not isinstance(mark_list, list):\n        mark_list = [mark_list]\n    return normalize_mark_list(mark_list)\n\n\ndef normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:\n    \"\"\"\n    normalizes marker decorating helpers to mark objects\n\n    :type mark_list: List[Union[Mark, Markdecorator]]\n    :rtype: List[Mark]\n    \"\"\"\n    extracted = [\n        getattr(mark, \"mark\", mark) for mark in mark_list\n    ]  # unpack MarkDecorator\n    for mark in extracted:\n        if not isinstance(mark, Mark):\n            raise TypeError(\"got {!r} instead of Mark\".format(mark))\n    return [x for x in extracted if isinstance(x, Mark)]\n\n\ndef store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MarkGenerator_MarkGenerator.__getattr__.return_MarkDecorator_Mark": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MarkGenerator_MarkGenerator.__getattr__.return_MarkDecorator_Mark", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 311, "end_line": 367, "span_ids": ["MarkGenerator", "MarkGenerator.__getattr__"], "tokens": 480}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"\n\n    _config = None\n    _markers = set()  # type: Set[str]\n\n    def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/latest/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MARK_GEN_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_MARK_GEN_", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 370, "end_line": 408, "span_ids": ["NodeKeywords", "NodeKeywords.__delitem__", "NodeKeywords.__getitem__", "NodeKeywords.__init__", "NodeKeywords.__iter__", "NodeKeywords.__len__", "NodeKeywords.__repr__", "NodeKeywords.__setitem__", "NodeKeywords._seen", "impl:2"], "tokens": 205}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "MARK_GEN = MarkGenerator()\n\n\nclass NodeKeywords(MutableMapping):\n    def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}\n\n    def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]\n\n    def __setitem__(self, key, value):\n        self._markers[key] = value\n\n    def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")\n\n    def __iter__(self):\n        seen = self._seen()\n        return iter(seen)\n\n    def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen\n\n    def __len__(self):\n        return len(self._seen())\n\n    def __repr__(self):\n        return \"<NodeKeywords for node {}>\".format(self.node)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch_MonkeyPatch.context": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch_MonkeyPatch.context", "embedding": null, "metadata": {"file_path": "src/_pytest/monkeypatch.py", "file_name": "monkeypatch.py", "file_type": "text/x-python", "category": "implementation", "start_line": 101, "end_line": 134, "span_ids": ["MonkeyPatch", "MonkeyPatch.__init__", "MonkeyPatch.context"], "tokens": 240}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MonkeyPatch:\n    \"\"\" Object returned by the ``monkeypatch`` fixture keeping a record of setattr/item/env/syspath changes.\n    \"\"\"\n\n    def __init__(self):\n        self._setattr = []\n        self._setitem = []\n        self._cwd = None\n        self._savesyspath = None\n\n    @contextmanager\n    def context(self) -> Generator[\"MonkeyPatch\", None, None]:\n        \"\"\"\n        Context manager that returns a new :class:`MonkeyPatch` object which\n        undoes any patching done inside the ``with`` block upon exit:\n\n        .. code-block:: python\n\n            import functools\n\n\n            def test_partial(monkeypatch):\n                with monkeypatch.context() as m:\n                    m.setattr(functools, \"partial\", 3)\n\n        Useful in situations where it is desired to undo some patches before the test ends,\n        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples\n        of this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.\n        \"\"\"\n        m = MonkeyPatch()\n        try:\n            yield m\n        finally:\n            m.undo()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.setattr_MonkeyPatch.setattr.setattr_target_name_val": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.setattr_MonkeyPatch.setattr.setattr_target_name_val", "embedding": null, "metadata": {"file_path": "src/_pytest/monkeypatch.py", "file_name": "monkeypatch.py", "file_type": "text/x-python", "category": "implementation", "start_line": 133, "end_line": 168, "span_ids": ["MonkeyPatch.setattr"], "tokens": 307}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MonkeyPatch:\n\n    def setattr(self, target, name, value=notset, raising=True):\n        \"\"\" Set attribute value on target, memorizing the old value.\n        By default raise AttributeError if the attribute did not exist.\n\n        For convenience you can specify a string as ``target`` which\n        will be interpreted as a dotted import path, with the last part\n        being the attribute name.  Example:\n        ``monkeypatch.setattr(\"os.getcwd\", lambda: \"/\")``\n        would set the ``getcwd`` function of the ``os`` module.\n\n        The ``raising`` value determines if the setattr should fail\n        if the attribute is not already present (defaults to True\n        which means it will raise).\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if value is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use setattr(target, name, value) or \"\n                    \"setattr(target, value) with target being a dotted \"\n                    \"import string\"\n                )\n            value = name\n            name, target = derive_importpath(target, raising)\n\n        oldval = getattr(target, name, notset)\n        if raising and oldval is notset:\n            raise AttributeError(\"{!r} has no attribute {!r}\".format(target, name))\n\n        # avoid class descriptors like staticmethod/classmethod\n        if inspect.isclass(target):\n            oldval = target.__dict__.get(name, notset)\n        self._setattr.append((target, name, oldval))\n        setattr(target, name, value)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.delattr_MonkeyPatch.delattr.if_not_hasattr_target_na": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.delattr_MonkeyPatch.delattr.if_not_hasattr_target_na", "embedding": null, "metadata": {"file_path": "src/_pytest/monkeypatch.py", "file_name": "monkeypatch.py", "file_type": "text/x-python", "category": "implementation", "start_line": 170, "end_line": 202, "span_ids": ["MonkeyPatch.delattr"], "tokens": 253}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MonkeyPatch:\n\n    def delattr(self, target, name=notset, raising=True):\n        \"\"\" Delete attribute ``name`` from ``target``, by default raise\n        AttributeError it the attribute did not previously exist.\n\n        If no ``name`` is specified and ``target`` is a string\n        it will be interpreted as a dotted import path with the\n        last part being the attribute name.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        attribute is missing.\n        \"\"\"\n        __tracebackhide__ = True\n        import inspect\n\n        if name is notset:\n            if not isinstance(target, str):\n                raise TypeError(\n                    \"use delattr(target, name) or \"\n                    \"delattr(target) with target being a dotted \"\n                    \"import string\"\n                )\n            name, target = derive_importpath(target, raising)\n\n        if not hasattr(target, name):\n            if raising:\n                raise AttributeError(name)\n        else:\n            oldval = getattr(target, name, notset)\n            # Avoid class descriptors like staticmethod/classmethod.\n            if inspect.isclass(target):\n                oldval = target.__dict__.get(name, notset)\n            self._setattr.append((target, name, oldval))\n            delattr(target, name)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.setitem_MonkeyPatch.delenv": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.setitem_MonkeyPatch.delenv", "embedding": null, "metadata": {"file_path": "src/_pytest/monkeypatch.py", "file_name": "monkeypatch.py", "file_type": "text/x-python", "category": "implementation", "start_line": 204, "end_line": 248, "span_ids": ["MonkeyPatch.delenv", "MonkeyPatch.delitem", "MonkeyPatch.setenv", "MonkeyPatch.setitem"], "tokens": 388}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MonkeyPatch:\n\n    def setitem(self, dic, name, value):\n        \"\"\" Set dictionary entry ``name`` to value. \"\"\"\n        self._setitem.append((dic, name, dic.get(name, notset)))\n        dic[name] = value\n\n    def delitem(self, dic, name, raising=True):\n        \"\"\" Delete ``name`` from dict. Raise KeyError if it doesn't exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        key is missing.\n        \"\"\"\n        if name not in dic:\n            if raising:\n                raise KeyError(name)\n        else:\n            self._setitem.append((dic, name, dic.get(name, notset)))\n            del dic[name]\n\n    def setenv(self, name, value, prepend=None):\n        \"\"\" Set environment variable ``name`` to ``value``.  If ``prepend``\n        is a character, read the current environment variable value\n        and prepend the ``value`` adjoined with the ``prepend`` character.\"\"\"\n        if not isinstance(value, str):\n            warnings.warn(\n                pytest.PytestWarning(\n                    \"Value of environment variable {name} type should be str, but got \"\n                    \"{value!r} (type: {type}); converted to str implicitly\".format(\n                        name=name, value=value, type=type(value).__name__\n                    )\n                ),\n                stacklevel=2,\n            )\n            value = str(value)\n        if prepend and name in os.environ:\n            value = value + prepend + os.environ[name]\n        self.setitem(os.environ, name, value)\n\n    def delenv(self, name, raising=True):\n        \"\"\" Delete ``name`` from the environment. Raise KeyError if it does\n        not exist.\n\n        If ``raising`` is set to False, no exception will be raised if the\n        environment variable is missing.\n        \"\"\"\n        self.delitem(os.environ, name, raising=raising)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.syspath_prepend_MonkeyPatch.chdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.syspath_prepend_MonkeyPatch.chdir", "embedding": null, "metadata": {"file_path": "src/_pytest/monkeypatch.py", "file_name": "monkeypatch.py", "file_type": "text/x-python", "category": "implementation", "start_line": 253, "end_line": 287, "span_ids": ["MonkeyPatch.chdir", "MonkeyPatch.syspath_prepend"], "tokens": 304}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MonkeyPatch:\n\n    def syspath_prepend(self, path):\n        \"\"\" Prepend ``path`` to ``sys.path`` list of import locations. \"\"\"\n        from pkg_resources import fixup_namespace_packages\n\n        if self._savesyspath is None:\n            self._savesyspath = sys.path[:]\n        sys.path.insert(0, str(path))\n\n        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171\n        fixup_namespace_packages(str(path))\n\n        # A call to syspathinsert() usually means that the caller wants to\n        # import some dynamically created files, thus with python3 we\n        # invalidate its import caches.\n        # This is especially important when any namespace package is in use,\n        # since then the mtime based FileFinder cache (that gets created in\n        # this case already) gets not invalidated when writing the new files\n        # quickly afterwards.\n        from importlib import invalidate_caches\n\n        invalidate_caches()\n\n    def chdir(self, path):\n        \"\"\" Change the current working directory to the specified path.\n        Path can be a string or a py.path.local object.\n        \"\"\"\n        if self._cwd is None:\n            self._cwd = os.getcwd()\n        if hasattr(path, \"chdir\"):\n            path.chdir()\n        elif isinstance(path, Path):\n            # modern python uses the fspath protocol here LEGACY\n            os.chdir(str(path))\n        else:\n            os.chdir(path)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.undo_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py_MonkeyPatch.undo_", "embedding": null, "metadata": {"file_path": "src/_pytest/monkeypatch.py", "file_name": "monkeypatch.py", "file_type": "text/x-python", "category": "implementation", "start_line": 286, "end_line": 322, "span_ids": ["MonkeyPatch.undo"], "tokens": 287}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MonkeyPatch:\n\n    def undo(self):\n        \"\"\" Undo previous changes.  This call consumes the\n        undo stack. Calling it a second time has no effect unless\n        you do more monkeypatching after the undo call.\n\n        There is generally no need to call `undo()`, since it is\n        called automatically during tear-down.\n\n        Note that the same `monkeypatch` fixture is used across a\n        single test function invocation. If `monkeypatch` is used both by\n        the test function itself and one of the test fixtures,\n        calling `undo()` will undo all of the changes made in\n        both functions.\n        \"\"\"\n        for obj, name, value in reversed(self._setattr):\n            if value is not notset:\n                setattr(obj, name, value)\n            else:\n                delattr(obj, name)\n        self._setattr[:] = []\n        for dictionary, name, value in reversed(self._setitem):\n            if value is notset:\n                try:\n                    del dictionary[name]\n                except KeyError:\n                    pass  # was already deleted, so we have the desired state\n            else:\n                dictionary[name] = value\n        self._setitem[:] = []\n        if self._savesyspath is not None:\n            sys.path[:] = self._savesyspath\n            self._savesyspath = None\n\n        if self._cwd is not None:\n            os.chdir(self._cwd)\n            self._cwd = None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node._repr_failure_py_Node.repr_failure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node._repr_failure_py_Node.repr_failure", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 333, "end_line": 385, "span_ids": ["Node._repr_failure_py", "Node.repr_failure"], "tokens": 413}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Node(metaclass=NodeMeta):\n\n    def _repr_failure_py(\n        self, excinfo: ExceptionInfo[Union[Failed, FixtureLookupError]], style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(\n        self, excinfo, style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_fnmatch_ex_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_fnmatch_ex_", "embedding": null, "metadata": {"file_path": "src/_pytest/pathlib.py", "file_name": "pathlib.py", "file_type": "text/x-python", "category": "implementation", "start_line": 330, "end_line": 368, "span_ids": ["fnmatch_ex", "parts"], "tokens": 341}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def fnmatch_ex(pattern: str, path) -> bool:\n    \"\"\"FNMatcher port from py.path.common which works with PurePath() instances.\n\n    The difference between this algorithm and PurePath.match() is that the latter matches \"**\" glob expressions\n    for each part of the path, while this algorithm uses the whole path instead.\n\n    For example:\n        \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\" with this algorithm, but not with\n        PurePath.match().\n\n    This algorithm was ported to keep backward-compatibility with existing settings which assume paths match according\n    this logic.\n\n    References:\n    * https://bugs.python.org/issue29249\n    * https://bugs.python.org/issue34731\n    \"\"\"\n    path = PurePath(path)\n    iswin32 = sys.platform.startswith(\"win\")\n\n    if iswin32 and sep not in pattern and posix_sep in pattern:\n        # Running on Windows, the pattern has no Windows path separators,\n        # and the pattern has one or more Posix path separators. Replace\n        # the Posix path separators with the Windows path separator.\n        pattern = pattern.replace(posix_sep, sep)\n\n    if sep not in pattern:\n        name = path.name\n    else:\n        name = str(path)\n        if path.is_absolute() and not os.path.isabs(pattern):\n            pattern = \"*{}{}\".format(os.sep, pattern)\n    return fnmatch.fnmatch(name, pattern)\n\n\ndef parts(s: str) -> Set[str]:\n    parts = s.split(sep)\n    return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LsofFdLeakChecker_LsofFdLeakChecker.matching_platform": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LsofFdLeakChecker_LsofFdLeakChecker.matching_platform", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 70, "end_line": 113, "span_ids": ["LsofFdLeakChecker", "LsofFdLeakChecker._exec_lsof", "LsofFdLeakChecker._parse_lsof_output", "LsofFdLeakChecker.get_open_files", "LsofFdLeakChecker.matching_platform"], "tokens": 296}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LsofFdLeakChecker:\n    def get_open_files(self):\n        out = self._exec_lsof()\n        open_files = self._parse_lsof_output(out)\n        return open_files\n\n    def _exec_lsof(self):\n        pid = os.getpid()\n        # py3: use subprocess.DEVNULL directly.\n        with open(os.devnull, \"wb\") as devnull:\n            return subprocess.check_output(\n                (\"lsof\", \"-Ffn0\", \"-p\", str(pid)), stderr=devnull\n            ).decode()\n\n    def _parse_lsof_output(self, out):\n        def isopen(line):\n            return line.startswith(\"f\") and (\n                \"deleted\" not in line\n                and \"mem\" not in line\n                and \"txt\" not in line\n                and \"cwd\" not in line\n            )\n\n        open_files = []\n\n        for line in out.split(\"\\n\"):\n            if isopen(line):\n                fields = line.split(\"\\0\")\n                fd = fields[0][1:]\n                filename = fields[1][1:]\n                if filename in IGNORE_PAM:\n                    continue\n                if filename.startswith(\"/\"):\n                    open_files.append((fd, filename))\n\n        return open_files\n\n    def matching_platform(self):\n        try:\n            subprocess.check_output((\"lsof\", \"-v\"))\n        except (OSError, subprocess.CalledProcessError):\n            return False\n        else:\n            return True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LsofFdLeakChecker.pytest_runtest_protocol_LsofFdLeakChecker.pytest_runtest_protocol": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LsofFdLeakChecker.pytest_runtest_protocol_LsofFdLeakChecker.pytest_runtest_protocol", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 115, "end_line": 136, "span_ids": ["LsofFdLeakChecker.pytest_runtest_protocol"], "tokens": 232}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LsofFdLeakChecker:\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_runtest_protocol(self, item):\n        lines1 = self.get_open_files()\n        yield\n        if hasattr(sys, \"pypy_version_info\"):\n            gc.collect()\n        lines2 = self.get_open_files()\n\n        new_fds = {t[0] for t in lines2} - {t[0] for t in lines1}\n        leaked_files = [t for t in lines2 if t[0] in new_fds]\n        if leaked_files:\n            error = []\n            error.append(\"***** %s FD leakage detected\" % len(leaked_files))\n            error.extend([str(f) for f in leaked_files])\n            error.append(\"*** Before:\")\n            error.extend([str(f) for f in lines1])\n            error.append(\"*** After:\")\n            error.extend([str(f) for f in lines2])\n            error.append(error[0])\n            error.append(\"*** function %s:%s: %s \" % item.location)\n            error.append(\"See issue #2366\")\n            item.warn(pytest.PytestWarning(\"\\n\".join(error)))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_RunResult_RunResult.parseoutcomes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_RunResult_RunResult.parseoutcomes", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 416, "end_line": 467, "span_ids": ["RunResult", "RunResult.__init__", "RunResult.__repr__", "RunResult.parseoutcomes"], "tokens": 394}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class RunResult:\n    \"\"\"The result of running a command.\"\"\"\n\n    def __init__(\n        self,\n        ret: Union[int, ExitCode],\n        outlines: List[str],\n        errlines: List[str],\n        duration: float,\n    ) -> None:\n        try:\n            self.ret = pytest.ExitCode(ret)  # type: Union[int, ExitCode]\n            \"\"\"the return value\"\"\"\n        except ValueError:\n            self.ret = ret\n        self.outlines = outlines\n        \"\"\"list of lines captured from stdout\"\"\"\n        self.errlines = errlines\n        \"\"\"list of lines captured from stderr\"\"\"\n        self.stdout = LineMatcher(outlines)\n        \"\"\":class:`LineMatcher` of stdout.\n\n        Use e.g. :func:`stdout.str() <LineMatcher.str()>` to reconstruct stdout, or the commonly used\n        :func:`stdout.fnmatch_lines() <LineMatcher.fnmatch_lines()>` method.\n        \"\"\"\n        self.stderr = LineMatcher(errlines)\n        \"\"\":class:`LineMatcher` of stderr\"\"\"\n        self.duration = duration\n        \"\"\"duration in seconds\"\"\"\n\n    def __repr__(self) -> str:\n        return (\n            \"<RunResult ret=%s len(stdout.lines)=%d len(stderr.lines)=%d duration=%.2fs>\"\n            % (self.ret, len(self.stdout.lines), len(self.stderr.lines), self.duration)\n        )\n\n    def parseoutcomes(self) -> Dict[str, int]:\n        \"\"\"Return a dictionary of outcomestring->num from parsing the terminal\n        output that the test process produced.\n\n        \"\"\"\n        for line in reversed(self.outlines):\n            if rex_session_duration.search(line):\n                outcomes = rex_outcome.findall(line)\n                ret = {noun: int(count) for (count, noun) in outcomes}\n                break\n        else:\n            raise ValueError(\"Pytest terminal summary report not found\")\n        if \"errors\" in ret:\n            assert \"error\" not in ret\n            ret[\"error\"] = ret.pop(\"errors\")\n        return ret", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_RunResult.assert_outcomes_SysPathsSnapshot.restore": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_RunResult.assert_outcomes_SysPathsSnapshot.restore", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 469, "end_line": 530, "span_ids": ["CwdSnapshot", "CwdSnapshot.__init__", "CwdSnapshot.restore", "RunResult.assert_outcomes", "SysModulesSnapshot", "SysModulesSnapshot.__init__", "SysModulesSnapshot.restore", "SysPathsSnapshot", "SysPathsSnapshot.__init__", "SysPathsSnapshot.restore"], "tokens": 423}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class RunResult:\n\n    def assert_outcomes(\n        self,\n        passed: int = 0,\n        skipped: int = 0,\n        failed: int = 0,\n        error: int = 0,\n        xpassed: int = 0,\n        xfailed: int = 0,\n    ) -> None:\n        \"\"\"Assert that the specified outcomes appear with the respective\n        numbers (0 means it didn't occur) in the text output from a test run.\n        \"\"\"\n        __tracebackhide__ = True\n\n        d = self.parseoutcomes()\n        obtained = {\n            \"passed\": d.get(\"passed\", 0),\n            \"skipped\": d.get(\"skipped\", 0),\n            \"failed\": d.get(\"failed\", 0),\n            \"error\": d.get(\"error\", 0),\n            \"xpassed\": d.get(\"xpassed\", 0),\n            \"xfailed\": d.get(\"xfailed\", 0),\n        }\n        expected = {\n            \"passed\": passed,\n            \"skipped\": skipped,\n            \"failed\": failed,\n            \"error\": error,\n            \"xpassed\": xpassed,\n            \"xfailed\": xfailed,\n        }\n        assert obtained == expected\n\n\nclass CwdSnapshot:\n    def __init__(self) -> None:\n        self.__saved = os.getcwd()\n\n    def restore(self) -> None:\n        os.chdir(self.__saved)\n\n\nclass SysModulesSnapshot:\n    def __init__(self, preserve: Optional[Callable[[str], bool]] = None):\n        self.__preserve = preserve\n        self.__saved = dict(sys.modules)\n\n    def restore(self) -> None:\n        if self.__preserve:\n            self.__saved.update(\n                (k, m) for k, m in sys.modules.items() if self.__preserve(k)\n            )\n        sys.modules.clear()\n        sys.modules.update(self.__saved)\n\n\nclass SysPathsSnapshot:\n    def __init__(self) -> None:\n        self.__saved = list(sys.path), list(sys.meta_path)\n\n    def restore(self) -> None:\n        sys.path[:], sys.meta_path[:] = self.__saved", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.Session_Testdir.inline_runsource": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.Session_Testdir.inline_runsource", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 773, "end_line": 855, "span_ids": ["Testdir.genitems", "Testdir.getnode", "Testdir.getpathnode", "Testdir.inline_runsource", "Testdir.runitem", "Testdir:5"], "tokens": 656}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    Session = Session\n\n    def getnode(self, config, arg):\n        \"\"\"Return the collection node of a file.\n\n        :param config: :py:class:`_pytest.config.Config` instance, see\n           :py:meth:`parseconfig` and :py:meth:`parseconfigure` to create the\n           configuration\n\n        :param arg: a :py:class:`py.path.local` instance of the file\n\n        \"\"\"\n        session = Session.from_config(config)\n        assert \"::\" not in str(arg)\n        p = py.path.local(arg)\n        config.hook.pytest_sessionstart(session=session)\n        res = session.perform_collect([str(p)], genitems=False)[0]\n        config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)\n        return res\n\n    def getpathnode(self, path):\n        \"\"\"Return the collection node of a file.\n\n        This is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to\n        create the (configured) pytest Config instance.\n\n        :param path: a :py:class:`py.path.local` instance of the file\n\n        \"\"\"\n        config = self.parseconfigure(path)\n        session = Session.from_config(config)\n        x = session.fspath.bestrelpath(path)\n        config.hook.pytest_sessionstart(session=session)\n        res = session.perform_collect([x], genitems=False)[0]\n        config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)\n        return res\n\n    def genitems(self, colitems):\n        \"\"\"Generate all test items from a collection node.\n\n        This recurses into the collection node and returns a list of all the\n        test items contained within.\n\n        \"\"\"\n        session = colitems[0].session\n        result = []\n        for colitem in colitems:\n            result.extend(session.genitems(colitem))\n        return result\n\n    def runitem(self, source):\n        \"\"\"Run the \"test_func\" Item.\n\n        The calling test instance (class containing the test method) must\n        provide a ``.getrunner()`` method which should return a runner which\n        can run the test protocol for a single item, e.g.\n        :py:func:`_pytest.runner.runtestprotocol`.\n\n        \"\"\"\n        # used from runner functional tests\n        item = self.getitem(source)\n        # the test class where we are called from wants to provide the runner\n        testclassinstance = self.request.instance\n        runner = testclassinstance.getrunner()\n        return runner(item)\n\n    def inline_runsource(self, source, *cmdlineargs):\n        \"\"\"Run a test module in process using ``pytest.main()``.\n\n        This run writes \"source\" into a temporary file and runs\n        ``pytest.main()`` on it, returning a :py:class:`HookRecorder` instance\n        for the result.\n\n        :param source: the source code of the test module\n\n        :param cmdlineargs: any extra command line arguments to use\n\n        :return: :py:class:`HookRecorder` instance of the result\n\n        \"\"\"\n        p = self.makepyfile(source)\n        values = list(cmdlineargs) + [p]\n        return self.inline_run(*values)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.inline_genitems_Testdir.inline_run.try_.finally_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.inline_genitems_Testdir.inline_run.try_.finally_", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 857, "end_line": 934, "span_ids": ["Testdir.inline_genitems", "Testdir.inline_run"], "tokens": 648}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def inline_genitems(self, *args):\n        \"\"\"Run ``pytest.main(['--collectonly'])`` in-process.\n\n        Runs the :py:func:`pytest.main` function to run all of pytest inside\n        the test process itself like :py:meth:`inline_run`, but returns a\n        tuple of the collected items and a :py:class:`HookRecorder` instance.\n\n        \"\"\"\n        rec = self.inline_run(\"--collect-only\", *args)\n        items = [x.item for x in rec.getcalls(\"pytest_itemcollected\")]\n        return items, rec\n\n    def inline_run(self, *args, plugins=(), no_reraise_ctrlc: bool = False):\n        \"\"\"Run ``pytest.main()`` in-process, returning a HookRecorder.\n\n        Runs the :py:func:`pytest.main` function to run all of pytest inside\n        the test process itself.  This means it can return a\n        :py:class:`HookRecorder` instance which gives more detailed results\n        from that run than can be done by matching stdout/stderr from\n        :py:meth:`runpytest`.\n\n        :param args: command line arguments to pass to :py:func:`pytest.main`\n\n        :kwarg plugins: extra plugin instances the ``pytest.main()`` instance should use.\n\n        :kwarg no_reraise_ctrlc: typically we reraise keyboard interrupts from the child run. If\n            True, the KeyboardInterrupt exception is captured.\n\n        :return: a :py:class:`HookRecorder` instance\n        \"\"\"\n        # (maybe a cpython bug?) the importlib cache sometimes isn't updated\n        # properly between file creation and inline_run (especially if imports\n        # are interspersed with file creation)\n        importlib.invalidate_caches()\n\n        plugins = list(plugins)\n        finalizers = []\n        try:\n            # Any sys.module or sys.path changes done while running pytest\n            # inline should be reverted after the test run completes to avoid\n            # clashing with later inline tests run within the same pytest test,\n            # e.g. just because they use matching test module names.\n            finalizers.append(self.__take_sys_modules_snapshot().restore)\n            finalizers.append(SysPathsSnapshot().restore)\n\n            # Important note:\n            # - our tests should not leave any other references/registrations\n            #   laying around other than possibly loaded test modules\n            #   referenced from sys.modules, as nothing will clean those up\n            #   automatically\n\n            rec = []\n\n            class Collect:\n                def pytest_configure(x, config):\n                    rec.append(self.make_hook_recorder(config.pluginmanager))\n\n            plugins.append(Collect())\n            ret = pytest.main(list(args), plugins=plugins)\n            if len(rec) == 1:\n                reprec = rec.pop()\n            else:\n\n                class reprec:  # type: ignore\n                    pass\n\n            reprec.ret = ret\n\n            # typically we reraise keyboard interrupts from the child run\n            # because it's our user requesting interruption of the testing\n            if ret == ExitCode.INTERRUPTED and not no_reraise_ctrlc:\n                calls = reprec.getcalls(\"pytest_keyboard_interrupt\")\n                if calls and calls[-1].excinfo.type == KeyboardInterrupt:\n                    raise KeyboardInterrupt()\n            return reprec\n        finally:\n            for finalizer in finalizers:\n                finalizer()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.runpytest_inprocess_Testdir.runpytest_inprocess.return_res": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.runpytest_inprocess_Testdir.runpytest_inprocess.return_res", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 936, "end_line": 976, "span_ids": ["Testdir.runpytest_inprocess"], "tokens": 254}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def runpytest_inprocess(self, *args, **kwargs) -> RunResult:\n        \"\"\"Return result of running pytest in-process, providing a similar\n        interface to what self.runpytest() provides.\n        \"\"\"\n        syspathinsert = kwargs.pop(\"syspathinsert\", False)\n\n        if syspathinsert:\n            self.syspathinsert()\n        now = time.time()\n        capture = MultiCapture(Capture=SysCapture)\n        capture.start_capturing()\n        try:\n            try:\n                reprec = self.inline_run(*args, **kwargs)\n            except SystemExit as e:\n                ret = e.args[0]\n                try:\n                    ret = ExitCode(e.args[0])\n                except ValueError:\n                    pass\n\n                class reprec:  # type: ignore\n                    ret = ret\n\n            except Exception:\n                traceback.print_exc()\n\n                class reprec:  # type: ignore\n                    ret = ExitCode(3)\n\n        finally:\n            out, err = capture.readouterr()\n            capture.stop_capturing()\n            sys.stdout.write(out)\n            sys.stderr.write(err)\n\n        res = RunResult(\n            reprec.ret, out.splitlines(), err.splitlines(), time.time() - now\n        )\n        res.reprec = reprec  # type: ignore\n        return res", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.run_Testdir.run.return_RunResult_ret_out": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.run_Testdir.run.return_RunResult_ret_out", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1146, "end_line": 1221, "span_ids": ["Testdir.run"], "tokens": 538}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def run(self, *cmdargs, timeout=None, stdin=CLOSE_STDIN) -> RunResult:\n        \"\"\"Run a command with arguments.\n\n        Run a process using subprocess.Popen saving the stdout and stderr.\n\n        :param args: the sequence of arguments to pass to `subprocess.Popen()`\n        :kwarg timeout: the period in seconds after which to timeout and raise\n            :py:class:`Testdir.TimeoutExpired`\n        :kwarg stdin: optional standard input.  Bytes are being send, closing\n            the pipe, otherwise it is passed through to ``popen``.\n            Defaults to ``CLOSE_STDIN``, which translates to using a pipe\n            (``subprocess.PIPE``) that gets closed.\n\n        Returns a :py:class:`RunResult`.\n\n        \"\"\"\n        __tracebackhide__ = True\n\n        cmdargs = tuple(\n            str(arg) if isinstance(arg, py.path.local) else arg for arg in cmdargs\n        )\n        p1 = self.tmpdir.join(\"stdout\")\n        p2 = self.tmpdir.join(\"stderr\")\n        print(\"running:\", *cmdargs)\n        print(\"     in:\", py.path.local())\n        f1 = open(str(p1), \"w\", encoding=\"utf8\")\n        f2 = open(str(p2), \"w\", encoding=\"utf8\")\n        try:\n            now = time.time()\n            popen = self.popen(\n                cmdargs,\n                stdin=stdin,\n                stdout=f1,\n                stderr=f2,\n                close_fds=(sys.platform != \"win32\"),\n            )\n            if isinstance(stdin, bytes):\n                popen.stdin.close()\n\n            def handle_timeout():\n                __tracebackhide__ = True\n\n                timeout_message = (\n                    \"{seconds} second timeout expired running:\"\n                    \" {command}\".format(seconds=timeout, command=cmdargs)\n                )\n\n                popen.kill()\n                popen.wait()\n                raise self.TimeoutExpired(timeout_message)\n\n            if timeout is None:\n                ret = popen.wait()\n            else:\n                try:\n                    ret = popen.wait(timeout)\n                except subprocess.TimeoutExpired:\n                    handle_timeout()\n        finally:\n            f1.close()\n            f2.close()\n        f1 = open(str(p1), encoding=\"utf8\")\n        f2 = open(str(p2), encoding=\"utf8\")\n        try:\n            out = f1.read().splitlines()\n            err = f2.read().splitlines()\n        finally:\n            f1.close()\n            f2.close()\n        self._dump_lines(out, sys.stdout)\n        self._dump_lines(err, sys.stderr)\n        try:\n            ret = ExitCode(ret)\n        except ValueError:\n            pass\n        return RunResult(ret, out, err, time.time() - now)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.spawn_pytest_LineComp.assert_contains_lines": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.spawn_pytest_LineComp.assert_contains_lines", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1269, "end_line": 1319, "span_ids": ["LineComp", "LineComp.__init__", "LineComp.assert_contains_lines", "Testdir.spawn", "Testdir.spawn_pytest"], "tokens": 433}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def spawn_pytest(\n        self, string: str, expect_timeout: float = 10.0\n    ) -> \"pexpect.spawn\":\n        \"\"\"Run pytest using pexpect.\n\n        This makes sure to use the right pytest and sets up the temporary\n        directory locations.\n\n        The pexpect child is returned.\n\n        \"\"\"\n        basetemp = self.tmpdir.mkdir(\"temp-pexpect\")\n        invoke = \" \".join(map(str, self._getpytestargs()))\n        cmd = \"{} --basetemp={} {}\".format(invoke, basetemp, string)\n        return self.spawn(cmd, expect_timeout=expect_timeout)\n\n    def spawn(self, cmd: str, expect_timeout: float = 10.0) -> \"pexpect.spawn\":\n        \"\"\"Run a command using pexpect.\n\n        The pexpect child is returned.\n\n        \"\"\"\n        pexpect = pytest.importorskip(\"pexpect\", \"3.0\")\n        if hasattr(sys, \"pypy_version_info\") and \"64\" in platform.machine():\n            pytest.skip(\"pypy-64 bit not supported\")\n        if not hasattr(pexpect, \"spawn\"):\n            pytest.skip(\"pexpect.spawn not available\")\n        logfile = self.tmpdir.join(\"spawn.out\").open(\"wb\")\n\n        child = pexpect.spawn(cmd, logfile=logfile)\n        self.request.addfinalizer(logfile.close)\n        child.timeout = expect_timeout\n        return child\n\n\nclass LineComp:\n    def __init__(self) -> None:\n        self.stringio = StringIO()\n        \"\"\":class:`python:io.StringIO()` instance used for input.\"\"\"\n\n    def assert_contains_lines(self, lines2: Sequence[str]) -> None:\n        \"\"\"Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.\n\n        Lines are matched using :func:`LineMatcher.fnmatch_lines`.\n        \"\"\"\n        __tracebackhide__ = True\n        val = self.stringio.getvalue()\n        self.stringio.truncate(0)\n        self.stringio.seek(0)\n        lines1 = val.split(\"\\n\")\n        LineMatcher(lines1).fnmatch_lines(lines2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_cmdline_main_pytest_configure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_cmdline_main_pytest_configure", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 127, "end_line": 159, "span_ids": ["pytest_cmdline_main", "pytest_configure", "pytest_generate_tests"], "tokens": 330}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_cmdline_main(config):\n    if config.option.showfixtures:\n        showfixtures(config)\n        return 0\n    if config.option.show_fixtures_per_test:\n        show_fixtures_per_test(config)\n        return 0\n\n\ndef pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        # TODO: Fix this type-ignore (overlapping kwargs).\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc] # noqa: F821\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"parametrize(argnames, argvalues): call a test function multiple \"\n        \"times passing in different arguments in turn. argvalues generally \"\n        \"needs to be a list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyobjMixin_PyobjMixin.reportinfo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyobjMixin_PyobjMixin.reportinfo", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 250, "end_line": 310, "span_ids": ["PyobjMixin", "PyobjMixin._getobj", "PyobjMixin.getmodpath", "PyobjMixin.obj", "PyobjMixin.obj_1", "PyobjMixin.reportinfo"], "tokens": 447}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PyobjMixin:\n    module = pyobj_property(\"Module\")\n    cls = pyobj_property(\"Class\")\n    instance = pyobj_property(\"Instance\")\n    _ALLOW_MARKERS = True\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwritten by subclasses.\"\"\"\n        return getattr(self.parent.obj, self.name)\n\n    def getmodpath(self, stopatmodule=True, includemodule=False):\n        \"\"\" return python path relative to the containing module. \"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            if isinstance(node, Instance):\n                continue\n            name = node.name\n            if isinstance(node, Module):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[py.path.local, str], int, str]:\n        # XXX caching?\n        obj = self.obj\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[obj.__module__].__file__\n            if file_path.endswith(\".pyc\"):\n                file_path = file_path[:-1]\n            fspath = file_path  # type: Union[py.path.local, str]\n            lineno = compat_co_firstlineno\n        else:\n            fspath, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        assert isinstance(lineno, int)\n        return fspath, lineno, modpath", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector._genfunctions_PyCollector._genfunctions.if_not_metafunc__calls_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector._genfunctions_PyCollector._genfunctions.if_not_metafunc__calls_", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 397, "end_line": 438, "span_ids": ["PyCollector._genfunctions"], "tokens": 335}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PyCollector(PyobjMixin, nodes.Collector):\n\n    def _genfunctions(self, name, funcobj):\n        module = self.getparent(Module).obj\n        clscol = self.getparent(Class)\n        cls = clscol and clscol.obj or None\n        fm = self.session._fixturemanager\n\n        definition = FunctionDefinition.from_parent(self, name=name, callobj=funcobj)\n        fixtureinfo = definition._fixtureinfo\n\n        metafunc = Metafunc(\n            definition, fixtureinfo, self.config, cls=cls, module=module\n        )\n        methods = []\n        if hasattr(module, \"pytest_generate_tests\"):\n            methods.append(module.pytest_generate_tests)\n        if hasattr(cls, \"pytest_generate_tests\"):\n            methods.append(cls().pytest_generate_tests)\n\n        self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))\n\n        if not metafunc._calls:\n            yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\n        else:\n            # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs\n            fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n\n            # add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n            # with direct parametrization, so make sure we update what the\n            # function really needs.\n            fixtureinfo.prune_dependency_tree()\n\n            for callspec in metafunc._calls:\n                subname = \"{}[{}]\".format(name, callspec.id)\n                yield Function.from_parent(\n                    self,\n                    name=subname,\n                    callspec=callspec,\n                    callobj=funcobj,\n                    fixtureinfo=fixtureinfo,\n                    keywords={callspec.id: True},\n                    originalname=name,\n                )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module_Module._inject_setup_module_fixture.self.obj.__pytest_setup_module": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module_Module._inject_setup_module_fixture.self.obj.__pytest_setup_module", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 429, "end_line": 466, "span_ids": ["Module", "Module._getobj", "Module._inject_setup_module_fixture", "Module.collect"], "tokens": 274}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Module(nodes.File, PyCollector):\n    \"\"\" Collector for test classes and functions. \"\"\"\n\n    def _getobj(self):\n        return self._importtestmodule()\n\n    def collect(self):\n        self._inject_setup_module_fixture()\n        self._inject_setup_function_fixture()\n        self.session._fixturemanager.parsefactories(self)\n        return super().collect()\n\n    def _inject_setup_module_fixture(self):\n        \"\"\"Injects a hidden autouse, module scoped fixture into the collected module object\n        that invokes setUpModule/tearDownModule if either or both are available.\n\n        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        \"\"\"\n        setup_module = _get_first_non_fixture_func(\n            self.obj, (\"setUpModule\", \"setup_module\")\n        )\n        teardown_module = _get_first_non_fixture_func(\n            self.obj, (\"tearDownModule\", \"teardown_module\")\n        )\n\n        if setup_module is None and teardown_module is None:\n            return\n\n        @fixtures.fixture(autouse=True, scope=\"module\")\n        def xunit_setup_module_fixture(request):\n            if setup_module is not None:\n                _call_with_optional_argument(setup_module, request.module)\n            yield\n            if teardown_module is not None:\n                _call_with_optional_argument(teardown_module, request.module)\n\n        self.obj.__pytest_setup_module = xunit_setup_module_fixture", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module._inject_setup_function_fixture_Module._inject_setup_function_fixture.self.obj.__pytest_setup_function": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module._inject_setup_function_fixture_Module._inject_setup_function_fixture.self.obj.__pytest_setup_function", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 468, "end_line": 495, "span_ids": ["Module._inject_setup_function_fixture"], "tokens": 236}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Module(nodes.File, PyCollector):\n\n    def _inject_setup_function_fixture(self):\n        \"\"\"Injects a hidden autouse, function scoped fixture into the collected module object\n        that invokes setup_function/teardown_function if either or both are available.\n\n        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        \"\"\"\n        setup_function = _get_first_non_fixture_func(self.obj, (\"setup_function\",))\n        teardown_function = _get_first_non_fixture_func(\n            self.obj, (\"teardown_function\",)\n        )\n        if setup_function is None and teardown_function is None:\n            return\n\n        @fixtures.fixture(autouse=True, scope=\"function\")\n        def xunit_setup_function_fixture(request):\n            if request.instance is not None:\n                # in this case we are bound to an instance, so we need to let\n                # setup_method handle this\n                yield\n                return\n            if setup_function is not None:\n                _call_with_optional_argument(setup_function, request.function)\n            yield\n            if teardown_function is not None:\n                _call_with_optional_argument(teardown_function, request.function)\n\n        self.obj.__pytest_setup_function = xunit_setup_function_fixture", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module._importtestmodule_Module._importtestmodule.return_mod": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Module._importtestmodule_Module._importtestmodule.return_mod", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 509, "end_line": 552, "span_ids": ["Module._importtestmodule"], "tokens": 422}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Module(nodes.File, PyCollector):\n\n    def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(ExceptionInfo.from_current().getrepr(style=\"short\"))\n        except self.fspath.ImportMismatchError as e:\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Package_Package.isinitpath": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Package_Package.isinitpath", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 555, "end_line": 594, "span_ids": ["Package", "Package.__init__", "Package.gethookproxy", "Package.isinitpath", "Package.setup"], "tokens": 309}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Package(Module):\n    def __init__(\n        self,\n        fspath: py.path.local,\n        parent: nodes.Collector,\n        # NOTE: following args are unused:\n        config=None,\n        session=None,\n        nodeid=None,\n    ) -> None:\n        # NOTE: could be just the following, but kept as-is for compat.\n        # nodes.FSCollector.__init__(self, fspath, parent=parent)\n        session = parent.session\n        nodes.FSCollector.__init__(\n            self, fspath, parent=parent, config=config, session=session, nodeid=nodeid\n        )\n\n        self.name = fspath.dirname\n\n    def setup(self):\n        # not using fixtures to call setup_module here because autouse fixtures\n        # from packages are not called automatically (#4085)\n        setup_module = _get_first_non_fixture_func(\n            self.obj, (\"setUpModule\", \"setup_module\")\n        )\n        if setup_module is not None:\n            _call_with_optional_argument(setup_module, self.obj)\n\n        teardown_module = _get_first_non_fixture_func(\n            self.obj, (\"tearDownModule\", \"teardown_module\")\n        )\n        if teardown_module is not None:\n            func = partial(_call_with_optional_argument, teardown_module, self.obj)\n            self.addfinalizer(func)\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def isinitpath(self, path):\n        return path in self.session._initialpaths", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._resolve_arg_value_types_Metafunc._resolve_arg_value_types.return_valtypes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._resolve_arg_value_types_Metafunc._resolve_arg_value_types.return_valtypes", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1043, "end_line": 1078, "span_ids": ["Metafunc._resolve_arg_value_types"], "tokens": 341}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, str]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(argnames, \"params\" if indirect else \"funcargs\")\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_if_using_arg_names_Metafunc._validate_if_using_arg_names.for_arg_in_argnames_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_if_using_arg_names_Metafunc._validate_if_using_arg_names.for_arg_in_argnames_", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1080, "end_line": 1111, "span_ids": ["Metafunc._validate_if_using_arg_names"], "tokens": 253}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n\n    def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__find_parametrized_scope__ascii_escaped_by_config": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__find_parametrized_scope__ascii_escaped_by_config", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1147, "end_line": 1190, "span_ids": ["_ascii_escaped_by_config", "_find_parametrized_scope"], "tokens": 368}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    from _pytest.fixtures import scopes\n\n    if isinstance(indirect, (list, tuple)):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\"\n        )\n    # TODO: If escaping is turned off and the user passes bytes,\n    #       will return a bytes. For now we ignore this but the\n    #       code *probably* doesn't handle this case.\n    return val if escape_option else ascii_escaped(val)  # type: ignore", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__idval__idval.return_str_argname_str": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__idval__idval.return_str_argname_str", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1193, "end_line": 1229, "span_ids": ["_idval"], "tokens": 301}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _idval(\n    val: object,\n    argname: str,\n    idx: int,\n    idfn: Optional[Callable[[object], Optional[object]]],\n    item,\n    config: Optional[Config],\n) -> str:\n    if idfn:\n        try:\n            generated_id = idfn(val)\n            if generated_id is not None:\n                val = generated_id\n        except Exception as e:\n            msg = \"{}: error raised while trying to determine id of parameter '{}' at position {}\"\n            msg = msg.format(item.nodeid, argname, idx)\n            raise ValueError(msg) from e\n    elif config:\n        hook_id = config.hook.pytest_make_parametrize_id(\n            config=config, val=val, argname=argname\n        )  # type: Optional[str]\n        if hook_id:\n            return hook_id\n\n    if isinstance(val, STRING_TYPES):\n        return _ascii_escaped_by_config(val, config)\n    elif val is None or isinstance(val, (float, int, bool)):\n        return str(val)\n    elif isinstance(val, REGEX_TYPE):\n        return ascii_escaped(val.pattern)\n    elif isinstance(val, enum.Enum):\n        return str(val)\n    elif isinstance(getattr(val, \"__name__\", None), str):\n        # name of a class, function, module, etc.\n        name = getattr(val, \"__name__\")  # type: str\n        return name\n    return str(argname) + str(idx)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__recursive_list_map_ApproxNumpy._yield_comparisons": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__recursive_list_map_ApproxNumpy._yield_comparisons", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 101, "end_line": 145, "span_ids": ["ApproxNumpy", "ApproxNumpy.__eq__", "ApproxNumpy.__repr__", "ApproxNumpy._yield_comparisons", "_recursive_list_map"], "tokens": 323}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _recursive_list_map(f, x):\n    if isinstance(x, list):\n        return list(_recursive_list_map(f, xi) for xi in x)\n    else:\n        return f(x)\n\n\nclass ApproxNumpy(ApproxBase):\n    \"\"\"\n    Perform approximate comparisons where the expected value is numpy array.\n    \"\"\"\n\n    def __repr__(self):\n        list_scalars = _recursive_list_map(self._approx_scalar, self.expected.tolist())\n        return \"approx({!r})\".format(list_scalars)\n\n    def __eq__(self, actual):\n        import numpy as np\n\n        # self.expected is supposed to always be an array here\n\n        if not np.isscalar(actual):\n            try:\n                actual = np.asarray(actual)\n            except:  # noqa\n                raise TypeError(\"cannot compare '{}' to numpy.ndarray\".format(actual))\n\n        if not np.isscalar(actual) and actual.shape != self.expected.shape:\n            return False\n\n        return ApproxBase.__eq__(self, actual)\n\n    def _yield_comparisons(self, actual):\n        import numpy as np\n\n        # `actual` can either be a numpy array or a scalar, it is treated in\n        # `__eq__` before being passed to `ApproxBase.__eq__`, which is the\n        # only method that calls this one.\n\n        if np.isscalar(actual):\n            for i in np.ndindex(self.expected.shape):\n                yield actual, self.expected[i].item()\n        else:\n            for i in np.ndindex(self.expected.shape):\n                yield actual[i].item(), self.expected[i].item()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxMapping_ApproxMapping._check_type": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxMapping_ApproxMapping._check_type", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 158, "end_line": 186, "span_ids": ["ApproxMapping", "ApproxMapping.__eq__", "ApproxMapping.__repr__", "ApproxMapping._check_type", "ApproxMapping._yield_comparisons"], "tokens": 237}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ApproxMapping(ApproxBase):\n    \"\"\"\n    Perform approximate comparisons where the expected value is a mapping with\n    numeric values (the keys can be anything).\n    \"\"\"\n\n    def __repr__(self):\n        return \"approx({!r})\".format(\n            {k: self._approx_scalar(v) for k, v in self.expected.items()}\n        )\n\n    def __eq__(self, actual):\n        if set(actual.keys()) != set(self.expected.keys()):\n            return False\n\n        return ApproxBase.__eq__(self, actual)\n\n    def _yield_comparisons(self, actual):\n        for k in self.expected.keys():\n            yield actual[k], self.expected[k]\n\n    def _check_type(self):\n        __tracebackhide__ = True\n        for key, value in self.expected.items():\n            if isinstance(value, type(self.expected)):\n                msg = \"pytest.approx() does not support nested dictionaries: key={!r} value={!r}\\n  full mapping={}\"\n                raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))\n            elif not isinstance(value, Number):\n                raise _non_numeric_type_error(self.expected, at=\"key={!r}\".format(key))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxSequencelike_ApproxSequencelike._check_type": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxSequencelike_ApproxSequencelike._check_type", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 189, "end_line": 220, "span_ids": ["ApproxSequencelike", "ApproxSequencelike.__eq__", "ApproxSequencelike.__repr__", "ApproxSequencelike._check_type", "ApproxSequencelike._yield_comparisons"], "tokens": 248}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ApproxSequencelike(ApproxBase):\n    \"\"\"\n    Perform approximate comparisons where the expected value is a sequence of\n    numbers.\n    \"\"\"\n\n    def __repr__(self):\n        seq_type = type(self.expected)\n        if seq_type not in (tuple, list, set):\n            seq_type = list\n        return \"approx({!r})\".format(\n            seq_type(self._approx_scalar(x) for x in self.expected)\n        )\n\n    def __eq__(self, actual):\n        if len(actual) != len(self.expected):\n            return False\n        return ApproxBase.__eq__(self, actual)\n\n    def _yield_comparisons(self, actual):\n        return zip(actual, self.expected)\n\n    def _check_type(self):\n        __tracebackhide__ = True\n        for index, x in enumerate(self.expected):\n            if isinstance(x, type(self.expected)):\n                msg = \"pytest.approx() does not support nested data structures: {!r} at index {}\\n  full sequence: {}\"\n                raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))\n            elif not isinstance(x, Number):\n                raise _non_numeric_type_error(\n                    self.expected, at=\"index {}\".format(index)\n                )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar.tolerance_approx": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar.tolerance_approx", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 292, "end_line": 536, "span_ids": ["ApproxDecimal", "ApproxScalar.tolerance", "approx"], "tokens": 418}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ApproxScalar(ApproxBase):\n\n    @property\n    def tolerance(self):\n        \"\"\"\n        Return the tolerance for the comparison.  This could be either an\n        absolute tolerance or a relative tolerance, depending on what the user\n        specified or which would be larger.\n        \"\"\"\n\n        def set_default(x, default):\n            return x if x is not None else default\n\n        # Figure out what the absolute tolerance should be.  ``self.abs`` is\n        # either None or a value specified by the user.\n        absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)\n\n        if absolute_tolerance < 0:\n            raise ValueError(\n                \"absolute tolerance can't be negative: {}\".format(absolute_tolerance)\n            )\n        if math.isnan(absolute_tolerance):\n            raise ValueError(\"absolute tolerance can't be NaN.\")\n\n        # If the user specified an absolute tolerance but not a relative one,\n        # just return the absolute tolerance.\n        if self.rel is None:\n            if self.abs is not None:\n                return absolute_tolerance\n\n        # Figure out what the relative tolerance should be.  ``self.rel`` is\n        # either None or a value specified by the user.  This is done after\n        # we've made sure the user didn't ask for an absolute tolerance only,\n        # because we don't want to raise errors about the relative tolerance if\n        # we aren't even going to use it.\n        relative_tolerance = set_default(\n            self.rel, self.DEFAULT_RELATIVE_TOLERANCE\n        ) * abs(self.expected)\n\n        if relative_tolerance < 0:\n            raise ValueError(\n                \"relative tolerance can't be negative: {}\".format(absolute_tolerance)\n            )\n        if math.isnan(relative_tolerance):\n            raise ValueError(\"relative tolerance can't be NaN.\")\n\n        # Return the larger of the relative and absolute tolerances.\n        return max(relative_tolerance, absolute_tolerance)\n\n\nclass ApproxDecimal(ApproxScalar):\n    \"\"\"\n    Perform approximate comparisons where the expected value is a decimal.\n    \"\"\"\n\n    DEFAULT_ABSOLUTE_TOLERANCE = Decimal(\"1e-12\")\n    DEFAULT_RELATIVE_TOLERANCE = Decimal(\"1e-6\")\n\n\ndef approx(expected, rel=None, abs=None, nan_ok=False):\n    # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_approx.__approx._": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_approx.__approx._", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 350, "end_line": 500, "span_ids": ["approx"], "tokens": 1883}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def approx(expected, rel=None, abs=None, nan_ok=False):\n    \"\"\"\n    Assert that two numbers (or two sets of numbers) are equal to each other\n    within some tolerance.\n\n    Due to the `intricacies of floating-point arithmetic`__, numbers that we\n    would intuitively expect to be equal are not always so::\n\n        >>> 0.1 + 0.2 == 0.3\n        False\n\n    __ https://docs.python.org/3/tutorial/floatingpoint.html\n\n    This problem is commonly encountered when writing tests, e.g. when making\n    sure that floating-point values are what you expect them to be.  One way to\n    deal with this problem is to assert that two floating-point numbers are\n    equal to within some appropriate tolerance::\n\n        >>> abs((0.1 + 0.2) - 0.3) < 1e-6\n        True\n\n    However, comparisons like this are tedious to write and difficult to\n    understand.  Furthermore, absolute comparisons like the one above are\n    usually discouraged because there's no tolerance that works well for all\n    situations.  ``1e-6`` is good for numbers around ``1``, but too small for\n    very big numbers and too big for very small ones.  It's better to express\n    the tolerance as a fraction of the expected value, but relative comparisons\n    like that are even more difficult to write correctly and concisely.\n\n    The ``approx`` class performs floating-point comparisons using a syntax\n    that's as intuitive as possible::\n\n        >>> from pytest import approx\n        >>> 0.1 + 0.2 == approx(0.3)\n        True\n\n    The same syntax also works for sequences of numbers::\n\n        >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))\n        True\n\n    Dictionary *values*::\n\n        >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})\n        True\n\n    ``numpy`` arrays::\n\n        >>> import numpy as np                                                          # doctest: +SKIP\n        >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP\n        True\n\n    And for a ``numpy`` array against a scalar::\n\n        >>> import numpy as np                                         # doctest: +SKIP\n        >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP\n        True\n\n    By default, ``approx`` considers numbers within a relative tolerance of\n    ``1e-6`` (i.e. one part in a million) of its expected value to be equal.\n    This treatment would lead to surprising results if the expected value was\n    ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.\n    To handle this case less surprisingly, ``approx`` also considers numbers\n    within an absolute tolerance of ``1e-12`` of its expected value to be\n    equal.  Infinity and NaN are special cases.  Infinity is only considered\n    equal to itself, regardless of the relative tolerance.  NaN is not\n    considered equal to anything by default, but you can make it be equal to\n    itself by setting the ``nan_ok`` argument to True.  (This is meant to\n    facilitate comparing arrays that use NaN to mean \"no data\".)\n\n    Both the relative and absolute tolerances can be changed by passing\n    arguments to the ``approx`` constructor::\n\n        >>> 1.0001 == approx(1)\n        False\n        >>> 1.0001 == approx(1, rel=1e-3)\n        True\n        >>> 1.0001 == approx(1, abs=1e-3)\n        True\n\n    If you specify ``abs`` but not ``rel``, the comparison will not consider\n    the relative tolerance at all.  In other words, two numbers that are within\n    the default relative tolerance of ``1e-6`` will still be considered unequal\n    if they exceed the specified absolute tolerance.  If you specify both\n    ``abs`` and ``rel``, the numbers will be considered equal if either\n    tolerance is met::\n\n        >>> 1 + 1e-8 == approx(1)\n        True\n        >>> 1 + 1e-8 == approx(1, abs=1e-12)\n        False\n        >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n        True\n\n    If you're thinking about using ``approx``, then you might want to know how\n    it compares to other good ways of comparing floating-point numbers.  All of\n    these algorithms are based on relative and absolute tolerances and should\n    agree for the most part, but they do have meaningful differences:\n\n    - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative\n      tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute\n      tolerance is met.  Because the relative tolerance is calculated w.r.t.\n      both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor\n      ``b`` is a \"reference value\").  You have to specify an absolute tolerance\n      if you want to compare to ``0.0`` because there is no tolerance by\n      default.  Only available in python>=3.5.  `More information...`__\n\n      __ https://docs.python.org/3/library/math.html#math.isclose\n\n    - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference\n      between ``a`` and ``b`` is less that the sum of the relative tolerance\n      w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance\n      is only calculated w.r.t. ``b``, this test is asymmetric and you can\n      think of ``b`` as the reference value.  Support for comparing sequences\n      is provided by ``numpy.allclose``.  `More information...`__\n\n      __ http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.isclose.html\n\n    - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``\n      are within an absolute tolerance of ``1e-7``.  No relative tolerance is\n      considered and the absolute tolerance cannot be changed, so this function\n      is not appropriate for very large or very small numbers.  Also, it's only\n      available in subclasses of ``unittest.TestCase`` and it's ugly because it\n      doesn't follow PEP8.  `More information...`__\n\n      __ https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual\n\n    - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative\n      tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.\n      Because the relative tolerance is only calculated w.r.t. ``b``, this test\n      is asymmetric and you can think of ``b`` as the reference value.  In the\n      special case that you explicitly specify an absolute tolerance but not a\n      relative tolerance, only the absolute tolerance is considered.\n\n    .. warning::\n\n       .. versionchanged:: 3.2\n\n       In order to avoid inconsistent behavior, ``TypeError`` is\n       raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.\n       The example below illustrates the problem::\n\n           assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)\n           assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)\n\n       In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``\n       to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to\n       comparison. This is because the call hierarchy of rich comparisons\n       follows a fixed behavior. `More information...`__\n\n       __ https://docs.python.org/3/reference/datamodel.html#object.__ge__\n    \"\"\"\n    # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_WarningsChecker_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_WarningsChecker_", "embedding": null, "metadata": {"file_path": "src/_pytest/recwarn.py", "file_name": "recwarn.py", "file_type": "text/x-python", "category": "implementation", "start_line": 203, "end_line": 265, "span_ids": ["WarningsChecker", "WarningsChecker.__exit__", "WarningsChecker.__init__"], "tokens": 469}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class WarningsChecker(WarningsRecorder):\n    def __init__(\n        self,\n        expected_warning: Optional[\n            Union[\"Type[Warning]\", Tuple[\"Type[Warning]\", ...]]\n        ] = None,\n        match_expr: Optional[Union[str, \"Pattern\"]] = None,\n    ) -> None:\n        super().__init__()\n\n        msg = \"exceptions must be derived from Warning, not %s\"\n        if expected_warning is None:\n            expected_warning_tup = None\n        elif isinstance(expected_warning, tuple):\n            for exc in expected_warning:\n                if not issubclass(exc, Warning):\n                    raise TypeError(msg % type(exc))\n            expected_warning_tup = expected_warning\n        elif issubclass(expected_warning, Warning):\n            expected_warning_tup = (expected_warning,)\n        else:\n            raise TypeError(msg % type(expected_warning))\n\n        self.expected_warning = expected_warning_tup\n        self.match_expr = match_expr\n\n    def __exit__(\n        self,\n        exc_type: Optional[\"Type[BaseException]\"],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        super().__exit__(exc_type, exc_val, exc_tb)\n\n        __tracebackhide__ = True\n\n        # only check if we're not currently handling an exception\n        if exc_type is None and exc_val is None and exc_tb is None:\n            if self.expected_warning is not None:\n                if not any(issubclass(r.category, self.expected_warning) for r in self):\n                    __tracebackhide__ = True\n                    fail(\n                        \"DID NOT WARN. No warnings of type {} was emitted. \"\n                        \"The list of emitted warnings is: {}.\".format(\n                            self.expected_warning, [each.message for each in self]\n                        )\n                    )\n                elif self.match_expr is not None:\n                    for r in self:\n                        if issubclass(r.category, self.expected_warning):\n                            if re.compile(self.match_expr).search(str(r.message)):\n                                break\n                    else:\n                        fail(\n                            \"DID NOT WARN. No warnings of type {} matching\"\n                            \" ('{}') was emitted. The list of emitted warnings\"\n                            \" is: {}.\".format(\n                                self.expected_warning,\n                                self.match_expr,\n                                [each.message for each in self],\n                            )\n                        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_unserialization_failure_TestReport.__repr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_unserialization_failure_TestReport.__repr__", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 198, "end_line": 269, "span_ids": ["TestReport", "TestReport.__init__", "TestReport.__repr__", "_report_unserialization_failure"], "tokens": 525}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _report_unserialization_failure(type_name, report_class, reportdict):\n    url = \"https://github.com/pytest-dev/pytest/issues\"\n    stream = StringIO()\n    pprint(\"-\" * 100, stream=stream)\n    pprint(\"INTERNALERROR: Unknown entry type returned: %s\" % type_name, stream=stream)\n    pprint(\"report_name: %s\" % report_class, stream=stream)\n    pprint(reportdict, stream=stream)\n    pprint(\"Please report this bug at %s\" % url, stream=stream)\n    pprint(\"-\" * 100, stream=stream)\n    raise RuntimeError(stream.getvalue())\n\n\nclass TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location: Tuple[str, Optional[int], str],\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ) -> None:\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location  # type: Tuple[str, Optional[int], str]\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_TestReport.from_item_and_call_TestReport.from_item_and_call.return_cls_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_TestReport.from_item_and_call_TestReport.from_item_and_call.return_cls_", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 271, "end_line": 312, "span_ids": ["TestReport.from_item_and_call"], "tokens": 294}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReport(BaseReport):\n\n    @classmethod\n    def from_item_and_call(cls, item, call) -> \"TestReport\":\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.duration\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/resultlog.py_ResultLog_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/resultlog.py_ResultLog_", "embedding": null, "metadata": {"file_path": "src/_pytest/resultlog.py", "file_name": "resultlog.py", "file_type": "text/x-python", "category": "implementation", "start_line": 51, "end_line": 103, "span_ids": ["ResultLog", "ResultLog.__init__", "ResultLog.log_outcome", "ResultLog.pytest_collectreport", "ResultLog.pytest_internalerror", "ResultLog.pytest_runtest_logreport", "ResultLog.write_log_entry"], "tokens": 431}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ResultLog:\n    def __init__(self, config, logfile):\n        self.config = config\n        self.logfile = logfile  # preferably line buffered\n\n    def write_log_entry(self, testpath, lettercode, longrepr):\n        print(\"{} {}\".format(lettercode, testpath), file=self.logfile)\n        for line in longrepr.splitlines():\n            print(\" %s\" % line, file=self.logfile)\n\n    def log_outcome(self, report, lettercode, longrepr):\n        testpath = getattr(report, \"nodeid\", None)\n        if testpath is None:\n            testpath = report.fspath\n        self.write_log_entry(testpath, lettercode, longrepr)\n\n    def pytest_runtest_logreport(self, report):\n        if report.when != \"call\" and report.passed:\n            return\n        res = self.config.hook.pytest_report_teststatus(\n            report=report, config=self.config\n        )\n        code = res[1]\n        if code == \"x\":\n            longrepr = str(report.longrepr)\n        elif code == \"X\":\n            longrepr = \"\"\n        elif report.passed:\n            longrepr = \"\"\n        elif report.skipped:\n            longrepr = str(report.longrepr[2])\n        else:\n            longrepr = str(report.longrepr)\n        self.log_outcome(report, code, longrepr)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            if report.failed:\n                code = \"F\"\n                longrepr = str(report.longrepr)\n            else:\n                assert report.skipped\n                code = \"S\"\n                longrepr = \"%s:%d: %s\" % report.longrepr\n            self.log_outcome(report, code, longrepr)\n\n    def pytest_internalerror(self, excrepr):\n        reprcrash = getattr(excrepr, \"reprcrash\", None)\n        path = getattr(reprcrash, \"path\", None)\n        if path is None:\n            path = \"cwd:%s\" % py.path.local()\n        self.write_log_entry(path, \"!\", str(excrepr))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_sessionstart__update_current_test_var": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_sessionstart__update_current_test_var", "embedding": null, "metadata": {"file_path": "src/_pytest/runner.py", "file_name": "runner.py", "file_type": "text/x-python", "category": "implementation", "start_line": 79, "end_line": 170, "span_ids": ["_update_current_test_var", "pytest_runtest_call", "pytest_runtest_protocol", "pytest_runtest_setup", "pytest_runtest_teardown", "pytest_sessionfinish", "pytest_sessionstart", "runtestprotocol", "show_test_item"], "tokens": 693}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_sessionstart(session):\n    session._setupstate = SetupState()\n\n\ndef pytest_sessionfinish(session):\n    session._setupstate.teardown_all()\n\n\ndef pytest_runtest_protocol(item, nextitem):\n    item.ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    item.ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True\n\n\ndef runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports\n\n\ndef show_test_item(item):\n    \"\"\"Show test function, parameters and the fixtures of the test item.\"\"\"\n    tw = item.config.get_terminal_writer()\n    tw.line()\n    tw.write(\" \" * 8)\n    tw.write(item.nodeid)\n    used_fixtures = sorted(getattr(item, \"fixturenames\", []))\n    if used_fixtures:\n        tw.write(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n    tw.flush()\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item, when):\n    \"\"\"\n    Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.\n\n    If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.\n    \"\"\"\n    var_name = \"PYTEST_CURRENT_TEST\"\n    if when:\n        value = \"{} ({})\".format(item.nodeid, when)\n        # don't allow null bytes on environment variables (see #2644, #2957)\n        value = value.replace(\"\\x00\", \"(null)\")\n        os.environ[var_name] = value\n    else:\n        os.environ.pop(var_name)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_report_teststatus_call_runtest_hook": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_report_teststatus_call_runtest_hook", "embedding": null, "metadata": {"file_path": "src/_pytest/runner.py", "file_name": "runner.py", "file_type": "text/x-python", "category": "implementation", "start_line": 173, "end_line": 223, "span_ids": ["call_and_report", "call_runtest_hook", "check_interactive_exception", "impl:2", "pytest_report_teststatus"], "tokens": 434}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_report_teststatus(report):\n    if report.when in (\"setup\", \"teardown\"):\n        if report.failed:\n            #      category, shortletter, verbose-word\n            return \"error\", \"E\", \"ERROR\"\n        elif report.skipped:\n            return \"skipped\", \"s\", \"SKIPPED\"\n        else:\n            return \"\", \"\", \"\"\n\n\n#\n# Implementation\n\n\ndef call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report\n\n\ndef check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )\n\n\ndef call_runtest_hook(item, when: \"Literal['setup', 'call', 'teardown']\", **kwds):\n    if when == \"setup\":\n        ihook = item.ihook.pytest_runtest_setup\n    elif when == \"call\":\n        ihook = item.ihook.pytest_runtest_call\n    elif when == \"teardown\":\n        ihook = item.ihook.pytest_runtest_teardown\n    else:\n        assert False, \"Unhandled runtest hook case: {}\".format(when)\n    reraise = (Exit,)  # type: Tuple[Type[BaseException], ...]\n    if not item.config.getoption(\"usepdb\", False):\n        reraise += (KeyboardInterrupt,)\n    return CallInfo.from_call(\n        lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_CallInfo_CallInfo.__repr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_CallInfo_CallInfo.__repr__", "embedding": null, "metadata": {"file_path": "src/_pytest/runner.py", "file_name": "runner.py", "file_type": "text/x-python", "category": "implementation", "start_line": 226, "end_line": 282, "span_ids": ["CallInfo", "CallInfo.__repr__", "CallInfo.from_call", "CallInfo.result"], "tokens": 457}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(repr=False)\nclass CallInfo:\n    \"\"\" Result/Exception info a function invocation.\n\n    :param result: The return value of the call, if it didn't raise. Can only be accessed\n        if excinfo is None.\n    :param Optional[ExceptionInfo] excinfo: The captured exception of the call, if it raised.\n    :param float start: The system time when the call started, in seconds since the epoch.\n    :param float stop: The system time when the call ended, in seconds since the epoch.\n    :param float duration: The call duration, in seconds.\n    :param str when: The context of invocation: \"setup\", \"call\", \"teardown\", ...\n    \"\"\"\n\n    _result = attr.ib()\n    excinfo = attr.ib(type=Optional[ExceptionInfo])\n    start = attr.ib(type=float)\n    stop = attr.ib(type=float)\n    duration = attr.ib(type=float)\n    when = attr.ib(type=str)\n\n    @property\n    def result(self):\n        if self.excinfo is not None:\n            raise AttributeError(\"{!r} has no valid result\".format(self))\n        return self._result\n\n    @classmethod\n    def from_call(cls, func, when, reraise=None) -> \"CallInfo\":\n        #: context of invocation: one of \"setup\", \"call\",\n        #: \"teardown\", \"memocollect\"\n        excinfo = None\n        start = time()\n        precise_start = perf_counter()\n        try:\n            result = func()\n        except:  # noqa\n            excinfo = ExceptionInfo.from_current()\n            if reraise is not None and excinfo.errisinstance(reraise):\n                raise\n            result = None\n        # use the perf counter\n        precise_stop = perf_counter()\n        duration = precise_stop - precise_start\n        stop = time()\n        return cls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n        )\n\n    def __repr__(self):\n        if self.excinfo is None:\n            return \"<CallInfo when={!r} result: {!r}>\".format(self.when, self._result)\n        return \"<CallInfo when={!r} excinfo={!r}>\".format(self.when, self.excinfo)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_SetupState_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_SetupState_", "embedding": null, "metadata": {"file_path": "src/_pytest/runner.py", "file_name": "runner.py", "file_type": "text/x-python", "category": "implementation", "start_line": 320, "end_line": 413, "span_ids": ["SetupState", "SetupState.__init__", "SetupState._callfinalizers", "SetupState._pop_and_teardown", "SetupState._teardown_towards", "SetupState._teardown_with_finalization", "SetupState.addfinalizer", "SetupState.prepare", "SetupState.teardown_all", "SetupState.teardown_exact", "collect_one_node"], "tokens": 708}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], None]]]\n\n    def addfinalizer(self, finalizer, colitem):\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)\n\n    def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)\n\n    def _callfinalizers(self, colitem):\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem):\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self):\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem):\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)\n\n    def _teardown_towards(self, needed_collectors):\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def prepare(self, colitem):\n        \"\"\" setup objects along the collector chain to the test-method\n            and teardown previously setup objects.\"\"\"\n        needed_collectors = colitem.listchain()\n        self._teardown_towards(needed_collectors)\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc\n                raise exc\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e\n                raise e\n\n\ndef collect_one_node(collector):\n    ihook = collector.ihook\n    ihook.pytest_collectstart(collector=collector)\n    rep = ihook.pytest_make_collect_report(collector=collector)\n    call = rep.__dict__.pop(\"call\", None)\n    if call and check_interactive_exception(call, rep):\n        ihook.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setuponly.py__show_fixture_action_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setuponly.py__show_fixture_action_", "embedding": null, "metadata": {"file_path": "src/_pytest/setuponly.py", "file_name": "setuponly.py", "file_type": "text/x-python", "category": "implementation", "start_line": 46, "end_line": 81, "span_ids": ["_show_fixture_action", "pytest_cmdline_main"], "tokens": 234}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _show_fixture_action(fixturedef, msg):\n    config = fixturedef._fixturemanager.config\n    capman = config.pluginmanager.getplugin(\"capturemanager\")\n    if capman:\n        capman.suspend_global_capture()\n\n    tw = config.get_terminal_writer()\n    tw.line()\n    tw.write(\" \" * 2 * fixturedef.scopenum)\n    tw.write(\n        \"{step} {scope} {fixture}\".format(\n            step=msg.ljust(8),  # align the output to TEARDOWN\n            scope=fixturedef.scope[0].upper(),\n            fixture=fixturedef.argname,\n        )\n    )\n\n    if msg == \"SETUP\":\n        deps = sorted(arg for arg in fixturedef.argnames if arg != \"request\")\n        if deps:\n            tw.write(\" (fixtures used: {})\".format(\", \".join(deps)))\n\n    if hasattr(fixturedef, \"cached_param\"):\n        tw.write(\"[{}]\".format(fixturedef.cached_param))\n\n    tw.flush()\n\n    if capman:\n        capman.resume_global_capture()\n\n\n@pytest.hookimpl(tryfirst=True)\ndef pytest_cmdline_main(config):\n    if config.option.setuponly:\n        config.option.setupshow = True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setupplan.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setupplan.py__", "embedding": null, "metadata": {"file_path": "src/_pytest/setupplan.py", "file_name": "setupplan.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 29, "span_ids": ["imports", "pytest_addoption", "pytest_cmdline_main", "pytest_fixture_setup"], "tokens": 174}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--setupplan\",\n        \"--setup-plan\",\n        action=\"store_true\",\n        help=\"show what fixtures and tests would be executed but \"\n        \"don't execute anything.\",\n    )\n\n\n@pytest.hookimpl(tryfirst=True)\ndef pytest_fixture_setup(fixturedef, request):\n    # Will return a dummy fixture if the setuponly option is provided.\n    if request.config.option.setupplan:\n        my_cache_key = fixturedef.cache_key(request)\n        fixturedef.cached_result = (None, my_cache_key, None)\n        return fixturedef.cached_result\n\n\n@pytest.hookimpl(tryfirst=True)\ndef pytest_cmdline_main(config):\n    if config.option.setupplan:\n        config.option.setuponly = True\n        config.option.setupshow = True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py_pytest_runtest_setup_check_strict_xfail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py_pytest_runtest_setup_check_strict_xfail", "embedding": null, "metadata": {"file_path": "src/_pytest/skipping.py", "file_name": "skipping.py", "file_type": "text/x-python", "category": "implementation", "start_line": 74, "end_line": 123, "span_ids": ["check_strict_xfail", "check_xfail_no_run", "pytest_pyfunc_call", "pytest_runtest_setup"], "tokens": 445}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item):\n    # Check if skip or skipif are specified as pytest marks\n    item._store[skipped_by_mark_key] = False\n    eval_skipif = MarkEvaluator(item, \"skipif\")\n    if eval_skipif.istrue():\n        item._store[skipped_by_mark_key] = True\n        skip(eval_skipif.getexplanation())\n\n    for skip_info in item.iter_markers(name=\"skip\"):\n        item._store[skipped_by_mark_key] = True\n        if \"reason\" in skip_info.kwargs:\n            skip(skip_info.kwargs[\"reason\"])\n        elif skip_info.args:\n            skip(skip_info.args[0])\n        else:\n            skip(\"unconditional skip\")\n\n    item._store[evalxfail_key] = MarkEvaluator(item, \"xfail\")\n    check_xfail_no_run(item)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pyfunc_call(pyfuncitem):\n    check_xfail_no_run(pyfuncitem)\n    outcome = yield\n    passed = outcome.excinfo is None\n    if passed:\n        check_strict_xfail(pyfuncitem)\n\n\ndef check_xfail_no_run(item):\n    \"\"\"check xfail(run=False)\"\"\"\n    if not item.config.option.runxfail:\n        evalxfail = item._store[evalxfail_key]\n        if evalxfail.istrue():\n            if not evalxfail.get(\"run\", True):\n                xfail(\"[NOTRUN] \" + evalxfail.getexplanation())\n\n\ndef check_strict_xfail(pyfuncitem):\n    \"\"\"check xfail(strict=True) for the given PASSING test\"\"\"\n    evalxfail = pyfuncitem._store[evalxfail_key]\n    if evalxfail.istrue():\n        strict_default = pyfuncitem.config.getini(\"xfail_strict\")\n        is_strict_xfail = evalxfail.get(\"strict\", strict_default)\n        if is_strict_xfail:\n            del pyfuncitem._store[evalxfail_key]\n            explanation = evalxfail.getexplanation()\n            fail(\"[XPASS(strict)] \" + explanation, pytrace=False)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py_pytest_runtest_makereport_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py_pytest_runtest_makereport_", "embedding": null, "metadata": {"file_path": "src/_pytest/skipping.py", "file_name": "skipping.py", "file_type": "text/x-python", "category": "implementation", "start_line": 126, "end_line": 184, "span_ids": ["pytest_report_teststatus", "pytest_runtest_makereport"], "tokens": 522}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    rep = outcome.get_result()\n    evalxfail = item._store.get(evalxfail_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif evalxfail and not rep.skipped and evalxfail.wasvalid() and evalxfail.istrue():\n        if call.excinfo:\n            if evalxfail.invalidraise(call.excinfo.value):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = evalxfail.getexplanation()\n        elif call.when == \"call\":\n            strict_default = item.config.getini(\"xfail_strict\")\n            is_strict_xfail = evalxfail.get(\"strict\", strict_default)\n            explanation = evalxfail.getexplanation()\n            if is_strict_xfail:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] {}\".format(explanation)\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = explanation\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        rep.longrepr = str(filename), line + 1, reason\n\n\n# called by terminalreporter progress reporting\n\n\ndef pytest_report_teststatus(report):\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped:\n            return \"xfailed\", \"x\", \"XFAIL\"\n        elif report.passed:\n            return \"xpassed\", \"X\", \"XPASS\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_pytest_addoption_pytest_addoption.parser_addini_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_pytest_addoption_pytest_addoption.parser_addini_", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 79, "end_line": 171, "span_ids": ["pytest_addoption"], "tokens": 651}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_addoption(parser):\n    group = parser.getgroup(\"terminal reporting\", \"reporting\", after=\"general\")\n    group._addoption(\n        \"-v\",\n        \"--verbose\",\n        action=\"count\",\n        default=0,\n        dest=\"verbose\",\n        help=\"increase verbosity.\",\n    )\n    group._addoption(\n        \"-q\",\n        \"--quiet\",\n        action=MoreQuietAction,\n        default=0,\n        dest=\"verbose\",\n        help=\"decrease verbosity.\",\n    )\n    group._addoption(\n        \"--verbosity\",\n        dest=\"verbose\",\n        type=int,\n        default=0,\n        help=\"set verbosity. Default is 0.\",\n    )\n    group._addoption(\n        \"-r\",\n        action=\"store\",\n        dest=\"reportchars\",\n        default=_REPORTCHARS_DEFAULT,\n        metavar=\"chars\",\n        help=\"show extra test summary info as specified by chars: (f)ailed, \"\n        \"(E)rror, (s)kipped, (x)failed, (X)passed, \"\n        \"(p)assed, (P)assed with output, (a)ll except passed (p/P), or (A)ll. \"\n        \"(w)arnings are enabled by default (see --disable-warnings), \"\n        \"'N' can be used to reset the list. (default: 'fE').\",\n    )\n    group._addoption(\n        \"--disable-warnings\",\n        \"--disable-pytest-warnings\",\n        default=False,\n        dest=\"disable_warnings\",\n        action=\"store_true\",\n        help=\"disable warnings summary\",\n    )\n    group._addoption(\n        \"-l\",\n        \"--showlocals\",\n        action=\"store_true\",\n        dest=\"showlocals\",\n        default=False,\n        help=\"show locals in tracebacks (disabled by default).\",\n    )\n    group._addoption(\n        \"--tb\",\n        metavar=\"style\",\n        action=\"store\",\n        dest=\"tbstyle\",\n        default=\"auto\",\n        choices=[\"auto\", \"long\", \"short\", \"no\", \"line\", \"native\"],\n        help=\"traceback print mode (auto/long/short/line/native/no).\",\n    )\n    group._addoption(\n        \"--show-capture\",\n        action=\"store\",\n        dest=\"showcapture\",\n        choices=[\"no\", \"stdout\", \"stderr\", \"log\", \"all\"],\n        default=\"all\",\n        help=\"Controls how captured stdout/stderr/log is shown on failed tests. \"\n        \"Default is 'all'.\",\n    )\n    group._addoption(\n        \"--fulltrace\",\n        \"--full-trace\",\n        action=\"store_true\",\n        default=False,\n        help=\"don't cut any tracebacks (default is to cut).\",\n    )\n    group._addoption(\n        \"--color\",\n        metavar=\"color\",\n        action=\"store\",\n        dest=\"color\",\n        default=\"auto\",\n        choices=[\"yes\", \"no\", \"auto\"],\n        help=\"color terminal output (yes/no/auto).\",\n    )\n\n    parser.addini(\n        \"console_output_style\",\n        help='console output: \"classic\", or with additional progress information (\"progress\" (percentage) | \"count\").',\n        default=\"progress\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_pytest_configure_pytest_report_teststatus": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_pytest_configure_pytest_report_teststatus", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 174, "end_line": 224, "span_ids": ["getreportopt", "pytest_configure", "pytest_report_teststatus"], "tokens": 372}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_configure(config: Config) -> None:\n    reporter = TerminalReporter(config, sys.stdout)\n    config.pluginmanager.register(reporter, \"terminalreporter\")\n    if config.option.debug or config.option.traceconfig:\n\n        def mywriter(tags, args):\n            msg = \" \".join(map(str, args))\n            reporter.write_line(\"[traceconfig] \" + msg)\n\n        config.trace.root.setprocessor(\"pytest:config\", mywriter)\n\n\ndef getreportopt(config: Config) -> str:\n    reportchars = config.option.reportchars\n\n    old_aliases = {\"F\", \"S\"}\n    reportopts = \"\"\n    for char in reportchars:\n        if char in old_aliases:\n            char = char.lower()\n        if char == \"a\":\n            reportopts = \"sxXEf\"\n        elif char == \"A\":\n            reportopts = \"PpsxXEf\"\n        elif char == \"N\":\n            reportopts = \"\"\n        elif char not in reportopts:\n            reportopts += char\n\n    if not config.option.disable_warnings and \"w\" not in reportopts:\n        reportopts = \"w\" + reportopts\n    elif config.option.disable_warnings and \"w\" in reportopts:\n        reportopts = reportopts.replace(\"w\", \"\")\n\n    return reportopts\n\n\n@pytest.hookimpl(trylast=True)  # after _pytest.runner\ndef pytest_report_teststatus(report: TestReport) -> Tuple[str, str, str]:\n    letter = \"F\"\n    if report.passed:\n        letter = \".\"\n    elif report.skipped:\n        letter = \"s\"\n\n    outcome = report.outcome\n    if report.when in (\"collect\", \"setup\", \"teardown\") and outcome == \"failed\":\n        outcome = \"error\"\n        letter = \"E\"\n\n    return outcome, letter, outcome.upper()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_WarningReport_WarningReport.get_location": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_WarningReport_WarningReport.get_location", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 227, "end_line": 259, "span_ids": ["WarningReport", "WarningReport.get_location"], "tokens": 257}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass WarningReport:\n    \"\"\"\n    Simple structure to hold warnings information captured by ``pytest_warning_captured``.\n\n    :ivar str message: user friendly message about the warning\n    :ivar str|None nodeid: node id that generated the warning (see ``get_location``).\n    :ivar tuple|py.path.local fslocation:\n        file system location of the source of the warning (see ``get_location``).\n    \"\"\"\n\n    message = attr.ib(type=str)\n    nodeid = attr.ib(type=Optional[str], default=None)\n    fslocation = attr.ib(default=None)\n    count_towards_summary = True\n\n    def get_location(self, config):\n        \"\"\"\n        Returns the more user-friendly information about the location\n        of a warning, or None.\n        \"\"\"\n        if self.nodeid:\n            return self.nodeid\n        if self.fslocation:\n            if isinstance(self.fslocation, tuple) and len(self.fslocation) >= 2:\n                filename, linenum = self.fslocation[:2]\n                relpath = py.path.local(filename).relto(config.invocation_dir)\n                if not relpath:\n                    relpath = str(filename)\n                return \"{}:{}\".format(relpath, linenum)\n            else:\n                return str(self.fslocation)\n        return None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.report_collect_TerminalReporter.report_collect.if_self_isatty_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.report_collect_TerminalReporter.report_collect.if_self_isatty_", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 574, "end_line": 612, "span_ids": ["TerminalReporter.report_collect"], "tokens": 313}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d error%s\" % (errors, \"s\" if errors != 1 else \"\")\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_sessionstart_TerminalReporter.pytest_sessionstart.self__write_report_lines_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_sessionstart_TerminalReporter.pytest_sessionstart.self__write_report_lines_", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 614, "end_line": 640, "span_ids": ["TerminalReporter.pytest_sessionstart"], "tokens": 253}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session: Session) -> None:\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        pypy_version_info = getattr(sys, \"pypy_version_info\", None)\n        if pypy_version_info:\n            verinfo = \".\".join(map(str, pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._write_report_lines_from_hooks_TerminalReporter.pytest_collection_finish": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._write_report_lines_from_hooks_TerminalReporter.pytest_collection_finish", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 642, "end_line": 680, "span_ids": ["TerminalReporter._write_report_lines_from_hooks", "TerminalReporter.pytest_collection_finish", "TerminalReporter.pytest_report_header"], "tokens": 305}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            failed = self.stats.get(\"failed\")\n            if failed:\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in failed:\n                    rep.toterminal(self._tw)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._printcollecteditems_TerminalReporter._printcollecteditems.for_item_in_items_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._printcollecteditems_TerminalReporter._printcollecteditems.for_item_in_items_", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 682, "end_line": 720, "span_ids": ["TerminalReporter._printcollecteditems"], "tokens": 334}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}  # type: Dict[str, int]\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    try:\n                        obj = col.obj  # type: ignore\n                    except AttributeError:\n                        continue\n                    doc = inspect.getdoc(obj)\n                    if doc:\n                        for line in doc.splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_sessionfinish_TerminalReporter.getreports": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_sessionfinish_TerminalReporter.getreports", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 722, "end_line": 824, "span_ids": ["TerminalReporter._getcrashline", "TerminalReporter._getfailureheadline", "TerminalReporter._locationline", "TerminalReporter._report_keyboardinterrupt", "TerminalReporter.getreports", "TerminalReporter.pytest_keyboard_interrupt", "TerminalReporter.pytest_sessionfinish", "TerminalReporter.pytest_terminal_summary", "TerminalReporter.pytest_unconfigure", "TerminalReporter:2"], "tokens": 737}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, session: Session, exitstatus: ExitCode):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if session.shouldfail:\n            self.write_sep(\"!\", session.shouldfail, red=True)\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        elif session.shouldstop:\n            self.write_sep(\"!\", session.shouldstop, red=True)\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_warnings_TerminalReporter.summary_warnings.if_self_hasopt_w_.self__tw_line_Docs_h": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_warnings_TerminalReporter.summary_warnings.if_self_hasopt_w_.self__tw_line_Docs_h", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 826, "end_line": 881, "span_ids": ["TerminalReporter.summary_warnings"], "tokens": 443}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\n                \"warnings\"\n            )  # type: Optional[List[WarningReport]]\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = (\n                order_preserving_dict()\n            )  # type: Dict[str, List[WarningReport]]\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            def collapsed_location_report(reports: List[WarningReport]):\n                locations = []\n                for w in reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        locations.append(location)\n\n                if len(locations) < 10:\n                    return \"\\n\".join(map(str, locations))\n\n                counts_by_filename = order_preserving_dict()  # type: Dict[str, int]\n                for loc in locations:\n                    key = str(loc).split(\"::\", 1)[0]\n                    counts_by_filename[key] = counts_by_filename.get(key, 0) + 1\n                return \"\\n\".join(\n                    \"{}: {} warning{}\".format(k, v, \"s\" if v > 1 else \"\")\n                    for k, v in counts_by_filename.items()\n                )\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, message_reports in reports_grouped_by_message.items():\n                maybe_location = collapsed_location_report(message_reports)\n                if maybe_location:\n                    self._tw.line(maybe_location)\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.short_test_summary_TerminalReporter.short_test_summary.if_lines_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.short_test_summary_TerminalReporter.short_test_summary.if_lines_", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1003, "end_line": 1070, "span_ids": ["TerminalReporter.short_test_summary"], "tokens": 580}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def short_test_summary(self) -> None:\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines: List[str]) -> None:\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self._tw.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines: List[str]) -> None:\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines: List[str]) -> None:\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines: List[str]) -> None:\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(self.startdir, skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }  # type: Mapping[str, Callable[[List[str]], None]]\n\n        lines = []  # type: List[str]\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempPathFactory.getbasetemp_TempPathFactory.getbasetemp": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempPathFactory.getbasetemp_TempPathFactory.getbasetemp", "embedding": null, "metadata": {"file_path": "src/_pytest/tmpdir.py", "file_name": "tmpdir.py", "file_type": "text/x-python", "category": "implementation", "start_line": 80, "end_line": 103, "span_ids": ["TempPathFactory.getbasetemp"], "tokens": 247}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass TempPathFactory:\n\n    def getbasetemp(self) -> Path:\n        \"\"\" return base temporary directory. \"\"\"\n        if self._basetemp is not None:\n            return self._basetemp\n\n        if self._given_basetemp is not None:\n            basetemp = self._given_basetemp\n            ensure_reset_dir(basetemp)\n            basetemp = basetemp.resolve()\n        else:\n            from_env = os.environ.get(\"PYTEST_DEBUG_TEMPROOT\")\n            temproot = Path(from_env or tempfile.gettempdir()).resolve()\n            user = get_user() or \"unknown\"\n            # use a sub-directory in the temproot to speed-up\n            # make_numbered_dir() call\n            rootdir = temproot.joinpath(\"pytest-of-{}\".format(user))\n            rootdir.mkdir(exist_ok=True)\n            basetemp = make_numbered_dir_with_cleanup(\n                prefix=\"pytest-\", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT\n            )\n        assert basetemp is not None, basetemp\n        self._basetemp = t = basetemp\n        self._trace(\"new basetemp\", t)\n        return t", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_pytest_runtest_makereport_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_pytest_runtest_makereport_", "embedding": null, "metadata": {"file_path": "src/_pytest/unittest.py", "file_name": "unittest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 223, "end_line": 283, "span_ids": ["check_testcase_implements_trial_reporter", "impl", "pytest_runtest_makereport", "pytest_runtest_protocol"], "tokens": 411}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookimpl(tryfirst=True)\ndef pytest_runtest_makereport(item, call):\n    if isinstance(item, TestCaseFunction):\n        if item._excinfo:\n            call.excinfo = item._excinfo.pop(0)\n            try:\n                del call.result\n            except AttributeError:\n                pass\n\n    unittest = sys.modules.get(\"unittest\")\n    if unittest and call.excinfo and call.excinfo.errisinstance(unittest.SkipTest):\n        # let's substitute the excinfo with a pytest.skip one\n        call2 = CallInfo.from_call(\n            lambda: pytest.skip(str(call.excinfo.value)), call.when\n        )\n        call.excinfo = call2.excinfo\n\n\n# twisted trial support\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_runtest_protocol(item):\n    if isinstance(item, TestCaseFunction) and \"twisted.trial.unittest\" in sys.modules:\n        ut = sys.modules[\"twisted.python.failure\"]\n        Failure__init__ = ut.Failure.__init__\n        check_testcase_implements_trial_reporter()\n\n        def excstore(\n            self, exc_value=None, exc_type=None, exc_tb=None, captureVars=None\n        ):\n            if exc_value is None:\n                self._rawexcinfo = sys.exc_info()\n            else:\n                if exc_type is None:\n                    exc_type = type(exc_value)\n                self._rawexcinfo = (exc_type, exc_value, exc_tb)\n            try:\n                Failure__init__(\n                    self, exc_value, exc_type, exc_tb, captureVars=captureVars\n                )\n            except TypeError:\n                Failure__init__(self, exc_value, exc_type, exc_tb)\n\n        ut.Failure.__init__ = excstore\n        yield\n        ut.Failure.__init__ = Failure__init__\n    else:\n        yield\n\n\ndef check_testcase_implements_trial_reporter(done=[]):\n    if done:\n        return\n    from zope.interface import classImplements\n    from twisted.trial.itrial import IReporter\n\n    classImplements(TestCaseFunction, IReporter)\n    done.append(1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_early_load_setuptools_name_TestGeneralUsage.test_early_load_setuptools_name.if_load_cov_early_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_early_load_setuptools_name_TestGeneralUsage.test_early_load_setuptools_name.if_load_cov_early_", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 108, "end_line": 150, "span_ids": ["TestGeneralUsage.test_early_load_setuptools_name"], "tokens": 307}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGeneralUsage:\n\n    @pytest.mark.parametrize(\"load_cov_early\", [True, False])\n    def test_early_load_setuptools_name(self, testdir, monkeypatch, load_cov_early):\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n\n        testdir.makepyfile(mytestplugin1_module=\"\")\n        testdir.makepyfile(mytestplugin2_module=\"\")\n        testdir.makepyfile(mycov_module=\"\")\n        testdir.syspathinsert()\n\n        loaded = []\n\n        @attr.s\n        class DummyEntryPoint:\n            name = attr.ib()\n            module = attr.ib()\n            group = \"pytest11\"\n\n            def load(self):\n                __import__(self.module)\n                loaded.append(self.name)\n                return sys.modules[self.module]\n\n        entry_points = [\n            DummyEntryPoint(\"myplugin1\", \"mytestplugin1_module\"),\n            DummyEntryPoint(\"myplugin2\", \"mytestplugin2_module\"),\n            DummyEntryPoint(\"mycov\", \"mycov_module\"),\n        ]\n\n        @attr.s\n        class DummyDist:\n            entry_points = attr.ib()\n            files = ()\n\n        def my_dists():\n            return (DummyDist(entry_points),)\n\n        monkeypatch.setattr(importlib_metadata, \"distributions\", my_dists)\n        params = (\"-p\", \"mycov\") if load_cov_early else ()\n        testdir.runpytest_inprocess(*params)\n        if load_cov_early:\n            assert loaded == [\"mycov\", \"myplugin1\", \"myplugin2\"]\n        else:\n            assert loaded == [\"myplugin1\", \"myplugin2\", \"mycov\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_assertion_magic_TestGeneralUsage.test_not_collectable_arguments": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_assertion_magic_TestGeneralUsage.test_not_collectable_arguments", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 152, "end_line": 193, "span_ids": ["TestGeneralUsage.test_assertion_magic", "TestGeneralUsage.test_nested_import_error", "TestGeneralUsage.test_not_collectable_arguments"], "tokens": 292}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGeneralUsage:\n\n    def test_assertion_magic(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_this():\n                x = 0\n                assert x\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\">       assert x\", \"E       assert 0\"])\n        assert result.ret == 1\n\n    def test_nested_import_error(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n                import import_fails\n                def test_this():\n                    assert import_fails.a == 1\n        \"\"\"\n        )\n        testdir.makepyfile(import_fails=\"import does_not_work\")\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"ImportError while importing test module*\",\n                \"*No module named *does_not_work*\",\n            ]\n        )\n        assert result.ret == 2\n\n    def test_not_collectable_arguments(self, testdir):\n        p1 = testdir.makepyfile(\"\")\n        p2 = testdir.makefile(\".pyc\", \"123\")\n        result = testdir.runpytest(p1, p2)\n        assert result.ret == ExitCode.USAGE_ERROR\n        result.stderr.fnmatch_lines(\n            [\n                \"ERROR: not found: {}\".format(p2),\n                \"(no name {!r} in any of [[][]])\".format(str(p2)),\n                \"\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_early_skip_TestGeneralUsage.test_directory_skipped": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_early_skip_TestGeneralUsage.test_directory_skipped", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 227, "end_line": 318, "span_ids": ["TestGeneralUsage.test_chdir", "TestGeneralUsage.test_conftest_printing_shows_if_error", "TestGeneralUsage.test_directory_skipped", "TestGeneralUsage.test_early_skip", "TestGeneralUsage.test_issue109_sibling_conftests_not_loaded", "TestGeneralUsage.test_issue88_initial_file_multinodes", "TestGeneralUsage.test_issue93_initialnode_importing_capturing"], "tokens": 723}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGeneralUsage:\n\n    @pytest.mark.filterwarnings(\"ignore::pytest.PytestDeprecationWarning\")\n    def test_early_skip(self, testdir):\n        testdir.mkdir(\"xyz\")\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_collect_directory():\n                pytest.skip(\"early\")\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.fnmatch_lines([\"*1 skip*\"])\n\n    def test_issue88_initial_file_multinodes(self, testdir):\n        testdir.copy_example(\"issue88_initial_file_multinodes\")\n        p = testdir.makepyfile(\"def test_hello(): pass\")\n        result = testdir.runpytest(p, \"--collect-only\")\n        result.stdout.fnmatch_lines([\"*MyFile*test_issue88*\", \"*Module*test_issue88*\"])\n\n    def test_issue93_initialnode_importing_capturing(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import sys\n            print(\"should not be seen\")\n            sys.stderr.write(\"stder42\\\\n\")\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.no_fnmatch_line(\"*should not be seen*\")\n        assert \"stderr42\" not in result.stderr.str()\n\n    def test_conftest_printing_shows_if_error(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            print(\"should be seen\")\n            assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret != 0\n        assert \"should be seen\" in result.stdout.str()\n\n    @pytest.mark.skipif(\n        not hasattr(py.path.local, \"mksymlinkto\"),\n        reason=\"symlink not available on this platform\",\n    )\n    def test_chdir(self, testdir):\n        testdir.tmpdir.join(\"py\").mksymlinkto(py._pydir)\n        p = testdir.tmpdir.join(\"main.py\")\n        p.write(\n            textwrap.dedent(\n                \"\"\"\\\n                import sys, os\n                sys.path.insert(0, '')\n                import py\n                print(py.__file__)\n                print(py.__path__)\n                os.chdir(os.path.dirname(os.getcwd()))\n                print(py.log)\n                \"\"\"\n            )\n        )\n        result = testdir.runpython(p)\n        assert not result.ret\n\n    def test_issue109_sibling_conftests_not_loaded(self, testdir):\n        sub1 = testdir.mkdir(\"sub1\")\n        sub2 = testdir.mkdir(\"sub2\")\n        sub1.join(\"conftest.py\").write(\"assert 0\")\n        result = testdir.runpytest(sub2)\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        sub2.ensure(\"__init__.py\")\n        p = sub2.ensure(\"test_hello.py\")\n        result = testdir.runpytest(p)\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result = testdir.runpytest(sub1)\n        assert result.ret == ExitCode.USAGE_ERROR\n\n    def test_directory_skipped(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_ignore_collect():\n                pytest.skip(\"intentional\")\n        \"\"\"\n        )\n        testdir.makepyfile(\"def test_hello(): pass\")\n        result = testdir.runpytest()\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.fnmatch_lines([\"*1 skipped*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_multiple_items_per_collector_byid_TestGeneralUsage.test_issue134_report_error_when_collecting_member": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_multiple_items_per_collector_byid_TestGeneralUsage.test_issue134_report_error_when_collecting_member", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 312, "end_line": 404, "span_ids": ["TestGeneralUsage.test_direct_addressing_notfound", "TestGeneralUsage.test_direct_addressing_selects", "TestGeneralUsage.test_docstring_on_hookspec", "TestGeneralUsage.test_initialization_error_issue49", "TestGeneralUsage.test_issue134_report_error_when_collecting_member", "TestGeneralUsage.test_multiple_items_per_collector_byid", "TestGeneralUsage.test_skip_on_generated_funcarg_id"], "tokens": 703}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGeneralUsage:\n\n    def test_multiple_items_per_collector_byid(self, testdir):\n        c = testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class MyItem(pytest.Item):\n                def runtest(self):\n                    pass\n            class MyCollector(pytest.File):\n                def collect(self):\n                    return [MyItem(name=\"xyz\", parent=self)]\n            def pytest_collect_file(path, parent):\n                if path.basename.startswith(\"conftest\"):\n                    return MyCollector(path, parent)\n        \"\"\"\n        )\n        result = testdir.runpytest(c.basename + \"::\" + \"xyz\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 pass*\"])\n\n    def test_skip_on_generated_funcarg_id(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('x', [3], ids=['hello-123'])\n            def pytest_runtest_setup(item):\n                print(item.keywords)\n                if 'hello-123' in item.keywords:\n                    pytest.skip(\"hello\")\n                assert 0\n        \"\"\"\n        )\n        p = testdir.makepyfile(\"\"\"def test_func(x): pass\"\"\")\n        res = testdir.runpytest(p)\n        assert res.ret == 0\n        res.stdout.fnmatch_lines([\"*1 skipped*\"])\n\n    def test_direct_addressing_selects(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('i', [1, 2], ids=[\"1\", \"2\"])\n            def test_func(i):\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest(p.basename + \"::\" + \"test_func[1]\")\n        assert res.ret == 0\n        res.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_direct_addressing_notfound(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_func():\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest(p.basename + \"::\" + \"test_notfound\")\n        assert res.ret\n        res.stderr.fnmatch_lines([\"*ERROR*not found*\"])\n\n    def test_docstring_on_hookspec(self):\n        from _pytest import hookspec\n\n        for name, value in vars(hookspec).items():\n            if name.startswith(\"pytest_\"):\n                assert value.__doc__, \"no docstring for %s\" % name\n\n    def test_initialization_error_issue49(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_configure():\n                x\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 3  # internal error\n        result.stderr.fnmatch_lines([\"INTERNAL*pytest_configure*\", \"INTERNAL*x*\"])\n        assert \"sessionstarttime\" not in result.stderr.str()\n\n    @pytest.mark.parametrize(\"lookfor\", [\"test_fun.py::test_a\"])\n    def test_issue134_report_error_when_collecting_member(self, testdir, lookfor):\n        testdir.makepyfile(\n            test_fun=\"\"\"\n            def test_a():\n                pass\n            def\"\"\"\n        )\n        result = testdir.runpytest(lookfor)\n        result.stdout.fnmatch_lines([\"*SyntaxError*\"])\n        if \"::\" in lookfor:\n            result.stderr.fnmatch_lines([\"*ERROR*\"])\n            assert result.ret == 4  # usage error only if item not found", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_report_all_failed_collections_initargs_TestGeneralUsage.test_parametrized_with_null_bytes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_report_all_failed_collections_initargs_TestGeneralUsage.test_parametrized_with_null_bytes", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 414, "end_line": 523, "span_ids": ["TestGeneralUsage.test_getsourcelines_error_issue553", "TestGeneralUsage.test_namespace_import_doesnt_confuse_import_hook", "TestGeneralUsage.test_parametrized_with_bytes_regex", "TestGeneralUsage.test_parametrized_with_null_bytes", "TestGeneralUsage.test_plugins_given_as_strings", "TestGeneralUsage.test_report_all_failed_collections_initargs", "TestGeneralUsage.test_unknown_option"], "tokens": 848}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGeneralUsage:\n\n    def test_report_all_failed_collections_initargs(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            from _pytest.config import ExitCode\n\n            def pytest_sessionfinish(exitstatus):\n                assert exitstatus == ExitCode.USAGE_ERROR\n                print(\"pytest_sessionfinish_called\")\n            \"\"\"\n        )\n        testdir.makepyfile(test_a=\"def\", test_b=\"def\")\n        result = testdir.runpytest(\"test_a.py::a\", \"test_b.py::b\")\n        result.stderr.fnmatch_lines([\"*ERROR*test_a.py::a*\", \"*ERROR*test_b.py::b*\"])\n        result.stdout.fnmatch_lines([\"pytest_sessionfinish_called\"])\n        assert result.ret == ExitCode.USAGE_ERROR\n\n    @pytest.mark.usefixtures(\"recwarn\")\n    def test_namespace_import_doesnt_confuse_import_hook(self, testdir):\n        \"\"\"\n        Ref #383. Python 3.3's namespace package messed with our import hooks\n        Importing a module that didn't exist, even if the ImportError was\n        gracefully handled, would make our test crash.\n\n        Use recwarn here to silence this warning in Python 2.7:\n            ImportWarning: Not importing directory '...\\not_a_package': missing __init__.py\n        \"\"\"\n        testdir.mkdir(\"not_a_package\")\n        p = testdir.makepyfile(\n            \"\"\"\n            try:\n                from not_a_package import doesnt_exist\n            except ImportError:\n                # We handle the import error gracefully here\n                pass\n\n            def test_whatever():\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest(p.basename)\n        assert res.ret == 0\n\n    def test_unknown_option(self, testdir):\n        result = testdir.runpytest(\"--qwlkej\")\n        result.stderr.fnmatch_lines(\n            \"\"\"\n            *unrecognized*\n        \"\"\"\n        )\n\n    def test_getsourcelines_error_issue553(self, testdir, monkeypatch):\n        monkeypatch.setattr(\"inspect.getsourcelines\", None)\n        p = testdir.makepyfile(\n            \"\"\"\n            def raise_error(obj):\n                raise OSError('source code not available')\n\n            import inspect\n            inspect.getsourcelines = raise_error\n\n            def test_foo(invalid_fixture):\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest(p)\n        res.stdout.fnmatch_lines(\n            [\"*source code not available*\", \"E*fixture 'invalid_fixture' not found\"]\n        )\n\n    def test_plugins_given_as_strings(self, tmpdir, monkeypatch, _sys_snapshot):\n        \"\"\"test that str values passed to main() as `plugins` arg\n        are interpreted as module names to be imported and registered.\n        #855.\n        \"\"\"\n        with pytest.raises(ImportError) as excinfo:\n            pytest.main([str(tmpdir)], plugins=[\"invalid.module\"])\n        assert \"invalid\" in str(excinfo.value)\n\n        p = tmpdir.join(\"test_test_plugins_given_as_strings.py\")\n        p.write(\"def test_foo(): pass\")\n        mod = types.ModuleType(\"myplugin\")\n        monkeypatch.setitem(sys.modules, \"myplugin\", mod)\n        assert pytest.main(args=[str(tmpdir)], plugins=[\"myplugin\"]) == 0\n\n    def test_parametrized_with_bytes_regex(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import re\n            import pytest\n            @pytest.mark.parametrize('r', [re.compile(b'foo')])\n            def test_stuff(r):\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest(p)\n        res.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_parametrized_with_null_bytes(self, testdir):\n        \"\"\"Test parametrization with values that contain null bytes and unicode characters (#2644, #2957)\"\"\"\n        p = testdir.makepyfile(\n            \"\"\"\\\n            import pytest\n\n            @pytest.mark.parametrize(\"data\", [b\"\\\\x00\", \"\\\\x00\", 'a\u00e7\u00e3o'])\n            def test_foo(data):\n                assert data\n            \"\"\"\n        )\n        res = testdir.runpytest(p)\n        res.assert_outcomes(passed=3)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants_TestInvocationVariants.test_invoke_plugin_api": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants_TestInvocationVariants.test_invoke_plugin_api", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 526, "end_line": 629, "span_ids": ["TestInvocationVariants", "TestInvocationVariants.test_double_pytestcmdline", "TestInvocationVariants.test_earlyinit", "TestInvocationVariants.test_equivalence_pytest_pytest", "TestInvocationVariants.test_import_star_py_dot_test", "TestInvocationVariants.test_import_star_pytest", "TestInvocationVariants.test_invoke_plugin_api", "TestInvocationVariants.test_invoke_with_invalid_type", "TestInvocationVariants.test_invoke_with_path", "TestInvocationVariants.test_pydoc", "TestInvocationVariants.test_python_minus_m_invocation_fail", "TestInvocationVariants.test_python_minus_m_invocation_ok", "TestInvocationVariants.test_python_pytest_package"], "tokens": 715}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestInvocationVariants:\n    def test_earlyinit(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            assert hasattr(pytest, 'mark')\n        \"\"\"\n        )\n        result = testdir.runpython(p)\n        assert result.ret == 0\n\n    def test_pydoc(self, testdir):\n        for name in (\"py.test\", \"pytest\"):\n            result = testdir.runpython_c(\"import {};help({})\".format(name, name))\n            assert result.ret == 0\n            s = result.stdout.str()\n            assert \"MarkGenerator\" in s\n\n    def test_import_star_py_dot_test(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            from py.test import *\n            #collect\n            #cmdline\n            #Item\n            # assert collect.Item is Item\n            # assert collect.Collector is Collector\n            main\n            skip\n            xfail\n        \"\"\"\n        )\n        result = testdir.runpython(p)\n        assert result.ret == 0\n\n    def test_import_star_pytest(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            from pytest import *\n            #Item\n            #File\n            main\n            skip\n            xfail\n        \"\"\"\n        )\n        result = testdir.runpython(p)\n        assert result.ret == 0\n\n    def test_double_pytestcmdline(self, testdir):\n        p = testdir.makepyfile(\n            run=\"\"\"\n            import pytest\n            pytest.main()\n            pytest.main()\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_hello():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpython(p)\n        result.stdout.fnmatch_lines([\"*1 passed*\", \"*1 passed*\"])\n\n    def test_python_minus_m_invocation_ok(self, testdir):\n        p1 = testdir.makepyfile(\"def test_hello(): pass\")\n        res = testdir.run(sys.executable, \"-m\", \"pytest\", str(p1))\n        assert res.ret == 0\n\n    def test_python_minus_m_invocation_fail(self, testdir):\n        p1 = testdir.makepyfile(\"def test_fail(): 0/0\")\n        res = testdir.run(sys.executable, \"-m\", \"pytest\", str(p1))\n        assert res.ret == 1\n\n    def test_python_pytest_package(self, testdir):\n        p1 = testdir.makepyfile(\"def test_pass(): pass\")\n        res = testdir.run(sys.executable, \"-m\", \"pytest\", str(p1))\n        assert res.ret == 0\n        res.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_equivalence_pytest_pytest(self):\n        assert pytest.main == py.test.cmdline.main\n\n    def test_invoke_with_invalid_type(self):\n        with pytest.raises(\n            TypeError, match=\"expected to be a list of strings, got: '-h'\"\n        ):\n            pytest.main(\"-h\")\n\n    def test_invoke_with_path(self, tmpdir, capsys):\n        retcode = pytest.main(tmpdir)\n        assert retcode == ExitCode.NO_TESTS_COLLECTED\n        out, err = capsys.readouterr()\n\n    def test_invoke_plugin_api(self, capsys):\n        class MyPlugin:\n            def pytest_addoption(self, parser):\n                parser.addoption(\"--myopt\")\n\n        pytest.main([\"-h\"], plugins=[MyPlugin()])\n        out, err = capsys.readouterr()\n        assert \"--myopt\" in out", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_namespace_package_TestInvocationVariants.test_invoke_test_and_doctestmodules": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_namespace_package_TestInvocationVariants.test_invoke_test_and_doctestmodules", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 681, "end_line": 755, "span_ids": ["TestInvocationVariants.test_cmdline_python_namespace_package", "TestInvocationVariants.test_invoke_test_and_doctestmodules"], "tokens": 572}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestInvocationVariants:\n\n    def test_cmdline_python_namespace_package(self, testdir, monkeypatch):\n        \"\"\"\n        test --pyargs option with namespace packages (#1567)\n\n        Ref: https://packaging.python.org/guides/packaging-namespace-packages/\n        \"\"\"\n        monkeypatch.delenv(\"PYTHONDONTWRITEBYTECODE\", raising=False)\n\n        search_path = []\n        for dirname in \"hello\", \"world\":\n            d = testdir.mkdir(dirname)\n            search_path.append(d)\n            ns = d.mkdir(\"ns_pkg\")\n            ns.join(\"__init__.py\").write(\n                \"__import__('pkg_resources').declare_namespace(__name__)\"\n            )\n            lib = ns.mkdir(dirname)\n            lib.ensure(\"__init__.py\")\n            lib.join(\"test_{}.py\".format(dirname)).write(\n                \"def test_{}(): pass\\ndef test_other():pass\".format(dirname)\n            )\n\n        # The structure of the test directory is now:\n        # .\n        # \u251c\u2500\u2500 hello\n        # \u2502   \u2514\u2500\u2500 ns_pkg\n        # \u2502       \u251c\u2500\u2500 __init__.py\n        # \u2502       \u2514\u2500\u2500 hello\n        # \u2502           \u251c\u2500\u2500 __init__.py\n        # \u2502           \u2514\u2500\u2500 test_hello.py\n        # \u2514\u2500\u2500 world\n        #     \u2514\u2500\u2500 ns_pkg\n        #         \u251c\u2500\u2500 __init__.py\n        #         \u2514\u2500\u2500 world\n        #             \u251c\u2500\u2500 __init__.py\n        #             \u2514\u2500\u2500 test_world.py\n\n        # NOTE: the different/reversed ordering is intentional here.\n        monkeypatch.setenv(\"PYTHONPATH\", prepend_pythonpath(*search_path))\n        for p in search_path:\n            monkeypatch.syspath_prepend(p)\n\n        # mixed module and filenames:\n        monkeypatch.chdir(\"world\")\n        result = testdir.runpytest(\"--pyargs\", \"-v\", \"ns_pkg.hello\", \"ns_pkg/world\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines(\n            [\n                \"test_hello.py::test_hello*PASSED*\",\n                \"test_hello.py::test_other*PASSED*\",\n                \"ns_pkg/world/test_world.py::test_world*PASSED*\",\n                \"ns_pkg/world/test_world.py::test_other*PASSED*\",\n                \"*4 passed in*\",\n            ]\n        )\n\n        # specify tests within a module\n        testdir.chdir()\n        result = testdir.runpytest(\n            \"--pyargs\", \"-v\", \"ns_pkg.world.test_world::test_other\"\n        )\n        assert result.ret == 0\n        result.stdout.fnmatch_lines(\n            [\"*test_world.py::test_other*PASSED*\", \"*1 passed*\"]\n        )\n\n    def test_invoke_test_and_doctestmodules(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def test():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(str(p) + \"::test\", \"--doctest-modules\")\n        result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_symlink_TestInvocationVariants.test_cmdline_python_package_symlink.if_hasattr_py_path_local_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_symlink_TestInvocationVariants.test_cmdline_python_package_symlink.if_hasattr_py_path_local_", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 765, "end_line": 837, "span_ids": ["TestInvocationVariants.test_cmdline_python_package_symlink"], "tokens": 578}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestInvocationVariants:\n\n    def test_cmdline_python_package_symlink(self, testdir, monkeypatch):\n        \"\"\"\n        test --pyargs option with packages with path containing symlink can\n        have conftest.py in their package (#2985)\n        \"\"\"\n        # dummy check that we can actually create symlinks: on Windows `os.symlink` is available,\n        # but normal users require special admin privileges to create symlinks.\n        if sys.platform == \"win32\":\n            try:\n                os.symlink(\n                    str(testdir.tmpdir.ensure(\"tmpfile\")),\n                    str(testdir.tmpdir.join(\"tmpfile2\")),\n                )\n            except OSError as e:\n                pytest.skip(str(e.args[0]))\n        monkeypatch.delenv(\"PYTHONDONTWRITEBYTECODE\", raising=False)\n\n        dirname = \"lib\"\n        d = testdir.mkdir(dirname)\n        foo = d.mkdir(\"foo\")\n        foo.ensure(\"__init__.py\")\n        lib = foo.mkdir(\"bar\")\n        lib.ensure(\"__init__.py\")\n        lib.join(\"test_bar.py\").write(\n            \"def test_bar(): pass\\ndef test_other(a_fixture):pass\"\n        )\n        lib.join(\"conftest.py\").write(\n            \"import pytest\\n@pytest.fixture\\ndef a_fixture():pass\"\n        )\n\n        d_local = testdir.mkdir(\"local\")\n        symlink_location = os.path.join(str(d_local), \"lib\")\n        os.symlink(str(d), symlink_location, target_is_directory=True)\n\n        # The structure of the test directory is now:\n        # .\n        # \u251c\u2500\u2500 local\n        # \u2502   \u2514\u2500\u2500 lib -> ../lib\n        # \u2514\u2500\u2500 lib\n        #     \u2514\u2500\u2500 foo\n        #         \u251c\u2500\u2500 __init__.py\n        #         \u2514\u2500\u2500 bar\n        #             \u251c\u2500\u2500 __init__.py\n        #             \u251c\u2500\u2500 conftest.py\n        #             \u2514\u2500\u2500 test_bar.py\n\n        # NOTE: the different/reversed ordering is intentional here.\n        search_path = [\"lib\", os.path.join(\"local\", \"lib\")]\n        monkeypatch.setenv(\"PYTHONPATH\", prepend_pythonpath(*search_path))\n        for p in search_path:\n            monkeypatch.syspath_prepend(p)\n\n        # module picked up in symlink-ed directory:\n        # It picks up local/lib/foo/bar (symlink) via sys.path.\n        result = testdir.runpytest(\"--pyargs\", \"-v\", \"foo.bar\")\n        testdir.chdir()\n        assert result.ret == 0\n        if hasattr(py.path.local, \"mksymlinkto\"):\n            result.stdout.fnmatch_lines(\n                [\n                    \"lib/foo/bar/test_bar.py::test_bar PASSED*\",\n                    \"lib/foo/bar/test_bar.py::test_other PASSED*\",\n                    \"*2 passed*\",\n                ]\n            )\n        else:\n            result.stdout.fnmatch_lines(\n                [\n                    \"*lib/foo/bar/test_bar.py::test_bar PASSED*\",\n                    \"*lib/foo/bar/test_bar.py::test_other PASSED*\",\n                    \"*2 passed*\",\n                ]\n            )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestDurations_TestDurations.test_with_not": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestDurations_TestDurations.test_with_not", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 914, "end_line": 1003, "span_ids": ["TestDurations", "TestDurations.test_calls", "TestDurations.test_calls_show_2", "TestDurations.test_calls_showall", "TestDurations.test_calls_showall_verbose", "TestDurations.test_with_deselected", "TestDurations.test_with_failing_collection", "TestDurations.test_with_not"], "tokens": 750}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDurations:\n    source = \"\"\"\n        import time\n        def test_something():\n            pass\n        def test_2():\n            time.sleep(0.010)\n        def test_1():\n            time.sleep(0.002)\n        def test_3():\n            time.sleep(0.020)\n    \"\"\"\n\n    def test_calls(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        result = testdir.runpytest_inprocess(\"--durations=10\")\n        assert result.ret == 0\n\n        result.stdout.fnmatch_lines_random(\n            [\"*durations*\", \"*call*test_3*\", \"*call*test_2*\"]\n        )\n\n        result.stdout.fnmatch_lines(\n            [\"(8 durations < 0.005s hidden.  Use -vv to show these durations.)\"]\n        )\n\n    def test_calls_show_2(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        result = testdir.runpytest_inprocess(\"--durations=2\")\n        assert result.ret == 0\n\n        lines = result.stdout.get_lines_after(\"*slowest*durations*\")\n        assert \"4 passed\" in lines[2]\n\n    def test_calls_showall(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        result = testdir.runpytest_inprocess(\"--durations=0\")\n        assert result.ret == 0\n\n        tested = \"3\"\n        for x in tested:\n            for y in (\"call\",):  # 'setup', 'call', 'teardown':\n                for line in result.stdout.lines:\n                    if (\"test_%s\" % x) in line and y in line:\n                        break\n                else:\n                    raise AssertionError(\"not found {} {}\".format(x, y))\n\n    def test_calls_showall_verbose(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        result = testdir.runpytest_inprocess(\"--durations=0\", \"-vv\")\n        assert result.ret == 0\n\n        for x in \"123\":\n            for y in (\"call\",):  # 'setup', 'call', 'teardown':\n                for line in result.stdout.lines:\n                    if (\"test_%s\" % x) in line and y in line:\n                        break\n                else:\n                    raise AssertionError(\"not found {} {}\".format(x, y))\n\n    def test_with_deselected(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        result = testdir.runpytest_inprocess(\"--durations=2\", \"-k test_3\")\n        assert result.ret == 0\n\n        result.stdout.fnmatch_lines([\"*durations*\", \"*call*test_3*\"])\n\n    def test_with_failing_collection(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        testdir.makepyfile(test_collecterror=\"\"\"xyz\"\"\")\n        result = testdir.runpytest_inprocess(\"--durations=2\", \"-k test_1\")\n        assert result.ret == 2\n\n        result.stdout.fnmatch_lines([\"*Interrupted: 1 error during collection*\"])\n        # Collection errors abort test execution, therefore no duration is\n        # output\n        result.stdout.no_fnmatch_line(\"*duration*\")\n\n    def test_with_not(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        result = testdir.runpytest_inprocess(\"-k not 1\")\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_fixture_values_leak_test_fixture_values_leak.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_fixture_values_leak_test_fixture_values_leak.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1066, "end_line": 1111, "span_ids": ["test_fixture_values_leak"], "tokens": 290}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fixture_values_leak(testdir):\n    \"\"\"Ensure that fixture objects are properly destroyed by the garbage collector at the end of their expected\n    life-times (#2981).\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import attr\n        import gc\n        import pytest\n        import weakref\n\n        @attr.s\n        class SomeObj(object):\n            name = attr.ib()\n\n        fix_of_test1_ref = None\n        session_ref = None\n\n        @pytest.fixture(scope='session')\n        def session_fix():\n            global session_ref\n            obj = SomeObj(name='session-fixture')\n            session_ref = weakref.ref(obj)\n            return obj\n\n        @pytest.fixture\n        def fix(session_fix):\n            global fix_of_test1_ref\n            obj = SomeObj(name='local-fixture')\n            fix_of_test1_ref = weakref.ref(obj)\n            return obj\n\n        def test1(fix):\n            assert fix_of_test1_ref() is fix\n\n        def test2():\n            gc.collect()\n            # fixture \"fix\" created during test1 must have been destroyed by now\n            assert fix_of_test1_ref() is None\n    \"\"\"\n    )\n    # Running on subprocess does not activate the HookRecorder\n    # which holds itself a reference to objects in case of the\n    # pytest_assert_reprcompare hook\n    result = testdir.runpytest_subprocess()\n    result.stdout.fnmatch_lines([\"* 2 passed *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_TestExceptionInfo_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_TestExceptionInfo_", "embedding": null, "metadata": {"file_path": "testing/code/test_code.py", "file_name": "test_code.py", "file_type": "text/x-python", "category": "test", "start_line": 141, "end_line": 201, "span_ids": ["TestExceptionInfo", "TestExceptionInfo.test_bad_getsource", "TestExceptionInfo.test_from_current_with_missing", "TestReprFuncArgs", "TestReprFuncArgs.test_not_raise_exception_with_mixed_encoding", "TestTracebackEntry", "TestTracebackEntry.test_getsource", "test_ExceptionChainRepr"], "tokens": 397}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestExceptionInfo:\n    def test_bad_getsource(self) -> None:\n        try:\n            if False:\n                pass\n            else:\n                assert False\n        except AssertionError:\n            exci = ExceptionInfo.from_current()\n        assert exci.getrepr()\n\n    def test_from_current_with_missing(self) -> None:\n        with pytest.raises(AssertionError, match=\"no current exception\"):\n            ExceptionInfo.from_current()\n\n\nclass TestTracebackEntry:\n    def test_getsource(self) -> None:\n        try:\n            if False:\n                pass\n            else:\n                assert False\n        except AssertionError:\n            exci = ExceptionInfo.from_current()\n        entry = exci.traceback[0]\n        source = entry.getsource()\n        assert source is not None\n        assert len(source) == 6\n        assert \"assert False\" in source[5]\n\n\nclass TestReprFuncArgs:\n    def test_not_raise_exception_with_mixed_encoding(self, tw_mock) -> None:\n        args = [(\"unicode_string\", \"S\u00e3o Paulo\"), (\"utf8_string\", b\"S\\xc3\\xa3o Paulo\")]\n\n        r = ReprFuncArgs(args)\n        r.toterminal(tw_mock)\n\n        assert (\n            tw_mock.lines[0]\n            == r\"unicode_string = S\u00e3o Paulo, utf8_string = b'S\\xc3\\xa3o Paulo'\"\n        )\n\n\ndef test_ExceptionChainRepr():\n    \"\"\"Test ExceptionChainRepr, especially with regard to being hashable.\"\"\"\n    try:\n        raise ValueError()\n    except ValueError:\n        excinfo1 = ExceptionInfo.from_current()\n        excinfo2 = ExceptionInfo.from_current()\n\n    repr1 = excinfo1.getrepr()\n    repr2 = excinfo2.getrepr()\n    assert repr1 != repr2\n\n    assert isinstance(repr1, ExceptionChainRepr)\n    assert hash(repr1) != hash(repr2)\n    assert repr1 is not excinfo1.getrepr()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h_TestTraceback_f_g_h.test_traceback_filter": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h_TestTraceback_f_g_h.test_traceback_filter", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 96, "end_line": 165, "span_ids": ["TestTraceback_f_g_h", "TestTraceback_f_g_h.setup_method", "TestTraceback_f_g_h.test_traceback_cut", "TestTraceback_f_g_h.test_traceback_cut_excludepath", "TestTraceback_f_g_h.test_traceback_entries", "TestTraceback_f_g_h.test_traceback_entry_getsource", "TestTraceback_f_g_h.test_traceback_entry_getsource_in_construct", "TestTraceback_f_g_h.test_traceback_filter"], "tokens": 554}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTraceback_f_g_h:\n    def setup_method(self, method):\n        try:\n            h()\n        except ValueError:\n            self.excinfo = _pytest._code.ExceptionInfo.from_current()\n\n    def test_traceback_entries(self):\n        tb = self.excinfo.traceback\n        entries = list(tb)\n        assert len(tb) == 4  # maybe fragile test\n        assert len(entries) == 4  # maybe fragile test\n        names = [\"f\", \"g\", \"h\"]\n        for entry in entries:\n            try:\n                names.remove(entry.frame.code.name)\n            except ValueError:\n                pass\n        assert not names\n\n    def test_traceback_entry_getsource(self):\n        tb = self.excinfo.traceback\n        s = str(tb[-1].getsource())\n        assert s.startswith(\"def f():\")\n        assert s.endswith(\"raise ValueError\")\n\n    def test_traceback_entry_getsource_in_construct(self):\n        source = _pytest._code.Source(\n            \"\"\"\\\n            def xyz():\n                try:\n                    raise ValueError\n                except somenoname:\n                    pass\n            xyz()\n            \"\"\"\n        )\n        try:\n            exec(source.compile())\n        except NameError:\n            tb = _pytest._code.ExceptionInfo.from_current().traceback\n            print(tb[-1].getsource())\n            s = str(tb[-1].getsource())\n            assert s.startswith(\"def xyz():\\n    try:\")\n            assert s.strip().endswith(\"except somenoname:\")\n\n    def test_traceback_cut(self):\n        co = _pytest._code.Code(f)\n        path, firstlineno = co.path, co.firstlineno\n        traceback = self.excinfo.traceback\n        newtraceback = traceback.cut(path=path, firstlineno=firstlineno)\n        assert len(newtraceback) == 1\n        newtraceback = traceback.cut(path=path, lineno=firstlineno + 2)\n        assert len(newtraceback) == 1\n\n    def test_traceback_cut_excludepath(self, testdir):\n        p = testdir.makepyfile(\"def f(): raise ValueError\")\n        with pytest.raises(ValueError) as excinfo:\n            p.pyimport().f()\n        basedir = py.path.local(pytest.__file__).dirpath()\n        newtraceback = excinfo.traceback.cut(excludepath=basedir)\n        for x in newtraceback:\n            if hasattr(x, \"path\"):\n                assert not py.path.local(x.path).relto(basedir)\n        assert newtraceback[-1].frame.code.path == p\n\n    def test_traceback_filter(self):\n        traceback = self.excinfo.traceback\n        ntraceback = traceback.filter()\n        assert len(ntraceback) == len(traceback) - 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h.test_traceback_filter_selective_TestTraceback_f_g_h.test_traceback_filter_selective.if_matching_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h.test_traceback_filter_selective_TestTraceback_f_g_h.test_traceback_filter_selective.if_matching_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 167, "end_line": 203, "span_ids": ["TestTraceback_f_g_h.test_traceback_filter_selective"], "tokens": 219}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTraceback_f_g_h:\n\n    @pytest.mark.parametrize(\n        \"tracebackhide, matching\",\n        [\n            (lambda info: True, True),\n            (lambda info: False, False),\n            (operator.methodcaller(\"errisinstance\", ValueError), True),\n            (operator.methodcaller(\"errisinstance\", IndexError), False),\n        ],\n    )\n    def test_traceback_filter_selective(self, tracebackhide, matching):\n        def f():\n            #\n            raise ValueError\n            #\n\n        def g():\n            #\n            __tracebackhide__ = tracebackhide\n            f()\n            #\n\n        def h():\n            #\n            g()\n            #\n\n        excinfo = pytest.raises(ValueError, h)\n        traceback = excinfo.traceback\n        ntraceback = traceback.filter()\n        print(\"old: {!r}\".format(traceback))\n        print(\"new: {!r}\".format(ntraceback))\n\n        if matching:\n            assert len(ntraceback) == len(traceback) - 2\n        else:\n            # -1 because of the __tracebackhide__ in pytest.raises\n            assert len(ntraceback) == len(traceback) - 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h.test_traceback_recursion_index_TestTraceback_f_g_h.test_traceback_getcrashentry_empty": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestTraceback_f_g_h.test_traceback_recursion_index_TestTraceback_f_g_h.test_traceback_getcrashentry_empty", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 206, "end_line": 307, "span_ids": ["TestTraceback_f_g_h.test_traceback_getcrashentry", "TestTraceback_f_g_h.test_traceback_getcrashentry_empty", "TestTraceback_f_g_h.test_traceback_messy_recursion", "TestTraceback_f_g_h.test_traceback_no_recursion_index", "TestTraceback_f_g_h.test_traceback_only_specific_recursion_errors", "TestTraceback_f_g_h.test_traceback_recursion_index"], "tokens": 653}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTraceback_f_g_h:\n\n    def test_traceback_recursion_index(self):\n        def f(n):\n            if n < 10:\n                n += 1\n            f(n)\n\n        excinfo = pytest.raises(RuntimeError, f, 8)\n        traceback = excinfo.traceback\n        recindex = traceback.recursionindex()\n        assert recindex == 3\n\n    def test_traceback_only_specific_recursion_errors(self, monkeypatch):\n        def f(n):\n            if n == 0:\n                raise RuntimeError(\"hello\")\n            f(n - 1)\n\n        excinfo = pytest.raises(RuntimeError, f, 25)\n        monkeypatch.delattr(excinfo.traceback.__class__, \"recursionindex\")\n        repr = excinfo.getrepr()\n        assert \"RuntimeError: hello\" in str(repr.reprcrash)\n\n    def test_traceback_no_recursion_index(self) -> None:\n        def do_stuff() -> None:\n            raise RuntimeError\n\n        def reraise_me() -> None:\n            import sys\n\n            exc, val, tb = sys.exc_info()\n            assert val is not None\n            raise val.with_traceback(tb)\n\n        def f(n: int) -> None:\n            try:\n                do_stuff()\n            except:  # noqa\n                reraise_me()\n\n        excinfo = pytest.raises(RuntimeError, f, 8)\n        assert excinfo is not None\n        traceback = excinfo.traceback\n        recindex = traceback.recursionindex()\n        assert recindex is None\n\n    def test_traceback_messy_recursion(self):\n        # XXX: simplified locally testable version\n        decorator = pytest.importorskip(\"decorator\").decorator\n\n        def log(f, *k, **kw):\n            print(\"{} {}\".format(k, kw))\n            f(*k, **kw)\n\n        log = decorator(log)\n\n        def fail():\n            raise ValueError(\"\")\n\n        fail = log(log(fail))\n\n        excinfo = pytest.raises(ValueError, fail)\n        assert excinfo.traceback.recursionindex() is None\n\n    def test_traceback_getcrashentry(self):\n        def i():\n            __tracebackhide__ = True\n            raise ValueError\n\n        def h():\n            i()\n\n        def g():\n            __tracebackhide__ = True\n            h()\n\n        def f():\n            g()\n\n        excinfo = pytest.raises(ValueError, f)\n        tb = excinfo.traceback\n        entry = tb.getcrashentry()\n        co = _pytest._code.Code(h)\n        assert entry.frame.code.path == co.path\n        assert entry.lineno == co.firstlineno + 1\n        assert entry.frame.code.name == \"h\"\n\n    def test_traceback_getcrashentry_empty(self):\n        def g():\n            __tracebackhide__ = True\n            raise ValueError\n\n        def f():\n            __tracebackhide__ = True\n            g()\n\n        excinfo = pytest.raises(ValueError, f)\n        tb = excinfo.traceback\n        entry = tb.getcrashentry()\n        co = _pytest._code.Code(g)\n        assert entry.frame.code.path == co.path\n        assert entry.lineno == co.firstlineno + 2\n        assert entry.frame.code.name == \"g\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_local_TestFormattedExcinfo.test_repr_local_truncated": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_local_TestFormattedExcinfo.test_repr_local_truncated", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 525, "end_line": 575, "span_ids": ["TestFormattedExcinfo.test_repr_local", "TestFormattedExcinfo.test_repr_local_truncated", "TestFormattedExcinfo.test_repr_local_with_error", "TestFormattedExcinfo.test_repr_local_with_exception_in_class_property"], "tokens": 574}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_local(self):\n        p = FormattedExcinfo(showlocals=True)\n        loc = {\"y\": 5, \"z\": 7, \"x\": 3, \"@x\": 2, \"__builtins__\": {}}\n        reprlocals = p.repr_locals(loc)\n        assert reprlocals.lines\n        assert reprlocals.lines[0] == \"__builtins__ = <builtins>\"\n        assert reprlocals.lines[1] == \"x          = 3\"\n        assert reprlocals.lines[2] == \"y          = 5\"\n        assert reprlocals.lines[3] == \"z          = 7\"\n\n    def test_repr_local_with_error(self):\n        class ObjWithErrorInRepr:\n            def __repr__(self):\n                raise NotImplementedError\n\n        p = FormattedExcinfo(showlocals=True, truncate_locals=False)\n        loc = {\"x\": ObjWithErrorInRepr(), \"__builtins__\": {}}\n        reprlocals = p.repr_locals(loc)\n        assert reprlocals.lines\n        assert reprlocals.lines[0] == \"__builtins__ = <builtins>\"\n        assert \"[NotImplementedError() raised in repr()]\" in reprlocals.lines[1]\n\n    def test_repr_local_with_exception_in_class_property(self):\n        class ExceptionWithBrokenClass(Exception):\n            # Type ignored because it's bypassed intentionally.\n            @property  # type: ignore\n            def __class__(self):\n                raise TypeError(\"boom!\")\n\n        class ObjWithErrorInRepr:\n            def __repr__(self):\n                raise ExceptionWithBrokenClass()\n\n        p = FormattedExcinfo(showlocals=True, truncate_locals=False)\n        loc = {\"x\": ObjWithErrorInRepr(), \"__builtins__\": {}}\n        reprlocals = p.repr_locals(loc)\n        assert reprlocals.lines\n        assert reprlocals.lines[0] == \"__builtins__ = <builtins>\"\n        assert \"[ExceptionWithBrokenClass() raised in repr()]\" in reprlocals.lines[1]\n\n    def test_repr_local_truncated(self):\n        loc = {\"l\": [i for i in range(10)]}\n        p = FormattedExcinfo(showlocals=True)\n        truncated_reprlocals = p.repr_locals(loc)\n        assert truncated_reprlocals.lines\n        assert truncated_reprlocals.lines[0] == \"l          = [0, 1, 2, 3, 4, 5, ...]\"\n\n        q = FormattedExcinfo(showlocals=True, truncate_locals=False)\n        full_reprlocals = q.repr_locals(loc)\n        assert full_reprlocals.lines\n        assert full_reprlocals.lines[0] == \"l          = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines_TestFormattedExcinfo.test_repr_tracebackentry_lines._assert_loc_message_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines_TestFormattedExcinfo.test_repr_tracebackentry_lines._assert_loc_message_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 577, "end_line": 607, "span_ids": ["TestFormattedExcinfo.test_repr_tracebackentry_lines"], "tokens": 257}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_tracebackentry_lines(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def func1():\n                raise ValueError(\"hello\\\\nworld\")\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.func1)\n        excinfo.traceback = excinfo.traceback.filter()\n        p = FormattedExcinfo()\n        reprtb = p.repr_traceback_entry(excinfo.traceback[-1])\n\n        # test as intermittent entry\n        lines = reprtb.lines\n        assert lines[0] == \"    def func1():\"\n        assert lines[1] == '>       raise ValueError(\"hello\\\\nworld\")'\n\n        # test as last entry\n        p = FormattedExcinfo(showlocals=True)\n        repr_entry = p.repr_traceback_entry(excinfo.traceback[-1], excinfo)\n        lines = repr_entry.lines\n        assert lines[0] == \"    def func1():\"\n        assert lines[1] == '>       raise ValueError(\"hello\\\\nworld\")'\n        assert lines[2] == \"E       ValueError: hello\"\n        assert lines[3] == \"E       world\"\n        assert not lines[4:]\n\n        loc = repr_entry.reprfileloc\n        assert loc.path == mod.__file__\n        assert loc.lineno == 3\n        # assert loc.message == \"ValueError: hello\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines2_TestFormattedExcinfo.test_repr_tracebackentry_lines2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines2_TestFormattedExcinfo.test_repr_tracebackentry_lines2", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 634, "end_line": 657, "span_ids": ["TestFormattedExcinfo.test_repr_tracebackentry_lines2"], "tokens": 314}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_tracebackentry_lines2(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def func1(m, x, y, z):\n                raise ValueError(\"hello\\\\nworld\")\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.func1, \"m\" * 90, 5, 13, \"z\" * 120)\n        excinfo.traceback = excinfo.traceback.filter()\n        entry = excinfo.traceback[-1]\n        p = FormattedExcinfo(funcargs=True)\n        reprfuncargs = p.repr_args(entry)\n        assert reprfuncargs.args[0] == (\"m\", repr(\"m\" * 90))\n        assert reprfuncargs.args[1] == (\"x\", \"5\")\n        assert reprfuncargs.args[2] == (\"y\", \"13\")\n        assert reprfuncargs.args[3] == (\"z\", repr(\"z\" * 120))\n\n        p = FormattedExcinfo(funcargs=True)\n        repr_entry = p.repr_traceback_entry(entry)\n        assert repr_entry.reprfuncargs.args == reprfuncargs.args\n        repr_entry.toterminal(tw_mock)\n        assert tw_mock.lines[0] == \"m = \" + repr(\"m\" * 90)\n        assert tw_mock.lines[1] == \"x = 5, y = 13\"\n        assert tw_mock.lines[2] == \"z = \" + repr(\"z\" * 120)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines_var_kw_args_TestFormattedExcinfo.test_repr_tracebackentry_lines_var_kw_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_lines_var_kw_args_TestFormattedExcinfo.test_repr_tracebackentry_lines_var_kw_args", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 659, "end_line": 679, "span_ids": ["TestFormattedExcinfo.test_repr_tracebackentry_lines_var_kw_args"], "tokens": 254}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_tracebackentry_lines_var_kw_args(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def func1(x, *y, **z):\n                raise ValueError(\"hello\\\\nworld\")\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.func1, \"a\", \"b\", c=\"d\")\n        excinfo.traceback = excinfo.traceback.filter()\n        entry = excinfo.traceback[-1]\n        p = FormattedExcinfo(funcargs=True)\n        reprfuncargs = p.repr_args(entry)\n        assert reprfuncargs.args[0] == (\"x\", repr(\"a\"))\n        assert reprfuncargs.args[1] == (\"y\", repr((\"b\",)))\n        assert reprfuncargs.args[2] == (\"z\", repr({\"c\": \"d\"}))\n\n        p = FormattedExcinfo(funcargs=True)\n        repr_entry = p.repr_traceback_entry(entry)\n        assert repr_entry.reprfuncargs.args == reprfuncargs.args\n        repr_entry.toterminal(tw_mock)\n        assert tw_mock.lines[0] == \"x = 'a', y = ('b',), z = {'c': 'd'}\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_short_TestFormattedExcinfo.test_repr_tracebackentry_short.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_short_TestFormattedExcinfo.test_repr_tracebackentry_short.None_6", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 681, "end_line": 706, "span_ids": ["TestFormattedExcinfo.test_repr_tracebackentry_short"], "tokens": 221}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_tracebackentry_short(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def func1():\n                raise ValueError(\"hello\")\n            def entry():\n                func1()\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n        p = FormattedExcinfo(style=\"short\")\n        reprtb = p.repr_traceback_entry(excinfo.traceback[-2])\n        lines = reprtb.lines\n        basename = py.path.local(mod.__file__).basename\n        assert lines[0] == \"    func1()\"\n        assert basename in str(reprtb.reprfileloc.path)\n        assert reprtb.reprfileloc.lineno == 5\n\n        # test last entry\n        p = FormattedExcinfo(style=\"short\")\n        reprtb = p.repr_traceback_entry(excinfo.traceback[-1], excinfo)\n        lines = reprtb.lines\n        assert lines[0] == '    raise ValueError(\"hello\")'\n        assert lines[1] == \"E   ValueError: hello\"\n        assert basename in str(reprtb.reprfileloc.path)\n        assert reprtb.reprfileloc.lineno == 3", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_no_TestFormattedExcinfo.test_repr_traceback_tbfilter": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_tracebackentry_no_TestFormattedExcinfo.test_repr_traceback_tbfilter", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 708, "end_line": 742, "span_ids": ["TestFormattedExcinfo.test_repr_traceback_tbfilter", "TestFormattedExcinfo.test_repr_tracebackentry_no"], "tokens": 271}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_tracebackentry_no(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def func1():\n                raise ValueError(\"hello\")\n            def entry():\n                func1()\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n        p = FormattedExcinfo(style=\"no\")\n        p.repr_traceback_entry(excinfo.traceback[-2])\n\n        p = FormattedExcinfo(style=\"no\")\n        reprentry = p.repr_traceback_entry(excinfo.traceback[-1], excinfo)\n        lines = reprentry.lines\n        assert lines[0] == \"E   ValueError: hello\"\n        assert not lines[1:]\n\n    def test_repr_traceback_tbfilter(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def f(x):\n                raise ValueError(x)\n            def entry():\n                f(0)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n        p = FormattedExcinfo(tbfilter=True)\n        reprtb = p.repr_traceback(excinfo)\n        assert len(reprtb.reprentries) == 2\n        p = FormattedExcinfo(tbfilter=False)\n        reprtb = p.repr_traceback(excinfo)\n        assert len(reprtb.reprentries) == 3", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_traceback_short_no_source_TestFormattedExcinfo.test_traceback_short_no_source": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_traceback_short_no_source_TestFormattedExcinfo.test_traceback_short_no_source", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 744, "end_line": 768, "span_ids": ["TestFormattedExcinfo.test_traceback_short_no_source"], "tokens": 228}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_traceback_short_no_source(self, importasmod, monkeypatch):\n        mod = importasmod(\n            \"\"\"\n            def func1():\n                raise ValueError(\"hello\")\n            def entry():\n                func1()\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n        from _pytest._code.code import Code\n\n        monkeypatch.setattr(Code, \"path\", \"bogus\")\n        excinfo.traceback[0].frame.code.path = \"bogus\"\n        p = FormattedExcinfo(style=\"short\")\n        reprtb = p.repr_traceback_entry(excinfo.traceback[-2])\n        lines = reprtb.lines\n        last_p = FormattedExcinfo(style=\"short\")\n        last_reprtb = last_p.repr_traceback_entry(excinfo.traceback[-1], excinfo)\n        last_lines = last_reprtb.lines\n        monkeypatch.undo()\n        assert lines[0] == \"    func1()\"\n\n        assert last_lines[0] == '    raise ValueError(\"hello\")'\n        assert last_lines[1] == \"E   ValueError: hello\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_traceback_and_excinfo_TestFormattedExcinfo.test_repr_traceback_and_excinfo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_traceback_and_excinfo_TestFormattedExcinfo.test_repr_traceback_and_excinfo", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 770, "end_line": 794, "span_ids": ["TestFormattedExcinfo.test_repr_traceback_and_excinfo"], "tokens": 225}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_traceback_and_excinfo(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def f(x):\n                raise ValueError(x)\n            def entry():\n                f(0)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n\n        for style in (\"long\", \"short\"):\n            p = FormattedExcinfo(style=style)\n            reprtb = p.repr_traceback(excinfo)\n            assert len(reprtb.reprentries) == 2\n            assert reprtb.style == style\n            assert not reprtb.extraline\n            repr = p.repr_excinfo(excinfo)\n            assert repr.reprtraceback\n            assert len(repr.reprtraceback.reprentries) == len(reprtb.reprentries)\n\n            assert repr.chain[0][0]\n            assert len(repr.chain[0][0].reprentries) == len(reprtb.reprentries)\n            assert repr.reprcrash.path.endswith(\"mod.py\")\n            assert repr.reprcrash.message == \"ValueError: 0\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_without_traceback_TestFormattedExcinfo.test_exc_chain_repr_without_traceback.matcher_fnmatch_lines_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_without_traceback_TestFormattedExcinfo.test_exc_chain_repr_without_traceback.matcher_fnmatch_lines_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 1216, "end_line": 1274, "span_ids": ["TestFormattedExcinfo.test_exc_chain_repr_without_traceback"], "tokens": 352}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    @pytest.mark.parametrize(\n        \"reason, description\",\n        [\n            pytest.param(\n                \"cause\",\n                \"The above exception was the direct cause of the following exception:\",\n                id=\"cause\",\n            ),\n            pytest.param(\n                \"context\",\n                \"During handling of the above exception, another exception occurred:\",\n                id=\"context\",\n            ),\n        ],\n    )\n    def test_exc_chain_repr_without_traceback(self, importasmod, reason, description):\n        \"\"\"\n        Handle representation of exception chains where one of the exceptions doesn't have a\n        real traceback, such as those raised in a subprocess submitted by the multiprocessing\n        module (#1984).\n        \"\"\"\n        exc_handling_code = \" from e\" if reason == \"cause\" else \"\"\n        mod = importasmod(\n            \"\"\"\n            def f():\n                try:\n                    g()\n                except Exception as e:\n                    raise RuntimeError('runtime problem'){exc_handling_code}\n            def g():\n                raise ValueError('invalid value')\n        \"\"\".format(\n                exc_handling_code=exc_handling_code\n            )\n        )\n\n        with pytest.raises(RuntimeError) as excinfo:\n            mod.f()\n\n        # emulate the issue described in #1984\n        attr = \"__%s__\" % reason\n        getattr(excinfo.value, attr).__traceback__ = None\n\n        r = excinfo.getrepr()\n        file = io.StringIO()\n        tw = TerminalWriter(file=file)\n        tw.hasmarkup = False\n        r.toterminal(tw)\n\n        matcher = LineMatcher(file.getvalue().splitlines())\n        matcher.fnmatch_lines(\n            [\n                \"ValueError: invalid value\",\n                description,\n                \"* except Exception as e:\",\n                \"> * raise RuntimeError('runtime problem')\" + exc_handling_code,\n                \"E *RuntimeError: runtime problem\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_cycle_TestFormattedExcinfo.test_exc_chain_repr_cycle.assert_out_expected_ou": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_cycle_TestFormattedExcinfo.test_exc_chain_repr_cycle.assert_out_expected_ou", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 1270, "end_line": 1310, "span_ids": ["TestFormattedExcinfo.test_exc_chain_repr_cycle"], "tokens": 280}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_exc_chain_repr_cycle(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            class Err(Exception):\n                pass\n            def fail():\n                return 0 / 0\n            def reraise():\n                try:\n                    fail()\n                except ZeroDivisionError as e:\n                    raise Err() from e\n            def unreraise():\n                try:\n                    reraise()\n                except Err as e:\n                    raise e.__cause__\n        \"\"\"\n        )\n        excinfo = pytest.raises(ZeroDivisionError, mod.unreraise)\n        r = excinfo.getrepr(style=\"short\")\n        r.toterminal(tw_mock)\n        out = \"\\n\".join(line for line in tw_mock.lines if isinstance(line, str))\n        expected_out = textwrap.dedent(\n            \"\"\"\\\n            :13: in unreraise\n                reraise()\n            :10: in reraise\n                raise Err() from e\n            E   test_exc_chain_repr_cycle0.mod.Err\n\n            During handling of the above exception, another exception occurred:\n            :15: in unreraise\n                raise e.__cause__\n            :8: in reraise\n                fail()\n            :5: in fail\n                return 0 / 0\n            E   ZeroDivisionError: division by zero\"\"\"\n        )\n        assert out == expected_out", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_test_repr_traceback_with_unicode_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_test_repr_traceback_with_unicode_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 1319, "end_line": 1398, "span_ids": ["test_cwd_deleted", "test_exception_repr_extraction_error_on_recursion", "test_no_recursion_index_on_recursion_error", "test_repr_traceback_with_unicode"], "tokens": 513}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"style\", [\"short\", \"long\"])\n@pytest.mark.parametrize(\"encoding\", [None, \"utf8\", \"utf16\"])\ndef test_repr_traceback_with_unicode(style, encoding):\n    if encoding is None:\n        msg = \"\u2639\"  # type: Union[str, bytes]\n    else:\n        msg = \"\u2639\".encode(encoding)\n    try:\n        raise RuntimeError(msg)\n    except RuntimeError:\n        e_info = ExceptionInfo.from_current()\n    formatter = FormattedExcinfo(style=style)\n    repr_traceback = formatter.repr_traceback(e_info)\n    assert repr_traceback is not None\n\n\ndef test_cwd_deleted(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test(tmpdir):\n            tmpdir.chdir()\n            tmpdir.remove()\n            assert False\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"* 1 failed in *\"])\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR*\")\n    result.stderr.no_fnmatch_line(\"*INTERNALERROR*\")\n\n\n@pytest.mark.usefixtures(\"limited_recursion_depth\")\ndef test_exception_repr_extraction_error_on_recursion():\n    \"\"\"\n    Ensure we can properly detect a recursion error even\n    if some locals raise error on comparison (#2459).\n    \"\"\"\n\n    class numpy_like:\n        def __eq__(self, other):\n            if type(other) is numpy_like:\n                raise ValueError(\n                    \"The truth value of an array \"\n                    \"with more than one element is ambiguous.\"\n                )\n\n    def a(x):\n        return b(numpy_like())\n\n    def b(x):\n        return a(numpy_like())\n\n    with pytest.raises(RuntimeError) as excinfo:\n        a(numpy_like())\n\n    matcher = LineMatcher(str(excinfo.getrepr()).splitlines())\n    matcher.fnmatch_lines(\n        [\n            \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\",\n            \"*The following exception happened*\",\n            \"*ValueError: The truth value of an array*\",\n        ]\n    )\n\n\n@pytest.mark.usefixtures(\"limited_recursion_depth\")\ndef test_no_recursion_index_on_recursion_error():\n    \"\"\"\n    Ensure that we don't break in case we can't find the recursion index\n    during a recursion error (#2486).\n    \"\"\"\n\n    class RecursionDepthError:\n        def __getattr__(self, attr):\n            return getattr(self, \"_\" + attr)\n\n    with pytest.raises(RuntimeError) as excinfo:\n        RecursionDepthError().trigger\n    assert \"maximum recursion\" in str(excinfo.getrepr())", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_TestSourceParsingAndCompiling.test_getstatementrange_ast_issue58_TestSourceParsingAndCompiling.test_offsetless_synerr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_TestSourceParsingAndCompiling.test_getstatementrange_ast_issue58_TestSourceParsingAndCompiling.test_offsetless_synerr", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 288, "end_line": 347, "span_ids": ["TestSourceParsingAndCompiling.test_compile_and_getsource", "TestSourceParsingAndCompiling.test_compile_to_ast", "TestSourceParsingAndCompiling.test_compilefuncs_and_path_sanity", "TestSourceParsingAndCompiling.test_getstatementrange_ast_issue58", "TestSourceParsingAndCompiling.test_getstatementrange_out_of_bounds_py3", "TestSourceParsingAndCompiling.test_getstatementrange_with_syntaxerror_issue7", "TestSourceParsingAndCompiling.test_offsetless_synerr"], "tokens": 567}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSourceParsingAndCompiling:\n\n    def test_getstatementrange_ast_issue58(self) -> None:\n        source = Source(\n            \"\"\"\\\n\n            def test_some():\n                for a in [a for a in\n                    CAUSE_ERROR]: pass\n\n            x = 3\n        \"\"\"\n        )\n        assert getstatement(2, source).lines == source.lines[2:3]\n        assert getstatement(3, source).lines == source.lines[3:4]\n\n    def test_getstatementrange_out_of_bounds_py3(self) -> None:\n        source = Source(\"if xxx:\\n   from .collections import something\")\n        r = source.getstatementrange(1)\n        assert r == (1, 2)\n\n    def test_getstatementrange_with_syntaxerror_issue7(self) -> None:\n        source = Source(\":\")\n        pytest.raises(SyntaxError, lambda: source.getstatementrange(0))\n\n    def test_compile_to_ast(self) -> None:\n        source = Source(\"x = 4\")\n        mod = source.compile(flag=ast.PyCF_ONLY_AST)\n        assert isinstance(mod, ast.Module)\n        compile(mod, \"<filename>\", \"exec\")\n\n    def test_compile_and_getsource(self) -> None:\n        co = self.source.compile()\n        exec(co, globals())\n        f(7)  # type: ignore\n        excinfo = pytest.raises(AssertionError, f, 6)  # type: ignore\n        assert excinfo is not None\n        frame = excinfo.traceback[-1].frame\n        assert isinstance(frame.code.fullsource, Source)\n        stmt = frame.code.fullsource.getstatement(frame.lineno)\n        assert str(stmt).strip().startswith(\"assert\")\n\n    @pytest.mark.parametrize(\"name\", [\"\", None, \"my\"])\n    def test_compilefuncs_and_path_sanity(self, name: Optional[str]) -> None:\n        def check(comp, name) -> None:\n            co = comp(self.source, name)\n            if not name:\n                expected = \"codegen %s:%d>\" % (mypath, mylineno + 2 + 2)  # type: ignore\n            else:\n                expected = \"codegen %r %s:%d>\" % (name, mypath, mylineno + 2 + 2)  # type: ignore\n            fn = co.co_filename\n            assert fn.endswith(expected)\n\n        mycode = _pytest._code.Code(self.test_compilefuncs_and_path_sanity)\n        mylineno = mycode.firstlineno\n        mypath = mycode.path\n\n        for comp in _pytest._code.compile, _pytest._code.Source.compile:\n            check(comp, name)\n\n    def test_offsetless_synerr(self):\n        pytest.raises(SyntaxError, _pytest._code.compile, \"lambda a,a: 0\", mode=\"eval\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/acceptance/fixture_mock_integration.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/acceptance/fixture_mock_integration.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/acceptance/fixture_mock_integration.py", "file_name": "fixture_mock_integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 17, "span_ids": ["docstring", "my_fixture", "test_foobar"], "tokens": 74}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Reproduces issue #3774\"\"\"\nfrom unittest import mock\n\nimport pytest\n\nconfig = {\"mykey\": \"ORIGINAL\"}\n\n\n@pytest.fixture(scope=\"function\")\n@mock.patch.dict(config, {\"mykey\": \"MOCKED\"})\ndef my_fixture():\n    return config[\"mykey\"]\n\n\ndef test_foobar(my_fixture):\n    assert my_fixture == \"MOCKED\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/collect_init_tests/tests/__init__.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/collect_init_tests/tests/__init__.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/collect/collect_init_tests/tests/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_init"], "tokens": 6}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_init():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/collect_init_tests/tests/test_foo.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/collect_init_tests/tests/test_foo.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/collect/collect_init_tests/tests/test_foo.py", "file_name": "test_foo.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_foo"], "tokens": 7}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_foo():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_infinite_recursion/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_infinite_recursion/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/collect/package_infinite_recursion/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 3, "span_ids": ["pytest_ignore_collect"], "tokens": 9}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_ignore_collect(path):\n    return False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_infinite_recursion/tests/test_basic.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_infinite_recursion/tests/test_basic.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/collect/package_infinite_recursion/tests/test_basic.py", "file_name": "test_basic.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test"], "tokens": 5}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_init_given_as_arg/pkg/test_foo.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/collect/package_init_given_as_arg/pkg/test_foo.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/collect/package_init_given_as_arg/pkg/test_foo.py", "file_name": "test_foo.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test"], "tokens": 5}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/config/collect_pytest_prefix/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/config/collect_pytest_prefix/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/config/collect_pytest_prefix/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 3, "span_ids": ["pytest_something"], "tokens": 6}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class pytest_something:\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/config/collect_pytest_prefix/test_foo.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/config/collect_pytest_prefix/test_foo.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/config/collect_pytest_prefix/test_foo.py", "file_name": "test_foo.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_foo"], "tokens": 7}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_foo():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/conftest_usageerror/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/conftest_usageerror/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/conftest_usageerror/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 9, "span_ids": ["pytest_configure", "pytest_unconfigure"], "tokens": 31}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_configure(config):\n    import pytest\n\n    raise pytest.UsageError(\"hello\")\n\n\ndef pytest_unconfigure(config):\n    print(\"pytest_unconfigure_called\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/dataclasses/test_compare_dataclasses.py", "file_name": "test_compare_dataclasses.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 15, "span_ids": ["imports", "test_dataclasses"], "tokens": 72}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from dataclasses import dataclass\nfrom dataclasses import field\n\n\ndef test_dataclasses():\n    @dataclass\n    class SimpleDataObject:\n        field_a: int = field()\n        field_b: int = field()\n\n    left = SimpleDataObject(1, \"b\")\n    right = SimpleDataObject(1, \"c\")\n\n    assert left == right", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses_field_comparison_off.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses_field_comparison_off.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/dataclasses/test_compare_dataclasses_field_comparison_off.py", "file_name": "test_compare_dataclasses_field_comparison_off.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 15, "span_ids": ["imports", "test_dataclasses_with_attribute_comparison_off"], "tokens": 78}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from dataclasses import dataclass\nfrom dataclasses import field\n\n\ndef test_dataclasses_with_attribute_comparison_off():\n    @dataclass\n    class SimpleDataObject:\n        field_a: int = field()\n        field_b: int = field(compare=False)\n\n    left = SimpleDataObject(1, \"b\")\n    right = SimpleDataObject(1, \"c\")\n\n    assert left == right", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses_verbose.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_dataclasses_verbose.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/dataclasses/test_compare_dataclasses_verbose.py", "file_name": "test_compare_dataclasses_verbose.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 15, "span_ids": ["imports", "test_dataclasses_verbose"], "tokens": 73}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from dataclasses import dataclass\nfrom dataclasses import field\n\n\ndef test_dataclasses_verbose():\n    @dataclass\n    class SimpleDataObject:\n        field_a: int = field()\n        field_b: int = field()\n\n    left = SimpleDataObject(1, \"b\")\n    right = SimpleDataObject(1, \"c\")\n\n    assert left == right", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_two_different_dataclasses.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/dataclasses/test_compare_two_different_dataclasses.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/dataclasses/test_compare_two_different_dataclasses.py", "file_name": "test_compare_two_different_dataclasses.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 20, "span_ids": ["imports", "test_comparing_two_different_data_classes"], "tokens": 107}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from dataclasses import dataclass\nfrom dataclasses import field\n\n\ndef test_comparing_two_different_data_classes():\n    @dataclass\n    class SimpleDataObjectOne:\n        field_a: int = field()\n        field_b: int = field()\n\n    @dataclass\n    class SimpleDataObjectTwo:\n        field_a: int = field()\n        field_b: int = field()\n\n    left = SimpleDataObjectOne(1, \"b\")\n    right = SimpleDataObjectTwo(1, \"c\")\n\n    assert left != right", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/custom_item/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/custom_item/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/custom_item/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 11, "span_ids": ["CustomItem", "CustomItem.runtest", "imports", "pytest_collect_file"], "tokens": 35}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\nclass CustomItem(pytest.Item, pytest.File):\n    def runtest(self):\n        pass\n\n\ndef pytest_collect_file(path, parent):\n    return CustomItem(path, parent)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/custom_item/foo/test_foo.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/custom_item/foo/test_foo.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/custom_item/foo/test_foo.py", "file_name": "test_foo.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test"], "tokens": 5}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 8, "span_ids": ["arg1", "imports"], "tokens": 30}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef arg1(request):\n    with pytest.raises(pytest.FixtureLookupError):\n        request.getfixturevalue(\"arg2\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/test_in_sub1.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/test_in_sub1.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub1/test_in_sub1.py", "file_name": "test_in_sub1.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_1"], "tokens": 9}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_1(arg1):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 7, "span_ids": ["arg2", "imports"], "tokens": 24}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef arg2(request):\n    pytest.raises(Exception, request.getfixturevalue, \"arg1\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/test_in_sub2.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/test_in_sub2.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_conftest_funcargs_only_available_in_subdir/sub2/test_in_sub2.py", "file_name": "test_in_sub2.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_2"], "tokens": 9}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_2(arg2):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_detect_recursive_dependency_error.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_detect_recursive_dependency_error.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_detect_recursive_dependency_error.py", "file_name": "test_detect_recursive_dependency_error.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 16, "span_ids": ["fix1", "fix2", "imports", "test"], "tokens": 38}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef fix1(fix2):\n    return 1\n\n\n@pytest.fixture\ndef fix2(fix1):\n    return 1\n\n\ndef test(fix1):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 7, "span_ids": ["imports", "spam"], "tokens": 13}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef spam():\n    return \"spam\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 7, "span_ids": ["imports", "spam"], "tokens": 16}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef spam(spam):\n    return spam * 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/test_spam.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/test_spam.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_conftest/pkg/test_spam.py", "file_name": "test_spam.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_spam"], "tokens": 15}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_spam(spam):\n    assert spam == \"spamspam\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 7, "span_ids": ["imports", "spam"], "tokens": 13}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef spam():\n    return \"spam\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/test_extend_fixture_conftest_module.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/test_extend_fixture_conftest_module.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_conftest_module/test_extend_fixture_conftest_module.py", "file_name": "test_extend_fixture_conftest_module.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 11, "span_ids": ["imports", "spam", "test_spam"], "tokens": 31}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef spam(spam):\n    return spam * 2\n\n\ndef test_spam(spam):\n    assert spam == \"spamspam\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_module_class.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_module_class.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_extend_fixture_module_class.py", "file_name": "test_extend_fixture_module_class.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 16, "span_ids": ["TestSpam", "TestSpam.spam", "TestSpam.test_spam", "imports", "spam"], "tokens": 50}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef spam():\n    return \"spam\"\n\n\nclass TestSpam:\n    @pytest.fixture\n    def spam(self, spam):\n        return spam * 2\n\n    def test_spam(self, spam):\n        assert spam == \"spamspam\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_basic.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_basic.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_funcarg_basic.py", "file_name": "test_funcarg_basic.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 16, "span_ids": ["imports", "other", "some", "test_func"], "tokens": 37}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef some(request):\n    return request.function.__name__\n\n\n@pytest.fixture\ndef other(request):\n    return 42\n\n\ndef test_func(some, other):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_classlevel.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_classlevel.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_classlevel.py", "file_name": "test_funcarg_lookup_classlevel.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 11, "span_ids": ["TestClass", "TestClass.something", "TestClass.test_method", "imports"], "tokens": 32}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\nclass TestClass:\n    @pytest.fixture\n    def something(self, request):\n        return request.instance\n\n    def test_method(self, something):\n        assert something is self", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_modulelevel.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_modulelevel.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookup_modulelevel.py", "file_name": "test_funcarg_lookup_modulelevel.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 16, "span_ids": ["TestClass", "TestClass.test_method", "imports", "something", "test_func"], "tokens": 49}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef something(request):\n    return request.function.__name__\n\n\nclass TestClass:\n    def test_method(self, something):\n        assert something == \"test_method\"\n\n\ndef test_func(something):\n    assert something == \"test_func\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookupfails.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookupfails.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/fill_fixtures/test_funcarg_lookupfails.py", "file_name": "test_funcarg_lookupfails.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 11, "span_ids": ["imports", "test_func", "xyzsomething"], "tokens": 22}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef xyzsomething(request):\n    return 42\n\n\ndef test_func(some):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/test_getfixturevalue_dynamic.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/test_getfixturevalue_dynamic.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/test_getfixturevalue_dynamic.py", "file_name": "test_getfixturevalue_dynamic.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 21, "span_ids": ["a", "b", "dynamic", "imports", "test"], "tokens": 58}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef dynamic():\n    pass\n\n\n@pytest.fixture\ndef a(request):\n    request.getfixturevalue(\"dynamic\")\n\n\n@pytest.fixture\ndef b(a):\n    pass\n\n\ndef test(b, request):\n    assert request.fixturenames == [\"b\", \"request\", \"a\", \"dynamic\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue88_initial_file_multinodes/conftest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue88_initial_file_multinodes/conftest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/issue88_initial_file_multinodes/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 15, "span_ids": ["MyFile", "MyFile.collect", "MyItem", "imports", "pytest_collect_file"], "tokens": 48}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\nclass MyFile(pytest.File):\n    def collect(self):\n        return [MyItem(\"hello\", parent=self)]\n\n\ndef pytest_collect_file(path, parent):\n    return MyFile(path, parent)\n\n\nclass MyItem(pytest.Item):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue88_initial_file_multinodes/test_hello.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue88_initial_file_multinodes/test_hello.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/issue88_initial_file_multinodes/test_hello.py", "file_name": "test_hello.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_hello"], "tokens": 6}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_hello():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/marks/marks_considered_keywords/test_marks_as_keywords.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/marks/marks_considered_keywords/test_marks_as_keywords.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/marks/marks_considered_keywords/test_marks_as_keywords.py", "file_name": "test_marks_as_keywords.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 7, "span_ids": ["imports", "test_mark"], "tokens": 12}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.mark.foo\ndef test_mark():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/perf_examples/collect_stats/template_test.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/perf_examples/collect_stats/template_test.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/perf_examples/collect_stats/template_test.py", "file_name": "template_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 3, "span_ids": ["test_x"], "tokens": 6}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_x():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/tmpdir/tmpdir_fixture.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/tmpdir/tmpdir_fixture.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/tmpdir/tmpdir_fixture.py", "file_name": "tmpdir_fixture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 8, "span_ids": ["imports", "test_fixture"], "tokens": 40}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.mark.parametrize(\"a\", [r\"qwe/\\abc\"])\ndef test_fixture(tmpdir, a):\n    tmpdir.check(dir=1)\n    assert tmpdir.listdir() == []", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_parametrized_fixture_error_message.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_parametrized_fixture_error_message.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/unittest/test_parametrized_fixture_error_message.py", "file_name": "test_parametrized_fixture_error_message.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 15, "span_ids": ["TestSomethingElse", "TestSomethingElse.test_two", "imports", "two"], "tokens": 42}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import unittest\n\nimport pytest\n\n\n@pytest.fixture(params=[1, 2])\ndef two(request):\n    return request.param\n\n\n@pytest.mark.usefixtures(\"two\")\nclass TestSomethingElse(unittest.TestCase):\n    def test_two(self):\n        pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/unittest/test_setup_skip.py", "file_name": "test_setup_skip.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 14, "span_ids": ["Base", "Base.setUp", "Test", "Test.test_foo", "docstring"], "tokens": 57}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Skipping an entire subclass with unittest.skip() should *not* call setUp from a base class.\"\"\"\nimport unittest\n\n\nclass Base(unittest.TestCase):\n    def setUp(self):\n        assert 0\n\n\n@unittest.skip(\"skip all tests\")\nclass Test(Base):\n    def test_foo(self):\n        assert 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip_class.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip_class.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/unittest/test_setup_skip_class.py", "file_name": "test_setup_skip_class.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 15, "span_ids": ["Base", "Base.setUpClass", "Test", "Test.test_foo", "docstring"], "tokens": 63}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Skipping an entire subclass with unittest.skip() should *not* call setUpClass from a base class.\"\"\"\nimport unittest\n\n\nclass Base(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        assert 0\n\n\n@unittest.skip(\"skip all tests\")\nclass Test(Base):\n    def test_foo(self):\n        assert 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip_module.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_setup_skip_module.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/unittest/test_setup_skip_module.py", "file_name": "test_setup_skip_module.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 13, "span_ids": ["Base", "Base.test", "docstring", "setUpModule"], "tokens": 48}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"setUpModule is always called, even if all tests in the module are skipped\"\"\"\nimport unittest\n\n\ndef setUpModule():\n    assert 0\n\n\n@unittest.skip(\"skip all tests\")\nclass Base(unittest.TestCase):\n    def test(self):\n        assert 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/warnings/test_group_warnings_by_message.py", "file_name": "test_group_warnings_by_message.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 22, "span_ids": ["func", "imports", "test_bar", "test_foo", "test_foo_1"], "tokens": 68}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import warnings\n\nimport pytest\n\n\ndef func(msg):\n    warnings.warn(UserWarning(msg))\n\n\n@pytest.mark.parametrize(\"i\", range(5))\ndef test_foo(i):\n    func(\"foo\")\n\n\ndef test_foo_1():\n    func(\"foo\")\n\n\n@pytest.mark.parametrize(\"i\", range(5))\ndef test_bar(i):\n    func(\"bar\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/examples/test_issue519.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/examples/test_issue519.py__", "embedding": null, "metadata": {"file_path": "testing/examples/test_issue519.py", "file_name": "test_issue519.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 4, "span_ids": ["test_510"], "tokens": 29}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_510(testdir):\n    testdir.copy_example(\"issue_519.py\")\n    testdir.runpytest(\"issue_519.py\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/create_executable.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/create_executable.py__", "embedding": null, "metadata": {"file_path": "testing/freeze/create_executable.py", "file_name": "create_executable.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 14, "span_ids": ["docstring"], "tokens": 97}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nGenerates an executable with pytest runner embedded using PyInstaller.\n\"\"\"\nif __name__ == \"__main__\":\n    import pytest\n    import subprocess\n\n    hidden = []\n    for x in pytest.freeze_includes():\n        hidden.extend([\"--hidden-import\", x])\n    hidden.extend([\"--hidden-import\", \"distutils\"])\n    args = [\"pyinstaller\", \"--noconfirm\"] + hidden + [\"runtests_script.py\"]\n    subprocess.check_call(\" \".join(args), shell=True)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/runtests_script.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/runtests_script.py__", "embedding": null, "metadata": {"file_path": "testing/freeze/runtests_script.py", "file_name": "runtests_script.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 11, "span_ids": ["docstring"], "tokens": 43}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nThis is the script that is actually frozen into an executable: simply executes\npytest main().\n\"\"\"\n\nif __name__ == \"__main__\":\n    import sys\n    import pytest\n\n    sys.exit(pytest.main())", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/tests/test_trivial.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/tests/test_trivial.py__", "embedding": null, "metadata": {"file_path": "testing/freeze/tests/test_trivial.py", "file_name": "test_trivial.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 7, "span_ids": ["test_lower", "test_upper"], "tokens": 32}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_upper():\n    assert \"foo\".upper() == \"FOO\"\n\n\ndef test_lower():\n    assert \"FOO\".lower() == \"foo\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/tox_run.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/freeze/tox_run.py__", "embedding": null, "metadata": {"file_path": "testing/freeze/tox_run.py", "file_name": "tox_run.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 13, "span_ids": ["docstring"], "tokens": 85}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nCalled by tox.ini: uses the generated executable to run the tests in ./tests/\ndirectory.\n\"\"\"\nif __name__ == \"__main__\":\n    import os\n    import sys\n\n    executable = os.path.join(os.getcwd(), \"dist\", \"runtests_script\", \"runtests_script\")\n    if sys.platform.startswith(\"win\"):\n        executable += \".exe\"\n    sys.exit(os.system(\"%s tests\" % executable))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_fixture.py_test_unicode_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_fixture.py_test_unicode_", "embedding": null, "metadata": {"file_path": "testing/logging/test_fixture.py", "file_name": "test_fixture.py", "file_type": "text/x-python", "category": "test", "start_line": 103, "end_line": 140, "span_ids": ["logging_during_setup_and_teardown", "test_caplog_captures_for_all_stages", "test_clear", "test_unicode"], "tokens": 303}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_unicode(caplog):\n    caplog.set_level(logging.INFO)\n    logger.info(\"b\u016b\")\n    assert caplog.records[0].levelname == \"INFO\"\n    assert caplog.records[0].msg == \"b\u016b\"\n    assert \"b\u016b\" in caplog.text\n\n\ndef test_clear(caplog):\n    caplog.set_level(logging.INFO)\n    logger.info(\"b\u016b\")\n    assert len(caplog.records)\n    assert caplog.text\n    caplog.clear()\n    assert not len(caplog.records)\n    assert not caplog.text\n\n\n@pytest.fixture\ndef logging_during_setup_and_teardown(caplog):\n    caplog.set_level(\"INFO\")\n    logger.info(\"a_setup_log\")\n    yield\n    logger.info(\"a_teardown_log\")\n    assert [x.message for x in caplog.get_records(\"teardown\")] == [\"a_teardown_log\"]\n\n\ndef test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardown):\n    assert not caplog.records\n    assert not caplog.get_records(\"call\")\n    logger.info(\"a_call_log\")\n    assert [x.message for x in caplog.get_records(\"call\")] == [\"a_call_log\"]\n\n    assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n\n    # This reaches into private API, don't use this type of thing in real tests!\n    assert set(caplog._item.catch_log_handlers.keys()) == {\"setup\", \"call\"}", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_root_logger_affected_test_root_logger_affected.with_open_log_file_as_rf": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_root_logger_affected_test_root_logger_affected.with_open_log_file_as_rf", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 52, "end_line": 85, "span_ids": ["test_root_logger_affected"], "tokens": 278}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_root_logger_affected(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        logger = logging.getLogger()\n\n        def test_foo():\n            logger.info('info text ' + 'going to logger')\n            logger.warning('warning text ' + 'going to logger')\n            logger.error('error text ' + 'going to logger')\n\n            assert 0\n    \"\"\"\n    )\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n    result = testdir.runpytest(\"--log-level=ERROR\", \"--log-file=pytest.log\")\n    assert result.ret == 1\n\n    # The capture log calls in the stdout section only contain the\n    # logger.error msg, because of --log-level=ERROR.\n    result.stdout.fnmatch_lines([\"*error text going to logger*\"])\n    stdout = result.stdout.str()\n    assert \"warning text going to logger\" not in stdout\n    assert \"info text going to logger\" not in stdout\n\n    # The log file should contain the warning and the error log messages and\n    # not the info one, because the default level of the root logger is\n    # WARNING.\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"info text going to logger\" not in contents\n        assert \"warning text going to logger\" in contents\n        assert \"error text going to logger\" in contents", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_level_log_level_interaction_test_disable_log_capturing": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_level_log_level_interaction_test_disable_log_capturing", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 85, "end_line": 190, "span_ids": ["test_disable_log_capturing", "test_log_cli_level_log_level_interaction", "test_setup_logging", "test_teardown_logging"], "tokens": 649}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_cli_level_log_level_interaction(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        logger = logging.getLogger()\n\n        def test_foo():\n            logger.debug('debug text ' + 'going to logger')\n            logger.info('info text ' + 'going to logger')\n            logger.warning('warning text ' + 'going to logger')\n            logger.error('error text ' + 'going to logger')\n            assert 0\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--log-cli-level=INFO\", \"--log-level=ERROR\")\n    assert result.ret == 1\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*-- live log call --*\",\n            \"*INFO*info text going to logger\",\n            \"*WARNING*warning text going to logger\",\n            \"*ERROR*error text going to logger\",\n            \"=* 1 failed in *=\",\n        ]\n    )\n    result.stdout.no_re_match_line(\"DEBUG\")\n\n\ndef test_setup_logging(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def setup_function(function):\n            logger.info('text going to logger from setup')\n\n        def test_foo():\n            logger.info('text going to logger from call')\n            assert False\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        [\n            \"*- Captured *log setup -*\",\n            \"*text going to logger from setup*\",\n            \"*- Captured *log call -*\",\n            \"*text going to logger from call*\",\n        ]\n    )\n\n\ndef test_teardown_logging(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            logger.info('text going to logger from call')\n\n        def teardown_function(function):\n            logger.info('text going to logger from teardown')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        [\n            \"*- Captured *log call -*\",\n            \"*text going to logger from call*\",\n            \"*- Captured *log teardown -*\",\n            \"*text going to logger from teardown*\",\n        ]\n    )\n\n\ndef test_disable_log_capturing(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            logger.warning('catch me if you can!')\n            sys.stderr.write('text going to stderr')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--no-print-logs\")\n    print(result.stdout)\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])\n    with pytest.raises(pytest.fail.Exception):\n        result.stdout.fnmatch_lines([\"*- Captured *log call -*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_disable_log_capturing_ini_test_log_cli_enabled_disabled.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_disable_log_capturing_ini_test_log_cli_enabled_disabled.None_1", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 196, "end_line": 256, "span_ids": ["test_disable_log_capturing_ini", "test_log_cli_enabled_disabled"], "tokens": 349}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_disable_log_capturing_ini(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_print=False\n        \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            logger.warning('catch me if you can!')\n            sys.stderr.write('text going to stderr')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    print(result.stdout)\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])\n    with pytest.raises(pytest.fail.Exception):\n        result.stdout.fnmatch_lines([\"*- Captured *log call -*\"])\n\n\n@pytest.mark.parametrize(\"enabled\", [True, False])\ndef test_log_cli_enabled_disabled(testdir, enabled):\n    msg = \"critical message logged by test\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        def test_log_cli():\n            logging.critical(\"{}\")\n    \"\"\".format(\n            msg\n        )\n    )\n    if enabled:\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            log_cli=true\n        \"\"\"\n        )\n    result = testdir.runpytest()\n    if enabled:\n        result.stdout.fnmatch_lines(\n            [\n                \"test_log_cli_enabled_disabled.py::test_log_cli \",\n                \"*-- live log call --*\",\n                \"CRITICAL *test_log_cli_enabled_disabled.py* critical message logged by test\",\n                \"PASSED*\",\n            ]\n        )\n    else:\n        assert msg not in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_test_log_cli_default_level.assert_result_ret_0": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_test_log_cli_default_level.assert_result_ret_0", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 256, "end_line": 287, "span_ids": ["test_log_cli_default_level"], "tokens": 212}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_cli_default_level(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_cli(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_cli_handler.level == logging.NOTSET\n            logging.getLogger('catchlog').info(\"INFO message won't be shown\")\n            logging.getLogger('catchlog').warning(\"WARNING message will be shown\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"test_log_cli_default_level.py::test_log_cli \",\n            \"WARNING*test_log_cli_default_level.py* message will be shown*\",\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*INFO message won't be shown*\")\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_multiple_tests_test_log_cli_default_level_multiple_tests.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_multiple_tests_test_log_cli_default_level_multiple_tests.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 293, "end_line": 325, "span_ids": ["test_log_cli_default_level_multiple_tests"], "tokens": 206}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_cli_default_level_multiple_tests(testdir, request):\n    \"\"\"Ensure we reset the first newline added by the live logger between tests\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        def test_log_1():\n            logging.warning(\"log message from test_log_1\")\n\n        def test_log_2():\n            logging.warning(\"log message from test_log_2\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"{}::test_log_1 \".format(filename),\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *50%*\",\n            \"{}::test_log_2 \".format(filename),\n            \"*WARNING*log message from test_log_2*\",\n            \"PASSED *100%*\",\n            \"=* 2 passed in *=\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_sections_test_log_cli_default_level_sections.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_default_level_sections_test_log_cli_default_level_sections.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 328, "end_line": 399, "span_ids": ["test_log_cli_default_level_sections"], "tokens": 517}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_cli_default_level_sections(testdir, request):\n    \"\"\"Check that with live logging enable we are printing the correct headers during\n    start/setup/call/teardown/finish.\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        import logging\n\n        def pytest_runtest_logstart():\n            logging.warning('>>>>> START >>>>>')\n\n        def pytest_runtest_logfinish():\n            logging.warning('<<<<< END <<<<<<<')\n    \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n\n        @pytest.fixture\n        def fix(request):\n            logging.warning(\"log message from setup of {}\".format(request.node.name))\n            yield\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n\n        def test_log_1(fix):\n            logging.warning(\"log message from test_log_1\")\n\n        def test_log_2(fix):\n            logging.warning(\"log message from test_log_2\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"{}::test_log_1 \".format(filename),\n            \"*-- live log start --*\",\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_1*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *50%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_1*\",\n            \"*-- live log finish --*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"{}::test_log_2 \".format(filename),\n            \"*-- live log start --*\",\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_2*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_2*\",\n            \"PASSED *100%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_2*\",\n            \"*-- live log finish --*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"=* 2 passed in *=\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_live_logs_unknown_sections_test_live_logs_unknown_sections.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_live_logs_unknown_sections_test_live_logs_unknown_sections.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 402, "end_line": 461, "span_ids": ["test_live_logs_unknown_sections"], "tokens": 374}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_live_logs_unknown_sections(testdir, request):\n    \"\"\"Check that with live logging enable we are printing the correct headers during\n    start/setup/call/teardown/finish.\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        import logging\n\n        def pytest_runtest_protocol(item, nextitem):\n            logging.warning('Unknown Section!')\n\n        def pytest_runtest_logstart():\n            logging.warning('>>>>> START >>>>>')\n\n        def pytest_runtest_logfinish():\n            logging.warning('<<<<< END <<<<<<<')\n    \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n\n        @pytest.fixture\n        def fix(request):\n            logging.warning(\"log message from setup of {}\".format(request.node.name))\n            yield\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n\n        def test_log_1(fix):\n            logging.warning(\"log message from test_log_1\")\n\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*WARNING*Unknown Section*\",\n            \"{}::test_log_1 \".format(filename),\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_1*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *100%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_1*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"=* 1 passed in *=\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_sections_single_new_line_after_test_outcome_test_sections_single_new_line_after_test_outcome.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_sections_single_new_line_after_test_outcome_test_sections_single_new_line_after_test_outcome.None_1", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 464, "end_line": 539, "span_ids": ["test_sections_single_new_line_after_test_outcome"], "tokens": 490}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_sections_single_new_line_after_test_outcome(testdir, request):\n    \"\"\"Check that only a single new line is written between log messages during\n    teardown/finish.\"\"\"\n    filename = request.node.name + \".py\"\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        import logging\n\n        def pytest_runtest_logstart():\n            logging.warning('>>>>> START >>>>>')\n\n        def pytest_runtest_logfinish():\n            logging.warning('<<<<< END <<<<<<<')\n            logging.warning('<<<<< END <<<<<<<')\n    \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n\n        @pytest.fixture\n        def fix(request):\n            logging.warning(\"log message from setup of {}\".format(request.node.name))\n            yield\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n            logging.warning(\"log message from teardown of {}\".format(request.node.name))\n\n        def test_log_1(fix):\n            logging.warning(\"log message from test_log_1\")\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"{}::test_log_1 \".format(filename),\n            \"*-- live log start --*\",\n            \"*WARNING* >>>>> START >>>>>*\",\n            \"*-- live log setup --*\",\n            \"*WARNING*log message from setup of test_log_1*\",\n            \"*-- live log call --*\",\n            \"*WARNING*log message from test_log_1*\",\n            \"PASSED *100%*\",\n            \"*-- live log teardown --*\",\n            \"*WARNING*log message from teardown of test_log_1*\",\n            \"*-- live log finish --*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"*WARNING* <<<<< END <<<<<<<*\",\n            \"=* 1 passed in *=\",\n        ]\n    )\n    assert (\n        re.search(\n            r\"(.+)live log teardown(.+)\\nWARNING(.+)\\nWARNING(.+)\",\n            result.stdout.str(),\n            re.MULTILINE,\n        )\n        is not None\n    )\n    assert (\n        re.search(\n            r\"(.+)live log finish(.+)\\nWARNING(.+)\\nWARNING(.+)\",\n            result.stdout.str(),\n            re.MULTILINE,\n        )\n        is not None\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_ini_level_test_log_cli_ini_level.assert_result_ret_0": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_ini_level_test_log_cli_ini_level.assert_result_ret_0", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 589, "end_line": 622, "span_ids": ["test_log_cli_ini_level"], "tokens": 237}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_cli_ini_level(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n        log_cli_level = INFO\n        \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_cli(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_cli_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"*test_log_cli_ini_level.py* This log message will be shown\",\n            \"PASSED\",  # 'PASSED' on its own line because the log message prints a new line\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*This log message won't be shown*\")\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_auto_enable_test_log_cli_auto_enable.if_cli_args_log_cli": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_auto_enable_test_log_cli_auto_enable.if_cli_args_log_cli", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 625, "end_line": 669, "span_ids": ["test_log_cli_auto_enable"], "tokens": 314}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"cli_args\",\n    [\"\", \"--log-level=WARNING\", \"--log-file-level=WARNING\", \"--log-cli-level=WARNING\"],\n)\ndef test_log_cli_auto_enable(testdir, cli_args):\n    \"\"\"Check that live logs are enabled if --log-level or --log-cli-level is passed on the CLI.\n    It should not be auto enabled if the same configs are set on the INI file.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        def test_log_1():\n            logging.info(\"log message from test_log_1 not to be shown\")\n            logging.warning(\"log message from test_log_1\")\n\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_level=INFO\n        log_cli_level=INFO\n    \"\"\"\n    )\n\n    result = testdir.runpytest(cli_args)\n    stdout = result.stdout.str()\n    if cli_args == \"--log-cli-level=WARNING\":\n        result.stdout.fnmatch_lines(\n            [\n                \"*::test_log_1 \",\n                \"*-- live log call --*\",\n                \"*WARNING*log message from test_log_1*\",\n                \"PASSED *100%*\",\n                \"=* 1 passed in *=\",\n            ]\n        )\n        assert \"INFO\" not in stdout\n    else:\n        result.stdout.fnmatch_lines(\n            [\"*test_log_cli_auto_enable*100%*\", \"=* 1 passed in *=\"]\n        )\n        assert \"INFO\" not in stdout\n        assert \"WARNING\" not in stdout", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_cli_test_log_file_cli.with_open_log_file_as_rf": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_cli_test_log_file_cli.with_open_log_file_as_rf", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 675, "end_line": 705, "span_ids": ["test_log_file_cli"], "tokens": 242}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_file_cli(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.WARNING\n            logging.getLogger('catchlog').info(\"This log message won't be shown\")\n            logging.getLogger('catchlog').warning(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    result = testdir.runpytest(\n        \"-s\", \"--log-file={}\".format(log_file), \"--log-file-level=WARNING\"\n    )\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_cli.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_cli_level_test_log_level_not_changed_by_default": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_cli_level_test_log_level_not_changed_by_default", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 708, "end_line": 750, "span_ids": ["test_log_file_cli_level", "test_log_level_not_changed_by_default"], "tokens": 312}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_file_cli_level(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    result = testdir.runpytest(\n        \"-s\", \"--log-file={}\".format(log_file), \"--log-file-level=INFO\"\n    )\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_cli_level.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents\n\n\ndef test_log_level_not_changed_by_default(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        def test_log_file():\n            assert logging.getLogger().level == logging.WARNING\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-s\")\n    result.stdout.fnmatch_lines([\"* 1 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_ini_test_log_file_ini.with_open_log_file_as_rf": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_ini_test_log_file_ini.with_open_log_file_as_rf", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 753, "end_line": 789, "span_ids": ["test_log_file_ini"], "tokens": 251}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_file_ini(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level=WARNING\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.WARNING\n            logging.getLogger('catchlog').info(\"This log message won't be shown\")\n            logging.getLogger('catchlog').warning(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_ini.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_ini_level_test_log_file_ini_level.with_open_log_file_as_rf": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_ini_level_test_log_file_ini_level.with_open_log_file_as_rf", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 792, "end_line": 828, "span_ids": ["test_log_file_ini_level"], "tokens": 253}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_file_ini_level(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_file(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_file_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines([\"test_log_file_ini_level.py PASSED\"])\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"This log message will be shown\" in contents\n        assert \"This log message won't be shown\" not in contents", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_unicode_test_log_file_unicode.with_open_log_file_encod": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_file_unicode_test_log_file_unicode.with_open_log_file_encod", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 828, "end_line": 860, "span_ids": ["test_log_file_unicode"], "tokens": 202}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_file_unicode(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\\\n        import logging\n\n        def test_log_file():\n            logging.getLogger('catchlog').info(\"Normal message\")\n            logging.getLogger('catchlog').info(\"\u251c\")\n            logging.getLogger('catchlog').info(\"Another normal message\")\n        \"\"\"\n    )\n\n    result = testdir.runpytest()\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file, encoding=\"utf-8\") as rfh:\n        contents = rfh.read()\n        assert \"Normal message\" in contents\n        assert \"\u251c\" in contents\n        assert \"Another normal message\" in contents", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_live_logging_suspends_capture_test_live_logging_suspends_capture.assert_out_file_getvalue_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_live_logging_suspends_capture_test_live_logging_suspends_capture.assert_out_file_getvalue_", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 863, "end_line": 905, "span_ids": ["test_live_logging_suspends_capture"], "tokens": 304}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"has_capture_manager\", [True, False])\ndef test_live_logging_suspends_capture(has_capture_manager, request):\n    \"\"\"Test that capture manager is suspended when we emitting messages for live logging.\n\n    This tests the implementation calls instead of behavior because it is difficult/impossible to do it using\n    ``testdir`` facilities because they do their own capturing.\n\n    We parametrize the test to also make sure _LiveLoggingStreamHandler works correctly if no capture manager plugin\n    is installed.\n    \"\"\"\n    import logging\n    import contextlib\n    from functools import partial\n    from _pytest.logging import _LiveLoggingStreamHandler\n\n    class MockCaptureManager:\n        calls = []\n\n        @contextlib.contextmanager\n        def global_and_fixture_disabled(self):\n            self.calls.append(\"enter disabled\")\n            yield\n            self.calls.append(\"exit disabled\")\n\n    class DummyTerminal(io.StringIO):\n        def section(self, *args, **kwargs):\n            pass\n\n    out_file = DummyTerminal()\n    capture_manager = MockCaptureManager() if has_capture_manager else None\n    handler = _LiveLoggingStreamHandler(out_file, capture_manager)\n    handler.set_when(\"call\")\n\n    logger = logging.getLogger(__name__ + \".test_live_logging_suspends_capture\")\n    logger.addHandler(handler)\n    request.addfinalizer(partial(logger.removeHandler, handler))\n\n    logger.critical(\"some message\")\n    if has_capture_manager:\n        assert MockCaptureManager.calls == [\"enter disabled\", \"exit disabled\"]\n    else:\n        assert MockCaptureManager.calls == []\n    assert out_file.getvalue() == \"\\nsome message\\n\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_repr_nd_array_TestApprox.test_repr_nd_array": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_repr_nd_array_TestApprox.test_repr_nd_array", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 73, "end_line": 87, "span_ids": ["TestApprox.test_repr_nd_array"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    @pytest.mark.parametrize(\n        \"value, expected_repr_string\",\n        [\n            (5.0, \"approx(5.0 \u00b1 5.0e-06)\"),\n            ([5.0], \"approx([5.0 \u00b1 5.0e-06])\"),\n            ([[5.0]], \"approx([[5.0 \u00b1 5.0e-06]])\"),\n            ([[5.0, 6.0]], \"approx([[5.0 \u00b1 5.0e-06, 6.0 \u00b1 6.0e-06]])\"),\n            ([[5.0], [6.0]], \"approx([[5.0 \u00b1 5.0e-06], [6.0 \u00b1 6.0e-06]])\"),\n        ],\n    )\n    def test_repr_nd_array(self, value, expected_repr_string):\n        \"\"\"Make sure that arrays of all different dimensions are repr'd correctly.\"\"\"\n        np = pytest.importorskip(\"numpy\")\n        np_array = np.array(value)\n        assert repr(approx(np_array)) == expected_repr_string", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_operator_overloading_TestApprox.test_inf_tolerance": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_operator_overloading_TestApprox.test_inf_tolerance", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 77, "end_line": 132, "span_ids": ["TestApprox.test_exactly_equal", "TestApprox.test_inf_tolerance", "TestApprox.test_negative_tolerance", "TestApprox.test_operator_overloading", "TestApprox.test_opposite_sign", "TestApprox.test_zero_tolerance"], "tokens": 705}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_operator_overloading(self):\n        assert 1 == approx(1, rel=1e-6, abs=1e-12)\n        assert not (1 != approx(1, rel=1e-6, abs=1e-12))\n        assert 10 != approx(1, rel=1e-6, abs=1e-12)\n        assert not (10 == approx(1, rel=1e-6, abs=1e-12))\n\n    def test_exactly_equal(self):\n        examples = [\n            (2.0, 2.0),\n            (0.1e200, 0.1e200),\n            (1.123e-300, 1.123e-300),\n            (12345, 12345.0),\n            (0.0, -0.0),\n            (345678, 345678),\n            (Decimal(\"1.0001\"), Decimal(\"1.0001\")),\n            (Fraction(1, 3), Fraction(-1, -3)),\n        ]\n        for a, x in examples:\n            assert a == approx(x)\n\n    def test_opposite_sign(self):\n        examples = [(eq, 1e-100, -1e-100), (ne, 1e100, -1e100)]\n        for op, a, x in examples:\n            assert op(a, approx(x))\n\n    def test_zero_tolerance(self):\n        within_1e10 = [(1.1e-100, 1e-100), (-1.1e-100, -1e-100)]\n        for a, x in within_1e10:\n            assert x == approx(x, rel=0.0, abs=0.0)\n            assert a != approx(x, rel=0.0, abs=0.0)\n            assert a == approx(x, rel=0.0, abs=5e-101)\n            assert a != approx(x, rel=0.0, abs=5e-102)\n            assert a == approx(x, rel=5e-1, abs=0.0)\n            assert a != approx(x, rel=5e-2, abs=0.0)\n\n    def test_negative_tolerance(self):\n        # Negative tolerances are not allowed.\n        illegal_kwargs = [\n            dict(rel=-1e100),\n            dict(abs=-1e100),\n            dict(rel=1e100, abs=-1e100),\n            dict(rel=-1e100, abs=1e100),\n            dict(rel=-1e100, abs=-1e100),\n        ]\n        for kwargs in illegal_kwargs:\n            with pytest.raises(ValueError):\n                1.1 == approx(1, **kwargs)\n\n    def test_inf_tolerance(self):\n        # Everything should be equal if the tolerance is infinite.\n        large_diffs = [(1, 1000), (1e-50, 1e50), (-1.0, -1e300), (0.0, 10)]\n        for a, x in large_diffs:\n            assert a != approx(x, rel=0.0, abs=0.0)\n            assert a == approx(x, rel=inf, abs=0.0)\n            assert a == approx(x, rel=0.0, abs=inf)\n            assert a == approx(x, rel=inf, abs=inf)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_inf_tolerance_expecting_zero_TestApprox.test_default_tolerances": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_inf_tolerance_expecting_zero_TestApprox.test_default_tolerances", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 134, "end_line": 170, "span_ids": ["TestApprox.test_default_tolerances", "TestApprox.test_inf_tolerance_expecting_zero", "TestApprox.test_nan_tolerance", "TestApprox.test_reasonable_defaults"], "tokens": 426}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_inf_tolerance_expecting_zero(self):\n        # If the relative tolerance is zero but the expected value is infinite,\n        # the actual tolerance is a NaN, which should be an error.\n        illegal_kwargs = [dict(rel=inf, abs=0.0), dict(rel=inf, abs=inf)]\n        for kwargs in illegal_kwargs:\n            with pytest.raises(ValueError):\n                1 == approx(0, **kwargs)\n\n    def test_nan_tolerance(self):\n        illegal_kwargs = [dict(rel=nan), dict(abs=nan), dict(rel=nan, abs=nan)]\n        for kwargs in illegal_kwargs:\n            with pytest.raises(ValueError):\n                1.1 == approx(1, **kwargs)\n\n    def test_reasonable_defaults(self):\n        # Whatever the defaults are, they should work for numbers close to 1\n        # than have a small amount of floating-point error.\n        assert 0.1 + 0.2 == approx(0.3)\n\n    def test_default_tolerances(self):\n        # This tests the defaults as they are currently set.  If you change the\n        # defaults, this test will fail but you should feel free to change it.\n        # None of the other tests (except the doctests) should be affected by\n        # the choice of defaults.\n        examples = [\n            # Relative tolerance used.\n            (eq, 1e100 + 1e94, 1e100),\n            (ne, 1e100 + 2e94, 1e100),\n            (eq, 1e0 + 1e-6, 1e0),\n            (ne, 1e0 + 2e-6, 1e0),\n            # Absolute tolerance used.\n            (eq, 1e-100, +1e-106),\n            (eq, 1e-100, +2e-106),\n            (eq, 1e-100, 0),\n        ]\n        for op, a, x in examples:\n            assert op(a, approx(x))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_custom_tolerances_TestApprox.test_custom_tolerances": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_custom_tolerances_TestApprox.test_custom_tolerances", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 172, "end_line": 186, "span_ids": ["TestApprox.test_custom_tolerances"], "tokens": 406}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_custom_tolerances(self):\n        assert 1e8 + 1e0 == approx(1e8, rel=5e-8, abs=5e0)\n        assert 1e8 + 1e0 == approx(1e8, rel=5e-9, abs=5e0)\n        assert 1e8 + 1e0 == approx(1e8, rel=5e-8, abs=5e-1)\n        assert 1e8 + 1e0 != approx(1e8, rel=5e-9, abs=5e-1)\n\n        assert 1e0 + 1e-8 == approx(1e0, rel=5e-8, abs=5e-8)\n        assert 1e0 + 1e-8 == approx(1e0, rel=5e-9, abs=5e-8)\n        assert 1e0 + 1e-8 == approx(1e0, rel=5e-8, abs=5e-9)\n        assert 1e0 + 1e-8 != approx(1e0, rel=5e-9, abs=5e-9)\n\n        assert 1e-8 + 1e-16 == approx(1e-8, rel=5e-8, abs=5e-16)\n        assert 1e-8 + 1e-16 == approx(1e-8, rel=5e-9, abs=5e-16)\n        assert 1e-8 + 1e-16 == approx(1e-8, rel=5e-8, abs=5e-17)\n        assert 1e-8 + 1e-16 != approx(1e-8, rel=5e-9, abs=5e-17)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_relative_tolerance_TestApprox.test_int": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_relative_tolerance_TestApprox.test_int", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 188, "end_line": 247, "span_ids": ["TestApprox.test_absolute_tolerance", "TestApprox.test_expecting_inf", "TestApprox.test_expecting_nan", "TestApprox.test_expecting_zero", "TestApprox.test_int", "TestApprox.test_relative_tolerance"], "tokens": 714}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_relative_tolerance(self):\n        within_1e8_rel = [(1e8 + 1e0, 1e8), (1e0 + 1e-8, 1e0), (1e-8 + 1e-16, 1e-8)]\n        for a, x in within_1e8_rel:\n            assert a == approx(x, rel=5e-8, abs=0.0)\n            assert a != approx(x, rel=5e-9, abs=0.0)\n\n    def test_absolute_tolerance(self):\n        within_1e8_abs = [(1e8 + 9e-9, 1e8), (1e0 + 9e-9, 1e0), (1e-8 + 9e-9, 1e-8)]\n        for a, x in within_1e8_abs:\n            assert a == approx(x, rel=0, abs=5e-8)\n            assert a != approx(x, rel=0, abs=5e-9)\n\n    def test_expecting_zero(self):\n        examples = [\n            (ne, 1e-6, 0.0),\n            (ne, -1e-6, 0.0),\n            (eq, 1e-12, 0.0),\n            (eq, -1e-12, 0.0),\n            (ne, 2e-12, 0.0),\n            (ne, -2e-12, 0.0),\n            (ne, inf, 0.0),\n            (ne, nan, 0.0),\n        ]\n        for op, a, x in examples:\n            assert op(a, approx(x, rel=0.0, abs=1e-12))\n            assert op(a, approx(x, rel=1e-6, abs=1e-12))\n\n    def test_expecting_inf(self):\n        examples = [\n            (eq, inf, inf),\n            (eq, -inf, -inf),\n            (ne, inf, -inf),\n            (ne, 0.0, inf),\n            (ne, nan, inf),\n        ]\n        for op, a, x in examples:\n            assert op(a, approx(x))\n\n    def test_expecting_nan(self):\n        examples = [\n            (eq, nan, nan),\n            (eq, -nan, -nan),\n            (eq, nan, -nan),\n            (ne, 0.0, nan),\n            (ne, inf, nan),\n        ]\n        for op, a, x in examples:\n            # Nothing is equal to NaN by default.\n            assert a != approx(x)\n\n            # If ``nan_ok=True``, then NaN is equal to NaN.\n            assert op(a, approx(x, nan_ok=True))\n\n    def test_int(self):\n        within_1e6 = [(1000001, 1000000), (-1000001, -1000000)]\n        for a, x in within_1e6:\n            assert a == approx(x, rel=5e-6, abs=0)\n            assert a != approx(x, rel=5e-7, abs=0)\n            assert approx(x, rel=5e-6, abs=0) == a\n            assert approx(x, rel=5e-7, abs=0) != a", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_decimal_TestApprox.test_list_wrong_len": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_decimal_TestApprox.test_list_wrong_len", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 249, "end_line": 297, "span_ids": ["TestApprox.test_complex", "TestApprox.test_decimal", "TestApprox.test_fraction", "TestApprox.test_list", "TestApprox.test_list_wrong_len"], "tokens": 634}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_decimal(self):\n        within_1e6 = [\n            (Decimal(\"1.000001\"), Decimal(\"1.0\")),\n            (Decimal(\"-1.000001\"), Decimal(\"-1.0\")),\n        ]\n        for a, x in within_1e6:\n            assert a == approx(x)\n            assert a == approx(x, rel=Decimal(\"5e-6\"), abs=0)\n            assert a != approx(x, rel=Decimal(\"5e-7\"), abs=0)\n            assert approx(x, rel=Decimal(\"5e-6\"), abs=0) == a\n            assert approx(x, rel=Decimal(\"5e-7\"), abs=0) != a\n\n    def test_fraction(self):\n        within_1e6 = [\n            (1 + Fraction(1, 1000000), Fraction(1)),\n            (-1 - Fraction(-1, 1000000), Fraction(-1)),\n        ]\n        for a, x in within_1e6:\n            assert a == approx(x, rel=5e-6, abs=0)\n            assert a != approx(x, rel=5e-7, abs=0)\n            assert approx(x, rel=5e-6, abs=0) == a\n            assert approx(x, rel=5e-7, abs=0) != a\n\n    def test_complex(self):\n        within_1e6 = [\n            (1.000001 + 1.0j, 1.0 + 1.0j),\n            (1.0 + 1.000001j, 1.0 + 1.0j),\n            (-1.000001 + 1.0j, -1.0 + 1.0j),\n            (1.0 - 1.000001j, 1.0 - 1.0j),\n        ]\n        for a, x in within_1e6:\n            assert a == approx(x, rel=5e-6, abs=0)\n            assert a != approx(x, rel=5e-7, abs=0)\n            assert approx(x, rel=5e-6, abs=0) == a\n            assert approx(x, rel=5e-7, abs=0) != a\n\n    def test_list(self):\n        actual = [1 + 1e-7, 2 + 1e-8]\n        expected = [1, 2]\n\n        # Return false if any element is outside the tolerance.\n        assert actual == approx(expected, rel=5e-7, abs=0)\n        assert actual != approx(expected, rel=5e-8, abs=0)\n        assert approx(expected, rel=5e-7, abs=0) == actual\n        assert approx(expected, rel=5e-8, abs=0) != actual\n\n    def test_list_wrong_len(self):\n        assert [1, 2] != approx([1])\n        assert [1, 2] != approx([1, 2, 3])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_tuple_TestApprox.test_dict_wrong_len": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_tuple_TestApprox.test_dict_wrong_len", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 299, "end_line": 328, "span_ids": ["TestApprox.test_dict", "TestApprox.test_dict_wrong_len", "TestApprox.test_tuple", "TestApprox.test_tuple_wrong_len"], "tokens": 411}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_tuple(self):\n        actual = (1 + 1e-7, 2 + 1e-8)\n        expected = (1, 2)\n\n        # Return false if any element is outside the tolerance.\n        assert actual == approx(expected, rel=5e-7, abs=0)\n        assert actual != approx(expected, rel=5e-8, abs=0)\n        assert approx(expected, rel=5e-7, abs=0) == actual\n        assert approx(expected, rel=5e-8, abs=0) != actual\n\n    def test_tuple_wrong_len(self):\n        assert (1, 2) != approx((1,))\n        assert (1, 2) != approx((1, 2, 3))\n\n    def test_dict(self):\n        actual = {\"a\": 1 + 1e-7, \"b\": 2 + 1e-8}\n        # Dictionaries became ordered in python3.6, so switch up the order here\n        # to make sure it doesn't matter.\n        expected = {\"b\": 2, \"a\": 1}\n\n        # Return false if any element is outside the tolerance.\n        assert actual == approx(expected, rel=5e-7, abs=0)\n        assert actual != approx(expected, rel=5e-8, abs=0)\n        assert approx(expected, rel=5e-7, abs=0) == actual\n        assert approx(expected, rel=5e-8, abs=0) != actual\n\n    def test_dict_wrong_len(self):\n        assert {\"a\": 1, \"b\": 2} != approx({\"a\": 1})\n        assert {\"a\": 1, \"b\": 2} != approx({\"a\": 1, \"c\": 2})\n        assert {\"a\": 1, \"b\": 2} != approx({\"a\": 1, \"b\": 2, \"c\": 3})", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_array_TestApprox.test_numpy_array": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_array_TestApprox.test_numpy_array", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 330, "end_line": 346, "span_ids": ["TestApprox.test_numpy_array"], "tokens": 226}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_numpy_array(self):\n        np = pytest.importorskip(\"numpy\")\n\n        actual = np.array([1 + 1e-7, 2 + 1e-8])\n        expected = np.array([1, 2])\n\n        # Return false if any element is outside the tolerance.\n        assert actual == approx(expected, rel=5e-7, abs=0)\n        assert actual != approx(expected, rel=5e-8, abs=0)\n        assert approx(expected, rel=5e-7, abs=0) == expected\n        assert approx(expected, rel=5e-8, abs=0) != actual\n\n        # Should be able to compare lists with numpy arrays.\n        assert list(actual) == approx(expected, rel=5e-7, abs=0)\n        assert list(actual) != approx(expected, rel=5e-8, abs=0)\n        assert actual == approx(list(expected), rel=5e-7, abs=0)\n        assert actual != approx(list(expected), rel=5e-8, abs=0)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_tolerance_args_TestApprox.test_numpy_tolerance_args.for_op__abs__rel_in_tes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_tolerance_args_TestApprox.test_numpy_tolerance_args.for_op__abs__rel_in_tes", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 348, "end_line": 376, "span_ids": ["TestApprox.test_numpy_tolerance_args"], "tokens": 315}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_numpy_tolerance_args(self):\n        \"\"\"\n        Check that numpy rel/abs args are handled correctly\n        for comparison against an np.array\n        Check both sides of the operator, hopefully it doesn't impact things.\n        Test all permutations of where the approx and np.array() can show up\n        \"\"\"\n        np = pytest.importorskip(\"numpy\")\n        expected = 100.0\n        actual = 99.0\n        abs_diff = expected - actual\n        rel_diff = (expected - actual) / expected\n\n        tests = [\n            (eq, abs_diff, 0),\n            (eq, 0, rel_diff),\n            (ne, 0, rel_diff / 2.0),  # rel diff fail\n            (ne, abs_diff / 2.0, 0),  # abs diff fail\n        ]\n\n        for op, _abs, _rel in tests:\n            assert op(np.array(actual), approx(expected, abs=_abs, rel=_rel))  # a, b\n            assert op(approx(expected, abs=_abs, rel=_rel), np.array(actual))  # b, a\n\n            assert op(actual, approx(np.array(expected), abs=_abs, rel=_rel))  # a, b\n            assert op(approx(np.array(expected), abs=_abs, rel=_rel), actual)  # b, a\n\n            assert op(np.array(actual), approx(np.array(expected), abs=_abs, rel=_rel))\n            assert op(approx(np.array(expected), abs=_abs, rel=_rel), np.array(actual))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_expecting_nan_TestApprox.test_comparison_operator_type_error": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_expecting_nan_TestApprox.test_comparison_operator_type_error", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 390, "end_line": 487, "span_ids": ["TestApprox.test_comparison_operator_type_error", "TestApprox.test_doctests", "TestApprox.test_expected_value_type_error", "TestApprox.test_numpy_array_wrong_shape", "TestApprox.test_numpy_expecting_inf", "TestApprox.test_numpy_expecting_nan", "TestApprox.test_unicode_plus_minus"], "tokens": 735}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_numpy_expecting_nan(self):\n        np = pytest.importorskip(\"numpy\")\n        examples = [\n            (eq, nan, nan),\n            (eq, -nan, -nan),\n            (eq, nan, -nan),\n            (ne, 0.0, nan),\n            (ne, inf, nan),\n        ]\n        for op, a, x in examples:\n            # Nothing is equal to NaN by default.\n            assert np.array(a) != approx(x)\n            assert a != approx(np.array(x))\n\n            # If ``nan_ok=True``, then NaN is equal to NaN.\n            assert op(np.array(a), approx(x, nan_ok=True))\n            assert op(a, approx(np.array(x), nan_ok=True))\n\n    def test_numpy_expecting_inf(self):\n        np = pytest.importorskip(\"numpy\")\n        examples = [\n            (eq, inf, inf),\n            (eq, -inf, -inf),\n            (ne, inf, -inf),\n            (ne, 0.0, inf),\n            (ne, nan, inf),\n        ]\n        for op, a, x in examples:\n            assert op(np.array(a), approx(x))\n            assert op(a, approx(np.array(x)))\n            assert op(np.array(a), approx(np.array(x)))\n\n    def test_numpy_array_wrong_shape(self):\n        np = pytest.importorskip(\"numpy\")\n\n        a12 = np.array([[1, 2]])\n        a21 = np.array([[1], [2]])\n\n        assert a12 != approx(a21)\n        assert a21 != approx(a12)\n\n    def test_doctests(self, mocked_doctest_runner):\n        import doctest\n\n        parser = doctest.DocTestParser()\n        test = parser.get_doctest(\n            approx.__doc__, {\"approx\": approx}, approx.__name__, None, None\n        )\n        mocked_doctest_runner.run(test)\n\n    def test_unicode_plus_minus(self, testdir):\n        \"\"\"\n        Comparing approx instances inside lists should not produce an error in the detailed diff.\n        Integration test for issue #2111.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_foo():\n                assert [3] == [pytest.approx(4)]\n        \"\"\"\n        )\n        expected = \"4.0e-06\"\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\"*At index 0 diff: 3 != 4 \u00b1 {}\".format(expected), \"=* 1 failed in *=\"]\n        )\n\n    @pytest.mark.parametrize(\n        \"x\",\n        [\n            pytest.param(None),\n            pytest.param(\"string\"),\n            pytest.param([\"string\"], id=\"nested-str\"),\n            pytest.param([[1]], id=\"nested-list\"),\n            pytest.param({\"key\": \"string\"}, id=\"dict-with-string\"),\n            pytest.param({\"key\": {\"key\": 1}}, id=\"nested-dict\"),\n        ],\n    )\n    def test_expected_value_type_error(self, x):\n        with pytest.raises(TypeError):\n            approx(x)\n\n    @pytest.mark.parametrize(\n        \"op\",\n        [\n            pytest.param(operator.le, id=\"<=\"),\n            pytest.param(operator.lt, id=\"<\"),\n            pytest.param(operator.ge, id=\">=\"),\n            pytest.param(operator.gt, id=\">\"),\n        ],\n    )\n    def test_comparison_operator_type_error(self, op):\n        \"\"\"\n        pytest.approx should raise TypeError for operators other than == and != (#2003).\n        \"\"\"\n        with pytest.raises(TypeError):\n            op(1, approx(1, rel=1e-6, abs=1e-12))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_array_with_scalar_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_numpy_array_with_scalar_", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 476, "end_line": 508, "span_ids": ["TestApprox.test_generic_sized_iterable_object", "TestApprox.test_numpy_array_with_scalar", "TestApprox.test_numpy_scalar_with_array"], "tokens": 321}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_numpy_array_with_scalar(self):\n        np = pytest.importorskip(\"numpy\")\n\n        actual = np.array([1 + 1e-7, 1 - 1e-8])\n        expected = 1.0\n\n        assert actual == approx(expected, rel=5e-7, abs=0)\n        assert actual != approx(expected, rel=5e-8, abs=0)\n        assert approx(expected, rel=5e-7, abs=0) == actual\n        assert approx(expected, rel=5e-8, abs=0) != actual\n\n    def test_numpy_scalar_with_array(self):\n        np = pytest.importorskip(\"numpy\")\n\n        actual = 1.0\n        expected = np.array([1 + 1e-7, 1 - 1e-8])\n\n        assert actual == approx(expected, rel=5e-7, abs=0)\n        assert actual != approx(expected, rel=5e-8, abs=0)\n        assert approx(expected, rel=5e-7, abs=0) == actual\n        assert approx(expected, rel=5e-8, abs=0) != actual\n\n    def test_generic_sized_iterable_object(self):\n        class MySizedIterable:\n            def __iter__(self):\n                return iter([1, 2, 3, 4])\n\n            def __len__(self):\n                return 4\n\n        expected = MySizedIterable()\n        assert [1, 2, 3, 4] == approx(expected)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestModule.test_show_traceback_import_error_TestModule.test_show_traceback_import_error_unicode": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestModule.test_show_traceback_import_error_TestModule.test_show_traceback_import_error_unicode", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 79, "end_line": 128, "span_ids": ["TestModule.test_show_traceback_import_error", "TestModule.test_show_traceback_import_error_unicode"], "tokens": 343}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestModule:\n\n    @pytest.mark.parametrize(\"verbose\", [0, 1, 2])\n    def test_show_traceback_import_error(self, testdir, verbose):\n        \"\"\"Import errors when collecting modules should display the traceback (#1976).\n\n        With low verbosity we omit pytest and internal modules, otherwise show all traceback entries.\n        \"\"\"\n        testdir.makepyfile(\n            foo_traceback_import_error=\"\"\"\n               from bar_traceback_import_error import NOT_AVAILABLE\n           \"\"\",\n            bar_traceback_import_error=\"\",\n        )\n        testdir.makepyfile(\n            \"\"\"\n               import foo_traceback_import_error\n        \"\"\"\n        )\n        args = (\"-v\",) * verbose\n        result = testdir.runpytest(*args)\n        result.stdout.fnmatch_lines(\n            [\n                \"ImportError while importing test module*\",\n                \"Traceback:\",\n                \"*from bar_traceback_import_error import NOT_AVAILABLE\",\n                \"*cannot import name *NOT_AVAILABLE*\",\n            ]\n        )\n        assert result.ret == 2\n\n        stdout = result.stdout.str()\n        for name in (\"_pytest\", os.path.join(\"py\", \"_path\")):\n            if verbose == 2:\n                assert name in stdout\n            else:\n                assert name not in stdout\n\n    def test_show_traceback_import_error_unicode(self, testdir):\n        \"\"\"Check test modules collected which raise ImportError with unicode messages\n        are handled properly (#2336).\n        \"\"\"\n        testdir.makepyfile(\"raise ImportError('Something bad happened \u263a')\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"ImportError while importing test module*\",\n                \"Traceback:\",\n                \"*raise ImportError*Something bad happened*\",\n            ]\n        )\n        assert result.ret == 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestClass_TestClass.test_issue2234_property": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestClass_TestClass.test_issue2234_property", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 131, "end_line": 249, "span_ids": ["TestClass", "TestClass.test_class_subclassobject", "TestClass.test_class_with_init_warning", "TestClass.test_class_with_new_warning", "TestClass.test_issue1035_obj_has_getattr", "TestClass.test_issue1579_namedtuple", "TestClass.test_issue2234_property", "TestClass.test_setup_teardown_class_as_classmethod", "TestClass.test_static_method"], "tokens": 675}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestClass:\n    def test_class_with_init_warning(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class TestClass1(object):\n                def __init__(self):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*cannot collect test class 'TestClass1' because it has \"\n                \"a __init__ constructor (from: test_class_with_init_warning.py)\"\n            ]\n        )\n\n    def test_class_with_new_warning(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class TestClass1(object):\n                def __new__(self):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*cannot collect test class 'TestClass1' because it has \"\n                \"a __new__ constructor (from: test_class_with_new_warning.py)\"\n            ]\n        )\n\n    def test_class_subclassobject(self, testdir):\n        testdir.getmodulecol(\n            \"\"\"\n            class test(object):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*collected 0*\"])\n\n    def test_static_method(self, testdir):\n        \"\"\"Support for collecting staticmethod tests (#2528, #2699)\"\"\"\n        testdir.getmodulecol(\n            \"\"\"\n            import pytest\n            class Test(object):\n                @staticmethod\n                def test_something():\n                    pass\n\n                @pytest.fixture\n                def fix(self):\n                    return 1\n\n                @staticmethod\n                def test_fix(fix):\n                    assert fix == 1\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*collected 2 items*\", \"*2 passed in*\"])\n\n    def test_setup_teardown_class_as_classmethod(self, testdir):\n        testdir.makepyfile(\n            test_mod1=\"\"\"\n            class TestClassMethod(object):\n                @classmethod\n                def setup_class(cls):\n                    pass\n                def test_1(self):\n                    pass\n                @classmethod\n                def teardown_class(cls):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_issue1035_obj_has_getattr(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            class Chameleon(object):\n                def __getattr__(self, name):\n                    return True\n            chameleon = Chameleon()\n        \"\"\"\n        )\n        colitems = modcol.collect()\n        assert len(colitems) == 0\n\n    def test_issue1579_namedtuple(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import collections\n\n            TestCase = collections.namedtuple('TestCase', ['a'])\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            \"*cannot collect test class 'TestCase' \"\n            \"because it has a __new__ constructor*\"\n        )\n\n    def test_issue2234_property(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class TestCase(object):\n                @property\n                def prop(self):\n                    raise NotImplementedError()\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction_TestFunction.test_issue213_parametrize_value_no_equal": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction_TestFunction.test_issue213_parametrize_value_no_equal", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 252, "end_line": 344, "span_ids": ["TestFunction", "TestFunction.make_function", "TestFunction.test_function_as_object_instance_ignored", "TestFunction.test_function_equality", "TestFunction.test_getmodulecollector", "TestFunction.test_issue197_parametrize_emptyset", "TestFunction.test_issue213_parametrize_value_no_equal", "TestFunction.test_repr_produces_actual_test_id", "TestFunction.test_single_tuple_unwraps_values"], "tokens": 636}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunction:\n    def test_getmodulecollector(self, testdir):\n        item = testdir.getitem(\"def test_func(): pass\")\n        modcol = item.getparent(pytest.Module)\n        assert isinstance(modcol, pytest.Module)\n        assert hasattr(modcol.obj, \"test_func\")\n\n    @pytest.mark.filterwarnings(\"default\")\n    def test_function_as_object_instance_ignored(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class A(object):\n                def __call__(self, tmpdir):\n                    0/0\n\n            test_a = A()\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 0 items\",\n                \"*test_function_as_object_instance_ignored.py:2: \"\n                \"*cannot collect 'test_a' because it is not a function.\",\n            ]\n        )\n\n    @staticmethod\n    def make_function(testdir, **kwargs):\n        from _pytest.fixtures import FixtureManager\n\n        config = testdir.parseconfigure()\n        session = testdir.Session.from_config(config)\n        session._fixturemanager = FixtureManager(session)\n\n        return pytest.Function.from_parent(parent=session, **kwargs)\n\n    def test_function_equality(self, testdir):\n        def func1():\n            pass\n\n        def func2():\n            pass\n\n        f1 = self.make_function(testdir, name=\"name\", args=(1,), callobj=func1)\n        assert f1 == f1\n        f2 = self.make_function(testdir, name=\"name\", callobj=func2)\n        assert f1 != f2\n\n    def test_repr_produces_actual_test_id(self, testdir):\n        f = self.make_function(\n            testdir, name=r\"test[\\xe5]\", callobj=self.test_repr_produces_actual_test_id\n        )\n        assert repr(f) == r\"<Function test[\\xe5]>\"\n\n    def test_issue197_parametrize_emptyset(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('arg', [])\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(skipped=1)\n\n    def test_single_tuple_unwraps_values(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize(('arg',), [(1,)])\n            def test_function(arg):\n                assert arg == 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_issue213_parametrize_value_no_equal(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            class A(object):\n                def __eq__(self, other):\n                    raise ValueError(\"not possible\")\n            @pytest.mark.parametrize('arg', [A()])\n            def test_function(arg):\n                assert arg.__class__.__name__ == \"A\"\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"--fulltrace\")\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_with_non_hashable_values_TestFunction.test_parametrize_overrides_parametrized_fixture": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_with_non_hashable_values_TestFunction.test_parametrize_overrides_parametrized_fixture", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 346, "end_line": 441, "span_ids": ["TestFunction.test_parametrize_overrides_fixture", "TestFunction.test_parametrize_overrides_parametrized_fixture", "TestFunction.test_parametrize_with_non_hashable_values", "TestFunction.test_parametrize_with_non_hashable_values_indirect"], "tokens": 632}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunction:\n\n    def test_parametrize_with_non_hashable_values(self, testdir):\n        \"\"\"Test parametrization with non-hashable values.\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            archival_mapping = {\n                '1.0': {'tag': '1.0'},\n                '1.2.2a1': {'tag': 'release-1.2.2a1'},\n            }\n\n            import pytest\n            @pytest.mark.parametrize('key value'.split(),\n                                     archival_mapping.items())\n            def test_archival_to_version(key, value):\n                assert key in archival_mapping\n                assert value == archival_mapping[key]\n        \"\"\"\n        )\n        rec = testdir.inline_run()\n        rec.assertoutcome(passed=2)\n\n    def test_parametrize_with_non_hashable_values_indirect(self, testdir):\n        \"\"\"Test parametrization with non-hashable values with indirect parametrization.\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            archival_mapping = {\n                '1.0': {'tag': '1.0'},\n                '1.2.2a1': {'tag': 'release-1.2.2a1'},\n            }\n\n            import pytest\n\n            @pytest.fixture\n            def key(request):\n                return request.param\n\n            @pytest.fixture\n            def value(request):\n                return request.param\n\n            @pytest.mark.parametrize('key value'.split(),\n                                     archival_mapping.items(), indirect=True)\n            def test_archival_to_version(key, value):\n                assert key in archival_mapping\n                assert value == archival_mapping[key]\n        \"\"\"\n        )\n        rec = testdir.inline_run()\n        rec.assertoutcome(passed=2)\n\n    def test_parametrize_overrides_fixture(self, testdir):\n        \"\"\"Test parametrization when parameter overrides existing fixture with same name.\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def value():\n                return 'value'\n\n            @pytest.mark.parametrize('value',\n                                     ['overridden'])\n            def test_overridden_via_param(value):\n                assert value == 'overridden'\n\n            @pytest.mark.parametrize('somevalue', ['overridden'])\n            def test_not_overridden(value, somevalue):\n                assert value == 'value'\n                assert somevalue == 'overridden'\n\n            @pytest.mark.parametrize('other,value', [('foo', 'overridden')])\n            def test_overridden_via_multiparam(other, value):\n                assert other == 'foo'\n                assert value == 'overridden'\n        \"\"\"\n        )\n        rec = testdir.inline_run()\n        rec.assertoutcome(passed=3)\n\n    def test_parametrize_overrides_parametrized_fixture(self, testdir):\n        \"\"\"Test parametrization when parameter overrides existing parametrized fixture with same name.\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[1, 2])\n            def value(request):\n                return request.param\n\n            @pytest.mark.parametrize('value',\n                                     ['overridden'])\n            def test_overridden_via_param(value):\n                assert value == 'overridden'\n        \"\"\"\n        )\n        rec = testdir.inline_run()\n        rec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestSorting_TestSorting.test_allow_sane_sorting_for_decorators": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestSorting_TestSorting.test_allow_sane_sorting_for_decorators", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 661, "end_line": 710, "span_ids": ["TestSorting", "TestSorting.test_allow_sane_sorting_for_decorators", "TestSorting.test_check_equality"], "tokens": 338}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSorting:\n    def test_check_equality(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            def test_pass(): pass\n            def test_fail(): assert 0\n        \"\"\"\n        )\n        fn1 = testdir.collect_by_name(modcol, \"test_pass\")\n        assert isinstance(fn1, pytest.Function)\n        fn2 = testdir.collect_by_name(modcol, \"test_pass\")\n        assert isinstance(fn2, pytest.Function)\n\n        assert fn1 == fn2\n        assert fn1 != modcol\n        assert hash(fn1) == hash(fn2)\n\n        fn3 = testdir.collect_by_name(modcol, \"test_fail\")\n        assert isinstance(fn3, pytest.Function)\n        assert not (fn1 == fn3)\n        assert fn1 != fn3\n\n        for fn in fn1, fn2, fn3:\n            assert fn != 3\n            assert fn != modcol\n            assert fn != [1, 2, 3]\n            assert [1, 2, 3] != fn\n            assert modcol != fn\n\n    def test_allow_sane_sorting_for_decorators(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            def dec(f):\n                g = lambda: f(2)\n                g.place_as = f\n                return g\n\n\n            def test_b(y):\n                pass\n            test_b = dec(test_b)\n\n            def test_a(y):\n                pass\n            test_a = dec(test_a)\n        \"\"\"\n        )\n        colitems = modcol.collect()\n        assert len(colitems) == 2\n        assert [item.name for item in colitems] == [\"test_b\", \"test_a\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestConftestCustomization_TestConftestCustomization.test_makeitem_non_underscore": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestConftestCustomization_TestConftestCustomization.test_makeitem_non_underscore", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 713, "end_line": 810, "span_ids": ["TestConftestCustomization", "TestConftestCustomization.test_customized_pymakeitem", "TestConftestCustomization.test_customized_pymakemodule_issue205_subdir", "TestConftestCustomization.test_makeitem_non_underscore", "TestConftestCustomization.test_pytest_pycollect_makeitem", "TestConftestCustomization.test_pytest_pycollect_module"], "tokens": 678}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConftestCustomization:\n    def test_pytest_pycollect_module(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule(pytest.Module):\n                pass\n            def pytest_pycollect_makemodule(path, parent):\n                if path.basename == \"test_xyz.py\":\n                    return MyModule(path, parent)\n        \"\"\"\n        )\n        testdir.makepyfile(\"def test_some(): pass\")\n        testdir.makepyfile(test_xyz=\"def test_func(): pass\")\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*<Module*test_pytest*\", \"*<MyModule*xyz*\"])\n\n    def test_customized_pymakemodule_issue205_subdir(self, testdir):\n        b = testdir.mkdir(\"a\").mkdir(\"b\")\n        b.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.hookimpl(hookwrapper=True)\n                def pytest_pycollect_makemodule():\n                    outcome = yield\n                    mod = outcome.get_result()\n                    mod.obj.hello = \"world\"\n                \"\"\"\n            )\n        )\n        b.join(\"test_module.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def test_hello():\n                    assert hello == \"world\"\n                \"\"\"\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_customized_pymakeitem(self, testdir):\n        b = testdir.mkdir(\"a\").mkdir(\"b\")\n        b.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.hookimpl(hookwrapper=True)\n                def pytest_pycollect_makeitem():\n                    outcome = yield\n                    if outcome.excinfo is None:\n                        result = outcome.get_result()\n                        if result:\n                            for func in result:\n                                func._some123 = \"world\"\n                \"\"\"\n            )\n        )\n        b.join(\"test_module.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n\n                @pytest.fixture()\n                def obj(request):\n                    return request.node._some123\n                def test_hello(obj):\n                    assert obj == \"world\"\n                \"\"\"\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_pytest_pycollect_makeitem(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class MyFunction(pytest.Function):\n                pass\n            def pytest_pycollect_makeitem(collector, name, obj):\n                if name == \"some\":\n                    return MyFunction(name, collector)\n        \"\"\"\n        )\n        testdir.makepyfile(\"def some(): pass\")\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*MyFunction*some*\"])\n\n    def test_makeitem_non_underscore(self, testdir, monkeypatch):\n        modcol = testdir.getmodulecol(\"def _hello(): pass\")\n        values = []\n        monkeypatch.setattr(\n            pytest.Module, \"_makeitem\", lambda self, name, obj: values.append(name)\n        )\n        values = modcol.collect()\n        assert \"_hello\" not in values", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestConftestCustomization.test_issue2369_collect_module_fileext_TestConftestCustomization.test_issue2369_collect_module_fileext.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestConftestCustomization.test_issue2369_collect_module_fileext_TestConftestCustomization.test_issue2369_collect_module_fileext.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 812, "end_line": 843, "span_ids": ["TestConftestCustomization.test_issue2369_collect_module_fileext"], "tokens": 246}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConftestCustomization:\n\n    def test_issue2369_collect_module_fileext(self, testdir):\n        \"\"\"Ensure we can collect files with weird file extensions as Python\n        modules (#2369)\"\"\"\n        # We'll implement a little finder and loader to import files containing\n        # Python source code whose file extension is \".narf\".\n        testdir.makeconftest(\n            \"\"\"\n            import sys, os, imp\n            from _pytest.python import Module\n\n            class Loader(object):\n                def load_module(self, name):\n                    return imp.load_source(name, name + \".narf\")\n            class Finder(object):\n                def find_module(self, name, path=None):\n                    if os.path.exists(name + \".narf\"):\n                        return Loader()\n            sys.meta_path.append(Finder())\n\n            def pytest_collect_file(path, parent):\n                if path.ext == \".narf\":\n                    return Module(path, parent)\"\"\"\n        )\n        testdir.makefile(\n            \".narf\",\n            \"\"\"\\\n            def test_something():\n                assert 1 + 1 == 2\"\"\",\n        )\n        # Use runpytest_subprocess, since we're futzing with sys.meta_path.\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_setup_only_available_in_subdir_test_modulecol_roundtrip": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_setup_only_available_in_subdir_test_modulecol_roundtrip", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 837, "end_line": 876, "span_ids": ["test_modulecol_roundtrip", "test_setup_only_available_in_subdir"], "tokens": 357}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_setup_only_available_in_subdir(testdir):\n    sub1 = testdir.mkpydir(\"sub1\")\n    sub2 = testdir.mkpydir(\"sub2\")\n    sub1.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n            def pytest_runtest_setup(item):\n                assert item.fspath.purebasename == \"test_in_sub1\"\n            def pytest_runtest_call(item):\n                assert item.fspath.purebasename == \"test_in_sub1\"\n            def pytest_runtest_teardown(item):\n                assert item.fspath.purebasename == \"test_in_sub1\"\n            \"\"\"\n        )\n    )\n    sub2.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n            def pytest_runtest_setup(item):\n                assert item.fspath.purebasename == \"test_in_sub2\"\n            def pytest_runtest_call(item):\n                assert item.fspath.purebasename == \"test_in_sub2\"\n            def pytest_runtest_teardown(item):\n                assert item.fspath.purebasename == \"test_in_sub2\"\n            \"\"\"\n        )\n    )\n    sub1.join(\"test_in_sub1.py\").write(\"def test_1(): pass\")\n    sub2.join(\"test_in_sub2.py\").write(\"def test_2(): pass\")\n    result = testdir.runpytest(\"-v\", \"-s\")\n    result.assert_outcomes(passed=2)\n\n\ndef test_modulecol_roundtrip(testdir):\n    modcol = testdir.getmodulecol(\"pass\", withinit=False)\n    trail = modcol.nodeid\n    newcol = modcol.session.perform_collect([trail], genitems=0)[0]\n    assert modcol.name == newcol.name", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestReportInfo_TestReportInfo.test_reportinfo_with_nasty_getattr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestReportInfo_TestReportInfo.test_reportinfo_with_nasty_getattr", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1032, "end_line": 1088, "span_ids": ["TestReportInfo", "TestReportInfo.test_class_reportinfo", "TestReportInfo.test_func_reportinfo", "TestReportInfo.test_itemreport_reportinfo", "TestReportInfo.test_reportinfo_with_nasty_getattr"], "tokens": 439}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportInfo:\n    def test_itemreport_reportinfo(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class MyFunction(pytest.Function):\n                def reportinfo(self):\n                    return \"ABCDE\", 42, \"custom\"\n            def pytest_pycollect_makeitem(collector, name, obj):\n                if name == \"test_func\":\n                    return MyFunction.from_parent(name=name, parent=collector)\n        \"\"\"\n        )\n        item = testdir.getitem(\"def test_func(): pass\")\n        item.config.pluginmanager.getplugin(\"runner\")\n        assert item.location == (\"ABCDE\", 42, \"custom\")\n\n    def test_func_reportinfo(self, testdir):\n        item = testdir.getitem(\"def test_func(): pass\")\n        fspath, lineno, modpath = item.reportinfo()\n        assert fspath == item.fspath\n        assert lineno == 0\n        assert modpath == \"test_func\"\n\n    def test_class_reportinfo(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            # lineno 0\n            class TestClass(object):\n                def test_hello(self): pass\n        \"\"\"\n        )\n        classcol = testdir.collect_by_name(modcol, \"TestClass\")\n        fspath, lineno, msg = classcol.reportinfo()\n        assert fspath == modcol.fspath\n        assert lineno == 1\n        assert msg == \"TestClass\"\n\n    @pytest.mark.filterwarnings(\n        \"ignore:usage of Generator.Function is deprecated, please use pytest.Function instead\"\n    )\n    def test_reportinfo_with_nasty_getattr(self, testdir):\n        # https://github.com/pytest-dev/pytest/issues/1204\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            # lineno 0\n            class TestClass(object):\n                def __getattr__(self, name):\n                    return \"this is not an int\"\n\n                def test_foo(self):\n                    pass\n        \"\"\"\n        )\n        classcol = testdir.collect_by_name(modcol, \"TestClass\")\n        instance = classcol.collect()[0]\n        fspath, lineno, msg = instance.reportinfo()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_package_ordering_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_package_ordering_", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1349, "end_line": 1382, "span_ids": ["test_package_ordering"], "tokens": 226}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_package_ordering(testdir):\n    \"\"\"\n    .\n    \u2514\u2500\u2500 root\n        \u251c\u2500\u2500 Test_root.py\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 sub1\n        \u2502   \u251c\u2500\u2500 Test_sub1.py\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 sub2\n            \u2514\u2500\u2500 test\n                \u2514\u2500\u2500 test_sub2.py\n\n    \"\"\"\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        python_files=*.py\n    \"\"\"\n    )\n    root = testdir.mkpydir(\"root\")\n    sub1 = root.mkdir(\"sub1\")\n    sub1.ensure(\"__init__.py\")\n    sub2 = root.mkdir(\"sub2\")\n    sub2_test = sub2.mkdir(\"sub2\")\n\n    root.join(\"Test_root.py\").write(\"def test_1(): pass\")\n    sub1.join(\"Test_sub1.py\").write(\"def test_2(): pass\")\n    sub2_test.join(\"test_sub2.py\").write(\"def test_3(): pass\")\n\n    # Execute from .\n    result = testdir.runpytest(\"-v\", \"-s\")\n    result.assert_outcomes(passed=3)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures_TestFillFixtures.test_extend_fixture_conftest_plugin.assert_result_ret_0": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures_TestFillFixtures.test_extend_fixture_conftest_plugin.assert_result_ret_0", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 85, "end_line": 184, "span_ids": ["TestFillFixtures", "TestFillFixtures.test_conftest_funcargs_only_available_in_subdir", "TestFillFixtures.test_detect_recursive_dependency_error", "TestFillFixtures.test_extend_fixture_conftest_conftest", "TestFillFixtures.test_extend_fixture_conftest_module", "TestFillFixtures.test_extend_fixture_conftest_plugin", "TestFillFixtures.test_extend_fixture_module_class", "TestFillFixtures.test_fillfuncargs_exposed", "TestFillFixtures.test_funcarg_basic", "TestFillFixtures.test_funcarg_lookup_classlevel", "TestFillFixtures.test_funcarg_lookup_modulelevel", "TestFillFixtures.test_funcarg_lookupfails"], "tokens": 717}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.pytester_example_path(\"fixtures/fill_fixtures\")\nclass TestFillFixtures:\n    def test_fillfuncargs_exposed(self):\n        # used by oejskit, kept for compatibility\n        assert pytest._fillfuncargs == fixtures.fillfixtures\n\n    def test_funcarg_lookupfails(self, testdir):\n        testdir.copy_example()\n        result = testdir.runpytest()  # \"--collect-only\")\n        assert result.ret != 0\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *def test_func(some)*\n            *fixture*some*not found*\n            *xyzsomething*\n            \"\"\"\n        )\n\n    def test_detect_recursive_dependency_error(self, testdir):\n        testdir.copy_example()\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\"*recursive dependency involving fixture 'fix1' detected*\"]\n        )\n\n    def test_funcarg_basic(self, testdir):\n        testdir.copy_example()\n        item = testdir.getitem(Path(\"test_funcarg_basic.py\"))\n        item._request._fillfixtures()\n        del item.funcargs[\"request\"]\n        assert len(get_public_names(item.funcargs)) == 2\n        assert item.funcargs[\"some\"] == \"test_func\"\n        assert item.funcargs[\"other\"] == 42\n\n    def test_funcarg_lookup_modulelevel(self, testdir):\n        testdir.copy_example()\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_funcarg_lookup_classlevel(self, testdir):\n        p = testdir.copy_example()\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_conftest_funcargs_only_available_in_subdir(self, testdir):\n        testdir.copy_example()\n        result = testdir.runpytest(\"-v\")\n        result.assert_outcomes(passed=2)\n\n    def test_extend_fixture_module_class(self, testdir):\n        testfile = testdir.copy_example()\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result = testdir.runpytest(testfile)\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_extend_fixture_conftest_module(self, testdir):\n        p = testdir.copy_example()\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result = testdir.runpytest(next(p.visit(\"test_*.py\")))\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_extend_fixture_conftest_conftest(self, testdir):\n        p = testdir.copy_example()\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result = testdir.runpytest(next(p.visit(\"test_*.py\")))\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_extend_fixture_conftest_plugin(self, testdir):\n        testdir.makepyfile(\n            testplugin=\"\"\"\n            import pytest\n\n            @pytest.fixture\n            def foo():\n                return 7\n        \"\"\"\n        )\n        testdir.syspathinsert()\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            pytest_plugins = 'testplugin'\n\n            @pytest.fixture\n            def foo(foo):\n                return foo + 7\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo(foo):\n                assert foo == 14\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_extend_fixture_plugin_plugin_TestFillFixtures.test_override_parametrized_fixture_conftest_module.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_extend_fixture_plugin_plugin_TestFillFixtures.test_override_parametrized_fixture_conftest_module.None_2", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 186, "end_line": 244, "span_ids": ["TestFillFixtures.test_extend_fixture_plugin_plugin", "TestFillFixtures.test_override_parametrized_fixture_conftest_module"], "tokens": 315}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.pytester_example_path(\"fixtures/fill_fixtures\")\nclass TestFillFixtures:\n\n    def test_extend_fixture_plugin_plugin(self, testdir):\n        # Two plugins should extend each order in loading order\n        testdir.makepyfile(\n            testplugin0=\"\"\"\n            import pytest\n\n            @pytest.fixture\n            def foo():\n                return 7\n        \"\"\"\n        )\n        testdir.makepyfile(\n            testplugin1=\"\"\"\n            import pytest\n\n            @pytest.fixture\n            def foo(foo):\n                return foo + 7\n        \"\"\"\n        )\n        testdir.syspathinsert()\n        testdir.makepyfile(\n            \"\"\"\n            pytest_plugins = ['testplugin0', 'testplugin1']\n\n            def test_foo(foo):\n                assert foo == 14\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 0\n\n    def test_override_parametrized_fixture_conftest_module(self, testdir):\n        \"\"\"Test override of the parametrized fixture with non-parametrized one on the test module level.\"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[1, 2, 3])\n            def spam(request):\n                return request.param\n        \"\"\"\n        )\n        testfile = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def spam():\n                return 'spam'\n\n            def test_spam(spam):\n                assert spam == 'spam'\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result = testdir.runpytest(testfile)\n        result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_parametrized_fixture_conftest_conftest_TestFillFixtures.test_override_non_parametrized_fixture_conftest_module.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_parametrized_fixture_conftest_conftest_TestFillFixtures.test_override_non_parametrized_fixture_conftest_module.None_2", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 246, "end_line": 312, "span_ids": ["TestFillFixtures.test_override_non_parametrized_fixture_conftest_module", "TestFillFixtures.test_override_parametrized_fixture_conftest_conftest"], "tokens": 406}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.pytester_example_path(\"fixtures/fill_fixtures\")\nclass TestFillFixtures:\n\n    def test_override_parametrized_fixture_conftest_conftest(self, testdir):\n        \"\"\"Test override of the parametrized fixture with non-parametrized one on the conftest level.\"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[1, 2, 3])\n            def spam(request):\n                return request.param\n        \"\"\"\n        )\n        subdir = testdir.mkpydir(\"subdir\")\n        subdir.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n\n                @pytest.fixture\n                def spam():\n                    return 'spam'\n                \"\"\"\n            )\n        )\n        testfile = subdir.join(\"test_spam.py\")\n        testfile.write(\n            textwrap.dedent(\n                \"\"\"\\\n                def test_spam(spam):\n                    assert spam == \"spam\"\n                \"\"\"\n            )\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result = testdir.runpytest(testfile)\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_override_non_parametrized_fixture_conftest_module(self, testdir):\n        \"\"\"Test override of the non-parametrized fixture with parametrized one on the test module level.\"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def spam():\n                return 'spam'\n        \"\"\"\n        )\n        testfile = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[1, 2, 3])\n            def spam(request):\n                return request.param\n\n            params = {'spam': 1}\n\n            def test_spam(spam):\n                assert spam == params['spam']\n                params['spam'] += 1\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*3 passed*\"])\n        result = testdir.runpytest(testfile)\n        result.stdout.fnmatch_lines([\"*3 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_non_parametrized_fixture_conftest_conftest_TestFillFixtures.test_override_non_parametrized_fixture_conftest_conftest.None_4": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_non_parametrized_fixture_conftest_conftest_TestFillFixtures.test_override_non_parametrized_fixture_conftest_conftest.None_4", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 314, "end_line": 352, "span_ids": ["TestFillFixtures.test_override_non_parametrized_fixture_conftest_conftest"], "tokens": 242}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.pytester_example_path(\"fixtures/fill_fixtures\")\nclass TestFillFixtures:\n\n    def test_override_non_parametrized_fixture_conftest_conftest(self, testdir):\n        \"\"\"Test override of the non-parametrized fixture with parametrized one on the conftest level.\"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def spam():\n                return 'spam'\n        \"\"\"\n        )\n        subdir = testdir.mkpydir(\"subdir\")\n        subdir.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n\n                @pytest.fixture(params=[1, 2, 3])\n                def spam(request):\n                    return request.param\n                \"\"\"\n            )\n        )\n        testfile = subdir.join(\"test_spam.py\")\n        testfile.write(\n            textwrap.dedent(\n                \"\"\"\\\n                params = {'spam': 1}\n\n                def test_spam(spam):\n                    assert spam == params['spam']\n                    params['spam'] += 1\n                \"\"\"\n            )\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*3 passed*\"])\n        result = testdir.runpytest(testfile)\n        result.stdout.fnmatch_lines([\"*3 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_autouse_fixture_with_parametrized_fixture_conftest_conftest_TestFillFixtures.test_autouse_fixture_plugin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_override_autouse_fixture_with_parametrized_fixture_conftest_conftest_TestFillFixtures.test_autouse_fixture_plugin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 354, "end_line": 420, "span_ids": ["TestFillFixtures.test_autouse_fixture_plugin", "TestFillFixtures.test_override_autouse_fixture_with_parametrized_fixture_conftest_conftest"], "tokens": 403}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.pytester_example_path(\"fixtures/fill_fixtures\")\nclass TestFillFixtures:\n\n    def test_override_autouse_fixture_with_parametrized_fixture_conftest_conftest(\n        self, testdir\n    ):\n        \"\"\"Test override of the autouse fixture with parametrized one on the conftest level.\n        This test covers the issue explained in issue 1601\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(autouse=True)\n            def spam():\n                return 'spam'\n        \"\"\"\n        )\n        subdir = testdir.mkpydir(\"subdir\")\n        subdir.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n\n                @pytest.fixture(params=[1, 2, 3])\n                def spam(request):\n                    return request.param\n                \"\"\"\n            )\n        )\n        testfile = subdir.join(\"test_spam.py\")\n        testfile.write(\n            textwrap.dedent(\n                \"\"\"\\\n                params = {'spam': 1}\n\n                def test_spam(spam):\n                    assert spam == params['spam']\n                    params['spam'] += 1\n                \"\"\"\n            )\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*3 passed*\"])\n        result = testdir.runpytest(testfile)\n        result.stdout.fnmatch_lines([\"*3 passed*\"])\n\n    def test_autouse_fixture_plugin(self, testdir):\n        # A fixture from a plugin has no baseid set, which screwed up\n        # the autouse fixture handling.\n        testdir.makepyfile(\n            testplugin=\"\"\"\n            import pytest\n\n            @pytest.fixture(autouse=True)\n            def foo(request):\n                request.function.foo = 7\n        \"\"\"\n        )\n        testdir.syspathinsert()\n        testdir.makepyfile(\n            \"\"\"\n            pytest_plugins = 'testplugin'\n\n            def test_foo(request):\n                assert request.function.foo == 7\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_funcarg_lookup_error_TestFillFixtures.test_fixture_excinfo_leak": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFillFixtures.test_funcarg_lookup_error_TestFillFixtures.test_fixture_excinfo_leak", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 422, "end_line": 482, "span_ids": ["TestFillFixtures.test_fixture_excinfo_leak", "TestFillFixtures.test_funcarg_lookup_error"], "tokens": 364}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.pytester_example_path(\"fixtures/fill_fixtures\")\nclass TestFillFixtures:\n\n    def test_funcarg_lookup_error(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def a_fixture(): pass\n\n            @pytest.fixture\n            def b_fixture(): pass\n\n            @pytest.fixture\n            def c_fixture(): pass\n\n            @pytest.fixture\n            def d_fixture(): pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_lookup_error(unknown):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*ERROR at setup of test_lookup_error*\",\n                \"  def test_lookup_error(unknown):*\",\n                \"E       fixture 'unknown' not found\",\n                \">       available fixtures:*a_fixture,*b_fixture,*c_fixture,*d_fixture*monkeypatch,*\",\n                # sorted\n                \">       use 'py*test --fixtures *' for help on them.\",\n                \"*1 error*\",\n            ]\n        )\n        result.stdout.no_fnmatch_line(\"*INTERNAL*\")\n\n    def test_fixture_excinfo_leak(self, testdir):\n        # on python2 sys.excinfo would leak into fixture executions\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            import traceback\n            import pytest\n\n            @pytest.fixture\n            def leak():\n                if sys.exc_info()[0]:  # python3 bug :)\n                    traceback.print_exc()\n                #fails\n                assert sys.exc_info() == (None, None, None)\n\n            def test_leak(leak):\n                if sys.exc_info()[0]:  # python3 bug :)\n                    traceback.print_exc()\n                assert sys.exc_info() == (None, None, None)\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic_TestRequestBasic.test_request_contains_funcarg_arg2fixturedefs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic_TestRequestBasic.test_request_contains_funcarg_arg2fixturedefs", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 485, "end_line": 538, "span_ids": ["TestRequestBasic", "TestRequestBasic.test_request_attributes", "TestRequestBasic.test_request_attributes_method", "TestRequestBasic.test_request_contains_funcarg_arg2fixturedefs"], "tokens": 358}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestBasic:\n    def test_request_attributes(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def something(request): pass\n            def test_func(something): pass\n        \"\"\"\n        )\n        req = fixtures.FixtureRequest(item)\n        assert req.function == item.obj\n        assert req.keywords == item.keywords\n        assert hasattr(req.module, \"test_func\")\n        assert req.cls is None\n        assert req.function.__name__ == \"test_func\"\n        assert req.config == item.config\n        assert repr(req).find(req.function.__name__) != -1\n\n    def test_request_attributes_method(self, testdir):\n        (item,) = testdir.getitems(\n            \"\"\"\n            import pytest\n            class TestB(object):\n\n                @pytest.fixture\n                def something(self, request):\n                    return 1\n                def test_func(self, something):\n                    pass\n        \"\"\"\n        )\n        req = item._request\n        assert req.cls.__name__ == \"TestB\"\n        assert req.instance.__class__ == req.cls\n\n    def test_request_contains_funcarg_arg2fixturedefs(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def something(request):\n                pass\n            class TestClass(object):\n                def test_method(self, something):\n                    pass\n        \"\"\"\n        )\n        (item1,) = testdir.genitems([modcol])\n        assert item1.name == \"test_method\"\n        arg2fixturedefs = fixtures.FixtureRequest(item1)._arg2fixturedefs\n        assert len(arg2fixturedefs) == 1\n        assert arg2fixturedefs[\"something\"][0].argname == \"something\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_garbage_TestRequestBasic.test_getfixturevalue_recursive": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_garbage_TestRequestBasic.test_getfixturevalue_recursive", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 540, "end_line": 602, "span_ids": ["TestRequestBasic.test_getfixturevalue_recursive", "TestRequestBasic.test_request_garbage"], "tokens": 340}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestBasic:\n\n    @pytest.mark.skipif(\n        hasattr(sys, \"pypy_version_info\"),\n        reason=\"this method of test doesn't work on pypy\",\n    )\n    def test_request_garbage(self, testdir):\n        try:\n            import xdist  # noqa\n        except ImportError:\n            pass\n        else:\n            pytest.xfail(\"this test is flaky when executed with xdist\")\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            import pytest\n            from _pytest.fixtures import PseudoFixtureDef\n            import gc\n\n            @pytest.fixture(autouse=True)\n            def something(request):\n                original = gc.get_debug()\n                gc.set_debug(gc.DEBUG_SAVEALL)\n                gc.collect()\n\n                yield\n\n                try:\n                    gc.collect()\n                    leaked = [x for _ in gc.garbage if isinstance(_, PseudoFixtureDef)]\n                    assert leaked == []\n                finally:\n                    gc.set_debug(original)\n\n            def test_func():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n\n    def test_getfixturevalue_recursive(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def something(request):\n                return 1\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def something(request):\n                return request.getfixturevalue(\"something\") + 1\n            def test_func(something):\n                assert something == 2\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_getfixturevalue_teardown_TestRequestBasic.test_getfixturevalue_teardown.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_getfixturevalue_teardown_TestRequestBasic.test_getfixturevalue_teardown.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 604, "end_line": 640, "span_ids": ["TestRequestBasic.test_getfixturevalue_teardown"], "tokens": 236}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestBasic:\n\n    def test_getfixturevalue_teardown(self, testdir):\n        \"\"\"\n        Issue #1895\n\n        `test_inner` requests `inner` fixture, which in turn requests `resource`\n        using `getfixturevalue`. `test_func` then requests `resource`.\n\n        `resource` is teardown before `inner` because the fixture mechanism won't consider\n        `inner` dependent on `resource` when it is used via `getfixturevalue`: `test_func`\n        will then cause the `resource`'s finalizer to be called first because of this.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session')\n            def resource():\n                r = ['value']\n                yield r\n                r.pop()\n\n            @pytest.fixture(scope='session')\n            def inner(request):\n                resource = request.getfixturevalue('resource')\n                assert resource == ['value']\n                yield\n                assert resource == ['value']\n\n            def test_inner(inner):\n                pass\n\n            def test_func(resource):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_subrequest_addfinalizer_exceptions_TestRequestBasic.test_request_subrequest_addfinalizer_exceptions.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_subrequest_addfinalizer_exceptions_TestRequestBasic.test_request_subrequest_addfinalizer_exceptions.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 748, "end_line": 780, "span_ids": ["TestRequestBasic.test_request_subrequest_addfinalizer_exceptions"], "tokens": 262}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestBasic:\n\n    def test_request_subrequest_addfinalizer_exceptions(self, testdir):\n        \"\"\"\n        Ensure exceptions raised during teardown by a finalizer are suppressed\n        until all finalizers are called, re-raising the first exception (#2440)\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            def _excepts(where):\n                raise Exception('Error in %s fixture' % where)\n            @pytest.fixture\n            def subrequest(request):\n                return request\n            @pytest.fixture\n            def something(subrequest):\n                subrequest.addfinalizer(lambda: values.append(1))\n                subrequest.addfinalizer(lambda: values.append(2))\n                subrequest.addfinalizer(lambda: _excepts('something'))\n            @pytest.fixture\n            def excepts(subrequest):\n                subrequest.addfinalizer(lambda: _excepts('excepts'))\n                subrequest.addfinalizer(lambda: values.append(3))\n            def test_first(something, excepts):\n                pass\n            def test_second():\n                assert values == [3, 2, 1]\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\"*Exception: Error in excepts fixture\", \"* 2 passed, 1 error in *\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestMarking_TestRequestMarking.test_accessmarker_dynamic.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestMarking_TestRequestMarking.test_accessmarker_dynamic.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 933, "end_line": 1000, "span_ids": ["TestRequestMarking", "TestRequestMarking.test_accesskeywords", "TestRequestMarking.test_accessmarker_dynamic", "TestRequestMarking.test_applymarker"], "tokens": 420}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestMarking:\n    def test_applymarker(self, testdir):\n        item1, item2 = testdir.getitems(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def something(request):\n                pass\n            class TestClass(object):\n                def test_func1(self, something):\n                    pass\n                def test_func2(self, something):\n                    pass\n        \"\"\"\n        )\n        req1 = fixtures.FixtureRequest(item1)\n        assert \"xfail\" not in item1.keywords\n        req1.applymarker(pytest.mark.xfail)\n        assert \"xfail\" in item1.keywords\n        assert \"skipif\" not in item1.keywords\n        req1.applymarker(pytest.mark.skipif)\n        assert \"skipif\" in item1.keywords\n        with pytest.raises(ValueError):\n            req1.applymarker(42)\n\n    def test_accesskeywords(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture()\n            def keywords(request):\n                return request.keywords\n            @pytest.mark.XYZ\n            def test_function(keywords):\n                assert keywords[\"XYZ\"]\n                assert \"abc\" not in keywords\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_accessmarker_dynamic(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture()\n            def keywords(request):\n                return request.keywords\n\n            @pytest.fixture(scope=\"class\", autouse=True)\n            def marking(request):\n                request.applymarker(pytest.mark.XYZ(\"hello\"))\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_fun1(keywords):\n                assert keywords[\"XYZ\"] is not None\n                assert \"abc\" not in keywords\n            def test_fun2(keywords):\n                assert keywords[\"XYZ\"] is not None\n                assert \"abc\" not in keywords\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories_TestFixtureManagerParseFactories.test_parsefactories_conftest_and_module_and_class": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories_TestFixtureManagerParseFactories.test_parsefactories_conftest_and_module_and_class", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1318, "end_line": 1394, "span_ids": ["TestFixtureManagerParseFactories", "TestFixtureManagerParseFactories.test_parsefactories_conftest", "TestFixtureManagerParseFactories.test_parsefactories_conftest_and_module_and_class", "TestFixtureManagerParseFactories.test_parsefactories_evil_objects_issue214", "TestFixtureManagerParseFactories.testdir"], "tokens": 494}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureManagerParseFactories:\n    @pytest.fixture\n    def testdir(self, request):\n        testdir = request.getfixturevalue(\"testdir\")\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def hello(request):\n                return \"conftest\"\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return testdir\n\n    def test_parsefactories_evil_objects_issue214(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class A(object):\n                def __call__(self):\n                    pass\n                def __getattr__(self, name):\n                    raise RuntimeError()\n            a = A()\n            def test_hello():\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1, failed=0)\n\n    def test_parsefactories_conftest(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_hello(item, fm):\n                for name in (\"fm\", \"hello\", \"item\"):\n                    faclist = fm.getfixturedefs(name, item.nodeid)\n                    assert len(faclist) == 1\n                    fac = faclist[0]\n                    assert fac.func.__name__ == name\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=1)\n\n    def test_parsefactories_conftest_and_module_and_class(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def hello(request):\n                return \"module\"\n            class TestClass(object):\n                @pytest.fixture\n                def hello(self, request):\n                    return \"class\"\n                def test_hello(self, item, fm):\n                    faclist = fm.getfixturedefs(\"hello\", item.nodeid)\n                    print(faclist)\n                    assert len(faclist) == 3\n\n                    assert faclist[0].func(item._request) == \"conftest\"\n                    assert faclist[1].func(item._request) == \"module\"\n                    assert faclist[2].func(item._request) == \"class\"\n            \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_parsefactories_relative_node_ids_TestFixtureManagerParseFactories.test_parsefactories_relative_node_ids.with_runner_as_cwd_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_parsefactories_relative_node_ids_TestFixtureManagerParseFactories.test_parsefactories_relative_node_ids.with_runner_as_cwd_", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1396, "end_line": 1443, "span_ids": ["TestFixtureManagerParseFactories.test_parsefactories_relative_node_ids"], "tokens": 279}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureManagerParseFactories:\n\n    def test_parsefactories_relative_node_ids(self, testdir):\n        # example mostly taken from:\n        # https://mail.python.org/pipermail/pytest-dev/2014-September/002617.html\n        runner = testdir.mkdir(\"runner\")\n        package = testdir.mkdir(\"package\")\n        package.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n            import pytest\n            @pytest.fixture\n            def one():\n                return 1\n            \"\"\"\n            )\n        )\n        package.join(\"test_x.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def test_x(one):\n                    assert one == 1\n                \"\"\"\n            )\n        )\n        sub = package.mkdir(\"sub\")\n        sub.join(\"__init__.py\").ensure()\n        sub.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.fixture\n                def one():\n                    return 2\n                \"\"\"\n            )\n        )\n        sub.join(\"test_y.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def test_x(one):\n                    assert one == 2\n                \"\"\"\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n        with runner.as_cwd():\n            reprec = testdir.inline_run(\"..\")\n            reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_package_xunit_fixture_TestFixtureManagerParseFactories.test_package_xunit_fixture.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_package_xunit_fixture_TestFixtureManagerParseFactories.test_package_xunit_fixture.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1445, "end_line": 1494, "span_ids": ["TestFixtureManagerParseFactories.test_package_xunit_fixture"], "tokens": 257}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureManagerParseFactories:\n\n    def test_package_xunit_fixture(self, testdir):\n        testdir.makepyfile(\n            __init__=\"\"\"\\\n            values = []\n        \"\"\"\n        )\n        package = testdir.mkdir(\"package\")\n        package.join(\"__init__.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                from .. import values\n                def setup_module():\n                    values.append(\"package\")\n                def teardown_module():\n                    values[:] = []\n                \"\"\"\n            )\n        )\n        package.join(\"test_x.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                from .. import values\n                def test_x():\n                    assert values == [\"package\"]\n                \"\"\"\n            )\n        )\n        package = testdir.mkdir(\"package2\")\n        package.join(\"__init__.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                from .. import values\n                def setup_module():\n                    values.append(\"package2\")\n                def teardown_module():\n                    values[:] = []\n                \"\"\"\n            )\n        )\n        package.join(\"test_x.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                from .. import values\n                def test_x():\n                    assert values == [\"package2\"]\n                \"\"\"\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_package_fixture_complex_TestFixtureManagerParseFactories.test_collect_custom_items": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureManagerParseFactories.test_package_fixture_complex_TestFixtureManagerParseFactories.test_collect_custom_items", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1496, "end_line": 1540, "span_ids": ["TestFixtureManagerParseFactories.test_collect_custom_items", "TestFixtureManagerParseFactories.test_package_fixture_complex"], "tokens": 272}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureManagerParseFactories:\n\n    def test_package_fixture_complex(self, testdir):\n        testdir.makepyfile(\n            __init__=\"\"\"\\\n            values = []\n        \"\"\"\n        )\n        testdir.syspathinsert(testdir.tmpdir.dirname)\n        package = testdir.mkdir(\"package\")\n        package.join(\"__init__.py\").write(\"\")\n        package.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                from .. import values\n                @pytest.fixture(scope=\"package\")\n                def one():\n                    values.append(\"package\")\n                    yield values\n                    values.pop()\n                @pytest.fixture(scope=\"package\", autouse=True)\n                def two():\n                    values.append(\"package-auto\")\n                    yield values\n                    values.pop()\n                \"\"\"\n            )\n        )\n        package.join(\"test_x.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                from .. import values\n                def test_package_autouse():\n                    assert values == [\"package-auto\"]\n                def test_package(one):\n                    assert values == [\"package-auto\", \"package\"]\n                \"\"\"\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_collect_custom_items(self, testdir):\n        testdir.copy_example(\"fixtures/custom_item\")\n        result = testdir.runpytest(\"foo\")\n        result.stdout.fnmatch_lines([\"*passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseDiscovery_TestAutouseDiscovery.test_setup_enabled_functionnode.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseDiscovery_TestAutouseDiscovery.test_setup_enabled_functionnode.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1543, "end_line": 1651, "span_ids": ["TestAutouseDiscovery", "TestAutouseDiscovery.test_parsefactories_conftest", "TestAutouseDiscovery.test_setup_at_classlevel", "TestAutouseDiscovery.test_setup_enabled_functionnode", "TestAutouseDiscovery.test_two_classes_separated_autouse", "TestAutouseDiscovery.testdir"], "tokens": 671}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAutouseDiscovery:\n    @pytest.fixture\n    def testdir(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def perfunction(request, tmpdir):\n                pass\n\n            @pytest.fixture()\n            def arg1(tmpdir):\n                pass\n            @pytest.fixture(autouse=True)\n            def perfunction2(arg1):\n                pass\n\n            @pytest.fixture\n            def fm(request):\n                return request._fixturemanager\n\n            @pytest.fixture\n            def item(request):\n                return request._pyfuncitem\n        \"\"\"\n        )\n        return testdir\n\n    def test_parsefactories_conftest(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            from _pytest.pytester import get_public_names\n            def test_check_setup(item, fm):\n                autousenames = fm._getautousenames(item.nodeid)\n                assert len(get_public_names(autousenames)) == 2\n                assert \"perfunction2\" in autousenames\n                assert \"perfunction\" in autousenames\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=1)\n\n    def test_two_classes_separated_autouse(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            class TestA(object):\n                values = []\n                @pytest.fixture(autouse=True)\n                def setup1(self):\n                    self.values.append(1)\n                def test_setup1(self):\n                    assert self.values == [1]\n            class TestB(object):\n                values = []\n                @pytest.fixture(autouse=True)\n                def setup2(self):\n                    self.values.append(1)\n                def test_setup2(self):\n                    assert self.values == [1]\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_setup_at_classlevel(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            class TestClass(object):\n                @pytest.fixture(autouse=True)\n                def permethod(self, request):\n                    request.instance.funcname = request.function.__name__\n                def test_method1(self):\n                    assert self.funcname == \"test_method1\"\n                def test_method2(self):\n                    assert self.funcname == \"test_method2\"\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=2)\n\n    @pytest.mark.xfail(reason=\"'enabled' feature not implemented\")\n    def test_setup_enabled_functionnode(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def enabled(parentnode, markers):\n                return \"needsdb\" in markers\n\n            @pytest.fixture(params=[1,2])\n            def db(request):\n                return request.param\n\n            @pytest.fixture(enabled=enabled, autouse=True)\n            def createdb(db):\n                pass\n\n            def test_func1(request):\n                assert \"db\" not in request.fixturenames\n\n            @pytest.mark.needsdb\n            def test_func2(request):\n                assert \"db\" in request.fixturenames\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseDiscovery.test_callables_nocode_TestAutouseDiscovery.test_autouse_in_module_and_two_classes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseDiscovery.test_callables_nocode_TestAutouseDiscovery.test_autouse_in_module_and_two_classes", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1653, "end_line": 1716, "span_ids": ["TestAutouseDiscovery.test_autouse_in_conftests", "TestAutouseDiscovery.test_autouse_in_module_and_two_classes", "TestAutouseDiscovery.test_callables_nocode"], "tokens": 432}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAutouseDiscovery:\n\n    def test_callables_nocode(self, testdir):\n        \"\"\"\n        an imported mock.call would break setup/factory discovery\n        due to it being callable and __code__ not being a code object\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n           class _call(tuple):\n               def __call__(self, *k, **kw):\n                   pass\n               def __getattr__(self, k):\n                   return self\n\n           call = _call()\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(failed=0, passed=0)\n\n    def test_autouse_in_conftests(self, testdir):\n        a = testdir.mkdir(\"a\")\n        b = testdir.mkdir(\"a1\")\n        conftest = testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def hello():\n                xxx\n        \"\"\"\n        )\n        conftest.move(a.join(conftest.basename))\n        a.join(\"test_something.py\").write(\"def test_func(): pass\")\n        b.join(\"test_otherthing.py\").write(\"def test_func(): pass\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *1 passed*1 error*\n        \"\"\"\n        )\n\n    def test_autouse_in_module_and_two_classes(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(autouse=True)\n            def append1():\n                values.append(\"module\")\n            def test_x():\n                assert values == [\"module\"]\n\n            class TestA(object):\n                @pytest.fixture(autouse=True)\n                def append2(self):\n                    values.append(\"A\")\n                def test_hello(self):\n                    assert values == [\"module\", \"module\", \"A\"], values\n            class TestA2(object):\n                def test_world(self):\n                    assert values == [\"module\", \"module\", \"A\", \"module\"], values\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=3)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement_TestAutouseManagement.test_session_parametrized_function.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement_TestAutouseManagement.test_session_parametrized_function.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1719, "end_line": 1824, "span_ids": ["TestAutouseManagement", "TestAutouseManagement.test_autouse_conftest_mid_directory", "TestAutouseManagement.test_funcarg_and_setup", "TestAutouseManagement.test_session_parametrized_function", "TestAutouseManagement.test_uses_parametrized_resource"], "tokens": 615}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAutouseManagement:\n    def test_autouse_conftest_mid_directory(self, testdir):\n        pkgdir = testdir.mkpydir(\"xyz123\")\n        pkgdir.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.fixture(autouse=True)\n                def app():\n                    import sys\n                    sys._myapp = \"hello\"\n                \"\"\"\n            )\n        )\n        t = pkgdir.ensure(\"tests\", \"test_app.py\")\n        t.write(\n            textwrap.dedent(\n                \"\"\"\\\n                import sys\n                def test_app():\n                    assert sys._myapp == \"hello\"\n                \"\"\"\n            )\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=1)\n\n    def test_funcarg_and_setup(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"module\")\n            def arg():\n                values.append(1)\n                return 0\n            @pytest.fixture(scope=\"module\", autouse=True)\n            def something(arg):\n                values.append(2)\n\n            def test_hello(arg):\n                assert len(values) == 2\n                assert values == [1,2]\n                assert arg == 0\n\n            def test_hello2(arg):\n                assert len(values) == 2\n                assert values == [1,2]\n                assert arg == 0\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_uses_parametrized_resource(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(params=[1,2])\n            def arg(request):\n                return request.param\n\n            @pytest.fixture(autouse=True)\n            def something(arg):\n                values.append(arg)\n\n            def test_hello():\n                if len(values) == 1:\n                    assert values == [1]\n                elif len(values) == 2:\n                    assert values == [1, 2]\n                else:\n                    0/0\n\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=2)\n\n    def test_session_parametrized_function(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            values = []\n\n            @pytest.fixture(scope=\"session\", params=[1,2])\n            def arg(request):\n               return request.param\n\n            @pytest.fixture(scope=\"function\", autouse=True)\n            def append(request, arg):\n                if request.function.__name__ == \"test_some\":\n                    values.append(arg)\n\n            def test_some():\n                pass\n\n            def test_result(arg):\n                assert len(values) == arg\n                assert values[:arg] == [1,2][:arg]\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\", \"-s\")\n        reprec.assertoutcome(passed=4)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_class_function_parametrization_finalization_TestAutouseManagement.test_class_function_parametrization_finalization.assert_values_fin_a1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_class_function_parametrization_finalization_TestAutouseManagement.test_class_function_parametrization_finalization.assert_values_fin_a1", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1826, "end_line": 1866, "span_ids": ["TestAutouseManagement.test_class_function_parametrization_finalization"], "tokens": 284}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAutouseManagement:\n\n    def test_class_function_parametrization_finalization(self, testdir):\n        p = testdir.makeconftest(\n            \"\"\"\n            import pytest\n            import pprint\n\n            values = []\n\n            @pytest.fixture(scope=\"function\", params=[1,2])\n            def farg(request):\n                return request.param\n\n            @pytest.fixture(scope=\"class\", params=list(\"ab\"))\n            def carg(request):\n                return request.param\n\n            @pytest.fixture(scope=\"function\", autouse=True)\n            def append(request, farg, carg):\n                def fin():\n                    values.append(\"fin_%s%s\" % (carg, farg))\n                request.addfinalizer(fin)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            class TestClass(object):\n                def test_1(self):\n                    pass\n            class TestClass2(object):\n                def test_2(self):\n                    pass\n        \"\"\"\n        )\n        confcut = \"--confcutdir={}\".format(testdir.tmpdir)\n        reprec = testdir.inline_run(\"-v\", \"-s\", confcut)\n        reprec.assertoutcome(passed=8)\n        config = reprec.getcalls(\"pytest_unconfigure\")[0].config\n        values = config.pluginmanager._getconftestmodules(p)[0].values\n        assert values == [\"fin_a1\", \"fin_a2\", \"fin_b1\", \"fin_b2\"] * 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_scope_ordering_TestAutouseManagement.test_parametrization_setup_teardown_ordering.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_scope_ordering_TestAutouseManagement.test_parametrization_setup_teardown_ordering.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1868, "end_line": 1918, "span_ids": ["TestAutouseManagement.test_parametrization_setup_teardown_ordering", "TestAutouseManagement.test_scope_ordering"], "tokens": 409}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAutouseManagement:\n\n    def test_scope_ordering(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"function\", autouse=True)\n            def fappend2():\n                values.append(2)\n            @pytest.fixture(scope=\"class\", autouse=True)\n            def classappend3():\n                values.append(3)\n            @pytest.fixture(scope=\"module\", autouse=True)\n            def mappend():\n                values.append(1)\n\n            class TestHallo(object):\n                def test_method(self):\n                    assert values == [1,3,2]\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_parametrization_setup_teardown_ordering(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            def pytest_generate_tests(metafunc):\n                if metafunc.cls is None:\n                    assert metafunc.function is test_finish\n                if metafunc.cls is not None:\n                    metafunc.parametrize(\"item\", [1,2], scope=\"class\")\n            class TestClass(object):\n                @pytest.fixture(scope=\"class\", autouse=True)\n                def addteardown(self, item, request):\n                    values.append(\"setup-%d\" % item)\n                    request.addfinalizer(lambda: values.append(\"teardown-%d\" % item))\n                def test_step1(self, item):\n                    values.append(\"step1-%d\" % item)\n                def test_step2(self, item):\n                    values.append(\"step2-%d\" % item)\n\n            def test_finish():\n                print(values)\n                assert values == [\"setup-1\", \"step1-1\", \"step2-1\", \"teardown-1\",\n                             \"setup-2\", \"step1-2\", \"step2-2\", \"teardown-2\",]\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=5)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_ordering_autouse_before_explicit_TestAutouseManagement.test_ordering_dependencies_torndown_first.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestAutouseManagement.test_ordering_autouse_before_explicit_TestAutouseManagement.test_ordering_dependencies_torndown_first.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1920, "end_line": 1964, "span_ids": ["TestAutouseManagement.test_ordering_autouse_before_explicit", "TestAutouseManagement.test_ordering_dependencies_torndown_first"], "tokens": 335}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAutouseManagement:\n\n    def test_ordering_autouse_before_explicit(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            values = []\n            @pytest.fixture(autouse=True)\n            def fix1():\n                values.append(1)\n            @pytest.fixture()\n            def arg1():\n                values.append(2)\n            def test_hello(arg1):\n                assert values == [1,2]\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    @pytest.mark.parametrize(\"param1\", [\"\", \"params=[1]\"], ids=[\"p00\", \"p01\"])\n    @pytest.mark.parametrize(\"param2\", [\"\", \"params=[1]\"], ids=[\"p10\", \"p11\"])\n    def test_ordering_dependencies_torndown_first(self, testdir, param1, param2):\n        \"\"\"#226\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(%(param1)s)\n            def arg1(request):\n                request.addfinalizer(lambda: values.append(\"fin1\"))\n                values.append(\"new1\")\n            @pytest.fixture(%(param2)s)\n            def arg2(request, arg1):\n                request.addfinalizer(lambda: values.append(\"fin2\"))\n                values.append(\"new2\")\n\n            def test_arg(arg2):\n                pass\n            def test_check():\n                assert values == [\"new1\", \"new2\", \"fin2\", \"fin1\"]\n        \"\"\"\n            % locals()\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker_TestFixtureMarker.test_scope_session_exc": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker_TestFixtureMarker.test_scope_session_exc", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1967, "end_line": 2072, "span_ids": ["TestFixtureMarker", "TestFixtureMarker.test_multiple_parametrization_issue_736", "TestFixtureMarker.test_override_parametrized_fixture_issue_979", "TestFixtureMarker.test_parametrize", "TestFixtureMarker.test_scope_session", "TestFixtureMarker.test_scope_session_exc"], "tokens": 661}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n    def test_parametrize(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(params=[\"a\", \"b\", \"c\"])\n            def arg(request):\n                return request.param\n            values = []\n            def test_param(arg):\n                values.append(arg)\n            def test_result():\n                assert values == list(\"abc\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=4)\n\n    def test_multiple_parametrization_issue_736(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[1,2,3])\n            def foo(request):\n                return request.param\n\n            @pytest.mark.parametrize('foobar', [4,5,6])\n            def test_issue(foo, foobar):\n                assert foo in [1,2,3]\n                assert foobar in [4,5,6]\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=9)\n\n    @pytest.mark.parametrize(\n        \"param_args\",\n        [\"'fixt, val'\", \"'fixt,val'\", \"['fixt', 'val']\", \"('fixt', 'val')\"],\n    )\n    def test_override_parametrized_fixture_issue_979(self, testdir, param_args):\n        \"\"\"Make sure a parametrized argument can override a parametrized fixture.\n\n        This was a regression introduced in the fix for #736.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[1, 2])\n            def fixt(request):\n                return request.param\n\n            @pytest.mark.parametrize(%s, [(3, 'x'), (4, 'x')])\n            def test_foo(fixt, val):\n                pass\n        \"\"\"\n            % param_args\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_scope_session(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"module\")\n            def arg():\n                values.append(1)\n                return 1\n\n            def test_1(arg):\n                assert arg == 1\n            def test_2(arg):\n                assert arg == 1\n                assert len(values) == 1\n            class TestClass(object):\n                def test3(self, arg):\n                    assert arg == 1\n                    assert len(values) == 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=3)\n\n    def test_scope_session_exc(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"session\")\n            def fix():\n                values.append(1)\n                pytest.skip('skipping')\n\n            def test_1(fix):\n                pass\n            def test_2(fix):\n                pass\n            def test_last():\n                assert values == [1]\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(skipped=2, passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_session_exc_two_fix_TestFixtureMarker.test_scope_module_uses_session": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_session_exc_two_fix_TestFixtureMarker.test_scope_module_uses_session", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2074, "end_line": 2151, "span_ids": ["TestFixtureMarker.test_scope_exc", "TestFixtureMarker.test_scope_module_uses_session", "TestFixtureMarker.test_scope_session_exc_two_fix"], "tokens": 439}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_scope_session_exc_two_fix(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            m = []\n            @pytest.fixture(scope=\"session\")\n            def a():\n                values.append(1)\n                pytest.skip('skipping')\n            @pytest.fixture(scope=\"session\")\n            def b(a):\n                m.append(1)\n\n            def test_1(b):\n                pass\n            def test_2(b):\n                pass\n            def test_last():\n                assert values == [1]\n                assert m == []\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(skipped=2, passed=1)\n\n    def test_scope_exc(self, testdir):\n        testdir.makepyfile(\n            test_foo=\"\"\"\n                def test_foo(fix):\n                    pass\n            \"\"\",\n            test_bar=\"\"\"\n                def test_bar(fix):\n                    pass\n            \"\"\",\n            conftest=\"\"\"\n                import pytest\n                reqs = []\n                @pytest.fixture(scope=\"session\")\n                def fix(request):\n                    reqs.append(1)\n                    pytest.skip()\n                @pytest.fixture\n                def req_list():\n                    return reqs\n            \"\"\",\n            test_real=\"\"\"\n                def test_last(req_list):\n                    assert req_list == [1]\n            \"\"\",\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(skipped=2, passed=1)\n\n    def test_scope_module_uses_session(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope=\"module\")\n            def arg():\n                values.append(1)\n                return 1\n\n            def test_1(arg):\n                assert arg == 1\n            def test_2(arg):\n                assert arg == 1\n                assert len(values) == 1\n            class TestClass(object):\n                def test3(self, arg):\n                    assert arg == 1\n                    assert len(values) == 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=3)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_module_and_finalizer_TestFixtureMarker.test_scope_module_and_finalizer.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_module_and_finalizer_TestFixtureMarker.test_scope_module_and_finalizer.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2153, "end_line": 2191, "span_ids": ["TestFixtureMarker.test_scope_module_and_finalizer"], "tokens": 259}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_scope_module_and_finalizer(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            finalized_list = []\n            created_list = []\n            @pytest.fixture(scope=\"module\")\n            def arg(request):\n                created_list.append(1)\n                assert request.scope == \"module\"\n                request.addfinalizer(lambda: finalized_list.append(1))\n            @pytest.fixture\n            def created(request):\n                return len(created_list)\n            @pytest.fixture\n            def finalized(request):\n                return len(finalized_list)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            test_mod1=\"\"\"\n                def test_1(arg, created, finalized):\n                    assert created == 1\n                    assert finalized == 0\n                def test_2(arg, created, finalized):\n                    assert created == 1\n                    assert finalized == 0\"\"\",\n            test_mod2=\"\"\"\n                def test_3(arg, created, finalized):\n                    assert created == 2\n                    assert finalized == 1\"\"\",\n            test_mode3=\"\"\"\n                def test_4(arg, created, finalized):\n                    assert created == 3\n                    assert finalized == 2\n            \"\"\",\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=4)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_module_parametrized_ordering_TestFixtureMarker.test_module_parametrized_ordering.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_module_parametrized_ordering_TestFixtureMarker.test_module_parametrized_ordering.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2305, "end_line": 2362, "span_ids": ["TestFixtureMarker.test_module_parametrized_ordering"], "tokens": 476}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_module_parametrized_ordering(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style=classic\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"session\", params=\"s1 s2\".split())\n            def sarg():\n                pass\n            @pytest.fixture(scope=\"module\", params=\"m1 m2\".split())\n            def marg():\n                pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            test_mod1=\"\"\"\n            def test_func(sarg):\n                pass\n            def test_func1(marg):\n                pass\n        \"\"\",\n            test_mod2=\"\"\"\n            def test_func2(sarg):\n                pass\n            def test_func3(sarg, marg):\n                pass\n            def test_func3b(sarg, marg):\n                pass\n            def test_func4(marg):\n                pass\n        \"\"\",\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            test_mod1.py::test_func[s1] PASSED\n            test_mod2.py::test_func2[s1] PASSED\n            test_mod2.py::test_func3[s1-m1] PASSED\n            test_mod2.py::test_func3b[s1-m1] PASSED\n            test_mod2.py::test_func3[s1-m2] PASSED\n            test_mod2.py::test_func3b[s1-m2] PASSED\n            test_mod1.py::test_func[s2] PASSED\n            test_mod2.py::test_func2[s2] PASSED\n            test_mod2.py::test_func3[s2-m1] PASSED\n            test_mod2.py::test_func3b[s2-m1] PASSED\n            test_mod2.py::test_func4[m1] PASSED\n            test_mod2.py::test_func3[s2-m2] PASSED\n            test_mod2.py::test_func3b[s2-m2] PASSED\n            test_mod2.py::test_func4[m2] PASSED\n            test_mod1.py::test_func1[m1] PASSED\n            test_mod1.py::test_func1[m2] PASSED\n        \"\"\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_dynamic_parametrized_ordering_TestFixtureMarker.test_dynamic_parametrized_ordering.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_dynamic_parametrized_ordering_TestFixtureMarker.test_dynamic_parametrized_ordering.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2364, "end_line": 2411, "span_ids": ["TestFixtureMarker.test_dynamic_parametrized_ordering"], "tokens": 396}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_dynamic_parametrized_ordering(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style=classic\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            def pytest_configure(config):\n                class DynamicFixturePlugin(object):\n                    @pytest.fixture(scope='session', params=['flavor1', 'flavor2'])\n                    def flavor(self, request):\n                        return request.param\n                config.pluginmanager.register(DynamicFixturePlugin(), 'flavor-fixture')\n\n            @pytest.fixture(scope='session', params=['vxlan', 'vlan'])\n            def encap(request):\n                return request.param\n\n            @pytest.fixture(scope='session', autouse='True')\n            def reprovision(request, flavor, encap):\n                pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test(reprovision):\n                pass\n            def test2(reprovision):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            test_dynamic_parametrized_ordering.py::test[flavor1-vxlan] PASSED\n            test_dynamic_parametrized_ordering.py::test2[flavor1-vxlan] PASSED\n            test_dynamic_parametrized_ordering.py::test[flavor2-vxlan] PASSED\n            test_dynamic_parametrized_ordering.py::test2[flavor2-vxlan] PASSED\n            test_dynamic_parametrized_ordering.py::test[flavor2-vlan] PASSED\n            test_dynamic_parametrized_ordering.py::test2[flavor2-vlan] PASSED\n            test_dynamic_parametrized_ordering.py::test[flavor1-vlan] PASSED\n            test_dynamic_parametrized_ordering.py::test2[flavor1-vlan] PASSED\n        \"\"\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_class_ordering_TestFixtureMarker.test_class_ordering.result_stdout_re_match_li": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_class_ordering_TestFixtureMarker.test_class_ordering.result_stdout_re_match_li", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2413, "end_line": 2471, "span_ids": ["TestFixtureMarker.test_class_ordering"], "tokens": 492}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_class_ordering(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style=classic\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            values = []\n\n            @pytest.fixture(scope=\"function\", params=[1,2])\n            def farg(request):\n                return request.param\n\n            @pytest.fixture(scope=\"class\", params=list(\"ab\"))\n            def carg(request):\n                return request.param\n\n            @pytest.fixture(scope=\"function\", autouse=True)\n            def append(request, farg, carg):\n                def fin():\n                    values.append(\"fin_%s%s\" % (carg, farg))\n                request.addfinalizer(fin)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            class TestClass2(object):\n                def test_1(self):\n                    pass\n                def test_2(self):\n                    pass\n            class TestClass(object):\n                def test_3(self):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-vs\")\n        result.stdout.re_match_lines(\n            r\"\"\"\n            test_class_ordering.py::TestClass2::test_1\\[a-1\\] PASSED\n            test_class_ordering.py::TestClass2::test_1\\[a-2\\] PASSED\n            test_class_ordering.py::TestClass2::test_2\\[a-1\\] PASSED\n            test_class_ordering.py::TestClass2::test_2\\[a-2\\] PASSED\n            test_class_ordering.py::TestClass2::test_1\\[b-1\\] PASSED\n            test_class_ordering.py::TestClass2::test_1\\[b-2\\] PASSED\n            test_class_ordering.py::TestClass2::test_2\\[b-1\\] PASSED\n            test_class_ordering.py::TestClass2::test_2\\[b-2\\] PASSED\n            test_class_ordering.py::TestClass::test_3\\[a-1\\] PASSED\n            test_class_ordering.py::TestClass::test_3\\[a-2\\] PASSED\n            test_class_ordering.py::TestClass::test_3\\[b-1\\] PASSED\n            test_class_ordering.py::TestClass::test_3\\[b-2\\] PASSED\n        \"\"\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_separated_order_higher_scope_first_TestFixtureMarker.test_parametrize_separated_order_higher_scope_first.assert_values_expected": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_separated_order_higher_scope_first_TestFixtureMarker.test_parametrize_separated_order_higher_scope_first.assert_values_expected", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2473, "end_line": 2547, "span_ids": ["TestFixtureMarker.test_parametrize_separated_order_higher_scope_first"], "tokens": 485}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_parametrize_separated_order_higher_scope_first(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"function\", params=[1, 2])\n            def arg(request):\n                param = request.param\n                request.addfinalizer(lambda: values.append(\"fin:%s\" % param))\n                values.append(\"create:%s\" % param)\n                return request.param\n\n            @pytest.fixture(scope=\"module\", params=[\"mod1\", \"mod2\"])\n            def modarg(request):\n                param = request.param\n                request.addfinalizer(lambda: values.append(\"fin:%s\" % param))\n                values.append(\"create:%s\" % param)\n                return request.param\n\n            values = []\n            def test_1(arg):\n                values.append(\"test1\")\n            def test_2(modarg):\n                values.append(\"test2\")\n            def test_3(arg, modarg):\n                values.append(\"test3\")\n            def test_4(modarg, arg):\n                values.append(\"test4\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\")\n        reprec.assertoutcome(passed=12)\n        values = reprec.getcalls(\"pytest_runtest_call\")[0].item.module.values\n        expected = [\n            \"create:1\",\n            \"test1\",\n            \"fin:1\",\n            \"create:2\",\n            \"test1\",\n            \"fin:2\",\n            \"create:mod1\",\n            \"test2\",\n            \"create:1\",\n            \"test3\",\n            \"fin:1\",\n            \"create:2\",\n            \"test3\",\n            \"fin:2\",\n            \"create:1\",\n            \"test4\",\n            \"fin:1\",\n            \"create:2\",\n            \"test4\",\n            \"fin:2\",\n            \"fin:mod1\",\n            \"create:mod2\",\n            \"test2\",\n            \"create:1\",\n            \"test3\",\n            \"fin:1\",\n            \"create:2\",\n            \"test3\",\n            \"fin:2\",\n            \"create:1\",\n            \"test4\",\n            \"fin:1\",\n            \"create:2\",\n            \"test4\",\n            \"fin:2\",\n            \"fin:mod2\",\n        ]\n        import pprint\n\n        pprint.pprint(list(zip(values, expected)))\n        assert values == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_fixture_finalizer_TestFixtureMarker.test_request_is_clean": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_fixture_finalizer_TestFixtureMarker.test_request_is_clean", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2590, "end_line": 2666, "span_ids": ["TestFixtureMarker.test_class_scope_with_normal_tests", "TestFixtureMarker.test_fixture_finalizer", "TestFixtureMarker.test_request_is_clean"], "tokens": 436}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_fixture_finalizer(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            import sys\n\n            @pytest.fixture\n            def browser(request):\n\n                def finalize():\n                    sys.stdout.write('Finalized')\n                request.addfinalizer(finalize)\n                return {}\n        \"\"\"\n        )\n        b = testdir.mkdir(\"subdir\")\n        b.join(\"test_overridden_fixture_finalizer.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.fixture\n                def browser(browser):\n                    browser['visited'] = True\n                    return browser\n\n                def test_browser(browser):\n                    assert browser['visited'] is True\n                \"\"\"\n            )\n        )\n        reprec = testdir.runpytest(\"-s\")\n        for test in [\"test_browser\"]:\n            reprec.stdout.fnmatch_lines([\"*Finalized*\"])\n\n    def test_class_scope_with_normal_tests(self, testdir):\n        testpath = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            class Box(object):\n                value = 0\n\n            @pytest.fixture(scope='class')\n            def a(request):\n                Box.value += 1\n                return Box.value\n\n            def test_a(a):\n                assert a == 1\n\n            class Test1(object):\n                def test_b(self, a):\n                    assert a == 2\n\n            class Test2(object):\n                def test_c(self, a):\n                    assert a == 3\"\"\"\n        )\n        reprec = testdir.inline_run(testpath)\n        for test in [\"test_a\", \"test_b\", \"test_c\"]:\n            assert reprec.matchreport(test).passed\n\n    def test_request_is_clean(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(params=[1, 2])\n            def fix(request):\n                request.addfinalizer(lambda: values.append(request.param))\n            def test_fix(fix):\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        values = reprec.getcalls(\"pytest_runtest_call\")[0].item.module.values\n        assert values == [1, 2]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_separated_lifecycle_TestFixtureMarker.test_parametrize_function_scoped_finalizers_called": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_separated_lifecycle_TestFixtureMarker.test_parametrize_function_scoped_finalizers_called", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2668, "end_line": 2719, "span_ids": ["TestFixtureMarker.test_parametrize_function_scoped_finalizers_called", "TestFixtureMarker.test_parametrize_separated_lifecycle"], "tokens": 377}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_parametrize_separated_lifecycle(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            values = []\n            @pytest.fixture(scope=\"module\", params=[1, 2])\n            def arg(request):\n                x = request.param\n                request.addfinalizer(lambda: values.append(\"fin%s\" % x))\n                return request.param\n            def test_1(arg):\n                values.append(arg)\n            def test_2(arg):\n                values.append(arg)\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-vs\")\n        reprec.assertoutcome(passed=4)\n        values = reprec.getcalls(\"pytest_runtest_call\")[0].item.module.values\n        import pprint\n\n        pprint.pprint(values)\n        # assert len(values) == 6\n        assert values[0] == values[1] == 1\n        assert values[2] == \"fin1\"\n        assert values[3] == values[4] == 2\n        assert values[5] == \"fin2\"\n\n    def test_parametrize_function_scoped_finalizers_called(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"function\", params=[1, 2])\n            def arg(request):\n                x = request.param\n                request.addfinalizer(lambda: values.append(\"fin%s\" % x))\n                return request.param\n\n            values = []\n            def test_1(arg):\n                values.append(arg)\n            def test_2(arg):\n                values.append(arg)\n            def test_3():\n                assert len(values) == 8\n                assert values == [1, \"fin1\", 2, \"fin2\", 1, \"fin1\", 2, \"fin2\"]\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\")\n        reprec.assertoutcome(passed=5)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_finalizer_order_on_parametrization_TestFixtureMarker.test_finalizer_order_on_parametrization.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_finalizer_order_on_parametrization_TestFixtureMarker.test_finalizer_order_on_parametrization.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2721, "end_line": 2756, "span_ids": ["TestFixtureMarker.test_finalizer_order_on_parametrization"], "tokens": 230}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    @pytest.mark.parametrize(\"scope\", [\"session\", \"function\", \"module\"])\n    def test_finalizer_order_on_parametrization(self, scope, testdir):\n        \"\"\"#246\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n\n            @pytest.fixture(scope=%(scope)r, params=[\"1\"])\n            def fix1(request):\n                return request.param\n\n            @pytest.fixture(scope=%(scope)r)\n            def fix2(request, base):\n                def cleanup_fix2():\n                    assert not values, \"base should not have been finalized\"\n                request.addfinalizer(cleanup_fix2)\n\n            @pytest.fixture(scope=%(scope)r)\n            def base(request, fix1):\n                def cleanup_base():\n                    values.append(\"fin_base\")\n                    print(\"finalizing base\")\n                request.addfinalizer(cleanup_base)\n\n            def test_begin():\n                pass\n            def test_baz(base, fix2):\n                pass\n            def test_other():\n                pass\n        \"\"\"\n            % {\"scope\": scope}\n        )\n        reprec = testdir.inline_run(\"-lvs\")\n        reprec.assertoutcome(passed=3)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_class_scope_parametrization_ordering_TestFixtureMarker.test_class_scope_parametrization_ordering.assert_values_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_class_scope_parametrization_ordering_TestFixtureMarker.test_class_scope_parametrization_ordering.assert_values_", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2758, "end_line": 2795, "span_ids": ["TestFixtureMarker.test_class_scope_parametrization_ordering"], "tokens": 229}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_class_scope_parametrization_ordering(self, testdir):\n        \"\"\"#396\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(params=[\"John\", \"Doe\"], scope=\"class\")\n            def human(request):\n                request.addfinalizer(lambda: values.append(\"fin %s\" % request.param))\n                return request.param\n\n            class TestGreetings(object):\n                def test_hello(self, human):\n                    values.append(\"test_hello\")\n\n            class TestMetrics(object):\n                def test_name(self, human):\n                    values.append(\"test_name\")\n\n                def test_population(self, human):\n                    values.append(\"test_population\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=6)\n        values = reprec.getcalls(\"pytest_runtest_call\")[0].item.module.values\n        assert values == [\n            \"test_hello\",\n            \"fin John\",\n            \"test_hello\",\n            \"fin Doe\",\n            \"test_name\",\n            \"test_population\",\n            \"fin John\",\n            \"test_name\",\n            \"test_population\",\n            \"fin Doe\",\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_setup_function_TestFixtureMarker.test_parametrize_setup_function.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrize_setup_function_TestFixtureMarker.test_parametrize_setup_function.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2797, "end_line": 2828, "span_ids": ["TestFixtureMarker.test_parametrize_setup_function"], "tokens": 220}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_parametrize_setup_function(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"module\", params=[1, 2])\n            def arg(request):\n                return request.param\n\n            @pytest.fixture(scope=\"module\", autouse=True)\n            def mysetup(request, arg):\n                request.addfinalizer(lambda: values.append(\"fin%s\" % arg))\n                values.append(\"setup%s\" % arg)\n\n            values = []\n            def test_1(arg):\n                values.append(arg)\n            def test_2(arg):\n                values.append(arg)\n            def test_3():\n                import pprint\n                pprint.pprint(values)\n                if arg == 1:\n                    assert values == [\"setup1\", 1, 1, ]\n                elif arg == 2:\n                    assert values == [\"setup1\", 1, 1, \"fin1\",\n                                 \"setup2\", 2, 2, ]\n\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\")\n        reprec.assertoutcome(passed=6)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_fixture_marked_function_not_collected_as_test_TestFixtureMarker.test_params_and_ids_yieldfixture": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_fixture_marked_function_not_collected_as_test_TestFixtureMarker.test_params_and_ids_yieldfixture", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2830, "end_line": 2877, "span_ids": ["TestFixtureMarker.test_fixture_marked_function_not_collected_as_test", "TestFixtureMarker.test_params_and_ids", "TestFixtureMarker.test_params_and_ids_yieldfixture"], "tokens": 287}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_fixture_marked_function_not_collected_as_test(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def test_app():\n                return 1\n\n            def test_something(test_app):\n                assert test_app == 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_params_and_ids(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[object(), object()],\n                            ids=['alpha', 'beta'])\n            def fix(request):\n                return request.param\n\n            def test_foo(fix):\n                assert 1\n        \"\"\"\n        )\n        res = testdir.runpytest(\"-v\")\n        res.stdout.fnmatch_lines([\"*test_foo*alpha*\", \"*test_foo*beta*\"])\n\n    def test_params_and_ids_yieldfixture(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.yield_fixture(params=[object(), object()],\n                                  ids=['alpha', 'beta'])\n            def fix(request):\n                 yield request.param\n\n            def test_foo(fix):\n                assert 1\n        \"\"\"\n        )\n        res = testdir.runpytest(\"-v\")\n        res.stdout.fnmatch_lines([\"*test_foo*alpha*\", \"*test_foo*beta*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_deterministic_fixture_collection_TestFixtureMarker.test_deterministic_fixture_collection.assert_out1_out2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_deterministic_fixture_collection_TestFixtureMarker.test_deterministic_fixture_collection.assert_out1_out2", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2879, "end_line": 2920, "span_ids": ["TestFixtureMarker.test_deterministic_fixture_collection"], "tokens": 295}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_deterministic_fixture_collection(self, testdir, monkeypatch):\n        \"\"\"#920\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"module\",\n                            params=[\"A\",\n                                    \"B\",\n                                    \"C\"])\n            def A(request):\n                return request.param\n\n            @pytest.fixture(scope=\"module\",\n                            params=[\"DDDDDDDDD\", \"EEEEEEEEEEEE\", \"FFFFFFFFFFF\", \"banansda\"])\n            def B(request, A):\n                return request.param\n\n            def test_foo(B):\n                # Something funky is going on here.\n                # Despite specified seeds, on what is collected,\n                # sometimes we get unexpected passes. hashing B seems\n                # to help?\n                assert hash(B) or True\n            \"\"\"\n        )\n        monkeypatch.setenv(\"PYTHONHASHSEED\", \"1\")\n        out1 = testdir.runpytest_subprocess(\"-v\")\n        monkeypatch.setenv(\"PYTHONHASHSEED\", \"2\")\n        out2 = testdir.runpytest_subprocess(\"-v\")\n        out1 = [\n            line\n            for line in out1.outlines\n            if line.startswith(\"test_deterministic_fixture_collection.py::test_foo\")\n        ]\n        out2 = [\n            line\n            for line in out2.outlines\n            if line.startswith(\"test_deterministic_fixture_collection.py::test_foo\")\n        ]\n        assert len(out1) == 12\n        assert out1 == out2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestScopeAccess_TestRequestScopeAccess.test_funcarg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestScopeAccess_TestRequestScopeAccess.test_funcarg", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2923, "end_line": 2974, "span_ids": ["TestRequestScopeAccess", "TestRequestScopeAccess.test_funcarg", "TestRequestScopeAccess.test_setup"], "tokens": 343}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestScopeAccess:\n    pytestmark = pytest.mark.parametrize(\n        (\"scope\", \"ok\", \"error\"),\n        [\n            [\"session\", \"\", \"fspath class function module\"],\n            [\"module\", \"module fspath\", \"cls function\"],\n            [\"class\", \"module fspath cls\", \"function\"],\n            [\"function\", \"module fspath cls function\", \"\"],\n        ],\n    )\n\n    def test_setup(self, testdir, scope, ok, error):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=%r, autouse=True)\n            def myscoped(request):\n                for x in %r:\n                    assert hasattr(request, x)\n                for x in %r:\n                    pytest.raises(AttributeError, lambda:\n                        getattr(request, x))\n                assert request.session\n                assert request.config\n            def test_func():\n                pass\n        \"\"\"\n            % (scope, ok.split(), error.split())\n        )\n        reprec = testdir.inline_run(\"-l\")\n        reprec.assertoutcome(passed=1)\n\n    def test_funcarg(self, testdir, scope, ok, error):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=%r)\n            def arg(request):\n                for x in %r:\n                    assert hasattr(request, x)\n                for x in %r:\n                    pytest.raises(AttributeError, lambda:\n                        getattr(request, x))\n                assert request.session\n                assert request.config\n            def test_func(arg):\n                pass\n        \"\"\"\n            % (scope, ok.split(), error.split())\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestErrors_TestErrors.test_setupfunc_missing_funcarg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestErrors_TestErrors.test_setupfunc_missing_funcarg", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3071, "end_line": 3135, "span_ids": ["TestErrors", "TestErrors.test_issue498_fixture_finalizer_failing", "TestErrors.test_setupfunc_missing_funcarg", "TestErrors.test_subfactory_missing_funcarg"], "tokens": 389}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestErrors:\n    def test_subfactory_missing_funcarg(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture()\n            def gen(qwe123):\n                return 1\n            def test_something(gen):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret != 0\n        result.stdout.fnmatch_lines(\n            [\"*def gen(qwe123):*\", \"*fixture*qwe123*not found*\", \"*1 error*\"]\n        )\n\n    def test_issue498_fixture_finalizer_failing(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def fix1(request):\n                def f():\n                    raise KeyError\n                request.addfinalizer(f)\n                return object()\n\n            values = []\n            def test_1(fix1):\n                values.append(fix1)\n            def test_2(fix1):\n                values.append(fix1)\n            def test_3():\n                assert values[0] != values[1]\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *ERROR*teardown*test_1*\n            *KeyError*\n            *ERROR*teardown*test_2*\n            *KeyError*\n            *3 pass*2 errors*\n        \"\"\"\n        )\n\n    def test_setupfunc_missing_funcarg(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def gen(qwe123):\n                return 1\n            def test_something():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret != 0\n        result.stdout.fnmatch_lines(\n            [\"*def gen(qwe123):*\", \"*fixture*qwe123*not found*\", \"*1 error*\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures_TestShowFixtures.test_show_fixtures_indented_doc": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures_TestShowFixtures.test_show_fixtures_indented_doc", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3138, "end_line": 3276, "span_ids": ["TestShowFixtures", "TestShowFixtures.test_funcarg_compat", "TestShowFixtures.test_show_fixtures", "TestShowFixtures.test_show_fixtures_conftest", "TestShowFixtures.test_show_fixtures_indented_doc", "TestShowFixtures.test_show_fixtures_testmodule", "TestShowFixtures.test_show_fixtures_trimmed_doc", "TestShowFixtures.test_show_fixtures_verbose"], "tokens": 708}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestShowFixtures:\n    def test_funcarg_compat(self, testdir):\n        config = testdir.parseconfigure(\"--funcargs\")\n        assert config.option.showfixtures\n\n    def test_show_fixtures(self, testdir):\n        result = testdir.runpytest(\"--fixtures\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tmpdir_factory [[]session scope[]]\",\n                \"*for the test session*\",\n                \"tmpdir\",\n                \"*temporary directory*\",\n            ]\n        )\n\n    def test_show_fixtures_verbose(self, testdir):\n        result = testdir.runpytest(\"--fixtures\", \"-v\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tmpdir_factory [[]session scope[]] -- *tmpdir.py*\",\n                \"*for the test session*\",\n                \"tmpdir -- *tmpdir.py*\",\n                \"*temporary directory*\",\n            ]\n        )\n\n    def test_show_fixtures_testmodule(self, testdir):\n        p = testdir.makepyfile(\n            '''\n            import pytest\n            @pytest.fixture\n            def _arg0():\n                \"\"\" hidden \"\"\"\n            @pytest.fixture\n            def arg1():\n                \"\"\"  hello world \"\"\"\n        '''\n        )\n        result = testdir.runpytest(\"--fixtures\", p)\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *tmpdir\n            *fixtures defined from*\n            *arg1*\n            *hello world*\n        \"\"\"\n        )\n        result.stdout.no_fnmatch_line(\"*arg0*\")\n\n    @pytest.mark.parametrize(\"testmod\", [True, False])\n    def test_show_fixtures_conftest(self, testdir, testmod):\n        testdir.makeconftest(\n            '''\n            import pytest\n            @pytest.fixture\n            def arg1():\n                \"\"\"  hello world \"\"\"\n        '''\n        )\n        if testmod:\n            testdir.makepyfile(\n                \"\"\"\n                def test_hello():\n                    pass\n            \"\"\"\n            )\n        result = testdir.runpytest(\"--fixtures\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *tmpdir*\n            *fixtures defined from*conftest*\n            *arg1*\n            *hello world*\n        \"\"\"\n        )\n\n    def test_show_fixtures_trimmed_doc(self, testdir):\n        p = testdir.makepyfile(\n            textwrap.dedent(\n                '''\\\n                import pytest\n                @pytest.fixture\n                def arg1():\n                    \"\"\"\n                    line1\n                    line2\n\n                    \"\"\"\n                @pytest.fixture\n                def arg2():\n                    \"\"\"\n                    line1\n                    line2\n\n                    \"\"\"\n                '''\n            )\n        )\n        result = testdir.runpytest(\"--fixtures\", p)\n        result.stdout.fnmatch_lines(\n            textwrap.dedent(\n                \"\"\"\\\n                * fixtures defined from test_show_fixtures_trimmed_doc *\n                arg2\n                    line1\n                    line2\n                arg1\n                    line1\n                    line2\n                \"\"\"\n            )\n        )\n\n    def test_show_fixtures_indented_doc(self, testdir):\n        p = testdir.makepyfile(\n            textwrap.dedent(\n                '''\\\n                import pytest\n                @pytest.fixture\n                def fixture1():\n                    \"\"\"\n                    line1\n                        indented line\n                    \"\"\"\n                '''\n            )\n        )\n        result = testdir.runpytest(\"--fixtures\", p)\n        result.stdout.fnmatch_lines(\n            textwrap.dedent(\n                \"\"\"\\\n                * fixtures defined from test_show_fixtures_indented_doc *\n                fixture1\n                    line1\n                        indented line\n                \"\"\"\n            )\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures.test_show_fixtures_indented_doc_first_line_unindented_TestShowFixtures.test_show_fixtures_different_files.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures.test_show_fixtures_indented_doc_first_line_unindented_TestShowFixtures.test_show_fixtures_different_files.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3184, "end_line": 3280, "span_ids": ["TestShowFixtures.test_show_fixtures_different_files", "TestShowFixtures.test_show_fixtures_indented_doc_first_line_unindented", "TestShowFixtures.test_show_fixtures_indented_in_class"], "tokens": 456}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestShowFixtures:\n\n    def test_show_fixtures_indented_doc_first_line_unindented(self, testdir):\n        p = testdir.makepyfile(\n            textwrap.dedent(\n                '''\\\n                import pytest\n                @pytest.fixture\n                def fixture1():\n                    \"\"\"line1\n                    line2\n                        indented line\n                    \"\"\"\n                '''\n            )\n        )\n        result = testdir.runpytest(\"--fixtures\", p)\n        result.stdout.fnmatch_lines(\n            textwrap.dedent(\n                \"\"\"\\\n                * fixtures defined from test_show_fixtures_indented_doc_first_line_unindented *\n                fixture1\n                    line1\n                    line2\n                        indented line\n                \"\"\"\n            )\n        )\n\n    def test_show_fixtures_indented_in_class(self, testdir):\n        p = testdir.makepyfile(\n            textwrap.dedent(\n                '''\\\n                import pytest\n                class TestClass(object):\n                    @pytest.fixture\n                    def fixture1(self):\n                        \"\"\"line1\n                        line2\n                            indented line\n                        \"\"\"\n                '''\n            )\n        )\n        result = testdir.runpytest(\"--fixtures\", p)\n        result.stdout.fnmatch_lines(\n            textwrap.dedent(\n                \"\"\"\\\n                * fixtures defined from test_show_fixtures_indented_in_class *\n                fixture1\n                    line1\n                    line2\n                        indented line\n                \"\"\"\n            )\n        )\n\n    def test_show_fixtures_different_files(self, testdir):\n        \"\"\"\n        #833: --fixtures only shows fixtures from first file\n        \"\"\"\n        testdir.makepyfile(\n            test_a='''\n            import pytest\n\n            @pytest.fixture\n            def fix_a():\n                \"\"\"Fixture A\"\"\"\n                pass\n\n            def test_a(fix_a):\n                pass\n        '''\n        )\n        testdir.makepyfile(\n            test_b='''\n            import pytest\n\n            @pytest.fixture\n            def fix_b():\n                \"\"\"Fixture B\"\"\"\n                pass\n\n            def test_b(fix_b):\n                pass\n        '''\n        )\n        result = testdir.runpytest(\"--fixtures\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            * fixtures defined from test_a *\n            fix_a\n                Fixture A\n\n            * fixtures defined from test_b *\n            fix_b\n                Fixture B\n        \"\"\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures.test_show_fixtures_with_same_name_TestShowFixtures.test_fixture_disallow_twice": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestShowFixtures.test_show_fixtures_with_same_name_TestShowFixtures.test_fixture_disallow_twice", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3282, "end_line": 3329, "span_ids": ["TestShowFixtures.test_fixture_disallow_twice", "TestShowFixtures.test_show_fixtures_with_same_name"], "tokens": 254}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestShowFixtures:\n\n    def test_show_fixtures_with_same_name(self, testdir):\n        testdir.makeconftest(\n            '''\n            import pytest\n            @pytest.fixture\n            def arg1():\n                \"\"\"Hello World in conftest.py\"\"\"\n                return \"Hello World\"\n        '''\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo(arg1):\n                assert arg1 == \"Hello World\"\n        \"\"\"\n        )\n        testdir.makepyfile(\n            '''\n            import pytest\n            @pytest.fixture\n            def arg1():\n                \"\"\"Hi from test module\"\"\"\n                return \"Hi\"\n            def test_bar(arg1):\n                assert arg1 == \"Hi\"\n        '''\n        )\n        result = testdir.runpytest(\"--fixtures\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            * fixtures defined from conftest *\n            arg1\n                Hello World in conftest.py\n\n            * fixtures defined from test_show_fixtures_with_same_name *\n            arg1\n                Hi from test module\n        \"\"\"\n        )\n\n    def test_fixture_disallow_twice(self):\n        \"\"\"Test that applying @pytest.fixture twice generates an error (#2334).\"\"\"\n        with pytest.raises(ValueError):\n\n            @pytest.fixture\n            @pytest.fixture\n            def foo():\n                raise NotImplementedError()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestContextManagerFixtureFuncs_TestContextManagerFixtureFuncs.test_custom_name": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestContextManagerFixtureFuncs_TestContextManagerFixtureFuncs.test_custom_name", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3332, "end_line": 3475, "span_ids": ["TestContextManagerFixtureFuncs", "TestContextManagerFixtureFuncs.flavor", "TestContextManagerFixtureFuncs.test_custom_name", "TestContextManagerFixtureFuncs.test_scoped", "TestContextManagerFixtureFuncs.test_setup_exception", "TestContextManagerFixtureFuncs.test_simple", "TestContextManagerFixtureFuncs.test_teardown_exception", "TestContextManagerFixtureFuncs.test_yields_more_than_one"], "tokens": 811}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestContextManagerFixtureFuncs:\n    @pytest.fixture(params=[\"fixture\", \"yield_fixture\"])\n    def flavor(self, request, testdir, monkeypatch):\n        monkeypatch.setenv(\"PYTEST_FIXTURE_FLAVOR\", request.param)\n        testdir.makepyfile(\n            test_context=\"\"\"\n            import os\n            import pytest\n            import warnings\n            VAR = \"PYTEST_FIXTURE_FLAVOR\"\n            if VAR not in os.environ:\n                warnings.warn(\"PYTEST_FIXTURE_FLAVOR was not set, assuming fixture\")\n                fixture = pytest.fixture\n            else:\n                fixture = getattr(pytest, os.environ[VAR])\n        \"\"\"\n        )\n\n    def test_simple(self, testdir, flavor):\n        testdir.makepyfile(\n            \"\"\"\n            from test_context import fixture\n            @fixture\n            def arg1():\n                print(\"setup\")\n                yield 1\n                print(\"teardown\")\n            def test_1(arg1):\n                print(\"test1\", arg1)\n            def test_2(arg1):\n                print(\"test2\", arg1)\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *setup*\n            *test1 1*\n            *teardown*\n            *setup*\n            *test2 1*\n            *teardown*\n        \"\"\"\n        )\n\n    def test_scoped(self, testdir, flavor):\n        testdir.makepyfile(\n            \"\"\"\n            from test_context import fixture\n            @fixture(scope=\"module\")\n            def arg1():\n                print(\"setup\")\n                yield 1\n                print(\"teardown\")\n            def test_1(arg1):\n                print(\"test1\", arg1)\n            def test_2(arg1):\n                print(\"test2\", arg1)\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *setup*\n            *test1 1*\n            *test2 1*\n            *teardown*\n        \"\"\"\n        )\n\n    def test_setup_exception(self, testdir, flavor):\n        testdir.makepyfile(\n            \"\"\"\n            from test_context import fixture\n            @fixture(scope=\"module\")\n            def arg1():\n                pytest.fail(\"setup\")\n                yield 1\n            def test_1(arg1):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *pytest.fail*setup*\n            *1 error*\n        \"\"\"\n        )\n\n    def test_teardown_exception(self, testdir, flavor):\n        testdir.makepyfile(\n            \"\"\"\n            from test_context import fixture\n            @fixture(scope=\"module\")\n            def arg1():\n                yield 1\n                pytest.fail(\"teardown\")\n            def test_1(arg1):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *pytest.fail*teardown*\n            *1 passed*1 error*\n        \"\"\"\n        )\n\n    def test_yields_more_than_one(self, testdir, flavor):\n        testdir.makepyfile(\n            \"\"\"\n            from test_context import fixture\n            @fixture(scope=\"module\")\n            def arg1():\n                yield 1\n                yield 2\n            def test_1(arg1):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *fixture function*\n            *test_yields*:2*\n        \"\"\"\n        )\n\n    def test_custom_name(self, testdir, flavor):\n        testdir.makepyfile(\n            \"\"\"\n            from test_context import fixture\n            @fixture(name='meow')\n            def arg1():\n                return 'mew'\n            def test_1(meow):\n                print(meow)\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines([\"*mew*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestParameterizedSubRequest_TestParameterizedSubRequest.test_external_fixture.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestParameterizedSubRequest_TestParameterizedSubRequest.test_external_fixture.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3478, "end_line": 3564, "span_ids": ["TestParameterizedSubRequest", "TestParameterizedSubRequest.test_call_from_fixture", "TestParameterizedSubRequest.test_call_from_test", "TestParameterizedSubRequest.test_external_fixture"], "tokens": 524}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestParameterizedSubRequest:\n    def test_call_from_fixture(self, testdir):\n        testdir.makepyfile(\n            test_call_from_fixture=\"\"\"\n            import pytest\n\n            @pytest.fixture(params=[0, 1, 2])\n            def fix_with_param(request):\n                return request.param\n\n            @pytest.fixture\n            def get_named_fixture(request):\n                return request.getfixturevalue('fix_with_param')\n\n            def test_foo(request, get_named_fixture):\n                pass\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"The requested fixture has no parameter defined for test:\",\n                \"    test_call_from_fixture.py::test_foo\",\n                \"Requested fixture 'fix_with_param' defined in:\",\n                \"test_call_from_fixture.py:4\",\n                \"Requested here:\",\n                \"test_call_from_fixture.py:9\",\n                \"*1 error in*\",\n            ]\n        )\n\n    def test_call_from_test(self, testdir):\n        testdir.makepyfile(\n            test_call_from_test=\"\"\"\n            import pytest\n\n            @pytest.fixture(params=[0, 1, 2])\n            def fix_with_param(request):\n                return request.param\n\n            def test_foo(request):\n                request.getfixturevalue('fix_with_param')\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"The requested fixture has no parameter defined for test:\",\n                \"    test_call_from_test.py::test_foo\",\n                \"Requested fixture 'fix_with_param' defined in:\",\n                \"test_call_from_test.py:4\",\n                \"Requested here:\",\n                \"test_call_from_test.py:8\",\n                \"*1 failed*\",\n            ]\n        )\n\n    def test_external_fixture(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(params=[0, 1, 2])\n            def fix_with_param(request):\n                return request.param\n            \"\"\"\n        )\n\n        testdir.makepyfile(\n            test_external_fixture=\"\"\"\n            def test_foo(request):\n                request.getfixturevalue('fix_with_param')\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"The requested fixture has no parameter defined for test:\",\n                \"    test_external_fixture.py::test_foo\",\n                \"\",\n                \"Requested fixture 'fix_with_param' defined in:\",\n                \"conftest.py:4\",\n                \"Requested here:\",\n                \"test_external_fixture.py:2\",\n                \"*1 failed*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_pytest_fixture_setup_and_post_finalizer_hook_test_pytest_fixture_setup_and_post_finalizer_hook.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_pytest_fixture_setup_and_post_finalizer_hook_test_pytest_fixture_setup_and_post_finalizer_hook.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3611, "end_line": 3651, "span_ids": ["test_pytest_fixture_setup_and_post_finalizer_hook"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_pytest_fixture_setup_and_post_finalizer_hook(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_fixture_setup(fixturedef, request):\n            print('ROOT setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        def pytest_fixture_post_finalizer(fixturedef, request):\n            print('ROOT finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n    \"\"\"\n    )\n    testdir.makepyfile(\n        **{\n            \"tests/conftest.py\": \"\"\"\n            def pytest_fixture_setup(fixturedef, request):\n                print('TESTS setup hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n            def pytest_fixture_post_finalizer(fixturedef, request):\n                print('TESTS finalizer hook called for {0} from {1}'.format(fixturedef.argname, request.node.name))\n        \"\"\",\n            \"tests/test_hooks.py\": \"\"\"\n            import pytest\n\n            @pytest.fixture()\n            def my_fixture():\n                return 'some'\n\n            def test_func(my_fixture):\n                print('TEST test_func')\n                assert my_fixture == 'some'\n        \"\"\",\n        }\n    )\n    result = testdir.runpytest(\"-s\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\n            \"*TESTS setup hook called for my_fixture from test_func*\",\n            \"*ROOT setup hook called for my_fixture from test_func*\",\n            \"*TEST test_func*\",\n            \"*TESTS finalizer hook called for my_fixture from test_func*\",\n            \"*ROOT finalizer hook called for my_fixture from test_func*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering_TestScopeOrdering.test_func_closure_module_auto.assert_request_fixturenam": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering_TestScopeOrdering.test_func_closure_module_auto.assert_request_fixturenam", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3654, "end_line": 3689, "span_ids": ["TestScopeOrdering", "TestScopeOrdering.test_func_closure_module_auto"], "tokens": 287}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestScopeOrdering:\n    \"\"\"Class of tests that ensure fixtures are ordered based on their scopes (#2405)\"\"\"\n\n    @pytest.mark.parametrize(\"variant\", [\"mark\", \"autouse\"])\n    def test_func_closure_module_auto(self, testdir, variant, monkeypatch):\n        \"\"\"Semantically identical to the example posted in #2405 when ``use_mark=True``\"\"\"\n        monkeypatch.setenv(\"FIXTURE_ACTIVATION_VARIANT\", variant)\n        testdir.makepyfile(\n            \"\"\"\n            import warnings\n            import os\n            import pytest\n            VAR = 'FIXTURE_ACTIVATION_VARIANT'\n            VALID_VARS = ('autouse', 'mark')\n\n            VARIANT = os.environ.get(VAR)\n            if VARIANT is None or VARIANT not in VALID_VARS:\n                warnings.warn(\"{!r} is not  in {}, assuming autouse\".format(VARIANT, VALID_VARS) )\n                variant = 'mark'\n\n            @pytest.fixture(scope='module', autouse=VARIANT == 'autouse')\n            def m1(): pass\n\n            if VARIANT=='mark':\n                pytestmark = pytest.mark.usefixtures('m1')\n\n            @pytest.fixture(scope='function', autouse=True)\n            def f1(): pass\n\n            def test_func(m1):\n                pass\n        \"\"\"\n        )\n        items, _ = testdir.inline_genitems()\n        request = FixtureRequest(items[0])\n        assert request.fixturenames == \"m1 f1\".split()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_with_native_fixtures_TestScopeOrdering.test_func_closure_with_native_fixtures.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_with_native_fixtures_TestScopeOrdering.test_func_closure_with_native_fixtures.None_2", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3691, "end_line": 3743, "span_ids": ["TestScopeOrdering.test_func_closure_with_native_fixtures"], "tokens": 389}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestScopeOrdering:\n\n    def test_func_closure_with_native_fixtures(self, testdir, monkeypatch):\n        \"\"\"Sanity check that verifies the order returned by the closures and the actual fixture execution order:\n        The execution order may differ because of fixture inter-dependencies.\n        \"\"\"\n        monkeypatch.setattr(pytest, \"FIXTURE_ORDER\", [], raising=False)\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            FIXTURE_ORDER = pytest.FIXTURE_ORDER\n\n            @pytest.fixture(scope=\"session\")\n            def s1():\n                FIXTURE_ORDER.append('s1')\n\n            @pytest.fixture(scope=\"package\")\n            def p1():\n                FIXTURE_ORDER.append('p1')\n\n            @pytest.fixture(scope=\"module\")\n            def m1():\n                FIXTURE_ORDER.append('m1')\n\n            @pytest.fixture(scope='session')\n            def my_tmpdir_factory():\n                FIXTURE_ORDER.append('my_tmpdir_factory')\n\n            @pytest.fixture\n            def my_tmpdir(my_tmpdir_factory):\n                FIXTURE_ORDER.append('my_tmpdir')\n\n            @pytest.fixture\n            def f1(my_tmpdir):\n                FIXTURE_ORDER.append('f1')\n\n            @pytest.fixture\n            def f2():\n                FIXTURE_ORDER.append('f2')\n\n            def test_foo(f1, p1, m1, f2, s1): pass\n        \"\"\"\n        )\n        items, _ = testdir.inline_genitems()\n        request = FixtureRequest(items[0])\n        # order of fixtures based on their scope and position in the parameter list\n        assert (\n            request.fixturenames == \"s1 my_tmpdir_factory p1 m1 f1 f2 my_tmpdir\".split()\n        )\n        testdir.runpytest()\n        # actual fixture execution differs: dependent fixtures must be created first (\"my_tmpdir\")\n        assert (\n            pytest.FIXTURE_ORDER == \"s1 my_tmpdir_factory p1 m1 my_tmpdir f1 f2\".split()\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_module_TestScopeOrdering.test_func_closure_scopes_reordered.assert_request_fixturenam": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_module_TestScopeOrdering.test_func_closure_scopes_reordered.assert_request_fixturenam", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3745, "end_line": 3795, "span_ids": ["TestScopeOrdering.test_func_closure_module", "TestScopeOrdering.test_func_closure_scopes_reordered"], "tokens": 304}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestScopeOrdering:\n\n    def test_func_closure_module(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='module')\n            def m1(): pass\n\n            @pytest.fixture(scope='function')\n            def f1(): pass\n\n            def test_func(f1, m1):\n                pass\n        \"\"\"\n        )\n        items, _ = testdir.inline_genitems()\n        request = FixtureRequest(items[0])\n        assert request.fixturenames == \"m1 f1\".split()\n\n    def test_func_closure_scopes_reordered(self, testdir):\n        \"\"\"Test ensures that fixtures are ordered by scope regardless of the order of the parameters, although\n        fixtures of same scope keep the declared order\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session')\n            def s1(): pass\n\n            @pytest.fixture(scope='module')\n            def m1(): pass\n\n            @pytest.fixture(scope='function')\n            def f1(): pass\n\n            @pytest.fixture(scope='function')\n            def f2(): pass\n\n            class Test:\n\n                @pytest.fixture(scope='class')\n                def c1(cls): pass\n\n                def test_func(self, f2, f1, c1, m1, s1):\n                    pass\n        \"\"\"\n        )\n        items, _ = testdir.inline_genitems()\n        request = FixtureRequest(items[0])\n        assert request.fixturenames == \"s1 m1 c1 f2 f1\".split()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_same_scope_closer_root_first_TestScopeOrdering.test_func_closure_same_scope_closer_root_first.assert_request_fixturenam": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_same_scope_closer_root_first_TestScopeOrdering.test_func_closure_same_scope_closer_root_first.assert_request_fixturenam", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3797, "end_line": 3835, "span_ids": ["TestScopeOrdering.test_func_closure_same_scope_closer_root_first"], "tokens": 241}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestScopeOrdering:\n\n    def test_func_closure_same_scope_closer_root_first(self, testdir):\n        \"\"\"Auto-use fixtures of same scope are ordered by closer-to-root first\"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='module', autouse=True)\n            def m_conf(): pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            **{\n                \"sub/conftest.py\": \"\"\"\n                import pytest\n\n                @pytest.fixture(scope='package', autouse=True)\n                def p_sub(): pass\n\n                @pytest.fixture(scope='module', autouse=True)\n                def m_sub(): pass\n            \"\"\",\n                \"sub/__init__.py\": \"\",\n                \"sub/test_func.py\": \"\"\"\n                import pytest\n\n                @pytest.fixture(scope='module', autouse=True)\n                def m_test(): pass\n\n                @pytest.fixture(scope='function')\n                def f1(): pass\n\n                def test_func(m_test, f1):\n                    pass\n        \"\"\",\n            }\n        )\n        items, _ = testdir.inline_genitems()\n        request = FixtureRequest(items[0])\n        assert request.fixturenames == \"p_sub m_conf m_sub m_test f1\".split()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_all_scopes_complex_TestScopeOrdering.test_func_closure_all_scopes_complex.assert_request_fixturenam": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_func_closure_all_scopes_complex_TestScopeOrdering.test_func_closure_all_scopes_complex.assert_request_fixturenam", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3837, "end_line": 3879, "span_ids": ["TestScopeOrdering.test_func_closure_all_scopes_complex"], "tokens": 258}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestScopeOrdering:\n\n    def test_func_closure_all_scopes_complex(self, testdir):\n        \"\"\"Complex test involving all scopes and mixing autouse with normal fixtures\"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session')\n            def s1(): pass\n\n            @pytest.fixture(scope='package', autouse=True)\n            def p1(): pass\n        \"\"\"\n        )\n        testdir.makepyfile(**{\"__init__.py\": \"\"})\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='module', autouse=True)\n            def m1(): pass\n\n            @pytest.fixture(scope='module')\n            def m2(s1): pass\n\n            @pytest.fixture(scope='function')\n            def f1(): pass\n\n            @pytest.fixture(scope='function')\n            def f2(): pass\n\n            class Test:\n\n                @pytest.fixture(scope='class', autouse=True)\n                def c1(self):\n                    pass\n\n                def test_func(self, f2, f1, m2):\n                    pass\n        \"\"\"\n        )\n        items, _ = testdir.inline_genitems()\n        request = FixtureRequest(items[0])\n        assert request.fixturenames == \"s1 p1 m1 m2 c1 f2 f1\".split()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestOEJSKITSpecials.test_autouse_fixture_test_wrapped_getfslineno": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestOEJSKITSpecials.test_autouse_fixture_test_wrapped_getfslineno", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 37, "end_line": 86, "span_ids": ["TestOEJSKITSpecials.test_autouse_fixture", "test_wrapped_getfslineno"], "tokens": 317}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestOEJSKITSpecials:\n\n    def test_autouse_fixture(self, testdir, recwarn):  # rough jstests usage\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_pycollect_makeitem(collector, name, obj):\n                if name == \"MyClass\":\n                    return MyCollector.from_parent(collector, name=name)\n            class MyCollector(pytest.Collector):\n                def reportinfo(self):\n                    return self.fspath, 3, \"xyz\"\n        \"\"\"\n        )\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            import pytest\n            @pytest.fixture(autouse=True)\n            def hello():\n                pass\n            @pytest.fixture\n            def arg1(request):\n                return 42\n            class MyClass(object):\n                pass\n        \"\"\"\n        )\n        # this hook finds funcarg factories\n        rep = runner.collect_one_node(modcol)\n        clscol = rep.result[0]\n        clscol.obj = lambda: None\n        clscol.funcargs = {}\n        pytest._fillfuncargs(clscol)\n        assert not clscol.funcargs\n\n\ndef test_wrapped_getfslineno():\n    def func():\n        pass\n\n    def wrap(f):\n        func.__wrapped__ = f\n        func.patchings = [\"qwe\"]\n        return func\n\n    @wrap\n    def wrapped_func(x, y, z):\n        pass\n\n    fs, lineno = python.getfslineno(wrapped_func)\n    fs2, lineno2 = python.getfslineno(wrap)\n    assert lineno > lineno2, \"getfslineno does not unwrap correctly\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration_TestMockDecoration.test_unittest_mock_and_pypi_mock": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration_TestMockDecoration.test_unittest_mock_and_pypi_mock", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 89, "end_line": 179, "span_ids": ["TestMockDecoration", "TestMockDecoration.test_getfuncargnames_patching", "TestMockDecoration.test_unittest_mock", "TestMockDecoration.test_unittest_mock_and_fixture", "TestMockDecoration.test_unittest_mock_and_pypi_mock", "TestMockDecoration.test_wrapped_getfuncargnames"], "tokens": 522}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMockDecoration:\n    def test_wrapped_getfuncargnames(self):\n        from _pytest.compat import getfuncargnames\n\n        def wrap(f):\n            def func():\n                pass\n\n            func.__wrapped__ = f\n            return func\n\n        @wrap\n        def f(x):\n            pass\n\n        values = getfuncargnames(f)\n        assert values == (\"x\",)\n\n    def test_getfuncargnames_patching(self):\n        from _pytest.compat import getfuncargnames\n        from unittest.mock import patch\n\n        class T:\n            def original(self, x, y, z):\n                pass\n\n        @patch.object(T, \"original\")\n        def f(x, y, z):\n            pass\n\n        values = getfuncargnames(f)\n        assert values == (\"y\", \"z\")\n\n    def test_unittest_mock(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import unittest.mock\n            class T(unittest.TestCase):\n                @unittest.mock.patch(\"os.path.abspath\")\n                def test_hello(self, abspath):\n                    import os\n                    os.path.abspath(\"hello\")\n                    abspath.assert_any_call(\"hello\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_unittest_mock_and_fixture(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import os.path\n            import unittest.mock\n            import pytest\n\n            @pytest.fixture\n            def inject_me():\n                pass\n\n            @unittest.mock.patch.object(os.path, \"abspath\",\n                                        new=unittest.mock.MagicMock)\n            def test_hello(inject_me):\n                import os\n                os.path.abspath(\"hello\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_unittest_mock_and_pypi_mock(self, testdir):\n        pytest.importorskip(\"mock\", \"1.0.1\")\n        testdir.makepyfile(\n            \"\"\"\n            import mock\n            import unittest.mock\n            class TestBoth(object):\n                @unittest.mock.patch(\"os.path.abspath\")\n                def test_hello(self, abspath):\n                    import os\n                    os.path.abspath(\"hello\")\n                    abspath.assert_any_call(\"hello\")\n\n                @mock.patch(\"os.path.abspath\")\n                def test_hello_mock(self, abspath):\n                    import os\n                    os.path.abspath(\"hello\")\n                    abspath.assert_any_call(\"hello\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_TestMockDecoration.test_mock.assert_funcnames_T_t": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_TestMockDecoration.test_mock.assert_funcnames_T_t", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 209, "end_line": 240, "span_ids": ["TestMockDecoration.test_mock"], "tokens": 258}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMockDecoration:\n\n    def test_mock(self, testdir):\n        pytest.importorskip(\"mock\", \"1.0.1\")\n        testdir.makepyfile(\n            \"\"\"\n            import os\n            import unittest\n            import mock\n\n            class T(unittest.TestCase):\n                @mock.patch(\"os.path.abspath\")\n                def test_hello(self, abspath):\n                    os.path.abspath(\"hello\")\n                    abspath.assert_any_call(\"hello\")\n            def mock_basename(path):\n                return \"mock_basename\"\n            @mock.patch(\"os.path.abspath\")\n            @mock.patch(\"os.path.normpath\")\n            @mock.patch(\"os.path.basename\", new=mock_basename)\n            def test_someting(normpath, abspath, tmpdir):\n                abspath.return_value = \"this\"\n                os.path.normpath(os.path.abspath(\"hello\"))\n                normpath.assert_any_call(\"this\")\n                assert os.path.basename(\"123\") == \"mock_basename\"\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n        calls = reprec.getcalls(\"pytest_runtest_logreport\")\n        funcnames = [\n            call.report.location[2] for call in calls if call.report.when == \"call\"\n        ]\n        assert funcnames == [\"T.test_hello\", \"test_someting\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_sorting_TestMockDecoration.test_mock_double_patch_issue473": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_sorting_TestMockDecoration.test_mock_double_patch_issue473", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 242, "end_line": 282, "span_ids": ["TestMockDecoration.test_mock_double_patch_issue473", "TestMockDecoration.test_mock_sorting"], "tokens": 292}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMockDecoration:\n\n    def test_mock_sorting(self, testdir):\n        pytest.importorskip(\"mock\", \"1.0.1\")\n        testdir.makepyfile(\n            \"\"\"\n            import os\n            import mock\n\n            @mock.patch(\"os.path.abspath\")\n            def test_one(abspath):\n                pass\n            @mock.patch(\"os.path.abspath\")\n            def test_two(abspath):\n                pass\n            @mock.patch(\"os.path.abspath\")\n            def test_three(abspath):\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        calls = reprec.getreports(\"pytest_runtest_logreport\")\n        calls = [x for x in calls if x.when == \"call\"]\n        names = [x.nodeid.split(\"::\")[-1] for x in calls]\n        assert names == [\"test_one\", \"test_two\", \"test_three\"]\n\n    def test_mock_double_patch_issue473(self, testdir):\n        pytest.importorskip(\"mock\", \"1.0.1\")\n        testdir.makepyfile(\n            \"\"\"\n            from mock import patch\n            from pytest import mark\n\n            @patch('os.getcwd')\n            @patch('os.path')\n            @mark.slow\n            class TestSimple(object):\n                def test_simple_thing(self, mock_path, mock_getcwd):\n                    pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestReRunTests_test_pytestconfig_is_session_scoped": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestReRunTests_test_pytestconfig_is_session_scoped", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 285, "end_line": 328, "span_ids": ["TestReRunTests", "TestReRunTests.test_rerun", "test_pytestconfig_is_session_scoped"], "tokens": 246}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReRunTests:\n    def test_rerun(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            from _pytest.runner import runtestprotocol\n            def pytest_runtest_protocol(item, nextitem):\n                runtestprotocol(item, log=False, nextitem=nextitem)\n                runtestprotocol(item, log=True, nextitem=nextitem)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            count = 0\n            req = None\n            @pytest.fixture\n            def fix(request):\n                global count, req\n                assert request != req\n                req = request\n                print(\"fix count %s\" % count)\n                count += 1\n            def test_fix(fix):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *fix count 0*\n            *fix count 1*\n        \"\"\"\n        )\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *2 passed*\n        \"\"\"\n        )\n\n\ndef test_pytestconfig_is_session_scoped():\n    from _pytest.fixtures import pytestconfig\n\n    assert pytestconfig._pytestfixturefunction.scope == \"session\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestNoselikeTestAttribute_TestNoselikeTestAttribute.test_class_with_nasty_getattr.assert_not_call_items": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestNoselikeTestAttribute_TestNoselikeTestAttribute.test_class_with_nasty_getattr.assert_not_call_items", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 331, "end_line": 412, "span_ids": ["TestNoselikeTestAttribute", "TestNoselikeTestAttribute.test_class_and_method", "TestNoselikeTestAttribute.test_class_with_nasty_getattr", "TestNoselikeTestAttribute.test_module_with_global_test", "TestNoselikeTestAttribute.test_unittest_class"], "tokens": 495}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNoselikeTestAttribute:\n    def test_module_with_global_test(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            __test__ = False\n            def test_hello():\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        assert not reprec.getfailedcollections()\n        calls = reprec.getreports(\"pytest_runtest_logreport\")\n        assert not calls\n\n    def test_class_and_method(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            __test__ = True\n            def test_func():\n                pass\n            test_func.__test__ = False\n\n            class TestSome(object):\n                __test__ = False\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        assert not reprec.getfailedcollections()\n        calls = reprec.getreports(\"pytest_runtest_logreport\")\n        assert not calls\n\n    def test_unittest_class(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import unittest\n            class TC(unittest.TestCase):\n                def test_1(self):\n                    pass\n            class TC2(unittest.TestCase):\n                __test__ = False\n                def test_2(self):\n                    pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        assert not reprec.getfailedcollections()\n        call = reprec.getcalls(\"pytest_collection_modifyitems\")[0]\n        assert len(call.items) == 1\n        assert call.items[0].cls.__name__ == \"TC\"\n\n    def test_class_with_nasty_getattr(self, testdir):\n        \"\"\"Make sure we handle classes with a custom nasty __getattr__ right.\n\n        With a custom __getattr__ which e.g. returns a function (like with a\n        RPC wrapper), we shouldn't assume this meant \"__test__ = True\".\n        \"\"\"\n        # https://github.com/pytest-dev/pytest/issues/1204\n        testdir.makepyfile(\n            \"\"\"\n            class MetaModel(type):\n\n                def __getattr__(cls, key):\n                    return lambda: None\n\n\n            BaseModel = MetaModel('Model', (), {})\n\n\n            class Model(BaseModel):\n\n                __metaclass__ = MetaModel\n\n                def test_blah(self):\n                    pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        assert not reprec.getfailedcollections()\n        call = reprec.getcalls(\"pytest_collection_modifyitems\")[0]\n        assert not call.items", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestParameterize_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestParameterize_", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 415, "end_line": 466, "span_ids": ["TestParameterize", "TestParameterize.test_idfn_fixture", "TestParameterize.test_idfn_marker"], "tokens": 289}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestParameterize:\n    \"\"\"#351\"\"\"\n\n    def test_idfn_marker(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def idfn(param):\n                if param == 0:\n                    return 'spam'\n                elif param == 1:\n                    return 'ham'\n                else:\n                    return None\n\n            @pytest.mark.parametrize('a,b', [(0, 2), (1, 2)], ids=idfn)\n            def test_params(a, b):\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest(\"--collect-only\")\n        res.stdout.fnmatch_lines([\"*spam-2*\", \"*ham-2*\"])\n\n    def test_idfn_fixture(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def idfn(param):\n                if param == 0:\n                    return 'spam'\n                elif param == 1:\n                    return 'ham'\n                else:\n                    return None\n\n            @pytest.fixture(params=[0, 1], ids=idfn)\n            def a(request):\n                return request.param\n\n            @pytest.fixture(params=[1, 2], ids=idfn)\n            def b(request):\n                return request.param\n\n            def test_params(a, b):\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest(\"--collect-only\")\n        res.stdout.fnmatch_lines([\"*spam-2*\", \"*ham-2*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_find_parametrized_scope_TestMetafunc.test_find_parametrized_scope.None_12": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_find_parametrized_scope_TestMetafunc.test_find_parametrized_scope.None_12", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 134, "end_line": 178, "span_ids": ["TestMetafunc.test_find_parametrized_scope"], "tokens": 419}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_find_parametrized_scope(self) -> None:\n        \"\"\"unittest for _find_parametrized_scope (#3941)\"\"\"\n        from _pytest.python import _find_parametrized_scope\n\n        @attr.s\n        class DummyFixtureDef:\n            scope = attr.ib()\n\n        fixtures_defs = dict(\n            session_fix=[DummyFixtureDef(\"session\")],\n            package_fix=[DummyFixtureDef(\"package\")],\n            module_fix=[DummyFixtureDef(\"module\")],\n            class_fix=[DummyFixtureDef(\"class\")],\n            func_fix=[DummyFixtureDef(\"function\")],\n        )\n\n        # use arguments to determine narrow scope; the cause of the bug is that it would look on all\n        # fixture defs given to the method\n        def find_scope(argnames, indirect):\n            return _find_parametrized_scope(argnames, fixtures_defs, indirect=indirect)\n\n        assert find_scope([\"func_fix\"], indirect=True) == \"function\"\n        assert find_scope([\"class_fix\"], indirect=True) == \"class\"\n        assert find_scope([\"module_fix\"], indirect=True) == \"module\"\n        assert find_scope([\"package_fix\"], indirect=True) == \"package\"\n        assert find_scope([\"session_fix\"], indirect=True) == \"session\"\n\n        assert find_scope([\"class_fix\", \"func_fix\"], indirect=True) == \"function\"\n        assert find_scope([\"func_fix\", \"session_fix\"], indirect=True) == \"function\"\n        assert find_scope([\"session_fix\", \"class_fix\"], indirect=True) == \"class\"\n        assert find_scope([\"package_fix\", \"session_fix\"], indirect=True) == \"package\"\n        assert find_scope([\"module_fix\", \"session_fix\"], indirect=True) == \"module\"\n\n        # when indirect is False or is not for all scopes, always use function\n        assert find_scope([\"session_fix\", \"module_fix\"], indirect=False) == \"function\"\n        assert (\n            find_scope([\"session_fix\", \"module_fix\"], indirect=[\"module_fix\"])\n            == \"function\"\n        )\n        assert (\n            find_scope(\n                [\"session_fix\", \"module_fix\"], indirect=[\"session_fix\", \"module_fix\"]\n            )\n            == \"module\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_native_strings_TestMetafunc.test_idmaker_native_strings.assert_result_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_native_strings_TestMetafunc.test_idmaker_native_strings.assert_result_", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 384, "end_line": 417, "span_ids": ["TestMetafunc.test_idmaker_native_strings"], "tokens": 256}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_idmaker_native_strings(self) -> None:\n        from _pytest.python import idmaker\n\n        result = idmaker(\n            (\"a\", \"b\"),\n            [\n                pytest.param(1.0, -1.1),\n                pytest.param(2, -202),\n                pytest.param(\"three\", \"three hundred\"),\n                pytest.param(True, False),\n                pytest.param(None, None),\n                pytest.param(re.compile(\"foo\"), re.compile(\"bar\")),\n                pytest.param(str, int),\n                pytest.param(list(\"six\"), [66, 66]),\n                pytest.param({7}, set(\"seven\")),\n                pytest.param(tuple(\"eight\"), (8, -8, 8)),\n                pytest.param(b\"\\xc3\\xb4\", b\"name\"),\n                pytest.param(b\"\\xc3\\xb4\", \"other\"),\n            ],\n        )\n        assert result == [\n            \"1.0--1.1\",\n            \"2--202\",\n            \"three-three hundred\",\n            \"True-False\",\n            \"None-None\",\n            \"foo-bar\",\n            \"str-int\",\n            \"a7-b7\",\n            \"a8-b8\",\n            \"a9-b9\",\n            \"\\\\xc3\\\\xb4-name\",\n            \"\\\\xc3\\\\xb4-other\",\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional_TestMetafuncFunctional.test_attributes.result_assert_outcomes_pa": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional_TestMetafuncFunctional.test_attributes.result_assert_outcomes_pa", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 992, "end_line": 1021, "span_ids": ["TestMetafuncFunctional", "TestMetafuncFunctional.test_attributes"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n    def test_attributes(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            # assumes that generate/provide runs in the same process\n            import sys, pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('metafunc', [metafunc])\n\n            @pytest.fixture\n            def metafunc(request):\n                return request.param\n\n            def test_function(metafunc, pytestconfig):\n                assert metafunc.config == pytestconfig\n                assert metafunc.module.__name__ == __name__\n                assert metafunc.function == test_function\n                assert metafunc.cls is None\n\n            class TestClass(object):\n                def test_method(self, metafunc, pytestconfig):\n                    assert metafunc.config == pytestconfig\n                    assert metafunc.module.__name__ == __name__\n                    unbound = TestClass.test_method\n                    assert metafunc.function == unbound\n                    assert metafunc.cls == TestClass\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-v\")\n        result.assert_outcomes(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_generate_same_function_names_issue403_TestMetafuncFunctional.test_parametrize_misspelling": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_generate_same_function_names_issue403_TestMetafuncFunctional.test_parametrize_misspelling", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1392, "end_line": 1434, "span_ids": ["TestMetafuncFunctional.test_generate_same_function_names_issue403", "TestMetafuncFunctional.test_parametrize_misspelling"], "tokens": 306}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n\n    def test_generate_same_function_names_issue403(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def make_tests():\n                @pytest.mark.parametrize(\"x\", range(2))\n                def test_foo(x):\n                    pass\n                return test_foo\n\n            test_x = make_tests()\n            test_y = make_tests()\n        \"\"\"\n        )\n        reprec = testdir.runpytest()\n        reprec.assert_outcomes(passed=4)\n\n    def test_parametrize_misspelling(self, testdir: Testdir) -> None:\n        \"\"\"#463\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.parametrise(\"x\", range(2))\n            def test_foo(x):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collectonly\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 0 items / 1 error\",\n                \"\",\n                \"*= ERRORS =*\",\n                \"*_ ERROR collecting test_parametrize_misspelling.py _*\",\n                \"test_parametrize_misspelling.py:3: in <module>\",\n                '    @pytest.mark.parametrise(\"x\", range(2))',\n                \"E   Failed: Unknown 'parametrise' mark, did you mean 'parametrize'?\",\n                \"*! Interrupted: 1 error during collection !*\",\n                \"*= 1 error in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto_TestMetafuncFunctionalAuto.test_parametrize_all_indirects.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto_TestMetafuncFunctionalAuto.test_parametrize_all_indirects.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1437, "end_line": 1529, "span_ids": ["TestMetafuncFunctionalAuto", "TestMetafuncFunctionalAuto.test_parametrize_all_indirects", "TestMetafuncFunctionalAuto.test_parametrize_auto_scope", "TestMetafuncFunctionalAuto.test_parametrize_auto_scope_indirect", "TestMetafuncFunctionalAuto.test_parametrize_auto_scope_override_fixture"], "tokens": 651}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctionalAuto:\n    \"\"\"\n    Tests related to automatically find out the correct scope for parametrized tests (#1832).\n    \"\"\"\n\n    def test_parametrize_auto_scope(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session', autouse=True)\n            def fixture():\n                return 1\n\n            @pytest.mark.parametrize('animal', [\"dog\", \"cat\"])\n            def test_1(animal):\n                assert animal in ('dog', 'cat')\n\n            @pytest.mark.parametrize('animal', ['fish'])\n            def test_2(animal):\n                assert animal == 'fish'\n\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 3 passed *\"])\n\n    def test_parametrize_auto_scope_indirect(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session')\n            def echo(request):\n                return request.param\n\n            @pytest.mark.parametrize('animal, echo', [(\"dog\", 1), (\"cat\", 2)], indirect=['echo'])\n            def test_1(animal, echo):\n                assert animal in ('dog', 'cat')\n                assert echo in (1, 2, 3)\n\n            @pytest.mark.parametrize('animal, echo', [('fish', 3)], indirect=['echo'])\n            def test_2(animal, echo):\n                assert animal == 'fish'\n                assert echo in (1, 2, 3)\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 3 passed *\"])\n\n    def test_parametrize_auto_scope_override_fixture(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='session', autouse=True)\n            def animal():\n                return 'fox'\n\n            @pytest.mark.parametrize('animal', [\"dog\", \"cat\"])\n            def test_1(animal):\n                assert animal in ('dog', 'cat')\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed *\"])\n\n    def test_parametrize_all_indirects(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture()\n            def animal(request):\n                return request.param\n\n            @pytest.fixture(scope='session')\n            def echo(request):\n                return request.param\n\n            @pytest.mark.parametrize('animal, echo', [(\"dog\", 1), (\"cat\", 2)], indirect=True)\n            def test_1(animal, echo):\n                assert animal in ('dog', 'cat')\n                assert echo in (1, 2, 3)\n\n            @pytest.mark.parametrize('animal, echo', [(\"fish\", 3)], indirect=True)\n            def test_2(animal, echo):\n                assert animal == 'fish'\n                assert echo in (1, 2, 3)\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 3 passed *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto.test_parametrize_some_arguments_auto_scope_TestMetafuncFunctionalAuto.test_parametrize_some_arguments_auto_scope.assert_class_fix_setup_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto.test_parametrize_some_arguments_auto_scope_TestMetafuncFunctionalAuto.test_parametrize_some_arguments_auto_scope.assert_class_fix_setup_", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1531, "end_line": 1564, "span_ids": ["TestMetafuncFunctionalAuto.test_parametrize_some_arguments_auto_scope"], "tokens": 249}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctionalAuto:\n\n    def test_parametrize_some_arguments_auto_scope(\n        self, testdir: Testdir, monkeypatch\n    ) -> None:\n        \"\"\"Integration test for (#3941)\"\"\"\n        class_fix_setup = []  # type: List[object]\n        monkeypatch.setattr(sys, \"class_fix_setup\", class_fix_setup, raising=False)\n        func_fix_setup = []  # type: List[object]\n        monkeypatch.setattr(sys, \"func_fix_setup\", func_fix_setup, raising=False)\n\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            import sys\n\n            @pytest.fixture(scope='class', autouse=True)\n            def class_fix(request):\n                sys.class_fix_setup.append(request.param)\n\n            @pytest.fixture(autouse=True)\n            def func_fix():\n                sys.func_fix_setup.append(True)\n\n            @pytest.mark.parametrize('class_fix', [10, 20], indirect=True)\n            class Test:\n                def test_foo(self):\n                    pass\n                def test_bar(self):\n                    pass\n            \"\"\"\n        )\n        result = testdir.runpytest_inprocess()\n        result.stdout.fnmatch_lines([\"* 4 passed in *\"])\n        assert func_fix_setup == [True] * 4\n        assert class_fix_setup == [10, 20]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto.test_parametrize_issue634_TestMetafuncFunctionalAuto.test_parametrize_issue634.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctionalAuto.test_parametrize_issue634_TestMetafuncFunctionalAuto.test_parametrize_issue634.None_1", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1566, "end_line": 1598, "span_ids": ["TestMetafuncFunctionalAuto.test_parametrize_issue634"], "tokens": 217}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctionalAuto:\n\n    def test_parametrize_issue634(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='module')\n            def foo(request):\n                print('preparing foo-%d' % request.param)\n                return 'foo-%d' % request.param\n\n            def test_one(foo):\n                pass\n\n            def test_two(foo):\n                pass\n\n            test_two.test_with = (2, 3)\n\n            def pytest_generate_tests(metafunc):\n                params = (1, 2, 3, 4)\n                if not 'foo' in metafunc.fixturenames:\n                    return\n\n                test_with = getattr(metafunc.function, 'test_with', None)\n                if test_with:\n                    params = test_with\n                metafunc.parametrize('foo', params, indirect=True)\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        output = result.stdout.str()\n        assert output.count(\"preparing foo-2\") == 1\n        assert output.count(\"preparing foo-3\") == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_should_show_fixtures_used_by_test_test_should_show_fixtures_used_by_test.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_should_show_fixtures_used_by_test_test_should_show_fixtures_used_by_test.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/show_fixtures_per_test.py", "file_name": "show_fixtures_per_test.py", "file_type": "text/x-python", "category": "test", "start_line": 86, "end_line": 120, "span_ids": ["test_should_show_fixtures_used_by_test"], "tokens": 201}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_should_show_fixtures_used_by_test(testdir):\n    testdir.makeconftest(\n        '''\n        import pytest\n        @pytest.fixture\n        def arg1():\n            \"\"\"arg1 from conftest\"\"\"\n        @pytest.fixture\n        def arg2():\n            \"\"\"arg2 from conftest\"\"\"\n    '''\n    )\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture\n        def arg1():\n            \"\"\"arg1 from testmodule\"\"\"\n        def test_args(arg1, arg2):\n            pass\n    '''\n    )\n    result = testdir.runpytest(\"--fixtures-per-test\", p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*fixtures used by test_args*\",\n            \"*(test_should_show_fixtures_used_by_test.py:6)*\",\n            \"arg1\",\n            \"    arg1 from testmodule\",\n            \"arg2\",\n            \"    arg2 from conftest\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_verbose_include_private_fixtures_and_loc_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_verbose_include_private_fixtures_and_loc_", "embedding": null, "metadata": {"file_path": "testing/python/show_fixtures_per_test.py", "file_name": "show_fixtures_per_test.py", "file_type": "text/x-python", "category": "test", "start_line": 123, "end_line": 184, "span_ids": ["test_doctest_items", "test_verbose_include_private_fixtures_and_loc"], "tokens": 374}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_verbose_include_private_fixtures_and_loc(testdir):\n    testdir.makeconftest(\n        '''\n        import pytest\n        @pytest.fixture\n        def _arg1():\n            \"\"\"_arg1 from conftest\"\"\"\n        @pytest.fixture\n        def arg2(_arg1):\n            \"\"\"arg2 from conftest\"\"\"\n    '''\n    )\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture\n        def arg3():\n            \"\"\"arg3 from testmodule\"\"\"\n        def test_args(arg2, arg3):\n            pass\n    '''\n    )\n    result = testdir.runpytest(\"--fixtures-per-test\", \"-v\", p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*fixtures used by test_args*\",\n            \"*(test_verbose_include_private_fixtures_and_loc.py:6)*\",\n            \"_arg1 -- conftest.py:3\",\n            \"    _arg1 from conftest\",\n            \"arg2 -- conftest.py:6\",\n            \"    arg2 from conftest\",\n            \"arg3 -- test_verbose_include_private_fixtures_and_loc.py:3\",\n            \"    arg3 from testmodule\",\n        ]\n    )\n\n\ndef test_doctest_items(testdir):\n    testdir.makepyfile(\n        '''\n        def foo():\n            \"\"\"\n            >>> 1 + 1\n            2\n            \"\"\"\n    '''\n    )\n    testdir.maketxtfile(\n        \"\"\"\n        >>> 1 + 1\n        2\n    \"\"\"\n    )\n    result = testdir.runpytest(\n        \"--fixtures-per-test\", \"--doctest-modules\", \"--doctest-glob=*.txt\", \"-v\"\n    )\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines([\"*collected 2 items*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_FilesCompleter_FilesCompleter.__call__.return_completion": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_FilesCompleter_FilesCompleter.__call__.return_completion", "embedding": null, "metadata": {"file_path": "testing/test_argcomplete.py", "file_name": "test_argcomplete.py", "file_type": "text/x-python", "category": "test", "start_line": 33, "end_line": 73, "span_ids": ["FilesCompleter", "FilesCompleter.__call__", "FilesCompleter.__init__"], "tokens": 317}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FilesCompleter:\n    \"File completer class, optionally takes a list of allowed extensions\"\n\n    def __init__(self, allowednames=(), directories=True):\n        # Fix if someone passes in a string instead of a list\n        if type(allowednames) is str:\n            allowednames = [allowednames]\n\n        self.allowednames = [x.lstrip(\"*\").lstrip(\".\") for x in allowednames]\n        self.directories = directories\n\n    def __call__(self, prefix, **kwargs):\n        completion = []\n        if self.allowednames:\n            if self.directories:\n                files = _wrapcall(\n                    [\"bash\", \"-c\", \"compgen -A directory -- '{p}'\".format(p=prefix)]\n                )\n                completion += [f + \"/\" for f in files]\n            for x in self.allowednames:\n                completion += _wrapcall(\n                    [\n                        \"bash\",\n                        \"-c\",\n                        \"compgen -A file -X '!*.{0}' -- '{p}'\".format(x, p=prefix),\n                    ]\n                )\n        else:\n            completion += _wrapcall(\n                [\"bash\", \"-c\", \"compgen -A file -- '{p}'\".format(p=prefix)]\n            )\n\n            anticomp = _wrapcall(\n                [\"bash\", \"-c\", \"compgen -A directory -- '{p}'\".format(p=prefix)]\n            )\n\n            completion = list(set(completion) - set(anticomp))\n\n            if self.directories:\n                completion += [f + \"/\" for f in anticomp]\n        return completion", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_TestArgComplete_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_TestArgComplete_", "embedding": null, "metadata": {"file_path": "testing/test_argcomplete.py", "file_name": "test_argcomplete.py", "file_type": "text/x-python", "category": "test", "start_line": 76, "end_line": 103, "span_ids": ["TestArgComplete", "TestArgComplete.test_compare_with_compgen", "TestArgComplete.test_remove_dir_prefix"], "tokens": 232}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestArgComplete:\n    @pytest.mark.skipif(\"sys.platform in ('win32', 'darwin')\")\n    def test_compare_with_compgen(self, tmpdir):\n        from _pytest._argcomplete import FastFilesCompleter\n\n        ffc = FastFilesCompleter()\n        fc = FilesCompleter()\n\n        with tmpdir.as_cwd():\n            assert equal_with_bash(\"\", ffc, fc, out=sys.stdout)\n\n            tmpdir.ensure(\"data\")\n\n            for x in [\"d\", \"data\", \"doesnotexist\", \"\"]:\n                assert equal_with_bash(x, ffc, fc, out=sys.stdout)\n\n    @pytest.mark.skipif(\"sys.platform in ('win32', 'darwin')\")\n    def test_remove_dir_prefix(self):\n        \"\"\"this is not compatible with compgen but it is with bash itself:\n        ls /usr/<TAB>\n        \"\"\"\n        from _pytest._argcomplete import FastFilesCompleter\n\n        ffc = FastFilesCompleter()\n        fc = FilesCompleter()\n        for x in \"/usr/\".split():\n            assert not equal_with_bash(x, ffc, fc, out=sys.stdout)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_installed_plugin_rewrite_TestImportHookInstallation.test_installed_plugin_rewrite.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_installed_plugin_rewrite_TestImportHookInstallation.test_installed_plugin_rewrite.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 148, "end_line": 217, "span_ids": ["TestImportHookInstallation.test_installed_plugin_rewrite"], "tokens": 466}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestImportHookInstallation:\n\n    @pytest.mark.parametrize(\"mode\", [\"plain\", \"rewrite\"])\n    def test_installed_plugin_rewrite(self, testdir, mode, monkeypatch):\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        # Make sure the hook is installed early enough so that plugins\n        # installed via setuptools are rewritten.\n        testdir.tmpdir.join(\"hampkg\").ensure(dir=1)\n        contents = {\n            \"hampkg/__init__.py\": \"\"\"\\\n                import pytest\n\n                @pytest.fixture\n                def check_first2():\n                    def check(values, value):\n                        assert values.pop(0) == value\n                    return check\n            \"\"\",\n            \"spamplugin.py\": \"\"\"\\\n            import pytest\n            from hampkg import check_first2\n\n            @pytest.fixture\n            def check_first():\n                def check(values, value):\n                    assert values.pop(0) == value\n                return check\n            \"\"\",\n            \"mainwrapper.py\": \"\"\"\\\n            import pytest\n            from _pytest.compat import importlib_metadata\n\n            class DummyEntryPoint(object):\n                name = 'spam'\n                module_name = 'spam.py'\n                group = 'pytest11'\n\n                def load(self):\n                    import spamplugin\n                    return spamplugin\n\n            class DummyDistInfo(object):\n                version = '1.0'\n                files = ('spamplugin.py', 'hampkg/__init__.py')\n                entry_points = (DummyEntryPoint(),)\n                metadata = {'name': 'foo'}\n\n            def distributions():\n                return (DummyDistInfo(),)\n\n            importlib_metadata.distributions = distributions\n            pytest.main()\n            \"\"\",\n            \"test_foo.py\": \"\"\"\\\n            def test(check_first):\n                check_first([10, 30], 30)\n\n            def test2(check_first2):\n                check_first([10, 30], 30)\n            \"\"\",\n        }\n        testdir.makepyfile(**contents)\n        result = testdir.run(\n            sys.executable, \"mainwrapper.py\", \"-s\", \"--assert=%s\" % mode\n        )\n        if mode == \"plain\":\n            expected = \"E       AssertionError\"\n        elif mode == \"rewrite\":\n            expected = \"*assert 10 == 30*\"\n        else:\n            assert 0\n        result.stdout.fnmatch_lines([expected])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_iterable_full_diff_TestAssert_reprcompare.test_iterable_full_diff.assert_expl_endswith_text": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_iterable_full_diff_TestAssert_reprcompare.test_iterable_full_diff.assert_expl_endswith_text", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 383, "end_line": 433, "span_ids": ["TestAssert_reprcompare.test_iterable_full_diff"], "tokens": 312}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    @pytest.mark.parametrize(\n        [\"left\", \"right\", \"expected\"],\n        [\n            pytest.param(\n                [0, 1],\n                [0, 2],\n                \"\"\"\n                Full diff:\n                - [0, 2]\n                ?     ^\n                + [0, 1]\n                ?     ^\n            \"\"\",\n                id=\"lists\",\n            ),\n            pytest.param(\n                {0: 1},\n                {0: 2},\n                \"\"\"\n                Full diff:\n                - {0: 2}\n                ?     ^\n                + {0: 1}\n                ?     ^\n            \"\"\",\n                id=\"dicts\",\n            ),\n            pytest.param(\n                {0, 1},\n                {0, 2},\n                \"\"\"\n                Full diff:\n                - {0, 2}\n                ?     ^\n                + {0, 1}\n                ?     ^\n            \"\"\",\n                id=\"sets\",\n            ),\n        ],\n    )\n    def test_iterable_full_diff(self, left, right, expected):\n        \"\"\"Test the full diff assertion failure explanation.\n\n        When verbose is False, then just a -v notice to get the diff is rendered,\n        when verbose is True, then ndiff of the pprint is returned.\n        \"\"\"\n        expl = callequal(left, right, verbose=0)\n        assert expl[-1] == \"Use -v to get the full diff\"\n        expl = \"\\n\".join(callequal(left, right, verbose=1))\n        assert expl.endswith(textwrap.dedent(expected).strip())", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_different_items_TestAssert_reprcompare.test_dict_different_items": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_different_items_TestAssert_reprcompare.test_dict_different_items", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 573, "end_line": 595, "span_ids": ["TestAssert_reprcompare.test_dict_different_items"], "tokens": 251}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_dict_different_items(self):\n        lines = callequal({\"a\": 0}, {\"b\": 1, \"c\": 2}, verbose=2)\n        assert lines == [\n            \"{'a': 0} == {'b': 1, 'c': 2}\",\n            \"Left contains 1 more item:\",\n            \"{'a': 0}\",\n            \"Right contains 2 more items:\",\n            \"{'b': 1, 'c': 2}\",\n            \"Full diff:\",\n            \"- {'b': 1, 'c': 2}\",\n            \"+ {'a': 0}\",\n        ]\n        lines = callequal({\"b\": 1, \"c\": 2}, {\"a\": 0}, verbose=2)\n        assert lines == [\n            \"{'b': 1, 'c': 2} == {'a': 0}\",\n            \"Left contains 2 more items:\",\n            \"{'b': 1, 'c': 2}\",\n            \"Right contains 1 more item:\",\n            \"{'a': 0}\",\n            \"Full diff:\",\n            \"- {'a': 0}\",\n            \"+ {'b': 1, 'c': 2}\",\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_dataclass_TestAssert_reprcompare_dataclass.test_comparing_two_different_data_classes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_dataclass_TestAssert_reprcompare_dataclass.test_comparing_two_different_data_classes", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 611, "end_line": 653, "span_ids": ["TestAssert_reprcompare_dataclass", "TestAssert_reprcompare_dataclass.test_comparing_two_different_data_classes", "TestAssert_reprcompare_dataclass.test_dataclasses", "TestAssert_reprcompare_dataclass.test_dataclasses_verbose", "TestAssert_reprcompare_dataclass.test_dataclasses_with_attribute_comparison_off"], "tokens": 434}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare_dataclass:\n    @pytest.mark.skipif(sys.version_info < (3, 7), reason=\"Dataclasses in Python3.7+\")\n    def test_dataclasses(self, testdir):\n        p = testdir.copy_example(\"dataclasses/test_compare_dataclasses.py\")\n        result = testdir.runpytest(p)\n        result.assert_outcomes(failed=1, passed=0)\n        result.stdout.fnmatch_lines(\n            [\n                \"*Omitting 1 identical items, use -vv to show*\",\n                \"*Differing attributes:*\",\n                \"*field_b: 'b' != 'c'*\",\n            ]\n        )\n\n    @pytest.mark.skipif(sys.version_info < (3, 7), reason=\"Dataclasses in Python3.7+\")\n    def test_dataclasses_verbose(self, testdir):\n        p = testdir.copy_example(\"dataclasses/test_compare_dataclasses_verbose.py\")\n        result = testdir.runpytest(p, \"-vv\")\n        result.assert_outcomes(failed=1, passed=0)\n        result.stdout.fnmatch_lines(\n            [\n                \"*Matching attributes:*\",\n                \"*['field_a']*\",\n                \"*Differing attributes:*\",\n                \"*field_b: 'b' != 'c'*\",\n            ]\n        )\n\n    @pytest.mark.skipif(sys.version_info < (3, 7), reason=\"Dataclasses in Python3.7+\")\n    def test_dataclasses_with_attribute_comparison_off(self, testdir):\n        p = testdir.copy_example(\n            \"dataclasses/test_compare_dataclasses_field_comparison_off.py\"\n        )\n        result = testdir.runpytest(p, \"-vv\")\n        result.assert_outcomes(failed=0, passed=1)\n\n    @pytest.mark.skipif(sys.version_info < (3, 7), reason=\"Dataclasses in Python3.7+\")\n    def test_comparing_two_different_data_classes(self, testdir):\n        p = testdir.copy_example(\n            \"dataclasses/test_compare_two_different_dataclasses.py\"\n        )\n        result = testdir.runpytest(p, \"-vv\")\n        result.assert_outcomes(failed=0, passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_attrsclass_TestAssert_reprcompare_attrsclass.test_comparing_two_different_attrs_classes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_attrsclass_TestAssert_reprcompare_attrsclass.test_comparing_two_different_attrs_classes", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 657, "end_line": 718, "span_ids": ["TestAssert_reprcompare_attrsclass", "TestAssert_reprcompare_attrsclass.test_attrs", "TestAssert_reprcompare_attrsclass.test_attrs_verbose", "TestAssert_reprcompare_attrsclass.test_attrs_with_attribute_comparison_off", "TestAssert_reprcompare_attrsclass.test_comparing_two_different_attrs_classes"], "tokens": 454}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare_attrsclass:\n    def test_attrs(self):\n        @attr.s\n        class SimpleDataObject:\n            field_a = attr.ib()\n            field_b = attr.ib()\n\n        left = SimpleDataObject(1, \"b\")\n        right = SimpleDataObject(1, \"c\")\n\n        lines = callequal(left, right)\n        assert lines[1].startswith(\"Omitting 1 identical item\")\n        assert \"Matching attributes\" not in lines\n        for line in lines[1:]:\n            assert \"field_a\" not in line\n\n    def test_attrs_verbose(self):\n        @attr.s\n        class SimpleDataObject:\n            field_a = attr.ib()\n            field_b = attr.ib()\n\n        left = SimpleDataObject(1, \"b\")\n        right = SimpleDataObject(1, \"c\")\n\n        lines = callequal(left, right, verbose=2)\n        assert lines[1].startswith(\"Matching attributes:\")\n        assert \"Omitting\" not in lines[1]\n        assert lines[2] == \"['field_a']\"\n\n    def test_attrs_with_attribute_comparison_off(self):\n        @attr.s\n        class SimpleDataObject:\n            field_a = attr.ib()\n            field_b = attr.ib(**{ATTRS_EQ_FIELD: False})\n\n        left = SimpleDataObject(1, \"b\")\n        right = SimpleDataObject(1, \"b\")\n\n        lines = callequal(left, right, verbose=2)\n        assert lines[1].startswith(\"Matching attributes:\")\n        assert \"Omitting\" not in lines[1]\n        assert lines[2] == \"['field_a']\"\n        for line in lines[2:]:\n            assert \"field_b\" not in line\n\n    def test_comparing_two_different_attrs_classes(self):\n        @attr.s\n        class SimpleDataObjectOne:\n            field_a = attr.ib()\n            field_b = attr.ib()\n\n        @attr.s\n        class SimpleDataObjectTwo:\n            field_a = attr.ib()\n            field_b = attr.ib()\n\n        left = SimpleDataObjectOne(1, \"b\")\n        right = SimpleDataObjectTwo(1, \"c\")\n\n        lines = callequal(left, right)\n        assert lines is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestFormatExplanation_TestFormatExplanation.test_fmt_multi_newline_before_where": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestFormatExplanation_TestFormatExplanation.test_fmt_multi_newline_before_where", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 720, "end_line": 804, "span_ids": ["TestFormatExplanation", "TestFormatExplanation.test_fmt_and", "TestFormatExplanation.test_fmt_multi_newline_before_where", "TestFormatExplanation.test_fmt_newline", "TestFormatExplanation.test_fmt_newline_before_where", "TestFormatExplanation.test_fmt_newline_escaped", "TestFormatExplanation.test_fmt_simple", "TestFormatExplanation.test_fmt_where", "TestFormatExplanation.test_fmt_where_nested", "TestFormatExplanation.test_special_chars_full"], "tokens": 694}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormatExplanation:\n    def test_special_chars_full(self, testdir):\n        # Issue 453, for the bug this would raise IndexError\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                assert '\\\\n}' == ''\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.stdout.fnmatch_lines([\"*AssertionError*\"])\n\n    def test_fmt_simple(self):\n        expl = \"assert foo\"\n        assert util.format_explanation(expl) == \"assert foo\"\n\n    def test_fmt_where(self):\n        expl = \"\\n\".join([\"assert 1\", \"{1 = foo\", \"} == 2\"])\n        res = \"\\n\".join([\"assert 1 == 2\", \" +  where 1 = foo\"])\n        assert util.format_explanation(expl) == res\n\n    def test_fmt_and(self):\n        expl = \"\\n\".join([\"assert 1\", \"{1 = foo\", \"} == 2\", \"{2 = bar\", \"}\"])\n        res = \"\\n\".join([\"assert 1 == 2\", \" +  where 1 = foo\", \" +  and   2 = bar\"])\n        assert util.format_explanation(expl) == res\n\n    def test_fmt_where_nested(self):\n        expl = \"\\n\".join([\"assert 1\", \"{1 = foo\", \"{foo = bar\", \"}\", \"} == 2\"])\n        res = \"\\n\".join([\"assert 1 == 2\", \" +  where 1 = foo\", \" +    where foo = bar\"])\n        assert util.format_explanation(expl) == res\n\n    def test_fmt_newline(self):\n        expl = \"\\n\".join(['assert \"foo\" == \"bar\"', \"~- foo\", \"~+ bar\"])\n        res = \"\\n\".join(['assert \"foo\" == \"bar\"', \"  - foo\", \"  + bar\"])\n        assert util.format_explanation(expl) == res\n\n    def test_fmt_newline_escaped(self):\n        expl = \"\\n\".join([\"assert foo == bar\", \"baz\"])\n        res = \"assert foo == bar\\\\nbaz\"\n        assert util.format_explanation(expl) == res\n\n    def test_fmt_newline_before_where(self):\n        expl = \"\\n\".join(\n            [\n                \"the assertion message here\",\n                \">assert 1\",\n                \"{1 = foo\",\n                \"} == 2\",\n                \"{2 = bar\",\n                \"}\",\n            ]\n        )\n        res = \"\\n\".join(\n            [\n                \"the assertion message here\",\n                \"assert 1 == 2\",\n                \" +  where 1 = foo\",\n                \" +  and   2 = bar\",\n            ]\n        )\n        assert util.format_explanation(expl) == res\n\n    def test_fmt_multi_newline_before_where(self):\n        expl = \"\\n\".join(\n            [\n                \"the assertion\",\n                \"~message here\",\n                \">assert 1\",\n                \"{1 = foo\",\n                \"} == 2\",\n                \"{2 = bar\",\n                \"}\",\n            ]\n        )\n        res = \"\\n\".join(\n            [\n                \"the assertion\",\n                \"  message here\",\n                \"assert 1 == 2\",\n                \" +  where 1 = foo\",\n                \" +  and   2 = bar\",\n            ]\n        )\n        assert util.format_explanation(expl) == res", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestTruncateExplanation_TestTruncateExplanation.test_truncates_at_4_lines_when_first_4_lines_are_GT_max_chars": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestTruncateExplanation_TestTruncateExplanation.test_truncates_at_4_lines_when_first_4_lines_are_GT_max_chars", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 807, "end_line": 860, "span_ids": ["TestTruncateExplanation", "TestTruncateExplanation.test_doesnt_truncate_at_when_input_is_5_lines_and_LT_max_chars", "TestTruncateExplanation.test_doesnt_truncate_when_input_is_empty_list", "TestTruncateExplanation.test_truncates_at_4_lines_when_first_4_lines_are_GT_max_chars", "TestTruncateExplanation.test_truncates_at_8_lines_when_first_8_lines_are_EQ_max_chars", "TestTruncateExplanation.test_truncates_at_8_lines_when_first_8_lines_are_LT_max_chars", "TestTruncateExplanation.test_truncates_at_8_lines_when_given_list_of_empty_strings"], "tokens": 690}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTruncateExplanation:\n    # The number of lines in the truncation explanation message. Used\n    # to calculate that results have the expected length.\n    LINES_IN_TRUNCATION_MSG = 2\n\n    def test_doesnt_truncate_when_input_is_empty_list(self):\n        expl = []\n        result = truncate._truncate_explanation(expl, max_lines=8, max_chars=100)\n        assert result == expl\n\n    def test_doesnt_truncate_at_when_input_is_5_lines_and_LT_max_chars(self):\n        expl = [\"a\" * 100 for x in range(5)]\n        result = truncate._truncate_explanation(expl, max_lines=8, max_chars=8 * 80)\n        assert result == expl\n\n    def test_truncates_at_8_lines_when_given_list_of_empty_strings(self):\n        expl = [\"\" for x in range(50)]\n        result = truncate._truncate_explanation(expl, max_lines=8, max_chars=100)\n        assert result != expl\n        assert len(result) == 8 + self.LINES_IN_TRUNCATION_MSG\n        assert \"Full output truncated\" in result[-1]\n        assert \"43 lines hidden\" in result[-1]\n        last_line_before_trunc_msg = result[-self.LINES_IN_TRUNCATION_MSG - 1]\n        assert last_line_before_trunc_msg.endswith(\"...\")\n\n    def test_truncates_at_8_lines_when_first_8_lines_are_LT_max_chars(self):\n        expl = [\"a\" for x in range(100)]\n        result = truncate._truncate_explanation(expl, max_lines=8, max_chars=8 * 80)\n        assert result != expl\n        assert len(result) == 8 + self.LINES_IN_TRUNCATION_MSG\n        assert \"Full output truncated\" in result[-1]\n        assert \"93 lines hidden\" in result[-1]\n        last_line_before_trunc_msg = result[-self.LINES_IN_TRUNCATION_MSG - 1]\n        assert last_line_before_trunc_msg.endswith(\"...\")\n\n    def test_truncates_at_8_lines_when_first_8_lines_are_EQ_max_chars(self):\n        expl = [\"a\" * 80 for x in range(16)]\n        result = truncate._truncate_explanation(expl, max_lines=8, max_chars=8 * 80)\n        assert result != expl\n        assert len(result) == 8 + self.LINES_IN_TRUNCATION_MSG\n        assert \"Full output truncated\" in result[-1]\n        assert \"9 lines hidden\" in result[-1]\n        last_line_before_trunc_msg = result[-self.LINES_IN_TRUNCATION_MSG - 1]\n        assert last_line_before_trunc_msg.endswith(\"...\")\n\n    def test_truncates_at_4_lines_when_first_4_lines_are_GT_max_chars(self):\n        expl = [\"a\" * 250 for x in range(10)]\n        result = truncate._truncate_explanation(expl, max_lines=8, max_chars=999)\n        assert result != expl\n        assert len(result) == 4 + self.LINES_IN_TRUNCATION_MSG\n        assert \"Full output truncated\" in result[-1]\n        assert \"7 lines hidden\" in result[-1]\n        last_line_before_trunc_msg = result[-self.LINES_IN_TRUNCATION_MSG - 1]\n        assert last_line_before_trunc_msg.endswith(\"...\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestTruncateExplanation.test_truncates_at_1_line_when_first_line_is_GT_max_chars_TestTruncateExplanation.test_full_output_truncated.None_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestTruncateExplanation.test_truncates_at_1_line_when_first_line_is_GT_max_chars_TestTruncateExplanation.test_full_output_truncated.None_5", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 999, "end_line": 1044, "span_ids": ["TestTruncateExplanation.test_full_output_truncated", "TestTruncateExplanation.test_truncates_at_1_line_when_first_line_is_GT_max_chars"], "tokens": 395}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTruncateExplanation:\n    # The number of lines in the truncation explanation message. Used\n\n    def test_truncates_at_1_line_when_first_line_is_GT_max_chars(self):\n        expl = [\"a\" * 250 for x in range(1000)]\n        result = truncate._truncate_explanation(expl, max_lines=8, max_chars=100)\n        assert result != expl\n        assert len(result) == 1 + self.LINES_IN_TRUNCATION_MSG\n        assert \"Full output truncated\" in result[-1]\n        assert \"1000 lines hidden\" in result[-1]\n        last_line_before_trunc_msg = result[-self.LINES_IN_TRUNCATION_MSG - 1]\n        assert last_line_before_trunc_msg.endswith(\"...\")\n\n    def test_full_output_truncated(self, monkeypatch, testdir):\n        \"\"\" Test against full runpytest() output. \"\"\"\n\n        line_count = 7\n        line_len = 100\n        expected_truncated_lines = 2\n        testdir.makepyfile(\n            r\"\"\"\n            def test_many_lines():\n                a = list([str(i)[0] * %d for i in range(%d)])\n                b = a[::2]\n                a = '\\n'.join(map(str, a))\n                b = '\\n'.join(map(str, b))\n                assert a == b\n        \"\"\"\n            % (line_len, line_count)\n        )\n        monkeypatch.delenv(\"CI\", raising=False)\n\n        result = testdir.runpytest()\n        # without -vv, truncate the message showing a few diff lines only\n        result.stdout.fnmatch_lines(\n            [\n                \"*+ 1*\",\n                \"*+ 3*\",\n                \"*+ 5*\",\n                \"*truncated (%d lines hidden)*use*-vv*\" % expected_truncated_lines,\n            ]\n        )\n\n        result = testdir.runpytest(\"-vv\")\n        result.stdout.fnmatch_lines([\"* 6*\"])\n\n        monkeypatch.setenv(\"CI\", \"1\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 6*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_python25_compile_issue257_test_sequence_comparison_uses_repr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_python25_compile_issue257_test_sequence_comparison_uses_repr", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 1047, "end_line": 1135, "span_ids": ["test_pytest_assertrepr_compare_integration", "test_python25_compile_issue257", "test_reprcompare_notin", "test_reprcompare_whitespaces", "test_rewritten", "test_sequence_comparison_uses_repr"], "tokens": 505}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_python25_compile_issue257(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_rewritten():\n            assert 1 == 2\n        # some comment\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        \"\"\"\n            *E*assert 1 == 2*\n            *1 failed*\n    \"\"\"\n    )\n\n\ndef test_rewritten(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_rewritten():\n            assert \"@py_builtins\" in globals()\n    \"\"\"\n    )\n    assert testdir.runpytest().ret == 0\n\n\ndef test_reprcompare_notin() -> None:\n    assert callop(\"not in\", \"foo\", \"aaafoobbb\") == [\n        \"'foo' not in 'aaafoobbb'\",\n        \"'foo' is contained here:\",\n        \"  aaafoobbb\",\n        \"?    +++\",\n    ]\n\n\ndef test_reprcompare_whitespaces():\n    assert callequal(\"\\r\\n\", \"\\n\") == [\n        r\"'\\r\\n' == '\\n'\",\n        r\"Strings contain only whitespace, escaping them using repr()\",\n        r\"- '\\n'\",\n        r\"+ '\\r\\n'\",\n        r\"?  ++\",\n    ]\n\n\ndef test_pytest_assertrepr_compare_integration(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_hello():\n            x = set(range(100))\n            y = x.copy()\n            y.remove(50)\n            assert x == y\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*def test_hello():*\",\n            \"*assert x == y*\",\n            \"*E*Extra items*left*\",\n            \"*E*50*\",\n            \"*= 1 failed in*\",\n        ]\n    )\n\n\ndef test_sequence_comparison_uses_repr(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_hello():\n            x = set(\"hello x\")\n            y = set(\"hello y\")\n            assert x == y\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*def test_hello():*\",\n            \"*assert x == y*\",\n            \"*E*Extra items*left*\",\n            \"*E*'x'*\",\n            \"*E*Extra items*right*\",\n            \"*E*'y'*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_assertrepr_loaded_per_dir_test_triple_quoted_string_issue113": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_assertrepr_loaded_per_dir_test_triple_quoted_string_issue113", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 1138, "end_line": 1186, "span_ids": ["test_assertion_options", "test_assertrepr_loaded_per_dir", "test_triple_quoted_string_issue113"], "tokens": 402}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_assertrepr_loaded_per_dir(testdir):\n    testdir.makepyfile(test_base=[\"def test_base(): assert 1 == 2\"])\n    a = testdir.mkdir(\"a\")\n    a_test = a.join(\"test_a.py\")\n    a_test.write(\"def test_a(): assert 1 == 2\")\n    a_conftest = a.join(\"conftest.py\")\n    a_conftest.write('def pytest_assertrepr_compare(): return [\"summary a\"]')\n    b = testdir.mkdir(\"b\")\n    b_test = b.join(\"test_b.py\")\n    b_test.write(\"def test_b(): assert 1 == 2\")\n    b_conftest = b.join(\"conftest.py\")\n    b_conftest.write('def pytest_assertrepr_compare(): return [\"summary b\"]')\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*def test_base():*\",\n            \"*E*assert 1 == 2*\",\n            \"*def test_a():*\",\n            \"*E*assert summary a*\",\n            \"*def test_b():*\",\n            \"*E*assert summary b*\",\n        ]\n    )\n\n\ndef test_assertion_options(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_hello():\n            x = 3\n            assert x == 4\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert \"3 == 4\" in result.stdout.str()\n    result = testdir.runpytest_subprocess(\"--assert=plain\")\n    result.stdout.no_fnmatch_line(\"*3 == 4*\")\n\n\ndef test_triple_quoted_string_issue113(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_hello():\n            assert \"\" == '''\n    '''\"\"\"\n    )\n    result = testdir.runpytest(\"--fulltrace\")\n    result.stdout.fnmatch_lines([\"*1 failed*\"])\n    result.stdout.no_fnmatch_line(\"*SyntaxError*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_traceback_failure_test_traceback_failure.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_traceback_failure_test_traceback_failure.None_1", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 1061, "end_line": 1113, "span_ids": ["test_traceback_failure"], "tokens": 336}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_traceback_failure(testdir):\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def g():\n            return 2\n        def f(x):\n            assert x == g()\n        def test_onefails():\n            f(3)\n    \"\"\"\n    )\n    result = testdir.runpytest(p1, \"--tb=long\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*test_traceback_failure.py F*\",\n            \"====* FAILURES *====\",\n            \"____*____\",\n            \"\",\n            \"    def test_onefails():\",\n            \">       f(3)\",\n            \"\",\n            \"*test_*.py:6: \",\n            \"_ _ _ *\",\n            # \"\",\n            \"    def f(x):\",\n            \">       assert x == g()\",\n            \"E       assert 3 == 2\",\n            \"E        +  where 2 = g()\",\n            \"\",\n            \"*test_traceback_failure.py:4: AssertionError\",\n        ]\n    )\n\n    result = testdir.runpytest(p1)  # \"auto\"\n    result.stdout.fnmatch_lines(\n        [\n            \"*test_traceback_failure.py F*\",\n            \"====* FAILURES *====\",\n            \"____*____\",\n            \"\",\n            \"    def test_onefails():\",\n            \">       f(3)\",\n            \"\",\n            \"*test_*.py:6: \",\n            \"\",\n            \"    def f(x):\",\n            \">       assert x == g()\",\n            \"E       assert 3 == 2\",\n            \"E        +  where 2 = g()\",\n            \"\",\n            \"*test_traceback_failure.py:4: AssertionError\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite_TestAssertionRewrite.test_place_initial_imports.None_9": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite_TestAssertionRewrite.test_place_initial_imports.None_9", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 65, "end_line": 106, "span_ids": ["TestAssertionRewrite", "TestAssertionRewrite.test_place_initial_imports"], "tokens": 388}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n    def test_place_initial_imports(self):\n        s = \"\"\"'Doc string'\\nother = stuff\"\"\"\n        m = rewrite(s)\n        assert isinstance(m.body[0], ast.Expr)\n        for imp in m.body[1:3]:\n            assert isinstance(imp, ast.Import)\n            assert imp.lineno == 2\n            assert imp.col_offset == 0\n        assert isinstance(m.body[3], ast.Assign)\n        s = \"\"\"from __future__ import division\\nother_stuff\"\"\"\n        m = rewrite(s)\n        assert isinstance(m.body[0], ast.ImportFrom)\n        for imp in m.body[1:3]:\n            assert isinstance(imp, ast.Import)\n            assert imp.lineno == 2\n            assert imp.col_offset == 0\n        assert isinstance(m.body[3], ast.Expr)\n        s = \"\"\"'doc string'\\nfrom __future__ import division\"\"\"\n        m = rewrite(s)\n        assert isinstance(m.body[0], ast.Expr)\n        assert isinstance(m.body[1], ast.ImportFrom)\n        for imp in m.body[2:4]:\n            assert isinstance(imp, ast.Import)\n            assert imp.lineno == 2\n            assert imp.col_offset == 0\n        s = \"\"\"'doc string'\\nfrom __future__ import division\\nother\"\"\"\n        m = rewrite(s)\n        assert isinstance(m.body[0], ast.Expr)\n        assert isinstance(m.body[1], ast.ImportFrom)\n        for imp in m.body[2:4]:\n            assert isinstance(imp, ast.Import)\n            assert imp.lineno == 3\n            assert imp.col_offset == 0\n        assert isinstance(m.body[4], ast.Expr)\n        s = \"\"\"from . import relative\\nother_stuff\"\"\"\n        m = rewrite(s)\n        for imp in m.body[:2]:\n            assert isinstance(imp, ast.Import)\n            assert imp.lineno == 1\n            assert imp.col_offset == 0\n        assert isinstance(m.body[3], ast.Expr)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_short_circuit_evaluation_TestAssertionRewrite.test_starred_with_side_effect": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_short_circuit_evaluation_TestAssertionRewrite.test_starred_with_side_effect", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 394, "end_line": 479, "span_ids": ["TestAssertionRewrite.test_at_operator_issue1290", "TestAssertionRewrite.test_binary_op", "TestAssertionRewrite.test_boolop_percent", "TestAssertionRewrite.test_short_circuit_evaluation", "TestAssertionRewrite.test_starred_with_side_effect", "TestAssertionRewrite.test_unary_op"], "tokens": 519}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_short_circuit_evaluation(self):\n        def f():\n            assert True or explode  # noqa\n\n        getmsg(f, must_pass=True)\n\n        def f():\n            x = 1\n            assert x == 1 or x == 2\n\n        getmsg(f, must_pass=True)\n\n    def test_unary_op(self):\n        def f():\n            x = True\n            assert not x\n\n        assert getmsg(f) == \"assert not True\"\n\n        def f():\n            x = 0\n            assert ~x + 1\n\n        assert getmsg(f) == \"assert (~0 + 1)\"\n\n        def f():\n            x = 3\n            assert -x + x\n\n        assert getmsg(f) == \"assert (-3 + 3)\"\n\n        def f():\n            x = 0\n            assert +x + x\n\n        assert getmsg(f) == \"assert (+0 + 0)\"\n\n    def test_binary_op(self):\n        def f():\n            x = 1\n            y = -1\n            assert x + y\n\n        assert getmsg(f) == \"assert (1 + -1)\"\n\n        def f():\n            assert not 5 % 4\n\n        assert getmsg(f) == \"assert not (5 % 4)\"\n\n    def test_boolop_percent(self):\n        def f():\n            assert 3 % 2 and False\n\n        assert getmsg(f) == \"assert ((3 % 2) and False)\"\n\n        def f():\n            assert False or 4 % 2\n\n        assert getmsg(f) == \"assert (False or (4 % 2))\"\n\n    def test_at_operator_issue1290(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class Matrix(object):\n                def __init__(self, num):\n                    self.num = num\n                def __matmul__(self, other):\n                    return self.num * other.num\n\n            def test_multmat_operator():\n                assert Matrix(2) @ Matrix(3) == 6\"\"\"\n        )\n        testdir.runpytest().assert_outcomes(passed=1)\n\n    def test_starred_with_side_effect(self, testdir):\n        \"\"\"See #4412\"\"\"\n        testdir.makepyfile(\n            \"\"\"\\\n            def test():\n                f = lambda x: x\n                x = iter([1, 2, 3])\n                assert 2 * next(x) == f(*[next(x)])\n            \"\"\"\n        )\n        testdir.runpytest().assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_call_TestAssertionRewrite.test_call.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_call_TestAssertionRewrite.test_call.None_6", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 481, "end_line": 550, "span_ids": ["TestAssertionRewrite.test_call"], "tokens": 336}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_call(self):\n        def g(a=42, *args, **kwargs):\n            return False\n\n        ns = {\"g\": g}\n\n        def f():\n            assert g()\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = g()\"\"\"\n        )\n\n        def f():\n            assert g(1)\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = g(1)\"\"\"\n        )\n\n        def f():\n            assert g(1, 2)\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = g(1, 2)\"\"\"\n        )\n\n        def f():\n            assert g(1, g=42)\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = g(1, g=42)\"\"\"\n        )\n\n        def f():\n            assert g(1, 3, g=23)\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = g(1, 3, g=23)\"\"\"\n        )\n\n        def f():\n            seq = [1, 2, 3]\n            assert g(*seq)\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = g(*[1, 2, 3])\"\"\"\n        )\n\n        def f():\n            x = \"a\"\n            assert g(**{x: 2})\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = g(**{'a': 2})\"\"\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_attribute_TestAssertionRewrite.test_formatchar": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_attribute_TestAssertionRewrite.test_formatchar", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 554, "end_line": 666, "span_ids": ["TestAssertionRewrite.test_assert_raising__bool__in_comparison", "TestAssertionRewrite.test_attribute", "TestAssertionRewrite.test_comparisons", "TestAssertionRewrite.test_custom_reprcompare", "TestAssertionRewrite.test_formatchar", "TestAssertionRewrite.test_len"], "tokens": 666}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_attribute(self):\n        class X:\n            g = 3\n\n        ns = {\"x\": X}\n\n        def f():\n            assert not x.g  # noqa\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert not 3\n +  where 3 = x.g\"\"\"\n        )\n\n        def f():\n            x.a = False  # noqa\n            assert x.a  # noqa\n\n        assert (\n            getmsg(f, ns)\n            == \"\"\"assert False\n +  where False = x.a\"\"\"\n        )\n\n    def test_comparisons(self):\n        def f():\n            a, b = range(2)\n            assert b < a\n\n        assert getmsg(f) == \"\"\"assert 1 < 0\"\"\"\n\n        def f():\n            a, b, c = range(3)\n            assert a > b > c\n\n        assert getmsg(f) == \"\"\"assert 0 > 1\"\"\"\n\n        def f():\n            a, b, c = range(3)\n            assert a < b > c\n\n        assert getmsg(f) == \"\"\"assert 1 > 2\"\"\"\n\n        def f():\n            a, b, c = range(3)\n            assert a < b <= c\n\n        getmsg(f, must_pass=True)\n\n        def f():\n            a, b, c = range(3)\n            assert a < b\n            assert b < c\n\n        getmsg(f, must_pass=True)\n\n    def test_len(self, request):\n        def f():\n            values = list(range(10))\n            assert len(values) == 11\n\n        msg = getmsg(f)\n        if request.config.getoption(\"verbose\") > 0:\n            assert msg == \"assert 10 == 11\\n  +10\\n  -11\"\n        else:\n            assert msg == \"assert 10 == 11\\n +  where 10 = len([0, 1, 2, 3, 4, 5, ...])\"\n\n    def test_custom_reprcompare(self, monkeypatch):\n        def my_reprcompare(op, left, right):\n            return \"42\"\n\n        monkeypatch.setattr(util, \"_reprcompare\", my_reprcompare)\n\n        def f():\n            assert 42 < 3\n\n        assert getmsg(f) == \"assert 42\"\n\n        def my_reprcompare(op, left, right):\n            return \"{} {} {}\".format(left, op, right)\n\n        monkeypatch.setattr(util, \"_reprcompare\", my_reprcompare)\n\n        def f():\n            assert 1 < 3 < 5 <= 4 < 7\n\n        assert getmsg(f) == \"assert 5 <= 4\"\n\n    def test_assert_raising__bool__in_comparison(self):\n        def f():\n            class A:\n                def __bool__(self):\n                    raise ValueError(42)\n\n                def __lt__(self, other):\n                    return A()\n\n                def __repr__(self):\n                    return \"<MY42 object>\"\n\n            def myany(x):\n                return False\n\n            assert myany(A() < 0)\n\n        assert \"<MY42 object> < 0\" in getmsg(f)\n\n    def test_formatchar(self):\n        def f():\n            assert \"%test\" == \"test\"\n\n        assert getmsg(f).startswith(\"assert '%test' == 'test'\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_custom_repr_TestAssertionRewrite.test_custom_repr_non_ascii": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_custom_repr_TestAssertionRewrite.test_custom_repr_non_ascii", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 668, "end_line": 698, "span_ids": ["TestAssertionRewrite.test_custom_repr", "TestAssertionRewrite.test_custom_repr_non_ascii"], "tokens": 216}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_custom_repr(self, request):\n        def f():\n            class Foo:\n                a = 1\n\n                def __repr__(self):\n                    return \"\\n{ \\n~ \\n}\"\n\n            f = Foo()\n            assert 0 == f.a\n\n        lines = util._format_lines([getmsg(f)])\n        if request.config.getoption(\"verbose\") > 0:\n            assert lines == [\"assert 0 == 1\\n  +0\\n  -1\"]\n        else:\n            assert lines == [\"assert 0 == 1\\n +  where 1 = \\\\n{ \\\\n~ \\\\n}.a\"]\n\n    def test_custom_repr_non_ascii(self):\n        def f():\n            class A:\n                name = \"\u00e4\"\n\n                def __repr__(self):\n                    return self.name.encode(\"UTF-8\")  # only legal in python2\n\n            a = A()\n            assert not a.name\n\n        msg = getmsg(f)\n        assert \"UnicodeDecodeError\" not in msg\n        assert \"UnicodeEncodeError\" not in msg", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_issue731_TestIssue925.test_many_brackets": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_issue731_TestIssue925.test_many_brackets", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1121, "end_line": 1169, "span_ids": ["TestIssue925", "TestIssue925.test_long_case", "TestIssue925.test_many_brackets", "TestIssue925.test_simple_case", "test_issue731"], "tokens": 336}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_issue731(testdir):\n    testdir.makepyfile(\n        \"\"\"\n    class LongReprWithBraces(object):\n        def __repr__(self):\n           return 'LongReprWithBraces({' + ('a' * 80) + '}' + ('a' * 120) + ')'\n\n        def some_method(self):\n            return False\n\n    def test_long_repr():\n        obj = LongReprWithBraces()\n        assert obj.some_method()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.no_fnmatch_line(\"*unbalanced braces*\")\n\n\nclass TestIssue925:\n    def test_simple_case(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n        def test_ternary_display():\n            assert (False == False) == False\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*E*assert (False == False) == False\"])\n\n    def test_long_case(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n        def test_ternary_display():\n             assert False == (False == True) == True\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*E*assert (False == True) == True\"])\n\n    def test_many_brackets(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_ternary_display():\n                 assert True == ((False == True) == True)\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*E*assert True == ((False == True) == True)\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestIssue2121_test_source_mtime_long_long": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestIssue2121_test_source_mtime_long_long", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1215, "end_line": 1258, "span_ids": ["TestIssue2121", "TestIssue2121.test_rewrite_python_files_contain_subdirs", "test_source_mtime_long_long"], "tokens": 311}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestIssue2121:\n    def test_rewrite_python_files_contain_subdirs(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"tests/file.py\": \"\"\"\n                def test_simple_failure():\n                    assert 1 + 1 == 3\n                \"\"\"\n            }\n        )\n        testdir.makeini(\n            \"\"\"\n                [pytest]\n                python_files = tests/**.py\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*E*assert (1 + 1) == 3\"])\n\n\n@pytest.mark.skipif(\n    sys.maxsize <= (2 ** 31 - 1), reason=\"Causes OverflowError on 32bit systems\"\n)\n@pytest.mark.parametrize(\"offset\", [-1, +1])\ndef test_source_mtime_long_long(testdir, offset):\n    \"\"\"Support modification dates after 2038 in rewritten files (#4903).\n\n    pytest would crash with:\n\n            fp.write(struct.pack(\"<ll\", mtime, size))\n        E   struct.error: argument out of range\n    \"\"\"\n    p = testdir.makepyfile(\n        \"\"\"\n        def test(): pass\n    \"\"\"\n    )\n    # use unsigned long timestamp which overflows signed long,\n    # which was the cause of the bug\n    # +1 offset also tests masking of 0xFFFFFFFF\n    timestamp = 2 ** 32 + offset\n    os.utime(str(p), (timestamp, timestamp))\n    result = testdir.runpytest()\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_rewrite_infinite_recursion_test_rewrite_infinite_recursion.assert_len_write_pyc_call": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_rewrite_infinite_recursion_test_rewrite_infinite_recursion.assert_len_write_pyc_call", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1208, "end_line": 1237, "span_ids": ["test_rewrite_infinite_recursion"], "tokens": 293}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_rewrite_infinite_recursion(testdir, pytestconfig, monkeypatch):\n    \"\"\"Fix infinite recursion when writing pyc files: if an import happens to be triggered when writing the pyc\n    file, this would cause another call to the hook, which would trigger another pyc writing, which could\n    trigger another import, and so on. (#3506)\"\"\"\n    from _pytest.assertion import rewrite\n\n    testdir.syspathinsert()\n    testdir.makepyfile(test_foo=\"def test_foo(): pass\")\n    testdir.makepyfile(test_bar=\"def test_bar(): pass\")\n\n    original_write_pyc = rewrite._write_pyc\n\n    write_pyc_called = []\n\n    def spy_write_pyc(*args, **kwargs):\n        # make a note that we have called _write_pyc\n        write_pyc_called.append(True)\n        # try to import a module at this point: we should not try to rewrite this module\n        assert hook.find_spec(\"test_bar\") is None\n        return original_write_pyc(*args, **kwargs)\n\n    monkeypatch.setattr(rewrite, \"_write_pyc\", spy_write_pyc)\n    monkeypatch.setattr(sys, \"dont_write_bytecode\", False)\n\n    hook = AssertionRewritingHook(pytestconfig)\n    spec = hook.find_spec(\"test_foo\")\n    assert spec is not None\n    module = importlib.util.module_from_spec(spec)\n    hook.exec_module(module)\n    assert len(write_pyc_called) == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestEarlyRewriteBailout_TestEarlyRewriteBailout.test_basic.None_7": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestEarlyRewriteBailout_TestEarlyRewriteBailout.test_basic.None_7", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1240, "end_line": 1300, "span_ids": ["TestEarlyRewriteBailout", "TestEarlyRewriteBailout.hook", "TestEarlyRewriteBailout.test_basic"], "tokens": 479}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestEarlyRewriteBailout:\n    @pytest.fixture\n    def hook(self, pytestconfig, monkeypatch, testdir):\n        \"\"\"Returns a patched AssertionRewritingHook instance so we can configure its initial paths and track\n        if PathFinder.find_spec has been called.\n        \"\"\"\n        import importlib.machinery\n\n        self.find_spec_calls = []\n        self.initial_paths = set()\n\n        class StubSession:\n            _initialpaths = self.initial_paths\n\n            def isinitpath(self, p):\n                return p in self._initialpaths\n\n        def spy_find_spec(name, path):\n            self.find_spec_calls.append(name)\n            return importlib.machinery.PathFinder.find_spec(name, path)\n\n        hook = AssertionRewritingHook(pytestconfig)\n        # use default patterns, otherwise we inherit pytest's testing config\n        hook.fnpats[:] = [\"test_*.py\", \"*_test.py\"]\n        monkeypatch.setattr(hook, \"_find_spec\", spy_find_spec)\n        hook.set_session(StubSession())\n        testdir.syspathinsert()\n        return hook\n\n    def test_basic(self, testdir, hook):\n        \"\"\"\n        Ensure we avoid calling PathFinder.find_spec when we know for sure a certain\n        module will not be rewritten to optimize assertion rewriting (#3918).\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def fix(): return 1\n        \"\"\"\n        )\n        testdir.makepyfile(test_foo=\"def test_foo(): pass\")\n        testdir.makepyfile(bar=\"def bar(): pass\")\n        foobar_path = testdir.makepyfile(foobar=\"def foobar(): pass\")\n        self.initial_paths.add(foobar_path)\n\n        # conftest files should always be rewritten\n        assert hook.find_spec(\"conftest\") is not None\n        assert self.find_spec_calls == [\"conftest\"]\n\n        # files matching \"python_files\" mask should always be rewritten\n        assert hook.find_spec(\"test_foo\") is not None\n        assert self.find_spec_calls == [\"conftest\", \"test_foo\"]\n\n        # file does not match \"python_files\": early bailout\n        assert hook.find_spec(\"bar\") is None\n        assert self.find_spec_calls == [\"conftest\", \"test_foo\"]\n\n        # file is an initial path (passed on the command-line): should be rewritten\n        assert hook.find_spec(\"foobar\") is not None\n        assert self.find_spec_calls == [\"conftest\", \"test_foo\", \"foobar\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_test_cache_reportheader_test_cache_reportheader_external_abspath": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_test_cache_reportheader_test_cache_reportheader_external_abspath", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 163, "end_line": 193, "span_ids": ["test_cache_reportheader", "test_cache_reportheader_external_abspath"], "tokens": 254}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"env\", ((), (\"TOX_ENV_DIR\", \"/tox_env_dir\")))\ndef test_cache_reportheader(env, testdir, monkeypatch):\n    testdir.makepyfile(\"\"\"def test_foo(): pass\"\"\")\n    if env:\n        monkeypatch.setenv(*env)\n        expected = os.path.join(env[1], \".pytest_cache\")\n    else:\n        monkeypatch.delenv(\"TOX_ENV_DIR\", raising=False)\n        expected = \".pytest_cache\"\n    result = testdir.runpytest(\"-v\")\n    result.stdout.fnmatch_lines([\"cachedir: %s\" % expected])\n\n\ndef test_cache_reportheader_external_abspath(testdir, tmpdir_factory):\n    external_cache = tmpdir_factory.mktemp(\n        \"test_cache_reportheader_external_abspath_abs\"\n    )\n\n    testdir.makepyfile(\"def test_hello(): pass\")\n    testdir.makeini(\n        \"\"\"\n    [pytest]\n    cache_dir = {abscache}\n    \"\"\".format(\n            abscache=external_cache\n        )\n    )\n    result = testdir.runpytest(\"-v\")\n    result.stdout.fnmatch_lines(\n        [\"cachedir: {abscache}\".format(abscache=external_cache)]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_test_cache_show_test_cache_show.None_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_test_cache_show_test_cache_show.None_5", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 191, "end_line": 240, "span_ids": ["test_cache_show"], "tokens": 373}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_cache_show(testdir):\n    result = testdir.runpytest(\"--cache-show\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*cache is empty*\"])\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_configure(config):\n            config.cache.set(\"my/name\", [1,2,3])\n            config.cache.set(\"my/hello\", \"world\")\n            config.cache.set(\"other/some\", {1:2})\n            dp = config.cache.makedir(\"mydb\")\n            dp.ensure(\"hello\")\n            dp.ensure(\"world\")\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 5  # no tests executed\n\n    result = testdir.runpytest(\"--cache-show\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*cachedir:*\",\n            \"*- cache values for '[*]' -*\",\n            \"cache/nodeids contains:\",\n            \"my/name contains:\",\n            \"  [1, 2, 3]\",\n            \"other/some contains:\",\n            \"  {*'1': 2}\",\n            \"*- cache directories for '[*]' -*\",\n            \"*mydb/hello*length 0*\",\n            \"*mydb/world*length 0*\",\n        ]\n    )\n    assert result.ret == 0\n\n    result = testdir.runpytest(\"--cache-show\", \"*/hello\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*cachedir:*\",\n            \"*- cache values for '[*]/hello' -*\",\n            \"my/hello contains:\",\n            \"  *'world'\",\n            \"*- cache directories for '[*]/hello' -*\",\n            \"d/mydb/hello*length 0*\",\n        ]\n    )\n    stdout = result.stdout.str()\n    assert \"other/some\" not in stdout\n    assert \"d/mydb/world\" not in stdout\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed_TestLastFailed.test_lastfailed_usecase.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed_TestLastFailed.test_lastfailed_usecase.None_6", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 248, "end_line": 293, "span_ids": ["TestLastFailed", "TestLastFailed.test_lastfailed_usecase"], "tokens": 383}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n    def test_lastfailed_usecase(self, testdir, monkeypatch):\n        monkeypatch.setattr(\"sys.dont_write_bytecode\", True)\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_1(): assert 0\n            def test_2(): assert 0\n            def test_3(): assert 1\n            \"\"\"\n        )\n        result = testdir.runpytest(str(p))\n        result.stdout.fnmatch_lines([\"*2 failed*\"])\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_1(): assert 1\n            def test_2(): assert 1\n            def test_3(): assert 0\n            \"\"\"\n        )\n        result = testdir.runpytest(str(p), \"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: rerun previous 2 failures\",\n                \"*= 2 passed in *\",\n            ]\n        )\n        result = testdir.runpytest(str(p), \"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 3 items\",\n                \"run-last-failure: no previously failed tests, not deselecting items.\",\n                \"*1 failed*2 passed*\",\n            ]\n        )\n        testdir.tmpdir.join(\".pytest_cache\").mkdir(\".git\")\n        result = testdir.runpytest(str(p), \"--lf\", \"--cache-clear\")\n        result.stdout.fnmatch_lines([\"*1 failed*2 passed*\"])\n        assert testdir.tmpdir.join(\".pytest_cache\", \"README.md\").isfile()\n        assert testdir.tmpdir.join(\".pytest_cache\", \".git\").isdir()\n\n        # Run this again to make sure clear-cache is robust\n        if os.path.isdir(\".pytest_cache\"):\n            shutil.rmtree(\".pytest_cache\")\n        result = testdir.runpytest(\"--lf\", \"--cache-clear\")\n        result.stdout.fnmatch_lines([\"*1 failed*2 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_failedfirst_order_TestLastFailed.test_lastfailed_failedfirst_order": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_failedfirst_order_TestLastFailed.test_lastfailed_failedfirst_order", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 295, "end_line": 325, "span_ids": ["TestLastFailed.test_failedfirst_order", "TestLastFailed.test_lastfailed_failedfirst_order"], "tokens": 288}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_failedfirst_order(self, testdir):\n        testdir.makepyfile(\n            test_a=\"def test_always_passes(): pass\",\n            test_b=\"def test_always_fails(): assert 0\",\n        )\n        result = testdir.runpytest()\n        # Test order will be collection order; alphabetical\n        result.stdout.fnmatch_lines([\"test_a.py*\", \"test_b.py*\"])\n        result = testdir.runpytest(\"--ff\")\n        # Test order will be failing tests first\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: rerun previous 1 failure first\",\n                \"test_b.py*\",\n                \"test_a.py*\",\n            ]\n        )\n\n    def test_lastfailed_failedfirst_order(self, testdir):\n        testdir.makepyfile(\n            test_a=\"def test_always_passes(): assert 1\",\n            test_b=\"def test_always_fails(): assert 0\",\n        )\n        result = testdir.runpytest()\n        # Test order will be collection order; alphabetical\n        result.stdout.fnmatch_lines([\"test_a.py*\", \"test_b.py*\"])\n        result = testdir.runpytest(\"--lf\", \"--ff\")\n        # Test order will be failing tests first\n        result.stdout.fnmatch_lines([\"test_b.py*\"])\n        result.stdout.no_fnmatch_line(\"*test_a.py*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_usecase_splice_TestLastFailed.test_non_serializable_parametrize": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_usecase_splice_TestLastFailed.test_non_serializable_parametrize", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 350, "end_line": 392, "span_ids": ["TestLastFailed.test_lastfailed_usecase_splice", "TestLastFailed.test_lastfailed_xpass", "TestLastFailed.test_non_serializable_parametrize"], "tokens": 328}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_lastfailed_usecase_splice(self, testdir, monkeypatch):\n        monkeypatch.setattr(\"sys.dont_write_bytecode\", True)\n        testdir.makepyfile(\n            \"def test_1(): assert 0\", test_something=\"def test_2(): assert 0\"\n        )\n        p2 = testdir.tmpdir.join(\"test_something.py\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*2 failed*\"])\n        result = testdir.runpytest(\"--lf\", p2)\n        result.stdout.fnmatch_lines([\"*1 failed*\"])\n        result = testdir.runpytest(\"--lf\")\n        result.stdout.fnmatch_lines([\"*2 failed*\"])\n\n    def test_lastfailed_xpass(self, testdir):\n        testdir.inline_runsource(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test_hello():\n                assert 1\n        \"\"\"\n        )\n        config = testdir.parseconfigure()\n        lastfailed = config.cache.get(\"cache/lastfailed\", -1)\n        assert lastfailed == -1\n\n    def test_non_serializable_parametrize(self, testdir):\n        \"\"\"Test that failed parametrized tests with unmarshable parameters\n        don't break pytest-cache.\n        \"\"\"\n        testdir.makepyfile(\n            r\"\"\"\n            import pytest\n\n            @pytest.mark.parametrize('val', [\n                b'\\xac\\x10\\x02G',\n            ])\n            def test_fail(val):\n                assert False\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 failed in*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_terminal_report_lastfailed_TestLastFailed.test_terminal_report_lastfailed.None_4": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_terminal_report_lastfailed_TestLastFailed.test_terminal_report_lastfailed.None_4", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 421, "end_line": 475, "span_ids": ["TestLastFailed.test_terminal_report_lastfailed"], "tokens": 339}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_terminal_report_lastfailed(self, testdir):\n        test_a = testdir.makepyfile(\n            test_a=\"\"\"\n            def test_a1():\n                pass\n            def test_a2():\n                pass\n        \"\"\"\n        )\n        test_b = testdir.makepyfile(\n            test_b=\"\"\"\n            def test_b1():\n                assert 0\n            def test_b2():\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"collected 4 items\", \"*2 failed, 2 passed in*\"])\n\n        result = testdir.runpytest(\"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: rerun previous 2 failures (skipped 1 file)\",\n                \"*2 failed in*\",\n            ]\n        )\n\n        result = testdir.runpytest(test_a, \"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: 2 known failures not in selected tests\",\n                \"*2 passed in*\",\n            ]\n        )\n\n        result = testdir.runpytest(test_b, \"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: rerun previous 2 failures\",\n                \"*2 failed in*\",\n            ]\n        )\n\n        result = testdir.runpytest(\"test_b.py::test_b1\", \"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 1 item\",\n                \"run-last-failure: rerun previous 1 failure\",\n                \"*1 failed in*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_terminal_report_failedfirst_TestLastFailed.test_lastfailed_collectfailure.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_terminal_report_failedfirst_TestLastFailed.test_lastfailed_collectfailure.None_2", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 477, "end_line": 527, "span_ids": ["TestLastFailed.test_lastfailed_collectfailure", "TestLastFailed.test_terminal_report_failedfirst"], "tokens": 363}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_terminal_report_failedfirst(self, testdir):\n        testdir.makepyfile(\n            test_a=\"\"\"\n            def test_a1():\n                assert 0\n            def test_a2():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"collected 2 items\", \"*1 failed, 1 passed in*\"])\n\n        result = testdir.runpytest(\"--ff\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: rerun previous 1 failure first\",\n                \"*1 failed, 1 passed in*\",\n            ]\n        )\n\n    def test_lastfailed_collectfailure(self, testdir, monkeypatch):\n\n        testdir.makepyfile(\n            test_maybe=\"\"\"\n            import os\n            env = os.environ\n            if '1' == env['FAILIMPORT']:\n                raise ImportError('fail')\n            def test_hello():\n                assert '0' == env['FAILTEST']\n        \"\"\"\n        )\n\n        def rlf(fail_import, fail_run):\n            monkeypatch.setenv(\"FAILIMPORT\", str(fail_import))\n            monkeypatch.setenv(\"FAILTEST\", str(fail_run))\n\n            testdir.runpytest(\"-q\")\n            config = testdir.parseconfigure()\n            lastfailed = config.cache.get(\"cache/lastfailed\", -1)\n            return lastfailed\n\n        lastfailed = rlf(fail_import=0, fail_run=0)\n        assert lastfailed == -1\n\n        lastfailed = rlf(fail_import=1, fail_run=0)\n        assert list(lastfailed) == [\"test_maybe.py\"]\n\n        lastfailed = rlf(fail_import=0, fail_run=1)\n        assert list(lastfailed) == [\"test_maybe.py::test_hello\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_failure_subset_TestLastFailed.test_lastfailed_failure_subset.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_failure_subset_TestLastFailed.test_lastfailed_failure_subset.None_3", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 529, "end_line": 580, "span_ids": ["TestLastFailed.test_lastfailed_failure_subset"], "tokens": 420}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_lastfailed_failure_subset(self, testdir, monkeypatch):\n\n        testdir.makepyfile(\n            test_maybe=\"\"\"\n            import os\n            env = os.environ\n            if '1' == env['FAILIMPORT']:\n                raise ImportError('fail')\n            def test_hello():\n                assert '0' == env['FAILTEST']\n        \"\"\"\n        )\n\n        testdir.makepyfile(\n            test_maybe2=\"\"\"\n            import os\n            env = os.environ\n            if '1' == env['FAILIMPORT']:\n                raise ImportError('fail')\n            def test_hello():\n                assert '0' == env['FAILTEST']\n\n            def test_pass():\n                pass\n        \"\"\"\n        )\n\n        def rlf(fail_import, fail_run, args=()):\n            monkeypatch.setenv(\"FAILIMPORT\", str(fail_import))\n            monkeypatch.setenv(\"FAILTEST\", str(fail_run))\n\n            result = testdir.runpytest(\"-q\", \"--lf\", *args)\n            config = testdir.parseconfigure()\n            lastfailed = config.cache.get(\"cache/lastfailed\", -1)\n            return result, lastfailed\n\n        result, lastfailed = rlf(fail_import=0, fail_run=0)\n        assert lastfailed == -1\n        result.stdout.fnmatch_lines([\"*3 passed*\"])\n\n        result, lastfailed = rlf(fail_import=1, fail_run=0)\n        assert sorted(list(lastfailed)) == [\"test_maybe.py\", \"test_maybe2.py\"]\n\n        result, lastfailed = rlf(fail_import=0, fail_run=0, args=(\"test_maybe2.py\",))\n        assert list(lastfailed) == [\"test_maybe.py\"]\n\n        # edge case of test selection - even if we remember failures\n        # from other tests we still need to run all tests if no test\n        # matches the failures\n        result, lastfailed = rlf(fail_import=0, fail_run=0, args=(\"test_maybe2.py\",))\n        assert list(lastfailed) == [\"test_maybe.py\"]\n        result.stdout.fnmatch_lines([\"*2 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_creates_cache_when_needed_TestLastFailed.get_cached_last_failed": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_creates_cache_when_needed_TestLastFailed.get_cached_last_failed", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 549, "end_line": 636, "span_ids": ["TestLastFailed.get_cached_last_failed", "TestLastFailed.test_failed_changed_to_xfail_or_skip", "TestLastFailed.test_lastfailed_creates_cache_when_needed", "TestLastFailed.test_lf_and_ff_prints_no_needless_message", "TestLastFailed.test_xfail_not_considered_failure", "TestLastFailed.test_xfail_strict_considered_failure"], "tokens": 667}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_lastfailed_creates_cache_when_needed(self, testdir):\n        # Issue #1342\n        testdir.makepyfile(test_empty=\"\")\n        testdir.runpytest(\"-q\", \"--lf\")\n        assert not os.path.exists(\".pytest_cache/v/cache/lastfailed\")\n\n        testdir.makepyfile(test_successful=\"def test_success():\\n    assert True\")\n        testdir.runpytest(\"-q\", \"--lf\")\n        assert not os.path.exists(\".pytest_cache/v/cache/lastfailed\")\n\n        testdir.makepyfile(test_errored=\"def test_error():\\n    assert False\")\n        testdir.runpytest(\"-q\", \"--lf\")\n        assert os.path.exists(\".pytest_cache/v/cache/lastfailed\")\n\n    def test_xfail_not_considered_failure(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test(): assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 xfailed*\"])\n        assert self.get_cached_last_failed(testdir) == []\n\n    def test_xfail_strict_considered_failure(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(strict=True)\n            def test(): pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 failed*\"])\n        assert self.get_cached_last_failed(testdir) == [\n            \"test_xfail_strict_considered_failure.py::test\"\n        ]\n\n    @pytest.mark.parametrize(\"mark\", [\"mark.xfail\", \"mark.skip\"])\n    def test_failed_changed_to_xfail_or_skip(self, testdir, mark):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test(): assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert self.get_cached_last_failed(testdir) == [\n            \"test_failed_changed_to_xfail_or_skip.py::test\"\n        ]\n        assert result.ret == 1\n\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.{mark}\n            def test(): assert 0\n        \"\"\".format(\n                mark=mark\n            )\n        )\n        result = testdir.runpytest()\n        assert result.ret == 0\n        assert self.get_cached_last_failed(testdir) == []\n        assert result.ret == 0\n\n    @pytest.mark.parametrize(\"quiet\", [True, False])\n    @pytest.mark.parametrize(\"opt\", [\"--ff\", \"--lf\"])\n    def test_lf_and_ff_prints_no_needless_message(self, quiet, opt, testdir):\n        # Issue 3853\n        testdir.makepyfile(\"def test(): assert 0\")\n        args = [opt]\n        if quiet:\n            args.append(\"-q\")\n        result = testdir.runpytest(*args)\n        result.stdout.no_fnmatch_line(\"*run all*\")\n\n        result = testdir.runpytest(*args)\n        if quiet:\n            result.stdout.no_fnmatch_line(\"*run all*\")\n        else:\n            assert \"rerun previous\" in result.stdout.str()\n\n    def get_cached_last_failed(self, testdir):\n        config = testdir.parseconfigure()\n        return sorted(config.cache.get(\"cache/lastfailed\", {}))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_cache_cumulative_TestLastFailed.test_cache_cumulative.None_4": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_cache_cumulative_TestLastFailed.test_cache_cumulative.None_4", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 638, "end_line": 702, "span_ids": ["TestLastFailed.test_cache_cumulative"], "tokens": 502}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_cache_cumulative(self, testdir):\n        \"\"\"\n        Test workflow where user fixes errors gradually file by file using --lf.\n        \"\"\"\n        # 1. initial run\n        test_bar = testdir.makepyfile(\n            test_bar=\"\"\"\n            def test_bar_1(): pass\n            def test_bar_2(): assert 0\n        \"\"\"\n        )\n        test_foo = testdir.makepyfile(\n            test_foo=\"\"\"\n            def test_foo_3(): pass\n            def test_foo_4(): assert 0\n        \"\"\"\n        )\n        testdir.runpytest()\n        assert self.get_cached_last_failed(testdir) == [\n            \"test_bar.py::test_bar_2\",\n            \"test_foo.py::test_foo_4\",\n        ]\n\n        # 2. fix test_bar_2, run only test_bar.py\n        testdir.makepyfile(\n            test_bar=\"\"\"\n            def test_bar_1(): pass\n            def test_bar_2(): pass\n        \"\"\"\n        )\n        result = testdir.runpytest(test_bar)\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n        # ensure cache does not forget that test_foo_4 failed once before\n        assert self.get_cached_last_failed(testdir) == [\"test_foo.py::test_foo_4\"]\n\n        result = testdir.runpytest(\"--last-failed\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 1 item\",\n                \"run-last-failure: rerun previous 1 failure (skipped 1 file)\",\n                \"*= 1 failed in *\",\n            ]\n        )\n        assert self.get_cached_last_failed(testdir) == [\"test_foo.py::test_foo_4\"]\n\n        # 3. fix test_foo_4, run only test_foo.py\n        test_foo = testdir.makepyfile(\n            test_foo=\"\"\"\n            def test_foo_3(): pass\n            def test_foo_4(): pass\n        \"\"\"\n        )\n        result = testdir.runpytest(test_foo, \"--last-failed\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 1 item\",\n                \"run-last-failure: rerun previous 1 failure\",\n                \"*= 1 passed in *\",\n            ]\n        )\n        assert self.get_cached_last_failed(testdir) == []\n\n        result = testdir.runpytest(\"--last-failed\")\n        result.stdout.fnmatch_lines([\"*4 passed*\"])\n        assert self.get_cached_last_failed(testdir) == []", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_no_failures_behavior_all_passed_TestLastFailed.test_lastfailed_no_failures_behavior_empty_cache": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_no_failures_behavior_all_passed_TestLastFailed.test_lastfailed_no_failures_behavior_empty_cache", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 704, "end_line": 756, "span_ids": ["TestLastFailed.test_lastfailed_no_failures_behavior_all_passed", "TestLastFailed.test_lastfailed_no_failures_behavior_empty_cache"], "tokens": 425}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_lastfailed_no_failures_behavior_all_passed(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_1(): pass\n            def test_2(): pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n        result = testdir.runpytest(\"--lf\")\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n        result = testdir.runpytest(\"--lf\", \"--lfnf\", \"all\")\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n        # Ensure the list passed to pytest_deselected is a copy,\n        # and not a reference which is cleared right after.\n        testdir.makeconftest(\n            \"\"\"\n            deselected = []\n\n            def pytest_deselected(items):\n                global deselected\n                deselected = items\n\n            def pytest_sessionfinish():\n                print(\"\\\\ndeselected={}\".format(len(deselected)))\n        \"\"\"\n        )\n\n        result = testdir.runpytest(\"--lf\", \"--lfnf\", \"none\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items / 2 deselected\",\n                \"run-last-failure: no previously failed tests, deselecting all items.\",\n                \"deselected=2\",\n                \"* 2 deselected in *\",\n            ]\n        )\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n    def test_lastfailed_no_failures_behavior_empty_cache(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_1(): pass\n            def test_2(): assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--lf\", \"--cache-clear\")\n        result.stdout.fnmatch_lines([\"*1 failed*1 passed*\"])\n        result = testdir.runpytest(\"--lf\", \"--cache-clear\", \"--lfnf\", \"all\")\n        result.stdout.fnmatch_lines([\"*1 failed*1 passed*\"])\n        result = testdir.runpytest(\"--lf\", \"--cache-clear\", \"--lfnf\", \"none\")\n        result.stdout.fnmatch_lines([\"*2 desel*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_skip_collection_TestLastFailed.test_lastfailed_skip_collection.None_4": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_skip_collection_TestLastFailed.test_lastfailed_skip_collection.None_4", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 758, "end_line": 808, "span_ids": ["TestLastFailed.test_lastfailed_skip_collection"], "tokens": 376}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_lastfailed_skip_collection(self, testdir):\n        \"\"\"\n        Test --lf behavior regarding skipping collection of files that are not marked as\n        failed in the cache (#5172).\n        \"\"\"\n        testdir.makepyfile(\n            **{\n                \"pkg1/test_1.py\": \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize('i', range(3))\n                def test_1(i): pass\n            \"\"\",\n                \"pkg2/test_2.py\": \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize('i', range(5))\n                def test_1(i):\n                    assert i not in (1, 3)\n            \"\"\",\n            }\n        )\n        # first run: collects 8 items (test_1: 3, test_2: 5)\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"collected 8 items\", \"*2 failed*6 passed*\"])\n        # second run: collects only 5 items from test_2, because all tests from test_1 have passed\n        result = testdir.runpytest(\"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: rerun previous 2 failures (skipped 1 file)\",\n                \"*= 2 failed in *\",\n            ]\n        )\n\n        # add another file and check if message is correct when skipping more than 1 file\n        testdir.makepyfile(\n            **{\n                \"pkg1/test_3.py\": \"\"\"\n                def test_3(): pass\n            \"\"\"\n            }\n        )\n        result = testdir.runpytest(\"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: rerun previous 2 failures (skipped 2 files)\",\n                \"*= 2 failed in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewFirst_TestNewFirst.test_newfirst_usecase.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewFirst_TestNewFirst.test_newfirst_usecase.None_6", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 873, "end_line": 937, "span_ids": ["TestNewFirst", "TestNewFirst.test_newfirst_usecase"], "tokens": 613}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNewFirst:\n    def test_newfirst_usecase(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"test_1/test_1.py\": \"\"\"\n                def test_1(): assert 1\n                def test_2(): assert 1\n                def test_3(): assert 1\n            \"\"\",\n                \"test_2/test_2.py\": \"\"\"\n                def test_1(): assert 1\n                def test_2(): assert 1\n                def test_3(): assert 1\n            \"\"\",\n            }\n        )\n\n        testdir.tmpdir.join(\"test_1/test_1.py\").setmtime(1)\n\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_1/test_1.py::test_1 PASSED*\",\n                \"*test_1/test_1.py::test_2 PASSED*\",\n                \"*test_1/test_1.py::test_3 PASSED*\",\n                \"*test_2/test_2.py::test_1 PASSED*\",\n                \"*test_2/test_2.py::test_2 PASSED*\",\n                \"*test_2/test_2.py::test_3 PASSED*\",\n            ]\n        )\n\n        result = testdir.runpytest(\"-v\", \"--nf\")\n\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_2/test_2.py::test_1 PASSED*\",\n                \"*test_2/test_2.py::test_2 PASSED*\",\n                \"*test_2/test_2.py::test_3 PASSED*\",\n                \"*test_1/test_1.py::test_1 PASSED*\",\n                \"*test_1/test_1.py::test_2 PASSED*\",\n                \"*test_1/test_1.py::test_3 PASSED*\",\n            ]\n        )\n\n        testdir.tmpdir.join(\"test_1/test_1.py\").write(\n            \"def test_1(): assert 1\\n\"\n            \"def test_2(): assert 1\\n\"\n            \"def test_3(): assert 1\\n\"\n            \"def test_4(): assert 1\\n\"\n        )\n        testdir.tmpdir.join(\"test_1/test_1.py\").setmtime(1)\n\n        result = testdir.runpytest(\"-v\", \"--nf\")\n\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_1/test_1.py::test_4 PASSED*\",\n                \"*test_2/test_2.py::test_1 PASSED*\",\n                \"*test_2/test_2.py::test_2 PASSED*\",\n                \"*test_2/test_2.py::test_3 PASSED*\",\n                \"*test_1/test_1.py::test_1 PASSED*\",\n                \"*test_1/test_1.py::test_2 PASSED*\",\n                \"*test_1/test_1.py::test_3 PASSED*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestReadme_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestReadme_", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 986, "end_line": 1048, "span_ids": ["TestReadme", "TestReadme.check_readme", "TestReadme.test_readme_failed", "TestReadme.test_readme_passed", "test_cachedir_tag", "test_does_not_create_boilerplate_in_existing_dirs", "test_gitignore"], "tokens": 502}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReadme:\n    def check_readme(self, testdir):\n        config = testdir.parseconfigure()\n        readme = config.cache._cachedir.joinpath(\"README.md\")\n        return readme.is_file()\n\n    def test_readme_passed(self, testdir):\n        testdir.makepyfile(\"def test_always_passes(): pass\")\n        testdir.runpytest()\n        assert self.check_readme(testdir) is True\n\n    def test_readme_failed(self, testdir):\n        testdir.makepyfile(\"def test_always_fails(): assert 0\")\n        testdir.runpytest()\n        assert self.check_readme(testdir) is True\n\n\ndef test_gitignore(testdir):\n    \"\"\"Ensure we automatically create .gitignore file in the pytest_cache directory (#3286).\"\"\"\n    from _pytest.cacheprovider import Cache\n\n    config = testdir.parseconfig()\n    cache = Cache.for_config(config)\n    cache.set(\"foo\", \"bar\")\n    msg = \"# Created by pytest automatically.\\n*\\n\"\n    gitignore_path = cache._cachedir.joinpath(\".gitignore\")\n    assert gitignore_path.read_text(encoding=\"UTF-8\") == msg\n\n    # Does not overwrite existing/custom one.\n    gitignore_path.write_text(\"custom\")\n    cache.set(\"something\", \"else\")\n    assert gitignore_path.read_text(encoding=\"UTF-8\") == \"custom\"\n\n\ndef test_does_not_create_boilerplate_in_existing_dirs(testdir):\n    from _pytest.cacheprovider import Cache\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        cache_dir = .\n        \"\"\"\n    )\n    config = testdir.parseconfig()\n    cache = Cache.for_config(config)\n    cache.set(\"foo\", \"bar\")\n\n    assert os.path.isdir(\"v\")  # cache contents\n    assert not os.path.exists(\".gitignore\")\n    assert not os.path.exists(\"README.md\")\n\n\ndef test_cachedir_tag(testdir):\n    \"\"\"Ensure we automatically create CACHEDIR.TAG file in the pytest_cache directory (#4278).\"\"\"\n    from _pytest.cacheprovider import Cache\n    from _pytest.cacheprovider import CACHEDIR_TAG_CONTENT\n\n    config = testdir.parseconfig()\n    cache = Cache.for_config(config)\n    cache.set(\"foo\", \"bar\")\n    cachedir_tag_path = cache._cachedir.joinpath(\"CACHEDIR.TAG\")\n    assert cachedir_tag_path.read_bytes() == CACHEDIR_TAG_CONTENT", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capturing_unicode_test_collect_capturing": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capturing_unicode_test_collect_capturing", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 76, "end_line": 123, "span_ids": ["test_capturing_bytes_in_utf8_encoding", "test_capturing_unicode", "test_collect_capturing"], "tokens": 306}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"method\", [\"fd\", \"sys\"])\ndef test_capturing_unicode(testdir, method):\n    obj = \"'b\\u00f6y'\"\n    testdir.makepyfile(\n        \"\"\"\\\n        # taken from issue 227 from nosetests\n        def test_unicode():\n            import sys\n            print(sys.stdout)\n            print(%s)\n        \"\"\"\n        % obj\n    )\n    result = testdir.runpytest(\"--capture=%s\" % method)\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\n@pytest.mark.parametrize(\"method\", [\"fd\", \"sys\"])\ndef test_capturing_bytes_in_utf8_encoding(testdir, method):\n    testdir.makepyfile(\n        \"\"\"\\\n        def test_unicode():\n            print('b\\\\u00f6y')\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--capture=%s\" % method)\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_collect_capturing(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import sys\n\n        print(\"collect %s failure\" % 13)\n        sys.stderr.write(\"collect %s_stderr failure\" % 13)\n        import xyz42123\n    \"\"\"\n    )\n    result = testdir.runpytest(p)\n    result.stdout.fnmatch_lines(\n        [\n            \"*Captured stdout*\",\n            \"collect 13 failure\",\n            \"*Captured stderr*\",\n            \"collect 13_stderr failure\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestPerTestCapturing_TestPerTestCapturing.test_capturing_outerr.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestPerTestCapturing_TestPerTestCapturing.test_capturing_outerr.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 144, "end_line": 284, "span_ids": ["TestPerTestCapturing", "TestPerTestCapturing.test_capture_and_fixtures", "TestPerTestCapturing.test_capture_scope_cache", "TestPerTestCapturing.test_capturing_outerr", "TestPerTestCapturing.test_no_carry_over", "TestPerTestCapturing.test_teardown_capturing", "TestPerTestCapturing.test_teardown_capturing_final"], "tokens": 814}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPerTestCapturing:\n    def test_capture_and_fixtures(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def setup_module(mod):\n                print(\"setup module\")\n            def setup_function(function):\n                print(\"setup \" + function.__name__)\n            def test_func1():\n                print(\"in func1\")\n                assert 0\n            def test_func2():\n                print(\"in func2\")\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"setup module*\",\n                \"setup test_func1*\",\n                \"in func1*\",\n                \"setup test_func2*\",\n                \"in func2*\",\n            ]\n        )\n\n    @pytest.mark.xfail(reason=\"unimplemented feature\")\n    def test_capture_scope_cache(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import sys\n            def setup_module(func):\n                print(\"module-setup\")\n            def setup_function(func):\n                print(\"function-setup\")\n            def test_func():\n                print(\"in function\")\n                assert 0\n            def teardown_function(func):\n                print(\"in teardown\")\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_func():*\",\n                \"*Captured stdout during setup*\",\n                \"module-setup*\",\n                \"function-setup*\",\n                \"*Captured stdout*\",\n                \"in teardown*\",\n            ]\n        )\n\n    def test_no_carry_over(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_func1():\n                print(\"in func1\")\n            def test_func2():\n                print(\"in func2\")\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        s = result.stdout.str()\n        assert \"in func1\" not in s\n        assert \"in func2\" in s\n\n    def test_teardown_capturing(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def setup_function(function):\n                print(\"setup func1\")\n            def teardown_function(function):\n                print(\"teardown func1\")\n                assert 0\n            def test_func1():\n                print(\"in func1\")\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"*teardown_function*\",\n                \"*Captured stdout*\",\n                \"setup func1*\",\n                \"in func1*\",\n                \"teardown func1*\",\n                # \"*1 fixture failure*\"\n            ]\n        )\n\n    def test_teardown_capturing_final(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def teardown_module(mod):\n                print(\"teardown module\")\n                assert 0\n            def test_func():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"*def teardown_module(mod):*\",\n                \"*Captured stdout*\",\n                \"*teardown module*\",\n                \"*1 error*\",\n            ]\n        )\n\n    def test_capturing_outerr(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\\\n            import sys\n            def test_capturing():\n                print(42)\n                sys.stderr.write(str(23))\n            def test_capturing_error():\n                print(1)\n                sys.stderr.write(str(2))\n                raise ValueError\n            \"\"\"\n        )\n        result = testdir.runpytest(p1)\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_capturing_outerr.py .F*\",\n                \"====* FAILURES *====\",\n                \"____*____\",\n                \"*test_capturing_outerr.py:8: ValueError\",\n                \"*--- Captured stdout *call*\",\n                \"1\",\n                \"*--- Captured stderr *call*\",\n                \"2\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestLoggingInteraction_TestLoggingInteraction.test_logging_after_cap_stopped.assert_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestLoggingInteraction_TestLoggingInteraction.test_logging_after_cap_stopped.assert_", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 287, "end_line": 422, "span_ids": ["TestLoggingInteraction", "TestLoggingInteraction.test_conftestlogging_and_test_logging", "TestLoggingInteraction.test_conftestlogging_is_shown", "TestLoggingInteraction.test_logging_after_cap_stopped", "TestLoggingInteraction.test_logging_and_crossscope_fixtures", "TestLoggingInteraction.test_logging_and_immediate_setupteardown", "TestLoggingInteraction.test_logging_stream_ownership"], "tokens": 914}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLoggingInteraction:\n    def test_logging_stream_ownership(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_logging():\n                import logging\n                import pytest\n                stream = capture.CaptureIO()\n                logging.basicConfig(stream=stream)\n                stream.close() # to free memory/release resources\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess(p)\n        assert result.stderr.str().find(\"atexit\") == -1\n\n    def test_logging_and_immediate_setupteardown(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            import logging\n            def setup_function(function):\n                logging.warning(\"hello1\")\n\n            def test_logging():\n                logging.warning(\"hello2\")\n                assert 0\n\n            def teardown_function(function):\n                logging.warning(\"hello3\")\n                assert 0\n            \"\"\"\n        )\n        for optargs in ((\"--capture=sys\",), (\"--capture=fd\",)):\n            print(optargs)\n            result = testdir.runpytest_subprocess(p, *optargs)\n            s = result.stdout.str()\n            result.stdout.fnmatch_lines(\n                [\"*WARN*hello3\", \"*WARN*hello1\", \"*WARN*hello2\"]  # errors show first!\n            )\n            # verify proper termination\n            assert \"closed\" not in s\n\n    def test_logging_and_crossscope_fixtures(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            import logging\n            def setup_module(function):\n                logging.warning(\"hello1\")\n\n            def test_logging():\n                logging.warning(\"hello2\")\n                assert 0\n\n            def teardown_module(function):\n                logging.warning(\"hello3\")\n                assert 0\n            \"\"\"\n        )\n        for optargs in ((\"--capture=sys\",), (\"--capture=fd\",)):\n            print(optargs)\n            result = testdir.runpytest_subprocess(p, *optargs)\n            s = result.stdout.str()\n            result.stdout.fnmatch_lines(\n                [\"*WARN*hello3\", \"*WARN*hello1\", \"*WARN*hello2\"]  # errors come first\n            )\n            # verify proper termination\n            assert \"closed\" not in s\n\n    def test_conftestlogging_is_shown(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\\\n                import logging\n                logging.basicConfig()\n                logging.warning(\"hello435\")\n            \"\"\"\n        )\n        # make sure that logging is still captured in tests\n        result = testdir.runpytest_subprocess(\"-s\", \"-p\", \"no:capturelog\")\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stderr.fnmatch_lines([\"WARNING*hello435*\"])\n        assert \"operation on closed file\" not in result.stderr.str()\n\n    def test_conftestlogging_and_test_logging(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\\\n                import logging\n                logging.basicConfig()\n            \"\"\"\n        )\n        # make sure that logging is still captured in tests\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_hello():\n                import logging\n                logging.warning(\"hello433\")\n                assert 0\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess(p, \"-p\", \"no:capturelog\")\n        assert result.ret != 0\n        result.stdout.fnmatch_lines([\"WARNING*hello433*\"])\n        assert \"something\" not in result.stderr.str()\n        assert \"operation on closed file\" not in result.stderr.str()\n\n    def test_logging_after_cap_stopped(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\\\n                import pytest\n                import logging\n\n                log = logging.getLogger(__name__)\n\n                @pytest.fixture\n                def log_on_teardown():\n                    yield\n                    log.warning('Logging on teardown')\n            \"\"\"\n        )\n        # make sure that logging is still captured in tests\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_hello(log_on_teardown):\n                import logging\n                logging.warning(\"hello433\")\n                assert 1\n                raise KeyboardInterrupt()\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess(p, \"--log-cli-level\", \"info\")\n        assert result.ret != 0\n        result.stdout.fnmatch_lines(\n            [\"*WARNING*hello433*\", \"*WARNING*Logging on teardown*\"]\n        )\n        assert (\n            \"AttributeError: 'NoneType' object has no attribute 'resume_capturing'\"\n            not in result.stderr.str()\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture_TestCaptureFixture.test_stdfd_functional": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture_TestCaptureFixture.test_stdfd_functional", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 407, "end_line": 501, "span_ids": ["TestCaptureFixture", "TestCaptureFixture.test_capsyscapfd", "TestCaptureFixture.test_capsyscapfdbinary", "TestCaptureFixture.test_capture_is_represented_on_failure_issue128", "TestCaptureFixture.test_capturing_getfixturevalue", "TestCaptureFixture.test_std_functional", "TestCaptureFixture.test_stdfd_functional"], "tokens": 656}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaptureFixture:\n    @pytest.mark.parametrize(\"opt\", [[], [\"-s\"]])\n    def test_std_functional(self, testdir, opt):\n        reprec = testdir.inline_runsource(\n            \"\"\"\\\n            def test_hello(capsys):\n                print(42)\n                out, err = capsys.readouterr()\n                assert out.startswith(\"42\")\n            \"\"\",\n            *opt,\n        )\n        reprec.assertoutcome(passed=1)\n\n    def test_capsyscapfd(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_one(capsys, capfd):\n                pass\n            def test_two(capfd, capsys):\n                pass\n            \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\n                \"*ERROR*setup*test_one*\",\n                \"E*capfd*capsys*same*time*\",\n                \"*ERROR*setup*test_two*\",\n                \"E*capsys*capfd*same*time*\",\n                \"*2 errors*\",\n            ]\n        )\n\n    def test_capturing_getfixturevalue(self, testdir):\n        \"\"\"Test that asking for \"capfd\" and \"capsys\" using request.getfixturevalue\n        in the same test is an error.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\\\n            def test_one(capsys, request):\n                request.getfixturevalue(\"capfd\")\n            def test_two(capfd, request):\n                request.getfixturevalue(\"capsys\")\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_one*\",\n                \"E * cannot use capfd and capsys at the same time\",\n                \"*test_two*\",\n                \"E * cannot use capsys and capfd at the same time\",\n                \"*2 failed in*\",\n            ]\n        )\n\n    def test_capsyscapfdbinary(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_one(capsys, capfdbinary):\n                pass\n            \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\"*ERROR*setup*test_one*\", \"E*capfdbinary*capsys*same*time*\", \"*1 error*\"]\n        )\n\n    @pytest.mark.parametrize(\"method\", [\"sys\", \"fd\"])\n    def test_capture_is_represented_on_failure_issue128(self, testdir, method):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_hello(cap{}):\n                print(\"xxx42xxx\")\n                assert 0\n            \"\"\".format(\n                method\n            )\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"xxx42xxx\"])\n\n    def test_stdfd_functional(self, testdir):\n        reprec = testdir.inline_runsource(\n            \"\"\"\\\n            def test_hello(capfd):\n                import os\n                os.write(1, b\"42\")\n                out, err = capfd.readouterr()\n                assert out.startswith(\"42\")\n                capfd.close()\n            \"\"\"\n        )\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_disabled_capture_fixture_TestCaptureFixture.test_disabled_capture_fixture.if_no_capture_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_disabled_capture_fixture_TestCaptureFixture.test_disabled_capture_fixture.if_no_capture_", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 588, "end_line": 614, "span_ids": ["TestCaptureFixture.test_disabled_capture_fixture"], "tokens": 235}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaptureFixture:\n\n    @pytest.mark.parametrize(\"fixture\", [\"capsys\", \"capfd\"])\n    @pytest.mark.parametrize(\"no_capture\", [True, False])\n    def test_disabled_capture_fixture(self, testdir, fixture, no_capture):\n        testdir.makepyfile(\n            \"\"\"\\\n            def test_disabled({fixture}):\n                print('captured before')\n                with {fixture}.disabled():\n                    print('while capture is disabled')\n                print('captured after')\n                assert {fixture}.readouterr() == ('captured before\\\\ncaptured after\\\\n', '')\n\n            def test_normal():\n                print('test_normal executed')\n        \"\"\".format(\n                fixture=fixture\n            )\n        )\n        args = (\"-s\",) if no_capture else ()\n        result = testdir.runpytest_subprocess(*args)\n        result.stdout.fnmatch_lines([\"*while capture is disabled*\", \"*= 2 passed in *\"])\n        result.stdout.no_fnmatch_line(\"*captured before*\")\n        result.stdout.no_fnmatch_line(\"*captured after*\")\n        if no_capture:\n            assert \"test_normal executed\" in result.stdout.str()\n        else:\n            result.stdout.no_fnmatch_line(\"*test_normal executed*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_fixture_use_by_other_fixtures_teardown_TestCaptureFixture.test_fixture_use_by_other_fixtures_teardown.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_fixture_use_by_other_fixtures_teardown_TestCaptureFixture.test_fixture_use_by_other_fixtures_teardown.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 656, "end_line": 682, "span_ids": ["TestCaptureFixture.test_fixture_use_by_other_fixtures_teardown"], "tokens": 201}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaptureFixture:\n\n    @pytest.mark.parametrize(\"cap\", [\"capsys\", \"capfd\"])\n    def test_fixture_use_by_other_fixtures_teardown(self, testdir, cap):\n        \"\"\"Ensure we can access setup and teardown buffers from teardown when using capsys/capfd (##3033)\"\"\"\n        testdir.makepyfile(\n            \"\"\"\\\n            import sys\n            import pytest\n            import os\n\n            @pytest.fixture()\n            def fix({cap}):\n                print(\"setup out\")\n                sys.stderr.write(\"setup err\\\\n\")\n                yield\n                out, err = {cap}.readouterr()\n                assert out == 'setup out\\\\ncall out\\\\n'\n                assert err == 'setup err\\\\ncall err\\\\n'\n\n            def test_a(fix):\n                print(\"call out\")\n                sys.stderr.write(\"call err\\\\n\")\n        \"\"\".format(\n                cap=cap\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_setup_failure_does_not_kill_capturing_test_error_during_readouterr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_setup_failure_does_not_kill_capturing_test_error_during_readouterr", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 682, "end_line": 782, "span_ids": ["test_capture_badoutput_issue412", "test_capture_binary_output", "test_capture_conftest_runtest_setup", "test_capture_early_option_parsing", "test_error_during_readouterr", "test_setup_failure_does_not_kill_capturing"], "tokens": 621}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_setup_failure_does_not_kill_capturing(testdir):\n    sub1 = testdir.mkpydir(\"sub1\")\n    sub1.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            def pytest_runtest_setup(item):\n                raise ValueError(42)\n            \"\"\"\n        )\n    )\n    sub1.join(\"test_mod.py\").write(\"def test_func1(): pass\")\n    result = testdir.runpytest(testdir.tmpdir, \"--traceconfig\")\n    result.stdout.fnmatch_lines([\"*ValueError(42)*\", \"*1 error*\"])\n\n\ndef test_capture_conftest_runtest_setup(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_runtest_setup():\n            print(\"hello19\")\n    \"\"\"\n    )\n    testdir.makepyfile(\"def test_func(): pass\")\n    result = testdir.runpytest()\n    assert result.ret == 0\n    result.stdout.no_fnmatch_line(\"*hello19*\")\n\n\ndef test_capture_badoutput_issue412(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import os\n\n        def test_func():\n            omg = bytearray([1,129,1])\n            os.write(1, omg)\n            assert 0\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--capture=fd\")\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *def test_func*\n        *assert 0*\n        *Captured*\n        *1 failed*\n    \"\"\"\n    )\n\n\ndef test_capture_early_option_parsing(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_runtest_setup():\n            print(\"hello19\")\n    \"\"\"\n    )\n    testdir.makepyfile(\"def test_func(): pass\")\n    result = testdir.runpytest(\"-vs\")\n    assert result.ret == 0\n    assert \"hello19\" in result.stdout.str()\n\n\ndef test_capture_binary_output(testdir):\n    testdir.makepyfile(\n        r\"\"\"\n        import pytest\n\n        def test_a():\n            import sys\n            import subprocess\n            subprocess.call([sys.executable, __file__])\n\n        def test_foo():\n            import os;os.write(1, b'\\xc3')\n\n        if __name__ == '__main__':\n            test_foo()\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--assert=plain\")\n    result.assert_outcomes(passed=2)\n\n\ndef test_error_during_readouterr(testdir):\n    \"\"\"Make sure we suspend capturing if errors occur during readouterr\"\"\"\n    testdir.makepyfile(\n        pytest_xyz=\"\"\"\n        from _pytest.capture import FDCapture\n\n        def bad_snap(self):\n            raise Exception('boom')\n\n        assert FDCapture.snap\n        FDCapture.snap = bad_snap\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess(\"-p\", \"pytest_xyz\", \"--version\")\n    result.stderr.fnmatch_lines(\n        [\"*in bad_snap\", \"    raise Exception('boom')\", \"Exception: boom\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestStdCaptureFDinvalidFD_TestStdCaptureFDinvalidFD.test_stdcapture_fd_invalid_fd.assert_result_parseoutcom": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestStdCaptureFDinvalidFD_TestStdCaptureFDinvalidFD.test_stdcapture_fd_invalid_fd.assert_result_parseoutcom", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1148, "end_line": 1179, "span_ids": ["TestStdCaptureFDinvalidFD", "TestStdCaptureFDinvalidFD.test_stdcapture_fd_invalid_fd"], "tokens": 297}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestStdCaptureFDinvalidFD:\n    def test_stdcapture_fd_invalid_fd(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import os\n            from _pytest import capture\n\n            def StdCaptureFD(out=True, err=True, in_=True):\n                return capture.MultiCapture(out, err, in_, Capture=capture.FDCapture)\n\n            def test_stdout():\n                os.close(1)\n                cap = StdCaptureFD(out=True, err=False, in_=False)\n                assert repr(cap.out) == \"<FDCapture 1 oldfd=<UNSET> _state=None tmpfile=<UNSET>>\"\n                cap.stop_capturing()\n\n            def test_stderr():\n                os.close(2)\n                cap = StdCaptureFD(out=False, err=True, in_=False)\n                assert repr(cap.err) == \"<FDCapture 2 oldfd=<UNSET> _state=None tmpfile=<UNSET>>\"\n                cap.stop_capturing()\n\n            def test_stdin():\n                os.close(0)\n                cap = StdCaptureFD(out=False, err=False, in_=True)\n                assert repr(cap.in_) == \"<FDCapture 0 oldfd=<UNSET> _state=None tmpfile=<UNSET>>\"\n                cap.stop_capturing()\n        \"\"\"\n        )\n        result = testdir.runpytest_subprocess(\"--capture=fd\")\n        assert result.ret == 0\n        assert result.parseoutcomes()[\"passed\"] == 3", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capture_not_started_but_reset_test_close_and_capture_again": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capture_not_started_but_reset_test_close_and_capture_again", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1182, "end_line": 1238, "span_ids": ["test_capsys_results_accessible_by_attribute", "test_capture_not_started_but_reset", "test_close_and_capture_again", "test_fdcapture_tmpfile_remains_the_same", "test_using_capsys_fixture_works_with_sys_stdout_encoding"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_capture_not_started_but_reset():\n    capsys = StdCapture()\n    capsys.stop_capturing()\n\n\ndef test_using_capsys_fixture_works_with_sys_stdout_encoding(capsys):\n    test_text = \"test text\"\n\n    print(test_text.encode(sys.stdout.encoding, \"replace\"))\n    (out, err) = capsys.readouterr()\n    assert out\n    assert err == \"\"\n\n\ndef test_capsys_results_accessible_by_attribute(capsys):\n    sys.stdout.write(\"spam\")\n    sys.stderr.write(\"eggs\")\n    capture_result = capsys.readouterr()\n    assert capture_result.out == \"spam\"\n    assert capture_result.err == \"eggs\"\n\n\n@pytest.mark.parametrize(\"use\", [True, False])\ndef test_fdcapture_tmpfile_remains_the_same(tmpfile, use):\n    if not use:\n        tmpfile = True\n    cap = StdCaptureFD(out=False, err=tmpfile)\n    try:\n        cap.start_capturing()\n        capfile = cap.err.tmpfile\n        cap.readouterr()\n    finally:\n        cap.stop_capturing()\n    capfile2 = cap.err.tmpfile\n    assert capfile2 == capfile\n\n\ndef test_close_and_capture_again(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import os\n        def test_close():\n            os.close(1)\n        def test_capture_again():\n            os.write(1, b\"hello\\\\n\")\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess()\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *test_capture_again*\n        *assert 0*\n        *stdout*\n        *hello*\n    \"\"\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capturing_and_logging_fundamentals_test_capturing_and_logging_fundamentals.assert_atexit_not_in_re": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capturing_and_logging_fundamentals_test_capturing_and_logging_fundamentals.assert_atexit_not_in_re", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1241, "end_line": 1278, "span_ids": ["test_capturing_and_logging_fundamentals"], "tokens": 256}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"method\", [\"SysCapture\", \"FDCapture\", \"TeeSysCapture\"])\ndef test_capturing_and_logging_fundamentals(testdir, method):\n    # here we check a fundamental feature\n    p = testdir.makepyfile(\n        \"\"\"\n        import sys, os\n        import py, logging\n        from _pytest import capture\n        cap = capture.MultiCapture(out=False, in_=False,\n                                     Capture=capture.%s)\n        cap.start_capturing()\n\n        logging.warning(\"hello1\")\n        outerr = cap.readouterr()\n        print(\"suspend, captured %%s\" %%(outerr,))\n        logging.warning(\"hello2\")\n\n        cap.pop_outerr_to_orig()\n        logging.warning(\"hello3\")\n\n        outerr = cap.readouterr()\n        print(\"suspend2, captured %%s\" %% (outerr,))\n    \"\"\"\n        % (method,)\n    )\n    result = testdir.runpython(p)\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        suspend, captured*hello1*\n        suspend2, captured*WARNING:root:hello3*\n    \"\"\"\n    )\n    result.stderr.fnmatch_lines(\n        \"\"\"\n        WARNING:root:hello2\n    \"\"\"\n    )\n    assert \"atexit\" not in result.stderr.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_global_capture_with_live_logging_test_global_capture_with_live_logging.None_7": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_global_capture_with_live_logging_test_global_capture_with_live_logging.None_7", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1362, "end_line": 1417, "span_ids": ["test_global_capture_with_live_logging"], "tokens": 334}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_global_capture_with_live_logging(testdir):\n    # Issue 3819\n    # capture should work with live cli logging\n\n    # Teardown report seems to have the capture for the whole process (setup, capture, teardown)\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_runtest_logreport(report):\n            if \"test_global\" in report.nodeid:\n                if report.when == \"teardown\":\n                    with open(\"caplog\", \"w\") as f:\n                        f.write(report.caplog)\n                    with open(\"capstdout\", \"w\") as f:\n                        f.write(report.capstdout)\n        \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        import sys\n        import pytest\n\n        logger = logging.getLogger(__name__)\n\n        @pytest.fixture\n        def fix1():\n            print(\"fix setup\")\n            logging.info(\"fix setup\")\n            yield\n            logging.info(\"fix teardown\")\n            print(\"fix teardown\")\n\n        def test_global(fix1):\n            print(\"begin test\")\n            logging.info(\"something in test\")\n            print(\"end test\")\n        \"\"\"\n    )\n    result = testdir.runpytest_subprocess(\"--log-cli-level=INFO\")\n    assert result.ret == 0\n\n    with open(\"caplog\") as f:\n        caplog = f.read()\n\n    assert \"fix setup\" in caplog\n    assert \"something in test\" in caplog\n    assert \"fix teardown\" in caplog\n\n    with open(\"capstdout\") as f:\n        capstdout = f.read()\n\n    assert \"fix setup\" in capstdout\n    assert \"begin test\" in capstdout\n    assert \"end test\" in capstdout\n    assert \"fix teardown\" in capstdout", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capture_with_live_logging_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_capture_with_live_logging_", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1420, "end_line": 1496, "span_ids": ["test__get_multicapture", "test_capture_with_live_logging", "test_encodedfile_writelines", "test_stderr_write_returns_len", "test_typeerror_encodedfile_write"], "tokens": 550}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"capture_fixture\", [\"capsys\", \"capfd\"])\ndef test_capture_with_live_logging(testdir, capture_fixture):\n    # Issue 3819\n    # capture should work with live cli logging\n\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n        import sys\n\n        logger = logging.getLogger(__name__)\n\n        def test_capture({0}):\n            print(\"hello\")\n            sys.stderr.write(\"world\\\\n\")\n            captured = {0}.readouterr()\n            assert captured.out == \"hello\\\\n\"\n            assert captured.err == \"world\\\\n\"\n\n            logging.info(\"something\")\n            print(\"next\")\n            logging.info(\"something\")\n\n            captured = {0}.readouterr()\n            assert captured.out == \"next\\\\n\"\n        \"\"\".format(\n            capture_fixture\n        )\n    )\n\n    result = testdir.runpytest_subprocess(\"--log-cli-level=INFO\")\n    assert result.ret == 0\n\n\ndef test_typeerror_encodedfile_write(testdir):\n    \"\"\"It should behave the same with and without output capturing (#4861).\"\"\"\n    p = testdir.makepyfile(\n        \"\"\"\n        def test_fails():\n            import sys\n            sys.stdout.write(b\"foo\")\n    \"\"\"\n    )\n    result_without_capture = testdir.runpytest(\"-s\", str(p))\n    result_with_capture = testdir.runpytest(str(p))\n\n    assert result_with_capture.ret == result_without_capture.ret\n    out = result_with_capture.stdout.str()\n    assert (\"TypeError: write() argument must be str, not bytes\" in out) or (\n        \"TypeError: unicode argument expected, got 'bytes'\" in out\n    )\n\n\ndef test_stderr_write_returns_len(capsys):\n    \"\"\"Write on Encoded files, namely captured stderr, should return number of characters written.\"\"\"\n    assert sys.stderr.write(\"Foo\") == 3\n\n\ndef test_encodedfile_writelines(tmpfile: BinaryIO) -> None:\n    ef = capture.EncodedFile(tmpfile, encoding=\"utf-8\")\n    with pytest.raises(TypeError):\n        ef.writelines([b\"line1\", b\"line2\"])\n    assert ef.writelines([\"line3\", \"line4\"]) is None  # type: ignore[func-returns-value]  # noqa: F821\n    ef.flush()\n    tmpfile.seek(0)\n    assert tmpfile.read() == b\"line3line4\"\n    tmpfile.close()\n    with pytest.raises(ValueError):\n        ef.read()\n\n\ndef test__get_multicapture() -> None:\n    assert isinstance(_get_multicapture(\"no\"), MultiCapture)\n    pytest.raises(ValueError, _get_multicapture, \"unknown\").match(\n        r\"^unknown capturing method: 'unknown'\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollector.test_getparent_TestCollector.test_can_skip_class_with_test_attr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollector.test_getparent_TestCollector.test_can_skip_class_with_test_attr", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 53, "end_line": 105, "span_ids": ["TestCollector.test_can_skip_class_with_test_attr", "TestCollector.test_getcustomfile_roundtrip", "TestCollector.test_getparent"], "tokens": 387}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCollector:\n\n    def test_getparent(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            class TestClass:\n                 def test_foo(self):\n                     pass\n        \"\"\"\n        )\n        cls = testdir.collect_by_name(modcol, \"TestClass\")\n        fn = testdir.collect_by_name(testdir.collect_by_name(cls, \"()\"), \"test_foo\")\n\n        parent = fn.getparent(pytest.Module)\n        assert parent is modcol\n\n        parent = fn.getparent(pytest.Function)\n        assert parent is fn\n\n        parent = fn.getparent(pytest.Class)\n        assert parent is cls\n\n    def test_getcustomfile_roundtrip(self, testdir):\n        hello = testdir.makefile(\".xxx\", hello=\"world\")\n        testdir.makepyfile(\n            conftest=\"\"\"\n            import pytest\n            class CustomFile(pytest.File):\n                pass\n            def pytest_collect_file(path, parent):\n                if path.ext == \".xxx\":\n                    return CustomFile.from_parent(fspath=path, parent=parent)\n        \"\"\"\n        )\n        node = testdir.getpathnode(hello)\n        assert isinstance(node, pytest.File)\n        assert node.name == \"hello.xxx\"\n        nodes = node.session.perform_collect([node.nodeid], genitems=False)\n        assert len(nodes) == 1\n        assert isinstance(nodes[0], pytest.File)\n\n    def test_can_skip_class_with_test_attr(self, testdir):\n        \"\"\"Assure test class is skipped when using `__test__=False` (See #2007).\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            class TestFoo(object):\n                __test__ = False\n                def __init__(self):\n                    pass\n                def test_foo():\n                    assert True\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"collected 0 items\", \"*no tests ran in*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test_ignored_virtualenvs_norecursedirs_precedence_TestCollectFS.test_ignored_virtualenvs_norecursedirs_precedence": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test_ignored_virtualenvs_norecursedirs_precedence_TestCollectFS.test_ignored_virtualenvs_norecursedirs_precedence", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 154, "end_line": 175, "span_ids": ["TestCollectFS.test_ignored_virtualenvs_norecursedirs_precedence"], "tokens": 212}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCollectFS:\n\n    @pytest.mark.parametrize(\n        \"fname\",\n        (\n            \"activate\",\n            \"activate.csh\",\n            \"activate.fish\",\n            \"Activate\",\n            \"Activate.bat\",\n            \"Activate.ps1\",\n        ),\n    )\n    def test_ignored_virtualenvs_norecursedirs_precedence(self, testdir, fname):\n        bindir = \"Scripts\" if sys.platform.startswith(\"win\") else \"bin\"\n        # norecursedirs takes priority\n        testdir.tmpdir.ensure(\".virtual\", bindir, fname)\n        testfile = testdir.tmpdir.ensure(\".virtual\", \"test_invenv.py\")\n        testfile.write(\"def test_hello(): pass\")\n        result = testdir.runpytest(\"--collect-in-virtualenv\")\n        result.stdout.no_fnmatch_line(\"*test_invenv*\")\n        # ...unless the virtualenv is explicitly given on the CLI\n        result = testdir.runpytest(\"--collect-in-virtualenv\", \".virtual\")\n        assert \"test_invenv\" in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test__in_venv_TestCollectFS.test_custom_norecursedirs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test__in_venv_TestCollectFS.test_custom_norecursedirs", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 173, "end_line": 208, "span_ids": ["TestCollectFS.test__in_venv", "TestCollectFS.test_custom_norecursedirs"], "tokens": 319}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCollectFS:\n\n    @pytest.mark.parametrize(\n        \"fname\",\n        (\n            \"activate\",\n            \"activate.csh\",\n            \"activate.fish\",\n            \"Activate\",\n            \"Activate.bat\",\n            \"Activate.ps1\",\n        ),\n    )\n    def test__in_venv(self, testdir, fname):\n        \"\"\"Directly test the virtual env detection function\"\"\"\n        bindir = \"Scripts\" if sys.platform.startswith(\"win\") else \"bin\"\n        # no bin/activate, not a virtualenv\n        base_path = testdir.tmpdir.mkdir(\"venv\")\n        assert _in_venv(base_path) is False\n        # with bin/activate, totally a virtualenv\n        base_path.ensure(bindir, fname)\n        assert _in_venv(base_path) is True\n\n    def test_custom_norecursedirs(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            norecursedirs = mydir xyz*\n        \"\"\"\n        )\n        tmpdir = testdir.tmpdir\n        tmpdir.ensure(\"mydir\", \"test_hello.py\").write(\"def test_1(): pass\")\n        tmpdir.ensure(\"xyz123\", \"test_2.py\").write(\"def test_2(): 0/0\")\n        tmpdir.ensure(\"xy\", \"test_ok.py\").write(\"def test_3(): pass\")\n        rec = testdir.inline_run()\n        rec.assertoutcome(passed=1)\n        rec = testdir.inline_run(\"xyz123/test_2.py\")\n        rec.assertoutcome(failed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestPrunetraceback_TestPrunetraceback.test_collect_report_postprocessing": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestPrunetraceback_TestPrunetraceback.test_collect_report_postprocessing", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 270, "end_line": 316, "span_ids": ["TestPrunetraceback", "TestPrunetraceback.test_collect_report_postprocessing", "TestPrunetraceback.test_custom_repr_failure"], "tokens": 296}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPrunetraceback:\n    def test_custom_repr_failure(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import not_exists\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_collect_file(path, parent):\n                return MyFile(path, parent)\n            class MyError(Exception):\n                pass\n            class MyFile(pytest.File):\n                def collect(self):\n                    raise MyError()\n                def repr_failure(self, excinfo):\n                    if excinfo.errisinstance(MyError):\n                        return \"hello world\"\n                    return pytest.File.repr_failure(self, excinfo)\n        \"\"\"\n        )\n\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"*ERROR collecting*\", \"*hello world*\"])\n\n    @pytest.mark.xfail(reason=\"other mechanism for adding to reporting needed\")\n    def test_collect_report_postprocessing(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import not_exists\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.hookimpl(hookwrapper=True)\n            def pytest_make_collect_report():\n                outcome = yield\n                rep = outcome.get_result()\n                rep.headerlines += [\"header1\"]\n                outcome.force_result(rep)\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"*ERROR collecting*\", \"*header1*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCustomConftests_TestCustomConftests.test_pytest_fs_collect_hooks_are_seen": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCustomConftests_TestCustomConftests.test_pytest_fs_collect_hooks_are_seen", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 324, "end_line": 411, "span_ids": ["TestCustomConftests", "TestCustomConftests.test_collectignore_exclude_on_option", "TestCustomConftests.test_collectignoreglob_exclude_on_option", "TestCustomConftests.test_ignore_collect_not_called_on_argument", "TestCustomConftests.test_ignore_collect_path", "TestCustomConftests.test_pytest_fs_collect_hooks_are_seen"], "tokens": 727}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCustomConftests:\n    def test_ignore_collect_path(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_ignore_collect(path, config):\n                return path.basename.startswith(\"x\") or \\\n                       path.basename == \"test_one.py\"\n        \"\"\"\n        )\n        sub = testdir.mkdir(\"xy123\")\n        sub.ensure(\"test_hello.py\").write(\"syntax error\")\n        sub.join(\"conftest.py\").write(\"syntax error\")\n        testdir.makepyfile(\"def test_hello(): pass\")\n        testdir.makepyfile(test_one=\"syntax error\")\n        result = testdir.runpytest(\"--fulltrace\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_ignore_collect_not_called_on_argument(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_ignore_collect(path, config):\n                return True\n        \"\"\"\n        )\n        p = testdir.makepyfile(\"def test_hello(): pass\")\n        result = testdir.runpytest(p)\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result = testdir.runpytest()\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.fnmatch_lines([\"*collected 0 items*\"])\n\n    def test_collectignore_exclude_on_option(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            collect_ignore = ['hello', 'test_world.py']\n            def pytest_addoption(parser):\n                parser.addoption(\"--XX\", action=\"store_true\", default=False)\n            def pytest_configure(config):\n                if config.getvalue(\"XX\"):\n                    collect_ignore[:] = []\n        \"\"\"\n        )\n        testdir.mkdir(\"hello\")\n        testdir.makepyfile(test_world=\"def test_hello(): pass\")\n        result = testdir.runpytest()\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.no_fnmatch_line(\"*passed*\")\n        result = testdir.runpytest(\"--XX\")\n        assert result.ret == 0\n        assert \"passed\" in result.stdout.str()\n\n    def test_collectignoreglob_exclude_on_option(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            collect_ignore_glob = ['*w*l[dt]*']\n            def pytest_addoption(parser):\n                parser.addoption(\"--XX\", action=\"store_true\", default=False)\n            def pytest_configure(config):\n                if config.getvalue(\"XX\"):\n                    collect_ignore_glob[:] = []\n        \"\"\"\n        )\n        testdir.makepyfile(test_world=\"def test_hello(): pass\")\n        testdir.makepyfile(test_welt=\"def test_hallo(): pass\")\n        result = testdir.runpytest()\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.fnmatch_lines([\"*collected 0 items*\"])\n        result = testdir.runpytest(\"--XX\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n    def test_pytest_fs_collect_hooks_are_seen(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule(pytest.Module):\n                pass\n            def pytest_collect_file(path, parent):\n                if path.ext == \".py\":\n                    return MyModule(path, parent)\n        \"\"\"\n        )\n        testdir.mkdir(\"sub\")\n        testdir.makepyfile(\"def test_x(): pass\")\n        result = testdir.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCustomConftests.test_pytest_collect_file_from_sister_dir_TestCustomConftests.test_pytest_collect_file_from_sister_dir.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCustomConftests.test_pytest_collect_file_from_sister_dir_TestCustomConftests.test_pytest_collect_file_from_sister_dir.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 413, "end_line": 442, "span_ids": ["TestCustomConftests.test_pytest_collect_file_from_sister_dir"], "tokens": 235}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCustomConftests:\n\n    def test_pytest_collect_file_from_sister_dir(self, testdir):\n        sub1 = testdir.mkpydir(\"sub1\")\n        sub2 = testdir.mkpydir(\"sub2\")\n        conf1 = testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule1(pytest.Module):\n                pass\n            def pytest_collect_file(path, parent):\n                if path.ext == \".py\":\n                    return MyModule1(path, parent)\n        \"\"\"\n        )\n        conf1.move(sub1.join(conf1.basename))\n        conf2 = testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class MyModule2(pytest.Module):\n                pass\n            def pytest_collect_file(path, parent):\n                if path.ext == \".py\":\n                    return MyModule2(path, parent)\n        \"\"\"\n        )\n        conf2.move(sub2.join(conf2.basename))\n        p = testdir.makepyfile(\"def test_x(): pass\")\n        p.copy(sub1.join(p.basename))\n        p.copy(sub2.join(p.basename))\n        result = testdir.runpytest(\"--co\")\n        result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession_TestSession.get_reported_items": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession_TestSession.get_reported_items", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 445, "end_line": 488, "span_ids": ["TestSession", "TestSession.get_reported_items", "TestSession.test_collect_topdir", "TestSession.test_parsearg"], "tokens": 403}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSession:\n    def test_parsearg(self, testdir) -> None:\n        p = testdir.makepyfile(\"def test_func(): pass\")\n        subdir = testdir.mkdir(\"sub\")\n        subdir.ensure(\"__init__.py\")\n        target = subdir.join(p.basename)\n        p.move(target)\n        subdir.chdir()\n        config = testdir.parseconfig(p.basename)\n        rcol = Session.from_config(config)\n        assert rcol.fspath == subdir\n        fspath, parts = rcol._parsearg(p.basename)\n\n        assert fspath == target\n        assert len(parts) == 0\n        fspath, parts = rcol._parsearg(p.basename + \"::test_func\")\n        assert fspath == target\n        assert parts[0] == \"test_func\"\n        assert len(parts) == 1\n\n    def test_collect_topdir(self, testdir):\n        p = testdir.makepyfile(\"def test_func(): pass\")\n        id = \"::\".join([p.basename, \"test_func\"])\n        # XXX migrate to collectonly? (see below)\n        config = testdir.parseconfig(id)\n        topdir = testdir.tmpdir\n        rcol = Session.from_config(config)\n        assert topdir == rcol.fspath\n        # rootid = rcol.nodeid\n        # root2 = rcol.perform_collect([rcol.nodeid], genitems=False)[0]\n        # assert root2 == rcol, rootid\n        colitems = rcol.perform_collect([rcol.nodeid], genitems=False)\n        assert len(colitems) == 1\n        assert colitems[0].fspath == p\n\n    def get_reported_items(self, hookrec):\n        \"\"\"Return pytest.Item instances reported by the pytest_collectreport hook\"\"\"\n        calls = hookrec.getcalls(\"pytest_collectreport\")\n        return [\n            x\n            for call in calls\n            for x in call.report.result\n            if isinstance(x, pytest.Item)\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_protocol_single_function_TestSession.test_collect_protocol_method": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_protocol_single_function_TestSession.test_collect_protocol_method", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 490, "end_line": 529, "span_ids": ["TestSession.test_collect_protocol_method", "TestSession.test_collect_protocol_single_function"], "tokens": 409}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSession:\n\n    def test_collect_protocol_single_function(self, testdir):\n        p = testdir.makepyfile(\"def test_func(): pass\")\n        id = \"::\".join([p.basename, \"test_func\"])\n        items, hookrec = testdir.inline_genitems(id)\n        (item,) = items\n        assert item.name == \"test_func\"\n        newid = item.nodeid\n        assert newid == id\n        pprint.pprint(hookrec.calls)\n        topdir = testdir.tmpdir  # noqa\n        hookrec.assert_contains(\n            [\n                (\"pytest_collectstart\", \"collector.fspath == topdir\"),\n                (\"pytest_make_collect_report\", \"collector.fspath == topdir\"),\n                (\"pytest_collectstart\", \"collector.fspath == p\"),\n                (\"pytest_make_collect_report\", \"collector.fspath == p\"),\n                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                (\"pytest_collectreport\", \"report.result[0].name == 'test_func'\"),\n            ]\n        )\n        # ensure we are reporting the collection of the single test item (#2464)\n        assert [x.name for x in self.get_reported_items(hookrec)] == [\"test_func\"]\n\n    def test_collect_protocol_method(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            class TestClass(object):\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        normid = p.basename + \"::TestClass::test_method\"\n        for id in [p.basename, p.basename + \"::TestClass\", normid]:\n            items, hookrec = testdir.inline_genitems(id)\n            assert len(items) == 1\n            assert items[0].name == \"test_method\"\n            newid = items[0].nodeid\n            assert newid == normid\n            # ensure we are reporting the collection of the single test item (#2464)\n            assert [x.name for x in self.get_reported_items(hookrec)] == [\"test_method\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_custom_nodes_multi_id_TestSession.test_collect_custom_nodes_multi_id.assert_len_self_get_repor": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_custom_nodes_multi_id_TestSession.test_collect_custom_nodes_multi_id.assert_len_self_get_repor", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 526, "end_line": 560, "span_ids": ["TestSession.test_collect_custom_nodes_multi_id"], "tokens": 266}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSession:\n\n    def test_collect_custom_nodes_multi_id(self, testdir):\n        p = testdir.makepyfile(\"def test_func(): pass\")\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            class SpecialItem(pytest.Item):\n                def runtest(self):\n                    return # ok\n            class SpecialFile(pytest.File):\n                def collect(self):\n                    return [SpecialItem(name=\"check\", parent=self)]\n            def pytest_collect_file(path, parent):\n                if path.basename == %r:\n                    return SpecialFile(fspath=path, parent=parent)\n        \"\"\"\n            % p.basename\n        )\n        id = p.basename\n\n        items, hookrec = testdir.inline_genitems(id)\n        pprint.pprint(hookrec.calls)\n        assert len(items) == 2\n        hookrec.assert_contains(\n            [\n                (\"pytest_collectstart\", \"collector.fspath == collector.session.fspath\"),\n                (\n                    \"pytest_collectstart\",\n                    \"collector.__class__.__name__ == 'SpecialFile'\",\n                ),\n                (\"pytest_collectstart\", \"collector.__class__.__name__ == 'Module'\"),\n                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                (\"pytest_collectreport\", \"report.nodeid.startswith(p.basename)\"),\n            ]\n        )\n        assert len(self.get_reported_items(hookrec)) == 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_subdir_event_ordering_TestSession.test_collect_two_commandline_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_collect_subdir_event_ordering_TestSession.test_collect_two_commandline_args", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 562, "end_line": 602, "span_ids": ["TestSession.test_collect_subdir_event_ordering", "TestSession.test_collect_two_commandline_args"], "tokens": 390}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSession:\n\n    def test_collect_subdir_event_ordering(self, testdir):\n        p = testdir.makepyfile(\"def test_func(): pass\")\n        aaa = testdir.mkpydir(\"aaa\")\n        test_aaa = aaa.join(\"test_aaa.py\")\n        p.move(test_aaa)\n\n        items, hookrec = testdir.inline_genitems()\n        assert len(items) == 1\n        pprint.pprint(hookrec.calls)\n        hookrec.assert_contains(\n            [\n                (\"pytest_collectstart\", \"collector.fspath == test_aaa\"),\n                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                (\"pytest_collectreport\", \"report.nodeid.startswith('aaa/test_aaa.py')\"),\n            ]\n        )\n\n    def test_collect_two_commandline_args(self, testdir):\n        p = testdir.makepyfile(\"def test_func(): pass\")\n        aaa = testdir.mkpydir(\"aaa\")\n        bbb = testdir.mkpydir(\"bbb\")\n        test_aaa = aaa.join(\"test_aaa.py\")\n        p.copy(test_aaa)\n        test_bbb = bbb.join(\"test_bbb.py\")\n        p.move(test_bbb)\n\n        id = \".\"\n\n        items, hookrec = testdir.inline_genitems(id)\n        assert len(items) == 2\n        pprint.pprint(hookrec.calls)\n        hookrec.assert_contains(\n            [\n                (\"pytest_collectstart\", \"collector.fspath == test_aaa\"),\n                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                (\"pytest_collectreport\", \"report.nodeid == 'aaa/test_aaa.py'\"),\n                (\"pytest_collectstart\", \"collector.fspath == test_bbb\"),\n                (\"pytest_pycollect_makeitem\", \"name == 'test_func'\"),\n                (\"pytest_collectreport\", \"report.nodeid == 'bbb/test_bbb.py'\"),\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_serialization_byid_TestSession.test_find_byid_without_instance_parents": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestSession.test_serialization_byid_TestSession.test_find_byid_without_instance_parents", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 609, "end_line": 633, "span_ids": ["TestSession.test_find_byid_without_instance_parents", "TestSession.test_serialization_byid"], "tokens": 231}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSession:\n\n    def test_serialization_byid(self, testdir):\n        testdir.makepyfile(\"def test_func(): pass\")\n        items, hookrec = testdir.inline_genitems()\n        assert len(items) == 1\n        (item,) = items\n        items2, hookrec = testdir.inline_genitems(item.nodeid)\n        (item2,) = items2\n        assert item2.name == item.name\n        assert item2.fspath == item.fspath\n\n    def test_find_byid_without_instance_parents(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            class TestClass(object):\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        arg = p.basename + \"::TestClass::test_method\"\n        items, hookrec = testdir.inline_genitems(arg)\n        assert len(items) == 1\n        (item,) = items\n        assert item.nodeid.endswith(\"TestClass::test_method\")\n        # ensure we are reporting the collection of the single test item (#2464)\n        assert [x.name for x in self.get_reported_items(hookrec)] == [\"test_method\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_Test_getinitialnodes_Test_getinitialnodes.test_pkgfile": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_Test_getinitialnodes_Test_getinitialnodes.test_pkgfile", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 631, "end_line": 662, "span_ids": ["Test_getinitialnodes", "Test_getinitialnodes.test_global_file", "Test_getinitialnodes.test_pkgfile"], "tokens": 280}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Test_getinitialnodes:\n    def test_global_file(self, testdir, tmpdir):\n        x = tmpdir.ensure(\"x.py\")\n        with tmpdir.as_cwd():\n            config = testdir.parseconfigure(x)\n        col = testdir.getnode(config, x)\n        assert isinstance(col, pytest.Module)\n        assert col.name == \"x.py\"\n        assert col.parent.parent is None\n        for col in col.listchain():\n            assert col.config is config\n\n    def test_pkgfile(self, testdir):\n        \"\"\"Verify nesting when a module is within a package.\n        The parent chain should match: Module<x.py> -> Package<subdir> -> Session.\n            Session's parent should always be None.\n        \"\"\"\n        tmpdir = testdir.tmpdir\n        subdir = tmpdir.join(\"subdir\")\n        x = subdir.ensure(\"x.py\")\n        subdir.ensure(\"__init__.py\")\n        with subdir.as_cwd():\n            config = testdir.parseconfigure(x)\n        col = testdir.getnode(config, x)\n        assert col.name == \"x.py\"\n        assert isinstance(col, pytest.Module)\n        assert isinstance(col.parent, pytest.Package)\n        assert isinstance(col.parent.parent, pytest.Session)\n        # session is batman (has no parents)\n        assert col.parent.parent.parent is None\n        for col in col.listchain():\n            assert col.config is config", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_Test_genitems_Test_genitems.test_class_and_functions_discovery_using_glob.assert_ids_MyTestSui": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_Test_genitems_Test_genitems.test_class_and_functions_discovery_using_glob.assert_ids_MyTestSui", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 670, "end_line": 751, "span_ids": ["Test_genitems", "Test_genitems.test_check_collect_hashes", "Test_genitems.test_class_and_functions_discovery_using_glob", "Test_genitems.test_example_items1"], "tokens": 568}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Test_genitems:\n    def test_check_collect_hashes(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                pass\n\n            def test_2():\n                pass\n        \"\"\"\n        )\n        p.copy(p.dirpath(p.purebasename + \"2\" + \".py\"))\n        items, reprec = testdir.inline_genitems(p.dirpath())\n        assert len(items) == 4\n        for numi, i in enumerate(items):\n            for numj, j in enumerate(items):\n                if numj != numi:\n                    assert hash(i) != hash(j)\n                    assert i != j\n\n    def test_example_items1(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def testone():\n                pass\n\n            class TestX(object):\n                def testmethod_one(self):\n                    pass\n\n            class TestY(TestX):\n                @pytest.mark.parametrize(\"arg0\", [\".[\"])\n                def testmethod_two(self, arg0):\n                    pass\n        \"\"\"\n        )\n        items, reprec = testdir.inline_genitems(p)\n        assert len(items) == 4\n        assert items[0].name == \"testone\"\n        assert items[1].name == \"testmethod_one\"\n        assert items[2].name == \"testmethod_one\"\n        assert items[3].name == \"testmethod_two[.[]\"\n\n        # let's also test getmodpath here\n        assert items[0].getmodpath() == \"testone\"\n        assert items[1].getmodpath() == \"TestX.testmethod_one\"\n        assert items[2].getmodpath() == \"TestY.testmethod_one\"\n        # PR #6202: Fix incorrect result of getmodpath method. (Resolves issue #6189)\n        assert items[3].getmodpath() == \"TestY.testmethod_two[.[]\"\n\n        s = items[0].getmodpath(stopatmodule=False)\n        assert s.endswith(\"test_example_items1.testone\")\n        print(s)\n\n    def test_class_and_functions_discovery_using_glob(self, testdir):\n        \"\"\"\n        tests that python_classes and python_functions config options work\n        as prefixes and glob-like patterns (issue #600).\n        \"\"\"\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            python_classes = *Suite Test\n            python_functions = *_test test\n        \"\"\"\n        )\n        p = testdir.makepyfile(\n            \"\"\"\n            class MyTestSuite(object):\n                def x_test(self):\n                    pass\n\n            class TestCase(object):\n                def test_y(self):\n                    pass\n        \"\"\"\n        )\n        items, reprec = testdir.inline_genitems(p)\n        ids = [x.getmodpath() for x in items]\n        assert ids == [\"MyTestSuite.x_test\", \"TestCase.test_y\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_matchnodes_two_collections_same_file_test_matchnodes_two_collections_same_file.res_stdout_fnmatch_lines_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_matchnodes_two_collections_same_file_test_matchnodes_two_collections_same_file.res_stdout_fnmatch_lines_", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 749, "end_line": 782, "span_ids": ["test_matchnodes_two_collections_same_file"], "tokens": 226}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_matchnodes_two_collections_same_file(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        def pytest_configure(config):\n            config.pluginmanager.register(Plugin2())\n\n        class Plugin2(object):\n            def pytest_collect_file(self, path, parent):\n                if path.ext == \".abc\":\n                    return MyFile2(path, parent)\n\n        def pytest_collect_file(path, parent):\n            if path.ext == \".abc\":\n                return MyFile1(path, parent)\n\n        class MyFile1(pytest.Item, pytest.File):\n            def runtest(self):\n                pass\n        class MyFile2(pytest.File):\n            def collect(self):\n                return [Item2(\"hello\", parent=self)]\n\n        class Item2(pytest.Item):\n            def runtest(self):\n                pass\n    \"\"\"\n    )\n    p = testdir.makefile(\".abc\", \"\")\n    result = testdir.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n    res = testdir.runpytest(\"%s::hello\" % p.basename)\n    res.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_invalid_signature_message_test_collect_handles_raising_on_dunder_class": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_invalid_signature_message_test_collect_handles_raising_on_dunder_class", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1014, "end_line": 1058, "span_ids": ["test_collect_handles_raising_on_dunder_class", "test_collect_invalid_signature_message"], "tokens": 241}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collect_invalid_signature_message(testdir):\n    \"\"\"Check that we issue a proper message when we can't determine the signature of a test\n    function (#4026).\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        class TestCase:\n            @pytest.fixture\n            def fix():\n                pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\"Could not determine arguments of *.fix *: invalid method signature\"]\n    )\n\n\ndef test_collect_handles_raising_on_dunder_class(testdir):\n    \"\"\"Handle proxy classes like Django's LazySettings that might raise on\n    ``isinstance`` (#4266).\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        class ImproperlyConfigured(Exception):\n            pass\n\n        class RaisesOnGetAttr(object):\n            def raises(self):\n                raise ImproperlyConfigured\n\n            __class__ = property(raises)\n\n        raises = RaisesOnGetAttr()\n\n\n        def test_1():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 passed in*\"])\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_with_chdir_during_import_test_collect_with_chdir_during_import.None_4": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_with_chdir_during_import_test_collect_with_chdir_during_import.None_4", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1061, "end_line": 1094, "span_ids": ["test_collect_with_chdir_during_import"], "tokens": 201}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collect_with_chdir_during_import(testdir):\n    subdir = testdir.tmpdir.mkdir(\"sub\")\n    testdir.tmpdir.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\n            import os\n            os.chdir(%r)\n            \"\"\"\n            % (str(subdir),)\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        def test_1():\n            import os\n            assert os.getcwd() == %r\n        \"\"\"\n        % (str(subdir),)\n    )\n    with testdir.tmpdir.as_cwd():\n        result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 passed in*\"])\n    assert result.ret == 0\n\n    # Handles relative testpaths.\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        testpaths = .\n    \"\"\"\n    )\n    with testdir.tmpdir.as_cwd():\n        result = testdir.runpytest(\"--collect-only\")\n    result.stdout.fnmatch_lines([\"collected 1 item\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pyargs_with_testpaths_test_collect_symlink_file_arg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pyargs_with_testpaths_test_collect_symlink_file_arg", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1097, "end_line": 1135, "span_ids": ["test_collect_pyargs_with_testpaths", "test_collect_symlink_file_arg"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collect_pyargs_with_testpaths(testdir, monkeypatch):\n    testmod = testdir.mkdir(\"testmod\")\n    # NOTE: __init__.py is not collected since it does not match python_files.\n    testmod.ensure(\"__init__.py\").write(\"def test_func(): pass\")\n    testmod.ensure(\"test_file.py\").write(\"def test_func(): pass\")\n\n    root = testdir.mkdir(\"root\")\n    root.ensure(\"pytest.ini\").write(\n        textwrap.dedent(\n            \"\"\"\n        [pytest]\n        addopts = --pyargs\n        testpaths = testmod\n    \"\"\"\n        )\n    )\n    monkeypatch.setenv(\"PYTHONPATH\", str(testdir.tmpdir), prepend=os.pathsep)\n    with root.as_cwd():\n        result = testdir.runpytest_subprocess()\n    result.stdout.fnmatch_lines([\"*1 passed in*\"])\n\n\n@pytest.mark.skipif(\n    not hasattr(py.path.local, \"mksymlinkto\"),\n    reason=\"symlink not available on this platform\",\n)\ndef test_collect_symlink_file_arg(testdir):\n    \"\"\"Test that collecting a direct symlink, where the target does not match python_files works (#4325).\"\"\"\n    real = testdir.makepyfile(\n        real=\"\"\"\n        def test_nodeid(request):\n            assert request.node.nodeid == \"real.py::test_nodeid\"\n        \"\"\"\n    )\n    symlink = testdir.tmpdir.join(\"symlink.py\")\n    symlink.mksymlinkto(real)\n    result = testdir.runpytest(\"-v\", symlink)\n    result.stdout.fnmatch_lines([\"real.py::test_nodeid PASSED*\", \"*1 passed in*\"])\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_symlink_out_of_tree_test_collectignore_via_conftest": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_symlink_out_of_tree_test_collectignore_via_conftest", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1185, "end_line": 1228, "span_ids": ["test_collect_symlink_out_of_tree", "test_collectignore_via_conftest"], "tokens": 357}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.skipif(\n    not hasattr(py.path.local, \"mksymlinkto\"),\n    reason=\"symlink not available on this platform\",\n)\ndef test_collect_symlink_out_of_tree(testdir):\n    \"\"\"Test collection of symlink via out-of-tree rootdir.\"\"\"\n    sub = testdir.tmpdir.join(\"sub\")\n    real = sub.join(\"test_real.py\")\n    real.write(\n        textwrap.dedent(\n            \"\"\"\n        def test_nodeid(request):\n            # Should not contain sub/ prefix.\n            assert request.node.nodeid == \"test_real.py::test_nodeid\"\n        \"\"\"\n        ),\n        ensure=True,\n    )\n\n    out_of_tree = testdir.tmpdir.join(\"out_of_tree\").ensure(dir=True)\n    symlink_to_sub = out_of_tree.join(\"symlink_to_sub\")\n    symlink_to_sub.mksymlinkto(sub)\n    sub.chdir()\n    result = testdir.runpytest(\"-vs\", \"--rootdir=%s\" % sub, symlink_to_sub)\n    result.stdout.fnmatch_lines(\n        [\n            # Should not contain \"sub/\"!\n            \"test_real.py::test_nodeid PASSED\"\n        ]\n    )\n    assert result.ret == 0\n\n\ndef test_collectignore_via_conftest(testdir):\n    \"\"\"collect_ignore in parent conftest skips importing child (issue #4592).\"\"\"\n    tests = testdir.mkpydir(\"tests\")\n    tests.ensure(\"conftest.py\").write(\"collect_ignore = ['ignore_me']\")\n\n    ignore_me = tests.mkdir(\"ignore_me\")\n    ignore_me.ensure(\"__init__.py\")\n    ignore_me.ensure(\"conftest.py\").write(\"assert 0, 'should_not_be_called'\")\n\n    result = testdir.runpytest()\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigCmdlineParsing_TestConfigCmdlineParsing.test_absolute_win32_path": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigCmdlineParsing_TestConfigCmdlineParsing.test_absolute_win32_path", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 146, "end_line": 196, "span_ids": ["TestConfigCmdlineParsing", "TestConfigCmdlineParsing.test_absolute_win32_path", "TestConfigCmdlineParsing.test_explicitly_specified_config_file_is_loaded", "TestConfigCmdlineParsing.test_parsing_again_fails"], "tokens": 306}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConfigCmdlineParsing:\n    def test_parsing_again_fails(self, testdir):\n        config = testdir.parseconfig()\n        pytest.raises(AssertionError, lambda: config.parse([]))\n\n    def test_explicitly_specified_config_file_is_loaded(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"custom\", \"\")\n        \"\"\"\n        )\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            custom = 0\n        \"\"\"\n        )\n        testdir.makefile(\n            \".ini\",\n            custom=\"\"\"\n            [pytest]\n            custom = 1\n        \"\"\",\n        )\n        config = testdir.parseconfig(\"-c\", \"custom.ini\")\n        assert config.getini(\"custom\") == \"1\"\n\n        testdir.makefile(\n            \".cfg\",\n            custom_tool_pytest_section=\"\"\"\n            [tool:pytest]\n            custom = 1\n        \"\"\",\n        )\n        config = testdir.parseconfig(\"-c\", \"custom_tool_pytest_section.cfg\")\n        assert config.getini(\"custom\") == \"1\"\n\n    def test_absolute_win32_path(self, testdir):\n        temp_ini_file = testdir.makefile(\n            \".ini\",\n            custom=\"\"\"\n            [pytest]\n            addopts = --version\n        \"\"\",\n        )\n        from os.path import normpath\n\n        temp_ini_file = normpath(str(temp_ini_file))\n        ret = pytest.main([\"-c\", temp_ini_file])\n        assert ret == ExitCode.OK", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI_TestConfigAPI.test_addini": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI_TestConfigAPI.test_addini", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 199, "end_line": 281, "span_ids": ["TestConfigAPI", "TestConfigAPI.test_addini", "TestConfigAPI.test_config_getoption", "TestConfigAPI.test_config_getoption_unicode", "TestConfigAPI.test_config_getvalueorskip", "TestConfigAPI.test_config_getvalueorskip_None", "TestConfigAPI.test_config_trace", "TestConfigAPI.test_getconftest_pathlist", "TestConfigAPI.test_getoption"], "tokens": 632}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConfigAPI:\n    def test_config_trace(self, testdir):\n        config = testdir.parseconfig()\n        values = []\n        config.trace.root.setwriter(values.append)\n        config.trace(\"hello\")\n        assert len(values) == 1\n        assert values[0] == \"hello [config]\\n\"\n\n    def test_config_getoption(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addoption(\"--hello\", \"-X\", dest=\"hello\")\n        \"\"\"\n        )\n        config = testdir.parseconfig(\"--hello=this\")\n        for x in (\"hello\", \"--hello\", \"-X\"):\n            assert config.getoption(x) == \"this\"\n        pytest.raises(ValueError, config.getoption, \"qweqwe\")\n\n    def test_config_getoption_unicode(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addoption('--hello', type=str)\n        \"\"\"\n        )\n        config = testdir.parseconfig(\"--hello=this\")\n        assert config.getoption(\"hello\") == \"this\"\n\n    def test_config_getvalueorskip(self, testdir):\n        config = testdir.parseconfig()\n        pytest.raises(pytest.skip.Exception, config.getvalueorskip, \"hello\")\n        verbose = config.getvalueorskip(\"verbose\")\n        assert verbose == config.option.verbose\n\n    def test_config_getvalueorskip_None(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addoption(\"--hello\")\n        \"\"\"\n        )\n        config = testdir.parseconfig()\n        with pytest.raises(pytest.skip.Exception):\n            config.getvalueorskip(\"hello\")\n\n    def test_getoption(self, testdir):\n        config = testdir.parseconfig()\n        with pytest.raises(ValueError):\n            config.getvalue(\"x\")\n        assert config.getoption(\"x\", 1) == 1\n\n    def test_getconftest_pathlist(self, testdir, tmpdir):\n        somepath = tmpdir.join(\"x\", \"y\", \"z\")\n        p = tmpdir.join(\"conftest.py\")\n        p.write(\"pathlist = ['.', %r]\" % str(somepath))\n        config = testdir.parseconfigure(p)\n        assert config._getconftest_pathlist(\"notexist\", path=tmpdir) is None\n        pl = config._getconftest_pathlist(\"pathlist\", path=tmpdir)\n        print(pl)\n        assert len(pl) == 2\n        assert pl[0] == tmpdir\n        assert pl[1] == somepath\n\n    def test_addini(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"myname\", \"my new ini value\")\n        \"\"\"\n        )\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            myname=hello\n        \"\"\"\n        )\n        config = testdir.parseconfig()\n        val = config.getini(\"myname\")\n        assert val == \"hello\"\n        pytest.raises(ValueError, config.getini, \"other\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI.test_addini_pathlist_TestConfigAPI.test_addinivalue_line_existing": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI.test_addini_pathlist_TestConfigAPI.test_addinivalue_line_existing", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 283, "end_line": 388, "span_ids": ["TestConfigAPI.test_addini_args", "TestConfigAPI.test_addini_bool", "TestConfigAPI.test_addini_linelist", "TestConfigAPI.test_addini_pathlist", "TestConfigAPI.test_addinivalue_line_existing"], "tokens": 728}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConfigAPI:\n\n    def test_addini_pathlist(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"paths\", \"my new ini value\", type=\"pathlist\")\n                parser.addini(\"abc\", \"abc value\")\n        \"\"\"\n        )\n        p = testdir.makeini(\n            \"\"\"\n            [pytest]\n            paths=hello world/sub.py\n        \"\"\"\n        )\n        config = testdir.parseconfig()\n        values = config.getini(\"paths\")\n        assert len(values) == 2\n        assert values[0] == p.dirpath(\"hello\")\n        assert values[1] == p.dirpath(\"world/sub.py\")\n        pytest.raises(ValueError, config.getini, \"other\")\n\n    def test_addini_args(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"args\", \"new args\", type=\"args\")\n                parser.addini(\"a2\", \"\", \"args\", default=\"1 2 3\".split())\n        \"\"\"\n        )\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            args=123 \"123 hello\" \"this\"\n        \"\"\"\n        )\n        config = testdir.parseconfig()\n        values = config.getini(\"args\")\n        assert len(values) == 3\n        assert values == [\"123\", \"123 hello\", \"this\"]\n        values = config.getini(\"a2\")\n        assert values == list(\"123\")\n\n    def test_addini_linelist(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"xy\", \"\", type=\"linelist\")\n                parser.addini(\"a2\", \"\", \"linelist\")\n        \"\"\"\n        )\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            xy= 123 345\n                second line\n        \"\"\"\n        )\n        config = testdir.parseconfig()\n        values = config.getini(\"xy\")\n        assert len(values) == 2\n        assert values == [\"123 345\", \"second line\"]\n        values = config.getini(\"a2\")\n        assert values == []\n\n    @pytest.mark.parametrize(\n        \"str_val, bool_val\", [(\"True\", True), (\"no\", False), (\"no-ini\", True)]\n    )\n    def test_addini_bool(self, testdir, str_val, bool_val):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"strip\", \"\", type=\"bool\", default=True)\n        \"\"\"\n        )\n        if str_val != \"no-ini\":\n            testdir.makeini(\n                \"\"\"\n                [pytest]\n                strip=%s\n            \"\"\"\n                % str_val\n            )\n        config = testdir.parseconfig()\n        assert config.getini(\"strip\") is bool_val\n\n    def test_addinivalue_line_existing(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"xy\", \"\", type=\"linelist\")\n        \"\"\"\n        )\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            xy= 123\n        \"\"\"\n        )\n        config = testdir.parseconfig()\n        values = config.getini(\"xy\")\n        assert len(values) == 1\n        assert values == [\"123\"]\n        config.addinivalue_line(\"xy\", \"456\")\n        values = config.getini(\"xy\")\n        assert len(values) == 2\n        assert values == [\"123\", \"456\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI.test_addinivalue_line_new_TestConfigAPI.test_iter_rewritable_modules": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigAPI.test_addinivalue_line_new_TestConfigAPI.test_iter_rewritable_modules", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 394, "end_line": 443, "span_ids": ["TestConfigAPI.test_addinivalue_line_new", "TestConfigAPI.test_confcutdir_check_isdir", "TestConfigAPI.test_iter_rewritable_modules"], "tokens": 507}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConfigAPI:\n\n    def test_addinivalue_line_new(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"xy\", \"\", type=\"linelist\")\n        \"\"\"\n        )\n        config = testdir.parseconfig()\n        assert not config.getini(\"xy\")\n        config.addinivalue_line(\"xy\", \"456\")\n        values = config.getini(\"xy\")\n        assert len(values) == 1\n        assert values == [\"456\"]\n        config.addinivalue_line(\"xy\", \"123\")\n        values = config.getini(\"xy\")\n        assert len(values) == 2\n        assert values == [\"456\", \"123\"]\n\n    def test_confcutdir_check_isdir(self, testdir):\n        \"\"\"Give an error if --confcutdir is not a valid directory (#2078)\"\"\"\n        exp_match = r\"^--confcutdir must be a directory, given: \"\n        with pytest.raises(pytest.UsageError, match=exp_match):\n            testdir.parseconfig(\n                \"--confcutdir\", testdir.tmpdir.join(\"file\").ensure(file=1)\n            )\n        with pytest.raises(pytest.UsageError, match=exp_match):\n            testdir.parseconfig(\"--confcutdir\", testdir.tmpdir.join(\"inexistant\"))\n        config = testdir.parseconfig(\n            \"--confcutdir\", testdir.tmpdir.join(\"dir\").ensure(dir=1)\n        )\n        assert config.getoption(\"confcutdir\") == str(testdir.tmpdir.join(\"dir\"))\n\n    @pytest.mark.parametrize(\n        \"names, expected\",\n        [\n            # dist-info based distributions root are files as will be put in PYTHONPATH\n            ([\"bar.py\"], [\"bar\"]),\n            ([\"foo/bar.py\"], [\"bar\"]),\n            ([\"foo/bar.pyc\"], []),\n            ([\"foo/__init__.py\"], [\"foo\"]),\n            ([\"bar/__init__.py\", \"xz.py\"], [\"bar\", \"xz\"]),\n            ([\"setup.py\"], []),\n            # egg based distributions root contain the files from the dist root\n            ([\"src/bar/__init__.py\"], [\"bar\"]),\n            ([\"src/bar/__init__.py\", \"setup.py\"], [\"bar\"]),\n            ([\"source/python/bar/__init__.py\", \"setup.py\"], [\"bar\"]),\n        ],\n    )\n    def test_iter_rewritable_modules(self, names, expected):\n        assert list(_iter_rewritable_modules(names)) == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigFromdictargs.test_inifilename_TestConfigFromdictargs.test_inifilename.None_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigFromdictargs.test_inifilename_TestConfigFromdictargs.test_inifilename.None_5", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 470, "end_line": 503, "span_ids": ["TestConfigFromdictargs.test_inifilename"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConfigFromdictargs:\n\n    def test_inifilename(self, tmpdir):\n        tmpdir.join(\"foo/bar.ini\").ensure().write(\n            textwrap.dedent(\n                \"\"\"\\\n                [pytest]\n                name = value\n                \"\"\"\n            )\n        )\n\n        inifile = \"../../foo/bar.ini\"\n        option_dict = {\"inifilename\": inifile, \"capture\": \"no\"}\n\n        cwd = tmpdir.join(\"a/b\")\n        cwd.join(\"pytest.ini\").ensure().write(\n            textwrap.dedent(\n                \"\"\"\\\n                [pytest]\n                name = wrong-value\n                should_not_be_set = true\n                \"\"\"\n            )\n        )\n        with cwd.ensure(dir=True).as_cwd():\n            config = Config.fromdictargs(option_dict, ())\n\n        assert config.args == [str(cwd)]\n        assert config.option.inifilename == inifile\n        assert config.option.capture == \"no\"\n\n        # this indicates this is the file used for getting configuration values\n        assert config.inifile == inifile\n        assert config.inicfg.get(\"name\") == \"value\"\n        assert config.inicfg.get(\"should_not_be_set\") is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs_TestOverrideIniArgs.test_override_ini_pathlist": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs_TestOverrideIniArgs.test_override_ini_pathlist", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 900, "end_line": 958, "span_ids": ["TestOverrideIniArgs", "TestOverrideIniArgs.test_override_ini_names", "TestOverrideIniArgs.test_override_ini_pathlist"], "tokens": 447}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestOverrideIniArgs:\n    @pytest.mark.parametrize(\"name\", \"setup.cfg tox.ini pytest.ini\".split())\n    def test_override_ini_names(self, testdir, name):\n        section = \"[pytest]\" if name != \"setup.cfg\" else \"[tool:pytest]\"\n        testdir.tmpdir.join(name).write(\n            textwrap.dedent(\n                \"\"\"\n            {section}\n            custom = 1.0\"\"\".format(\n                    section=section\n                )\n            )\n        )\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"custom\", \"\")\"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_pass(pytestconfig):\n                ini_val = pytestconfig.getini(\"custom\")\n                print('\\\\ncustom_option:%s\\\\n' % ini_val)\"\"\"\n        )\n\n        result = testdir.runpytest(\"--override-ini\", \"custom=2.0\", \"-s\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"custom_option:2.0\"])\n\n        result = testdir.runpytest(\n            \"--override-ini\", \"custom=2.0\", \"--override-ini=custom=3.0\", \"-s\"\n        )\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"custom_option:3.0\"])\n\n    def test_override_ini_pathlist(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addini(\"paths\", \"my new ini value\", type=\"pathlist\")\"\"\"\n        )\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            paths=blah.py\"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import py.path\n            def test_pathlist(pytestconfig):\n                config_paths = pytestconfig.getini(\"paths\")\n                print(config_paths)\n                for cpf in config_paths:\n                    print('\\\\nuser_path:%s' % cpf.basename)\"\"\"\n        )\n        result = testdir.runpytest(\n            \"--override-ini\", \"paths=foo/bar1.py foo/bar2.py\", \"-s\"\n        )\n        result.stdout.fnmatch_lines([\"user_path:bar1.py\", \"user_path:bar2.py\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_override_multiple_and_default_TestOverrideIniArgs.test_override_multiple_and_default.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_override_multiple_and_default_TestOverrideIniArgs.test_override_multiple_and_default.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 960, "end_line": 1004, "span_ids": ["TestOverrideIniArgs.test_override_multiple_and_default"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestOverrideIniArgs:\n\n    def test_override_multiple_and_default(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_addoption(parser):\n                addini = parser.addini\n                addini(\"custom_option_1\", \"\", default=\"o1\")\n                addini(\"custom_option_2\", \"\", default=\"o2\")\n                addini(\"custom_option_3\", \"\", default=False, type=\"bool\")\n                addini(\"custom_option_4\", \"\", default=True, type=\"bool\")\"\"\"\n        )\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            custom_option_1=custom_option_1\n            custom_option_2=custom_option_2\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_multiple_options(pytestconfig):\n                prefix = \"custom_option\"\n                for x in range(1, 5):\n                    ini_value=pytestconfig.getini(\"%s_%d\" % (prefix, x))\n                    print('\\\\nini%d:%s' % (x, ini_value))\n        \"\"\"\n        )\n        result = testdir.runpytest(\n            \"--override-ini\",\n            \"custom_option_1=fulldir=/tmp/user1\",\n            \"-o\",\n            \"custom_option_2=url=/tmp/user2?a=b&d=e\",\n            \"-o\",\n            \"custom_option_3=True\",\n            \"-o\",\n            \"custom_option_4=no\",\n            \"-s\",\n        )\n        result.stdout.fnmatch_lines(\n            [\n                \"ini1:fulldir=/tmp/user1\",\n                \"ini2:url=/tmp/user2?a=b&d=e\",\n                \"ini3:True\",\n                \"ini4:False\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_multiple_override_ini_options_test_help_via_addopts": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_multiple_override_ini_options_test_help_via_addopts", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1161, "end_line": 1202, "span_ids": ["TestOverrideIniArgs.test_multiple_override_ini_options", "test_help_via_addopts"], "tokens": 320}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestOverrideIniArgs:\n\n    def test_multiple_override_ini_options(self, testdir):\n        \"\"\"Ensure a file path following a '-o' option does not generate an error (#3103)\"\"\"\n        testdir.makepyfile(\n            **{\n                \"conftest.py\": \"\"\"\n                def pytest_addoption(parser):\n                    parser.addini('foo', default=None, help='some option')\n                    parser.addini('bar', default=None, help='some option')\n            \"\"\",\n                \"test_foo.py\": \"\"\"\n                def test(pytestconfig):\n                    assert pytestconfig.getini('foo') == '1'\n                    assert pytestconfig.getini('bar') == '0'\n            \"\"\",\n                \"test_bar.py\": \"\"\"\n                def test():\n                    assert False\n            \"\"\",\n            }\n        )\n        result = testdir.runpytest(\"-o\", \"foo=1\", \"-o\", \"bar=0\", \"test_foo.py\")\n        assert \"ERROR:\" not in result.stderr.str()\n        result.stdout.fnmatch_lines([\"collected 1 item\", \"*= 1 passed in *=\"])\n\n\ndef test_help_via_addopts(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        addopts = --unknown-option-should-allow-for-help --help\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\n            \"usage: *\",\n            \"positional arguments:\",\n            # Displays full/default help.\n            \"to see available markers type: pytest --markers\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_in_nonpkg_with_init_test_issue151_load_all_conftests": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_in_nonpkg_with_init_test_issue151_load_all_conftests", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 84, "end_line": 110, "span_ids": ["test_conftest_in_nonpkg_with_init", "test_doubledash_considered", "test_issue151_load_all_conftests"], "tokens": 294}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_conftest_in_nonpkg_with_init(tmpdir, _sys_snapshot):\n    tmpdir.ensure(\"adir-1.0/conftest.py\").write(\"a=1 ; Directory = 3\")\n    tmpdir.ensure(\"adir-1.0/b/conftest.py\").write(\"b=2 ; a = 1.5\")\n    tmpdir.ensure(\"adir-1.0/b/__init__.py\")\n    tmpdir.ensure(\"adir-1.0/__init__.py\")\n    ConftestWithSetinitial(tmpdir.join(\"adir-1.0\", \"b\"))\n\n\ndef test_doubledash_considered(testdir):\n    conf = testdir.mkdir(\"--option\")\n    conf.ensure(\"conftest.py\")\n    conftest = PytestPluginManager()\n    conftest_setinitial(conftest, [conf.basename, conf.basename])\n    values = conftest._getconftestmodules(conf)\n    assert len(values) == 1\n\n\ndef test_issue151_load_all_conftests(testdir):\n    names = \"code proj src\".split()\n    for name in names:\n        p = testdir.mkdir(name)\n        p.ensure(\"conftest.py\")\n\n    conftest = PytestPluginManager()\n    conftest_setinitial(conftest, names)\n    d = list(conftest._conftestpath2mod.values())\n    assert len(d) == len(names)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_global_import_test_conftest_global_import": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_global_import_test_conftest_global_import", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 113, "end_line": 134, "span_ids": ["test_conftest_global_import"], "tokens": 203}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_conftest_global_import(testdir):\n    testdir.makeconftest(\"x=3\")\n    p = testdir.makepyfile(\n        \"\"\"\n        import py, pytest\n        from _pytest.config import PytestPluginManager\n        conf = PytestPluginManager()\n        mod = conf._importconftest(py.path.local(\"conftest.py\"))\n        assert mod.x == 3\n        import conftest\n        assert conftest is mod, (conftest, mod)\n        subconf = py.path.local().ensure(\"sub\", \"conftest.py\")\n        subconf.write(\"y=4\")\n        mod2 = conf._importconftest(subconf)\n        assert mod != mod2\n        assert mod2.y == 4\n        import conftest\n        assert conftest is mod2, (conftest, mod)\n    \"\"\"\n    )\n    res = testdir.runpython(p)\n    assert res.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftestcutdir_test_conftestcutdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftestcutdir_test_conftestcutdir", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 133, "end_line": 150, "span_ids": ["test_conftestcutdir"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_conftestcutdir(testdir):\n    conf = testdir.makeconftest(\"\")\n    p = testdir.mkdir(\"x\")\n    conftest = PytestPluginManager()\n    conftest_setinitial(conftest, [testdir.tmpdir], confcutdir=p)\n    values = conftest._getconftestmodules(p)\n    assert len(values) == 0\n    values = conftest._getconftestmodules(conf.dirpath())\n    assert len(values) == 0\n    assert conf not in conftest._conftestpath2mod\n    # but we can still import a conftest directly\n    conftest._importconftest(conf)\n    values = conftest._getconftestmodules(conf.dirpath())\n    assert values[0].__file__.startswith(str(conf))\n    # and all sub paths get updated properly\n    values = conftest._getconftestmodules(p)\n    assert len(values) == 1\n    assert values[0].__file__.startswith(str(conf))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftestcutdir_inplace_considered_test_conftest_confcutdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftestcutdir_inplace_considered_test_conftest_confcutdir", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 153, "end_line": 190, "span_ids": ["test_conftest_confcutdir", "test_conftestcutdir_inplace_considered", "test_setinitial_conftest_subdirs"], "tokens": 403}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_conftestcutdir_inplace_considered(testdir):\n    conf = testdir.makeconftest(\"\")\n    conftest = PytestPluginManager()\n    conftest_setinitial(conftest, [conf.dirpath()], confcutdir=conf.dirpath())\n    values = conftest._getconftestmodules(conf.dirpath())\n    assert len(values) == 1\n    assert values[0].__file__.startswith(str(conf))\n\n\n@pytest.mark.parametrize(\"name\", \"test tests whatever .dotdir\".split())\ndef test_setinitial_conftest_subdirs(testdir, name):\n    sub = testdir.mkdir(name)\n    subconftest = sub.ensure(\"conftest.py\")\n    conftest = PytestPluginManager()\n    conftest_setinitial(conftest, [sub.dirpath()], confcutdir=testdir.tmpdir)\n    key = Path(str(subconftest)).resolve()\n    if name not in (\"whatever\", \".dotdir\"):\n        assert key in conftest._conftestpath2mod\n        assert len(conftest._conftestpath2mod) == 1\n    else:\n        assert key not in conftest._conftestpath2mod\n        assert len(conftest._conftestpath2mod) == 0\n\n\ndef test_conftest_confcutdir(testdir):\n    testdir.makeconftest(\"assert 0\")\n    x = testdir.mkdir(\"x\")\n    x.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            def pytest_addoption(parser):\n                parser.addoption(\"--xyz\", action=\"store_true\")\n            \"\"\"\n        )\n    )\n    result = testdir.runpytest(\"-h\", \"--confcutdir=%s\" % x, x)\n    result.stdout.fnmatch_lines([\"*--xyz*\"])\n    result.stdout.no_fnmatch_line(\"*warning: could not load initial*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_symlink_test_conftest_symlink.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_symlink_test_conftest_symlink.None_2", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 192, "end_line": 241, "span_ids": ["test_conftest_symlink"], "tokens": 365}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.skipif(\n    not hasattr(py.path.local, \"mksymlinkto\"),\n    reason=\"symlink not available on this platform\",\n)\ndef test_conftest_symlink(testdir):\n    \"\"\"Ensure that conftest.py is used for resolved symlinks.\"\"\"\n    real = testdir.tmpdir.mkdir(\"real\")\n    realtests = real.mkdir(\"app\").mkdir(\"tests\")\n    testdir.tmpdir.join(\"symlinktests\").mksymlinkto(realtests)\n    testdir.tmpdir.join(\"symlink\").mksymlinkto(real)\n    testdir.makepyfile(\n        **{\n            \"real/app/tests/test_foo.py\": \"def test1(fixture): pass\",\n            \"real/conftest.py\": textwrap.dedent(\n                \"\"\"\n                import pytest\n\n                print(\"conftest_loaded\")\n\n                @pytest.fixture\n                def fixture():\n                    print(\"fixture_used\")\n                \"\"\"\n            ),\n        }\n    )\n    result = testdir.runpytest(\"-vs\", \"symlinktests\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*conftest_loaded*\",\n            \"real/app/tests/test_foo.py::test1 fixture_used\",\n            \"PASSED\",\n        ]\n    )\n    assert result.ret == ExitCode.OK\n\n    # Should not cause \"ValueError: Plugin already registered\" (#4174).\n    result = testdir.runpytest(\"-vs\", \"symlink\")\n    assert result.ret == ExitCode.OK\n\n    realtests.ensure(\"__init__.py\")\n    result = testdir.runpytest(\"-vs\", \"symlinktests/test_foo.py::test1\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*conftest_loaded*\",\n            \"real/app/tests/test_foo.py::test1 fixture_used\",\n            \"PASSED\",\n        ]\n    )\n    assert result.ret == ExitCode.OK", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_fixture_dependency_test_conftest_found_with_double_dash": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_fixture_dependency_test_conftest_found_with_double_dash", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 360, "end_line": 422, "span_ids": ["test_conftest_found_with_double_dash", "test_fixture_dependency"], "tokens": 359}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fixture_dependency(testdir):\n    ct1 = testdir.makeconftest(\"\")\n    ct1 = testdir.makepyfile(\"__init__.py\")\n    ct1.write(\"\")\n    sub = testdir.mkdir(\"sub\")\n    sub.join(\"__init__.py\").write(\"\")\n    sub.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def not_needed():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def foo():\n                assert False, \"Should not be called!\"\n\n            @pytest.fixture\n            def bar(foo):\n                return 'bar'\n            \"\"\"\n        )\n    )\n    subsub = sub.mkdir(\"subsub\")\n    subsub.join(\"__init__.py\").write(\"\")\n    subsub.join(\"test_bar.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n\n            @pytest.fixture\n            def bar():\n                return 'sub bar'\n\n            def test_event_fixture(bar):\n                assert bar == 'sub bar'\n            \"\"\"\n        )\n    )\n    result = testdir.runpytest(\"sub\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_conftest_found_with_double_dash(testdir):\n    sub = testdir.mkdir(\"sub\")\n    sub.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            def pytest_addoption(parser):\n                parser.addoption(\"--hello-world\", action=\"store_true\")\n            \"\"\"\n        )\n    )\n    p = sub.join(\"test_hello.py\")\n    p.write(\"def test_hello(): pass\")\n    result = testdir.runpytest(str(p) + \"::test_hello\", \"-h\")\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *--hello-world*\n    \"\"\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_TestConftestVisibility_TestConftestVisibility._setup_tree.return_runner_runner_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_TestConftestVisibility_TestConftestVisibility._setup_tree.return_runner_runner_", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 414, "end_line": 476, "span_ids": ["TestConftestVisibility", "TestConftestVisibility._setup_tree"], "tokens": 413}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConftestVisibility:\n    def _setup_tree(self, testdir):  # for issue616\n        # example mostly taken from:\n        # https://mail.python.org/pipermail/pytest-dev/2014-September/002617.html\n        runner = testdir.mkdir(\"empty\")\n        package = testdir.mkdir(\"package\")\n\n        package.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.fixture\n                def fxtr():\n                    return \"from-package\"\n                \"\"\"\n            )\n        )\n        package.join(\"test_pkgroot.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def test_pkgroot(fxtr):\n                    assert fxtr == \"from-package\"\n                \"\"\"\n            )\n        )\n\n        swc = package.mkdir(\"swc\")\n        swc.join(\"__init__.py\").ensure()\n        swc.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.fixture\n                def fxtr():\n                    return \"from-swc\"\n                \"\"\"\n            )\n        )\n        swc.join(\"test_with_conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def test_with_conftest(fxtr):\n                    assert fxtr == \"from-swc\"\n                \"\"\"\n            )\n        )\n\n        snc = package.mkdir(\"snc\")\n        snc.join(\"__init__.py\").ensure()\n        snc.join(\"test_no_conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def test_no_conftest(fxtr):\n                    assert fxtr == \"from-package\"   # No local conftest.py, so should\n                                                    # use value from parent dir's\n                \"\"\"\n            )\n        )\n        print(\"created directory structure:\")\n        for x in testdir.tmpdir.visit():\n            print(\"   \" + x.relto(testdir.tmpdir))\n\n        return {\"runner\": runner, \"package\": package, \"swc\": swc, \"snc\": snc}", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_TestConftestVisibility._N_B_swc_stands_for__TestConftestVisibility.test_parsefactories_relative_node_ids.with_dirs_chdir_as_cwd_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_TestConftestVisibility._N_B_swc_stands_for__TestConftestVisibility.test_parsefactories_relative_node_ids.with_dirs_chdir_as_cwd_", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 478, "end_line": 515, "span_ids": ["TestConftestVisibility._setup_tree", "TestConftestVisibility.test_parsefactories_relative_node_ids"], "tokens": 398}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConftestVisibility:\n\n    # N.B.: \"swc\" stands for \"subdir with conftest.py\"\n    #       \"snc\" stands for \"subdir no [i.e. without] conftest.py\"\n    @pytest.mark.parametrize(\n        \"chdir,testarg,expect_ntests_passed\",\n        [\n            # Effective target: package/..\n            (\"runner\", \"..\", 3),\n            (\"package\", \"..\", 3),\n            (\"swc\", \"../..\", 3),\n            (\"snc\", \"../..\", 3),\n            # Effective target: package\n            (\"runner\", \"../package\", 3),\n            (\"package\", \".\", 3),\n            (\"swc\", \"..\", 3),\n            (\"snc\", \"..\", 3),\n            # Effective target: package/swc\n            (\"runner\", \"../package/swc\", 1),\n            (\"package\", \"./swc\", 1),\n            (\"swc\", \".\", 1),\n            (\"snc\", \"../swc\", 1),\n            # Effective target: package/snc\n            (\"runner\", \"../package/snc\", 1),\n            (\"package\", \"./snc\", 1),\n            (\"swc\", \"../snc\", 1),\n            (\"snc\", \".\", 1),\n        ],\n    )\n    def test_parsefactories_relative_node_ids(\n        self, testdir, chdir, testarg, expect_ntests_passed\n    ):\n        \"\"\"#616\"\"\"\n        dirs = self._setup_tree(testdir)\n        print(\"pytest run in cwd: %s\" % (dirs[chdir].relto(testdir.tmpdir)))\n        print(\"pytestarg        : %s\" % (testarg))\n        print(\"expected pass    : %s\" % (expect_ntests_passed))\n        with dirs[chdir].as_cwd():\n            reprec = testdir.inline_run(testarg, \"-q\", \"--traceconfig\")\n            reprec.assertoutcome(passed=expect_ntests_passed)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_search_conftest_up_to_inifile_test_search_conftest_up_to_inifile.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_search_conftest_up_to_inifile_test_search_conftest_up_to_inifile.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 507, "end_line": 555, "span_ids": ["test_search_conftest_up_to_inifile"], "tokens": 332}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"confcutdir,passed,error\", [(\".\", 2, 0), (\"src\", 1, 1), (None, 1, 1)]\n)\ndef test_search_conftest_up_to_inifile(testdir, confcutdir, passed, error):\n    \"\"\"Test that conftest files are detected only up to an ini file, unless\n    an explicit --confcutdir option is given.\n    \"\"\"\n    root = testdir.tmpdir\n    src = root.join(\"src\").ensure(dir=1)\n    src.join(\"pytest.ini\").write(\"[pytest]\")\n    src.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n            @pytest.fixture\n            def fix1(): pass\n            \"\"\"\n        )\n    )\n    src.join(\"test_foo.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            def test_1(fix1):\n                pass\n            def test_2(out_of_reach):\n                pass\n            \"\"\"\n        )\n    )\n    root.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n            @pytest.fixture\n            def out_of_reach(): pass\n            \"\"\"\n        )\n    )\n\n    args = [str(src)]\n    if confcutdir:\n        args = [\"--confcutdir=%s\" % root.join(confcutdir)]\n    result = testdir.runpytest(*args)\n    match = \"\"\n    if passed:\n        match += \"*%d passed*\" % passed\n    if error:\n        match += \"*%d error*\" % error\n    result.stdout.fnmatch_lines(match)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_issue1073_conftest_special_objects_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_issue1073_conftest_special_objects_", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 580, "end_line": 653, "span_ids": ["test_conftest_exception_handling", "test_hook_proxy", "test_issue1073_conftest_special_objects", "test_required_option_help"], "tokens": 493}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_issue1073_conftest_special_objects(testdir):\n    testdir.makeconftest(\n        \"\"\"\\\n        class DontTouchMe(object):\n            def __getattr__(self, x):\n                raise Exception('cant touch me')\n\n        x = DontTouchMe()\n        \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\\\n        def test_some():\n            pass\n        \"\"\"\n    )\n    res = testdir.runpytest()\n    assert res.ret == 0\n\n\ndef test_conftest_exception_handling(testdir):\n    testdir.makeconftest(\n        \"\"\"\\\n        raise ValueError()\n        \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\\\n        def test_some():\n            pass\n        \"\"\"\n    )\n    res = testdir.runpytest()\n    assert res.ret == 4\n    assert \"raise ValueError()\" in [line.strip() for line in res.errlines]\n\n\ndef test_hook_proxy(testdir):\n    \"\"\"Session's gethookproxy() would cache conftests incorrectly (#2016).\n    It was decided to remove the cache altogether.\n    \"\"\"\n    testdir.makepyfile(\n        **{\n            \"root/demo-0/test_foo1.py\": \"def test1(): pass\",\n            \"root/demo-a/test_foo2.py\": \"def test1(): pass\",\n            \"root/demo-a/conftest.py\": \"\"\"\\\n            def pytest_ignore_collect(path, config):\n                return True\n            \"\"\",\n            \"root/demo-b/test_foo3.py\": \"def test1(): pass\",\n            \"root/demo-c/test_foo4.py\": \"def test1(): pass\",\n        }\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\"*test_foo1.py*\", \"*test_foo3.py*\", \"*test_foo4.py*\", \"*3 passed*\"]\n    )\n\n\ndef test_required_option_help(testdir):\n    testdir.makeconftest(\"assert 0\")\n    x = testdir.mkdir(\"x\")\n    x.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            def pytest_addoption(parser):\n                parser.addoption(\"--xyz\", action=\"store_true\", required=True)\n            \"\"\"\n        )\n    )\n    result = testdir.runpytest(\"-h\", x)\n    result.stdout.no_fnmatch_line(\"*argument --xyz is required*\")\n    assert \"general:\" in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_new_pattern_TestDoctests.test_multiple_patterns.None_4": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_new_pattern_TestDoctests.test_multiple_patterns.None_4", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 103, "end_line": 142, "span_ids": ["TestDoctests.test_multiple_patterns", "TestDoctests.test_new_pattern"], "tokens": 285}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_new_pattern(self, testdir):\n        p = testdir.maketxtfile(\n            xdoc=\"\"\"\n            >>> x = 1\n            >>> x == 1\n            False\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-glob=x*.txt\")\n        reprec.assertoutcome(failed=1)\n\n    def test_multiple_patterns(self, testdir):\n        \"\"\"Test support for multiple --doctest-glob arguments (#1255).\n        \"\"\"\n        testdir.maketxtfile(\n            xdoc=\"\"\"\n            >>> 1\n            1\n        \"\"\"\n        )\n        testdir.makefile(\n            \".foo\",\n            test=\"\"\"\n            >>> 1\n            1\n        \"\"\",\n        )\n        testdir.maketxtfile(\n            test_normal=\"\"\"\n            >>> 1\n            1\n        \"\"\"\n        )\n        expected = {\"xdoc.txt\", \"test.foo\", \"test_normal.txt\"}\n        assert {x.basename for x in testdir.tmpdir.listdir()} == expected\n        args = [\"--doctest-glob=xdoc*.txt\", \"--doctest-glob=*.foo\"]\n        result = testdir.runpytest(*args)\n        result.stdout.fnmatch_lines([\"*test.foo *\", \"*xdoc.txt *\", \"*2 passed*\"])\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*test_normal.txt *\", \"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals_TestLiterals.test_allow_unicode.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals_TestLiterals.test_allow_unicode.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 736, "end_line": 774, "span_ids": ["TestLiterals", "TestLiterals.test_allow_unicode"], "tokens": 234}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLiterals:\n    @pytest.mark.parametrize(\"config_mode\", [\"ini\", \"comment\"])\n    def test_allow_unicode(self, testdir, config_mode):\n        \"\"\"Test that doctests which output unicode work in all python versions\n        tested by pytest when the ALLOW_UNICODE option is used (either in\n        the ini file or by an inline comment).\n        \"\"\"\n        if config_mode == \"ini\":\n            testdir.makeini(\n                \"\"\"\n            [pytest]\n            doctest_optionflags = ALLOW_UNICODE\n            \"\"\"\n            )\n            comment = \"\"\n        else:\n            comment = \"#doctest: +ALLOW_UNICODE\"\n\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> b'12'.decode('ascii') {comment}\n            '12'\n        \"\"\".format(\n                comment=comment\n            )\n        )\n        testdir.makepyfile(\n            foo=\"\"\"\n            def foo():\n              '''\n              >>> b'12'.decode('ascii') {comment}\n              '12'\n              '''\n        \"\"\".format(\n                comment=comment\n            )\n        )\n        reprec = testdir.inline_run(\"--doctest-modules\")\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestSkips_TestDoctestSkips.test_continue_on_failure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestSkips_TestDoctestSkips.test_continue_on_failure", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 991, "end_line": 1069, "span_ids": ["TestDoctestSkips", "TestDoctestSkips.makedoctest", "TestDoctestSkips.test_all_skipped", "TestDoctestSkips.test_continue_on_failure", "TestDoctestSkips.test_one_skipped", "TestDoctestSkips.test_one_skipped_failed", "TestDoctestSkips.test_vacuous_all_skipped"], "tokens": 611}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctestSkips:\n    \"\"\"\n    If all examples in a doctest are skipped due to the SKIP option, then\n    the tests should be SKIPPED rather than PASSED. (#957)\n    \"\"\"\n\n    @pytest.fixture(params=[\"text\", \"module\"])\n    def makedoctest(self, testdir, request):\n        def makeit(doctest):\n            mode = request.param\n            if mode == \"text\":\n                testdir.maketxtfile(doctest)\n            else:\n                assert mode == \"module\"\n                testdir.makepyfile('\"\"\"\\n%s\"\"\"' % doctest)\n\n        return makeit\n\n    def test_one_skipped(self, testdir, makedoctest):\n        makedoctest(\n            \"\"\"\n            >>> 1 + 1  # doctest: +SKIP\n            2\n            >>> 2 + 2\n            4\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"--doctest-modules\")\n        reprec.assertoutcome(passed=1)\n\n    def test_one_skipped_failed(self, testdir, makedoctest):\n        makedoctest(\n            \"\"\"\n            >>> 1 + 1  # doctest: +SKIP\n            2\n            >>> 2 + 2\n            200\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"--doctest-modules\")\n        reprec.assertoutcome(failed=1)\n\n    def test_all_skipped(self, testdir, makedoctest):\n        makedoctest(\n            \"\"\"\n            >>> 1 + 1  # doctest: +SKIP\n            2\n            >>> 2 + 2  # doctest: +SKIP\n            200\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"--doctest-modules\")\n        reprec.assertoutcome(skipped=1)\n\n    def test_vacuous_all_skipped(self, testdir, makedoctest):\n        makedoctest(\"\")\n        reprec = testdir.inline_run(\"--doctest-modules\")\n        reprec.assertoutcome(passed=0, skipped=0)\n\n    def test_continue_on_failure(self, testdir):\n        testdir.maketxtfile(\n            test_something=\"\"\"\n            >>> i = 5\n            >>> def foo():\n            ...     raise ValueError('error1')\n            >>> foo()\n            >>> i\n            >>> i + 2\n            7\n            >>> i + 1\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--doctest-modules\", \"--doctest-continue-on-failure\")\n        result.assert_outcomes(passed=0, failed=1)\n        # The lines that contains the failure are 4, 5, and 8.  The first one\n        # is a stack trace and the other two are mismatches.\n        result.stdout.fnmatch_lines(\n            [\"*4: UnexpectedException*\", \"*5: DocTestFailure*\", \"*8: DocTestFailure*\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures_TestDoctestAutoUseFixtures.test_doctest_module_session_fixture.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures_TestDoctestAutoUseFixtures.test_doctest_module_session_fixture.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1072, "end_line": 1110, "span_ids": ["TestDoctestAutoUseFixtures", "TestDoctestAutoUseFixtures.test_doctest_module_session_fixture"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctestAutoUseFixtures:\n\n    SCOPES = [\"module\", \"session\", \"class\", \"function\"]\n\n    def test_doctest_module_session_fixture(self, testdir):\n        \"\"\"Test that session fixtures are initialized for doctest modules (#768)\n        \"\"\"\n        # session fixture which changes some global data, which will\n        # be accessed by doctests in a module\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            import sys\n\n            @pytest.yield_fixture(autouse=True, scope='session')\n            def myfixture():\n                assert not hasattr(sys, 'pytest_session_data')\n                sys.pytest_session_data = 1\n                yield\n                del sys.pytest_session_data\n        \"\"\"\n        )\n        testdir.makepyfile(\n            foo=\"\"\"\n            import sys\n\n            def foo():\n              '''\n              >>> assert sys.pytest_session_data == 1\n              '''\n\n            def bar():\n              '''\n              >>> assert sys.pytest_session_data == 1\n              '''\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines([\"*2 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_fixture_scopes_TestDoctestAutoUseFixtures.test_fixture_scopes.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_fixture_scopes_TestDoctestAutoUseFixtures.test_fixture_scopes.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1112, "end_line": 1143, "span_ids": ["TestDoctestAutoUseFixtures.test_fixture_scopes"], "tokens": 218}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctestAutoUseFixtures:\n\n    @pytest.mark.parametrize(\"scope\", SCOPES)\n    @pytest.mark.parametrize(\"enable_doctest\", [True, False])\n    def test_fixture_scopes(self, testdir, scope, enable_doctest):\n        \"\"\"Test that auto-use fixtures work properly with doctest modules.\n        See #1057 and #1100.\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(autouse=True, scope=\"{scope}\")\n            def auto(request):\n                return 99\n        \"\"\".format(\n                scope=scope\n            )\n        )\n        testdir.makepyfile(\n            test_1='''\n            def test_foo():\n                \"\"\"\n                >>> getfixture('auto') + 1\n                100\n                \"\"\"\n            def test_bar():\n                assert 1\n        '''\n        )\n        params = (\"--doctest-modules\",) if enable_doctest else ()\n        passes = 3 if enable_doctest else 2\n        result = testdir.runpytest(*params)\n        result.stdout.fnmatch_lines([\"*=== %d passed in *\" % passes])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_fixture_module_doctest_scopes_TestDoctestAutoUseFixtures.test_fixture_module_doctest_scopes.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_fixture_module_doctest_scopes_TestDoctestAutoUseFixtures.test_fixture_module_doctest_scopes.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1236, "end_line": 1272, "span_ids": ["TestDoctestAutoUseFixtures.test_fixture_module_doctest_scopes"], "tokens": 255}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctestAutoUseFixtures:\n\n    @pytest.mark.parametrize(\"scope\", SCOPES)\n    @pytest.mark.parametrize(\"autouse\", [True, False])\n    @pytest.mark.parametrize(\"use_fixture_in_doctest\", [True, False])\n    def test_fixture_module_doctest_scopes(\n        self, testdir, scope, autouse, use_fixture_in_doctest\n    ):\n        \"\"\"Test that auto-use fixtures work properly with doctest files.\n        See #1057 and #1100.\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(autouse={autouse}, scope=\"{scope}\")\n            def auto(request):\n                return 99\n        \"\"\".format(\n                scope=scope, autouse=autouse\n            )\n        )\n        if use_fixture_in_doctest:\n            testdir.maketxtfile(\n                test_doc=\"\"\"\n                >>> getfixture('auto')\n                99\n            \"\"\"\n            )\n        else:\n            testdir.maketxtfile(\n                test_doc=\"\"\"\n                >>> 1 + 1\n                2\n            \"\"\"\n            )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.no_fnmatch_line(\"*FAILURES*\")\n        result.stdout.fnmatch_lines([\"*=== 1 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_auto_use_request_attributes_TestDoctestAutoUseFixtures.test_auto_use_request_attributes.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestAutoUseFixtures.test_auto_use_request_attributes_TestDoctestAutoUseFixtures.test_auto_use_request_attributes.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1274, "end_line": 1304, "span_ids": ["TestDoctestAutoUseFixtures.test_auto_use_request_attributes"], "tokens": 214}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctestAutoUseFixtures:\n\n    @pytest.mark.parametrize(\"scope\", SCOPES)\n    def test_auto_use_request_attributes(self, testdir, scope):\n        \"\"\"Check that all attributes of a request in an autouse fixture\n        behave as expected when requested for a doctest item.\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(autouse=True, scope=\"{scope}\")\n            def auto(request):\n                if \"{scope}\" == 'module':\n                    assert request.module is None\n                if \"{scope}\" == 'class':\n                    assert request.cls is None\n                if \"{scope}\" == 'function':\n                    assert request.function is None\n                return 99\n        \"\"\".format(\n                scope=scope\n            )\n        )\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> 1 + 1\n            2\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        str(result.stdout.no_fnmatch_line(\"*FAILURES*\"))\n        result.stdout.fnmatch_lines([\"*=== 1 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestNamespaceFixture_TestDoctestNamespaceFixture.test_namespace_pyfile.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestNamespaceFixture_TestDoctestNamespaceFixture.test_namespace_pyfile.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1216, "end_line": 1275, "span_ids": ["TestDoctestNamespaceFixture", "TestDoctestNamespaceFixture.test_namespace_doctestfile", "TestDoctestNamespaceFixture.test_namespace_pyfile"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctestNamespaceFixture:\n\n    SCOPES = [\"module\", \"session\", \"class\", \"function\"]\n\n    @pytest.mark.parametrize(\"scope\", SCOPES)\n    def test_namespace_doctestfile(self, testdir, scope):\n        \"\"\"\n        Check that inserting something into the namespace works in a\n        simple text file doctest\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            import contextlib\n\n            @pytest.fixture(autouse=True, scope=\"{scope}\")\n            def add_contextlib(doctest_namespace):\n                doctest_namespace['cl'] = contextlib\n        \"\"\".format(\n                scope=scope\n            )\n        )\n        p = testdir.maketxtfile(\n            \"\"\"\n            >>> print(cl.__name__)\n            contextlib\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p)\n        reprec.assertoutcome(passed=1)\n\n    @pytest.mark.parametrize(\"scope\", SCOPES)\n    def test_namespace_pyfile(self, testdir, scope):\n        \"\"\"\n        Check that inserting something into the namespace works in a\n        simple Python file docstring doctest\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            import contextlib\n\n            @pytest.fixture(autouse=True, scope=\"{scope}\")\n            def add_contextlib(doctest_namespace):\n                doctest_namespace['cl'] = contextlib\n        \"\"\".format(\n                scope=scope\n            )\n        )\n        p = testdir.makepyfile(\n            \"\"\"\n            def foo():\n                '''\n                >>> print(cl.__name__)\n                contextlib\n                '''\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\")\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_entry_points.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_entry_points.py__", "embedding": null, "metadata": {"file_path": "testing/test_entry_points.py", "file_name": "test_entry_points.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 8, "span_ids": ["imports", "test_pytest_entry_points_are_identical"], "tokens": 61}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from _pytest.compat import importlib_metadata\n\n\ndef test_pytest_entry_points_are_identical():\n    dist = importlib_metadata.distribution(\"pytest\")\n    entry_map = {ep.name: ep for ep in dist.entry_points}\n    assert entry_map[\"pytest\"].value == entry_map[\"py.test\"].value", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython_TestPython.test_timing_function": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython_TestPython.test_timing_function", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 124, "end_line": 218, "span_ids": ["TestPython", "TestPython.test_hostname_in_xml", "TestPython.test_summing_simple", "TestPython.test_summing_simple_with_errors", "TestPython.test_timestamp_in_xml", "TestPython.test_timing_function"], "tokens": 649}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n    @parametrize_families\n    def test_summing_simple(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_pass():\n                pass\n            def test_fail():\n                assert 0\n            def test_skip():\n                pytest.skip(\"\")\n            @pytest.mark.xfail\n            def test_xfail():\n                assert 0\n            @pytest.mark.xfail\n            def test_xpass():\n                assert 1\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(name=\"pytest\", errors=0, failures=1, skipped=2, tests=5)\n\n    @parametrize_families\n    def test_summing_simple_with_errors(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def fixture():\n                raise Exception()\n            def test_pass():\n                pass\n            def test_fail():\n                assert 0\n            def test_error(fixture):\n                pass\n            @pytest.mark.xfail\n            def test_xfail():\n                assert False\n            @pytest.mark.xfail(strict=True)\n            def test_xpass():\n                assert True\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(name=\"pytest\", errors=1, failures=2, skipped=1, tests=5)\n\n    @parametrize_families\n    def test_hostname_in_xml(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            def test_pass():\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(hostname=platform.node())\n\n    @parametrize_families\n    def test_timestamp_in_xml(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            def test_pass():\n                pass\n        \"\"\"\n        )\n        start_time = datetime.now()\n        result, dom = run_and_parse(family=xunit_family)\n        node = dom.find_first_by_tag(\"testsuite\")\n        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n        assert start_time <= timestamp < datetime.now()\n\n    def test_timing_function(self, testdir, run_and_parse):\n        testdir.makepyfile(\n            \"\"\"\n            import time, pytest\n            def setup_module():\n                time.sleep(0.01)\n            def teardown_module():\n                time.sleep(0.01)\n            def test_sleep():\n                time.sleep(0.01)\n        \"\"\"\n        )\n        result, dom = run_and_parse()\n        node = dom.find_first_by_tag(\"testsuite\")\n        tnode = node.find_first_by_tag(\"testcase\")\n        val = tnode[\"time\"]\n        assert round(float(val), 2) >= 0.03", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_junit_duration_report_TestPython.test_junit_duration_report.if_duration_report_to": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_junit_duration_report_TestPython.test_junit_duration_report.if_duration_report_to", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 220, "end_line": 251, "span_ids": ["TestPython.test_junit_duration_report"], "tokens": 229}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @pytest.mark.parametrize(\"duration_report\", [\"call\", \"total\"])\n    def test_junit_duration_report(\n        self, testdir, monkeypatch, duration_report, run_and_parse\n    ):\n\n        # mock LogXML.node_reporter so it always sets a known duration to each test report object\n        original_node_reporter = LogXML.node_reporter\n\n        def node_reporter_wrapper(s, report):\n            report.duration = 1.0\n            reporter = original_node_reporter(s, report)\n            return reporter\n\n        monkeypatch.setattr(LogXML, \"node_reporter\", node_reporter_wrapper)\n\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(\n            \"-o\", \"junit_duration_report={}\".format(duration_report)\n        )\n        node = dom.find_first_by_tag(\"testsuite\")\n        tnode = node.find_first_by_tag(\"testcase\")\n        val = float(tnode[\"time\"])\n        if duration_report == \"total\":\n            assert val == 3.0\n        else:\n            assert duration_report == \"call\"\n            assert val == 1.0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_TestPython.test_skip_contains_name_reason": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_TestPython.test_skip_contains_name_reason", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 253, "end_line": 341, "span_ids": ["TestPython.test_call_failure_teardown_error", "TestPython.test_setup_error", "TestPython.test_skip_contains_name_reason", "TestPython.test_teardown_error"], "tokens": 694}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @parametrize_families\n    def test_setup_error(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def arg(request):\n                raise ValueError()\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(errors=1, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_setup_error\", name=\"test_function\")\n        fnode = tnode.find_first_by_tag(\"error\")\n        fnode.assert_attr(message=\"test setup failure\")\n        assert \"ValueError\" in fnode.toxml()\n\n    @parametrize_families\n    def test_teardown_error(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def arg():\n                yield\n                raise ValueError()\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_teardown_error\", name=\"test_function\")\n        fnode = tnode.find_first_by_tag(\"error\")\n        fnode.assert_attr(message=\"test teardown failure\")\n        assert \"ValueError\" in fnode.toxml()\n\n    @parametrize_families\n    def test_call_failure_teardown_error(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def arg():\n                yield\n                raise Exception(\"Teardown Exception\")\n            def test_function(arg):\n                raise Exception(\"Call Exception\")\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(errors=1, failures=1, tests=1)\n        first, second = dom.find_by_tag(\"testcase\")\n        if not first or not second or first == second:\n            assert 0\n        fnode = first.find_first_by_tag(\"failure\")\n        fnode.assert_attr(message=\"Exception: Call Exception\")\n        snode = second.find_first_by_tag(\"error\")\n        snode.assert_attr(message=\"test teardown failure\")\n\n    @parametrize_families\n    def test_skip_contains_name_reason(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_skip():\n                pytest.skip(\"hello23\")\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret == 0\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(skipped=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_skip_contains_name_reason\", name=\"test_skip\")\n        snode = tnode.find_first_by_tag(\"skipped\")\n        snode.assert_attr(type=\"pytest.skip\", message=\"hello23\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_mark_skip_contains_name_reason_TestPython.test_classname_nested_dir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_mark_skip_contains_name_reason_TestPython.test_classname_nested_dir", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 343, "end_line": 432, "span_ids": ["TestPython.test_classname_instance", "TestPython.test_classname_nested_dir", "TestPython.test_mark_skip_contains_name_reason", "TestPython.test_mark_skip_doesnt_capture_output", "TestPython.test_mark_skipif_contains_name_reason"], "tokens": 727}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @parametrize_families\n    def test_mark_skip_contains_name_reason(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip(reason=\"hello24\")\n            def test_skip():\n                assert True\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret == 0\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(skipped=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(\n            classname=\"test_mark_skip_contains_name_reason\", name=\"test_skip\"\n        )\n        snode = tnode.find_first_by_tag(\"skipped\")\n        snode.assert_attr(type=\"pytest.skip\", message=\"hello24\")\n\n    @parametrize_families\n    def test_mark_skipif_contains_name_reason(\n        self, testdir, run_and_parse, xunit_family\n    ):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            GLOBAL_CONDITION = True\n            @pytest.mark.skipif(GLOBAL_CONDITION, reason=\"hello25\")\n            def test_skip():\n                assert True\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret == 0\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(skipped=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(\n            classname=\"test_mark_skipif_contains_name_reason\", name=\"test_skip\"\n        )\n        snode = tnode.find_first_by_tag(\"skipped\")\n        snode.assert_attr(type=\"pytest.skip\", message=\"hello25\")\n\n    @parametrize_families\n    def test_mark_skip_doesnt_capture_output(\n        self, testdir, run_and_parse, xunit_family\n    ):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip(reason=\"foo\")\n            def test_skip():\n                print(\"bar!\")\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret == 0\n        node_xml = dom.find_first_by_tag(\"testsuite\").toxml()\n        assert \"bar!\" not in node_xml\n\n    @parametrize_families\n    def test_classname_instance(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            class TestClass(object):\n                def test_method(self):\n                    assert 0\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(failures=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(\n            classname=\"test_classname_instance.TestClass\", name=\"test_method\"\n        )\n\n    @parametrize_families\n    def test_classname_nested_dir(self, testdir, run_and_parse, xunit_family):\n        p = testdir.tmpdir.ensure(\"sub\", \"test_hello.py\")\n        p.write(\"def test_func(): 0/0\")\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(failures=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"sub.test_hello\", name=\"test_func\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_mangle_test_address_test_dont_configure_on_slaves": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_mangle_test_address_test_dont_configure_on_slaves", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 855, "end_line": 887, "span_ids": ["test_dont_configure_on_slaves", "test_mangle_test_address"], "tokens": 241}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_mangle_test_address():\n    from _pytest.junitxml import mangle_test_address\n\n    address = \"::\".join([\"a/my.py.thing.py\", \"Class\", \"()\", \"method\", \"[a-1-::]\"])\n    newnames = mangle_test_address(address)\n    assert newnames == [\"a.my.py.thing\", \"Class\", \"method\", \"[a-1-::]\"]\n\n\ndef test_dont_configure_on_slaves(tmpdir):\n    gotten = []\n\n    class FakeConfig:\n        def __init__(self):\n            self.pluginmanager = self\n            self.option = self\n            self._store = Store()\n\n        def getini(self, name):\n            return \"pytest\"\n\n        junitprefix = None\n        # XXX: shouldn't need tmpdir ?\n        xmlpath = str(tmpdir.join(\"junix.xml\"))\n        register = gotten.append\n\n    fake_config = FakeConfig()\n    from _pytest import junitxml\n\n    junitxml.pytest_configure(fake_config)\n    assert len(gotten) == 1\n    FakeConfig.slaveinput = None\n    junitxml.pytest_configure(fake_config)\n    assert len(gotten) == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestNonPython_TestNonPython.test_summing_simple.assert_custom_item_runte": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestNonPython_TestNonPython.test_summing_simple.assert_custom_item_runte", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 819, "end_line": 847, "span_ids": ["TestNonPython", "TestNonPython.test_summing_simple"], "tokens": 259}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNonPython:\n    @parametrize_families\n    def test_summing_simple(self, testdir, run_and_parse, xunit_family):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_collect_file(path, parent):\n                if path.ext == \".xyz\":\n                    return MyItem(path, parent)\n            class MyItem(pytest.Item):\n                def __init__(self, path, parent):\n                    super(MyItem, self).__init__(path.basename, parent)\n                    self.fspath = path\n                def runtest(self):\n                    raise ValueError(42)\n                def repr_failure(self, excinfo):\n                    return \"custom item runtest failed\"\n        \"\"\"\n        )\n        testdir.tmpdir.join(\"myfile.xyz\").write(\"hello\")\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(errors=0, failures=1, skipped=0, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(name=\"myfile.xyz\")\n        fnode = tnode.find_first_by_tag(\"failure\")\n        fnode.assert_attr(message=\"custom item runtest failed\")\n        assert \"custom item runtest failed\" in fnode.toxml()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_nullbyte_test_nullbyte_replace": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_nullbyte_test_nullbyte_replace", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 921, "end_line": 961, "span_ids": ["test_nullbyte", "test_nullbyte_replace"], "tokens": 398}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-out\"])\ndef test_nullbyte(testdir, junit_logging):\n    # A null byte can not occur in XML (see section 2.2 of the spec)\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        def test_print_nullbyte():\n            sys.stdout.write('Here the null -->' + chr(0) + '<--')\n            sys.stdout.write('In repr form -->' + repr(chr(0)) + '<--')\n            assert False\n    \"\"\"\n    )\n    xmlf = testdir.tmpdir.join(\"junit.xml\")\n    testdir.runpytest(\"--junitxml=%s\" % xmlf, \"-o\", \"junit_logging=%s\" % junit_logging)\n    text = xmlf.read()\n    assert \"\\x00\" not in text\n    if junit_logging == \"system-out\":\n        assert \"#x00\" in text\n    if junit_logging == \"no\":\n        assert \"#x00\" not in text\n\n\n@pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-out\"])\ndef test_nullbyte_replace(testdir, junit_logging):\n    # Check if the null byte gets replaced\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        def test_print_nullbyte():\n            sys.stdout.write('Here the null -->' + chr(0) + '<--')\n            sys.stdout.write('In repr form -->' + repr(chr(0)) + '<--')\n            assert False\n    \"\"\"\n    )\n    xmlf = testdir.tmpdir.join(\"junit.xml\")\n    testdir.runpytest(\"--junitxml=%s\" % xmlf, \"-o\", \"junit_logging=%s\" % junit_logging)\n    text = xmlf.read()\n    if junit_logging == \"system-out\":\n        assert \"#x0\" in text\n    if junit_logging == \"no\":\n        assert \"#x0\" not in text", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_invalid_xml_escape_test_invalid_xml_escape.for_i_in_valid_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_invalid_xml_escape_test_invalid_xml_escape.for_i_in_valid_", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 964, "end_line": 997, "span_ids": ["test_invalid_xml_escape"], "tokens": 301}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_invalid_xml_escape():\n    # Test some more invalid xml chars, the full range should be\n    # tested really but let's just test the edges of the ranges\n    # instead.\n    # XXX This only tests low unicode character points for now as\n    #     there are some issues with the testing infrastructure for\n    #     the higher ones.\n    # XXX Testing 0xD (\\r) is tricky as it overwrites the just written\n    #     line in the output, so we skip it too.\n    invalid = (\n        0x00,\n        0x1,\n        0xB,\n        0xC,\n        0xE,\n        0x19,\n        27,  # issue #126\n        0xD800,\n        0xDFFF,\n        0xFFFE,\n        0x0FFFF,\n    )  # , 0x110000)\n    valid = (0x9, 0xA, 0x20)\n    # 0xD, 0xD7FF, 0xE000, 0xFFFD, 0x10000, 0x10FFFF)\n\n    for i in invalid:\n        got = bin_xml_escape(chr(i)).uniobj\n        if i <= 0xFF:\n            expected = \"#x%02X\" % i\n        else:\n            expected = \"#x%04X\" % i\n        assert got == expected\n    for i in valid:\n        assert chr(i) == bin_xml_escape(chr(i)).uniobj", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_logxml_path_expansion_test_double_colon_split_method_issue469": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_logxml_path_expansion_test_double_colon_split_method_issue469", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 928, "end_line": 1017, "span_ids": ["test_double_colon_split_function_issue469", "test_double_colon_split_method_issue469", "test_escaped_parametrized_names_xml", "test_logxml_changingdir", "test_logxml_check_isdir", "test_logxml_makedir", "test_logxml_path_expansion"], "tokens": 687}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_logxml_path_expansion(tmpdir, monkeypatch):\n    home_tilde = py.path.local(os.path.expanduser(\"~\")).join(\"test.xml\")\n    xml_tilde = LogXML(\"~%stest.xml\" % tmpdir.sep, None)\n    assert xml_tilde.logfile == home_tilde\n\n    monkeypatch.setenv(\"HOME\", str(tmpdir))\n    home_var = os.path.normpath(os.path.expandvars(\"$HOME/test.xml\"))\n    xml_var = LogXML(\"$HOME%stest.xml\" % tmpdir.sep, None)\n    assert xml_var.logfile == home_var\n\n\ndef test_logxml_changingdir(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_func():\n            import os\n            os.chdir(\"a\")\n    \"\"\"\n    )\n    testdir.tmpdir.mkdir(\"a\")\n    result = testdir.runpytest(\"--junitxml=a/x.xml\")\n    assert result.ret == 0\n    assert testdir.tmpdir.join(\"a/x.xml\").check()\n\n\ndef test_logxml_makedir(testdir):\n    \"\"\"--junitxml should automatically create directories for the xml file\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        def test_pass():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--junitxml=path/to/results.xml\")\n    assert result.ret == 0\n    assert testdir.tmpdir.join(\"path/to/results.xml\").check()\n\n\ndef test_logxml_check_isdir(testdir):\n    \"\"\"Give an error if --junit-xml is a directory (#2089)\"\"\"\n    result = testdir.runpytest(\"--junit-xml=.\")\n    result.stderr.fnmatch_lines([\"*--junitxml must be a filename*\"])\n\n\ndef test_escaped_parametrized_names_xml(testdir, run_and_parse):\n    testdir.makepyfile(\n        \"\"\"\\\n        import pytest\n        @pytest.mark.parametrize('char', [\"\\\\x00\"])\n        def test_func(char):\n            assert char\n        \"\"\"\n    )\n    result, dom = run_and_parse()\n    assert result.ret == 0\n    node = dom.find_first_by_tag(\"testcase\")\n    node.assert_attr(name=\"test_func[\\\\x00]\")\n\n\ndef test_double_colon_split_function_issue469(testdir, run_and_parse):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.parametrize('param', [\"double::colon\"])\n        def test_func(param):\n            pass\n    \"\"\"\n    )\n    result, dom = run_and_parse()\n    assert result.ret == 0\n    node = dom.find_first_by_tag(\"testcase\")\n    node.assert_attr(classname=\"test_double_colon_split_function_issue469\")\n    node.assert_attr(name=\"test_func[double::colon]\")\n\n\ndef test_double_colon_split_method_issue469(testdir, run_and_parse):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        class TestClass(object):\n            @pytest.mark.parametrize('param', [\"double::colon\"])\n            def test_func(self, param):\n                pass\n    \"\"\"\n    )\n    result, dom = run_and_parse()\n    assert result.ret == 0\n    node = dom.find_first_by_tag(\"testcase\")\n    node.assert_attr(classname=\"test_double_colon_split_method_issue469.TestClass\")\n    node.assert_attr(name=\"test_func[double::colon]\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_unicode_issue368_test_unicode_issue368.log_pytest_sessionfinish_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_unicode_issue368_test_unicode_issue368.log_pytest_sessionfinish_", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1020, "end_line": 1046, "span_ids": ["test_unicode_issue368"], "tokens": 215}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_unicode_issue368(testdir):\n    path = testdir.tmpdir.join(\"test.xml\")\n    log = LogXML(str(path), None)\n    ustr = \"\u0412\u041d\u0418!\"\n\n    class Report(BaseReport):\n        longrepr = ustr\n        sections = []\n        nodeid = \"something\"\n        location = \"tests/filename.py\", 42, \"TestClass.method\"\n\n    test_report = Report()\n\n    # hopefully this is not too brittle ...\n    log.pytest_sessionstart()\n    node_reporter = log._opentestcase(test_report)\n    node_reporter.append_failure(test_report)\n    node_reporter.append_collect_error(test_report)\n    node_reporter.append_collect_skipped(test_report)\n    node_reporter.append_error(test_report)\n    test_report.longrepr = \"filename\", 1, ustr\n    node_reporter.append_skipped(test_report)\n    test_report.longrepr = \"filename\", 1, \"Skipped: \u5361\u5623\u5623\"\n    node_reporter.append_skipped(test_report)\n    test_report.wasxfail = ustr\n    node_reporter.append_skipped(test_report)\n    log.pytest_sessionfinish()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_record_property_test_record_attribute.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_record_property_test_record_attribute.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1121, "end_line": 1200, "span_ids": ["test_record_attribute", "test_record_fixtures_without_junitxml", "test_record_property", "test_record_property_same_name"], "tokens": 578}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_record_property(testdir, run_and_parse):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture\n        def other(record_property):\n            record_property(\"bar\", 1)\n        def test_record(record_property, other):\n            record_property(\"foo\", \"<1\");\n    \"\"\"\n    )\n    result, dom = run_and_parse()\n    node = dom.find_first_by_tag(\"testsuite\")\n    tnode = node.find_first_by_tag(\"testcase\")\n    psnode = tnode.find_first_by_tag(\"properties\")\n    pnodes = psnode.find_by_tag(\"property\")\n    pnodes[0].assert_attr(name=\"bar\", value=\"1\")\n    pnodes[1].assert_attr(name=\"foo\", value=\"<1\")\n    result.stdout.fnmatch_lines([\"*= 1 passed in *\"])\n\n\ndef test_record_property_same_name(testdir, run_and_parse):\n    testdir.makepyfile(\n        \"\"\"\n        def test_record_with_same_name(record_property):\n            record_property(\"foo\", \"bar\")\n            record_property(\"foo\", \"baz\")\n    \"\"\"\n    )\n    result, dom = run_and_parse()\n    node = dom.find_first_by_tag(\"testsuite\")\n    tnode = node.find_first_by_tag(\"testcase\")\n    psnode = tnode.find_first_by_tag(\"properties\")\n    pnodes = psnode.find_by_tag(\"property\")\n    pnodes[0].assert_attr(name=\"foo\", value=\"bar\")\n    pnodes[1].assert_attr(name=\"foo\", value=\"baz\")\n\n\n@pytest.mark.parametrize(\"fixture_name\", [\"record_property\", \"record_xml_attribute\"])\ndef test_record_fixtures_without_junitxml(testdir, fixture_name):\n    testdir.makepyfile(\n        \"\"\"\n        def test_record({fixture_name}):\n            {fixture_name}(\"foo\", \"bar\")\n    \"\"\".format(\n            fixture_name=fixture_name\n        )\n    )\n    result = testdir.runpytest()\n    assert result.ret == 0\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_record_attribute(testdir, run_and_parse):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        junit_family = xunit1\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture\n        def other(record_xml_attribute):\n            record_xml_attribute(\"bar\", 1)\n        def test_record(record_xml_attribute, other):\n            record_xml_attribute(\"foo\", \"<1\");\n    \"\"\"\n    )\n    result, dom = run_and_parse()\n    node = dom.find_first_by_tag(\"testsuite\")\n    tnode = node.find_first_by_tag(\"testcase\")\n    tnode.assert_attr(bar=\"1\")\n    tnode.assert_attr(foo=\"<1\")\n    result.stdout.fnmatch_lines(\n        [\"*test_record_attribute.py:6:*record_xml_attribute is an experimental feature\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_record_fixtures_xunit2_test_record_fixtures_xunit2.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_record_fixtures_xunit2_test_record_fixtures_xunit2.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1203, "end_line": 1240, "span_ids": ["test_record_fixtures_xunit2"], "tokens": 273}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"default\")\n@pytest.mark.parametrize(\"fixture_name\", [\"record_xml_attribute\", \"record_property\"])\ndef test_record_fixtures_xunit2(testdir, fixture_name, run_and_parse):\n    \"\"\"Ensure record_xml_attribute and record_property drop values when outside of legacy family\n    \"\"\"\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        junit_family = xunit2\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture\n        def other({fixture_name}):\n            {fixture_name}(\"bar\", 1)\n        def test_record({fixture_name}, other):\n            {fixture_name}(\"foo\", \"<1\");\n    \"\"\".format(\n            fixture_name=fixture_name\n        )\n    )\n\n    result, dom = run_and_parse(family=None)\n    expected_lines = []\n    if fixture_name == \"record_xml_attribute\":\n        expected_lines.append(\n            \"*test_record_fixtures_xunit2.py:6:*record_xml_attribute is an experimental feature\"\n        )\n    expected_lines = [\n        \"*test_record_fixtures_xunit2.py:6:*{fixture_name} is incompatible \"\n        \"with junit_family 'xunit2' (use 'legacy' or 'xunit1')\".format(\n            fixture_name=fixture_name\n        )\n    ]\n    result.stdout.fnmatch_lines(expected_lines)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_random_report_log_xdist_test_random_report_log_xdist": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_random_report_log_xdist_test_random_report_log_xdist", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1170, "end_line": 1192, "span_ids": ["test_random_report_log_xdist"], "tokens": 205}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_random_report_log_xdist(testdir, monkeypatch, run_and_parse):\n    \"\"\"xdist calls pytest_runtest_logreport as they are executed by the slaves,\n    with nodes from several nodes overlapping, so junitxml must cope with that\n    to produce correct reports. #1064\n    \"\"\"\n    pytest.importorskip(\"xdist\")\n    monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n    testdir.makepyfile(\n        \"\"\"\n        import pytest, time\n        @pytest.mark.parametrize('i', list(range(30)))\n        def test_x(i):\n            assert i != 22\n    \"\"\"\n    )\n    _, dom = run_and_parse(\"-n2\")\n    suite_node = dom.find_first_by_tag(\"testsuite\")\n    failed = []\n    for case_node in suite_node.find_by_tag(\"testcase\"):\n        if case_node.find_first_by_tag(\"failure\"):\n            failed.append(case_node[\"name\"])\n\n    assert failed == [\"test_x[22]\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_fancy_items_regression_test_fancy_items_regression.assert_items_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_fancy_items_regression_test_fancy_items_regression.assert_items_", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1313, "end_line": 1362, "span_ids": ["test_fancy_items_regression"], "tokens": 274}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fancy_items_regression(testdir, run_and_parse):\n    # issue 1259\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        class FunItem(pytest.Item):\n            def runtest(self):\n                pass\n        class NoFunItem(pytest.Item):\n            def runtest(self):\n                pass\n\n        class FunCollector(pytest.File):\n            def collect(self):\n                return [\n                    FunItem('a', self),\n                    NoFunItem('a', self),\n                    NoFunItem('b', self),\n                ]\n\n        def pytest_collect_file(path, parent):\n            if path.check(ext='.py'):\n                return FunCollector(path, parent)\n    \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        def test_pass():\n            pass\n    \"\"\"\n    )\n\n    result, dom = run_and_parse()\n\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR*\")\n\n    items = sorted(\"%(classname)s %(name)s\" % x for x in dom.find_by_tag(\"testcase\"))\n    import pprint\n\n    pprint.pprint(items)\n    assert items == [\n        \"conftest a\",\n        \"conftest a\",\n        \"conftest b\",\n        \"test_fancy_items_regression a\",\n        \"test_fancy_items_regression a\",\n        \"test_fancy_items_regression b\",\n        \"test_fancy_items_regression test_pass\",\n    ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional_TestFunctional.test_mark_closest": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional_TestFunctional.test_mark_closest", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 453, "end_line": 564, "span_ids": ["TestFunctional", "TestFunctional.test_mark_closest", "TestFunctional.test_mark_decorator_baseclasses_merged", "TestFunctional.test_mark_decorator_subclass_does_not_propagate_to_base", "TestFunctional.test_mark_should_not_pass_to_siebling_class", "TestFunctional.test_merging_markers_deep"], "tokens": 696}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunctional:\n    def test_merging_markers_deep(self, testdir):\n        # issue 199 - propagate markers into nested classes\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            class TestA(object):\n                pytestmark = pytest.mark.a\n                def test_b(self):\n                    assert True\n                class TestC(object):\n                    # this one didn't get marked\n                    def test_d(self):\n                        assert True\n        \"\"\"\n        )\n        items, rec = testdir.inline_genitems(p)\n        for item in items:\n            print(item, item.keywords)\n            assert [x for x in item.iter_markers() if x.name == \"a\"]\n\n    def test_mark_decorator_subclass_does_not_propagate_to_base(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.a\n            class Base(object): pass\n\n            @pytest.mark.b\n            class Test1(Base):\n                def test_foo(self): pass\n\n            class Test2(Base):\n                def test_bar(self): pass\n        \"\"\"\n        )\n        items, rec = testdir.inline_genitems(p)\n        self.assert_markers(items, test_foo=(\"a\", \"b\"), test_bar=(\"a\",))\n\n    def test_mark_should_not_pass_to_siebling_class(self, testdir):\n        \"\"\"#568\"\"\"\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            class TestBase(object):\n                def test_foo(self):\n                    pass\n\n            @pytest.mark.b\n            class TestSub(TestBase):\n                pass\n\n\n            class TestOtherSub(TestBase):\n                pass\n\n        \"\"\"\n        )\n        items, rec = testdir.inline_genitems(p)\n        base_item, sub_item, sub_item_other = items\n        print(items, [x.nodeid for x in items])\n        # new api segregates\n        assert not list(base_item.iter_markers(name=\"b\"))\n        assert not list(sub_item_other.iter_markers(name=\"b\"))\n        assert list(sub_item.iter_markers(name=\"b\"))\n\n    def test_mark_decorator_baseclasses_merged(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.a\n            class Base(object): pass\n\n            @pytest.mark.b\n            class Base2(Base): pass\n\n            @pytest.mark.c\n            class Test1(Base2):\n                def test_foo(self): pass\n\n            class Test2(Base2):\n                @pytest.mark.d\n                def test_bar(self): pass\n        \"\"\"\n        )\n        items, rec = testdir.inline_genitems(p)\n        self.assert_markers(items, test_foo=(\"a\", \"b\", \"c\"), test_bar=(\"a\", \"b\", \"d\"))\n\n    def test_mark_closest(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.c(location=\"class\")\n            class Test:\n                @pytest.mark.c(location=\"function\")\n                def test_has_own(self):\n                    pass\n\n                def test_has_inherited(self):\n                    pass\n\n        \"\"\"\n        )\n        items, rec = testdir.inline_genitems(p)\n        has_own, has_inherited = items\n        assert has_own.get_closest_marker(\"c\").kwargs == {\"location\": \"function\"}\n        assert has_inherited.get_closest_marker(\"c\").kwargs == {\"location\": \"class\"}\n        assert has_own.get_closest_marker(\"missing\") is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestKeywordSelection_TestKeywordSelection.test_select_extra_keywords.assert_dlist_0_items_0_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestKeywordSelection_TestKeywordSelection.test_select_extra_keywords.assert_dlist_0_items_0_", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 690, "end_line": 752, "span_ids": ["TestKeywordSelection", "TestKeywordSelection.test_select_extra_keywords", "TestKeywordSelection.test_select_simple"], "tokens": 455}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestKeywordSelection:\n    def test_select_simple(self, testdir):\n        file_test = testdir.makepyfile(\n            \"\"\"\n            def test_one():\n                assert 0\n            class TestClass(object):\n                def test_method_one(self):\n                    assert 42 == 43\n        \"\"\"\n        )\n\n        def check(keyword, name):\n            reprec = testdir.inline_run(\"-s\", \"-k\", keyword, file_test)\n            passed, skipped, failed = reprec.listoutcomes()\n            assert len(failed) == 1\n            assert failed[0].nodeid.split(\"::\")[-1] == name\n            assert len(reprec.getcalls(\"pytest_deselected\")) == 1\n\n        for keyword in [\"test_one\", \"est_on\"]:\n            check(keyword, \"test_one\")\n        check(\"TestClass and test\", \"test_method_one\")\n\n    @pytest.mark.parametrize(\n        \"keyword\",\n        [\n            \"xxx\",\n            \"xxx and test_2\",\n            \"TestClass\",\n            \"xxx and not test_1\",\n            \"TestClass and test_2\",\n            \"xxx and TestClass and test_2\",\n        ],\n    )\n    def test_select_extra_keywords(self, testdir, keyword):\n        p = testdir.makepyfile(\n            test_select=\"\"\"\n            def test_1():\n                pass\n            class TestClass(object):\n                def test_2(self):\n                    pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            conftest=\"\"\"\n            import pytest\n            @pytest.hookimpl(hookwrapper=True)\n            def pytest_pycollect_makeitem(name):\n                outcome = yield\n                if name == \"TestClass\":\n                    item = outcome.get_result()\n                    item.extra_keyword_matches.add(\"xxx\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p.dirpath(), \"-s\", \"-k\", keyword)\n        print(\"keyword\", repr(keyword))\n        passed, skipped, failed = reprec.listoutcomes()\n        assert len(passed) == 1\n        assert passed[0].nodeid.endswith(\"test_2\")\n        dlist = reprec.getcalls(\"pytest_deselected\")\n        assert len(dlist) == 1\n        assert dlist[0].items[0].name == \"test_1\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestKeywordSelection.test_select_starton_TestKeywordSelection.test_no_magic_values": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestKeywordSelection.test_select_starton_TestKeywordSelection.test_no_magic_values", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 773, "end_line": 835, "span_ids": ["TestKeywordSelection.test_keyword_extra", "TestKeywordSelection.test_keyword_extra_dash", "TestKeywordSelection.test_no_magic_values", "TestKeywordSelection.test_select_starton"], "tokens": 503}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestKeywordSelection:\n\n    def test_select_starton(self, testdir):\n        threepass = testdir.makepyfile(\n            test_threepass=\"\"\"\n            def test_one(): assert 1\n            def test_two(): assert 1\n            def test_three(): assert 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-k\", \"test_two:\", threepass)\n        passed, skipped, failed = reprec.listoutcomes()\n        assert len(passed) == 2\n        assert not failed\n        dlist = reprec.getcalls(\"pytest_deselected\")\n        assert len(dlist) == 1\n        item = dlist[0].items[0]\n        assert item.name == \"test_one\"\n\n    def test_keyword_extra(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n           def test_one():\n               assert 0\n           test_one.mykeyword = True\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-k\", \"mykeyword\", p)\n        passed, skipped, failed = reprec.countoutcomes()\n        assert failed == 1\n\n    @pytest.mark.xfail\n    def test_keyword_extra_dash(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n           def test_one():\n               assert 0\n           test_one.mykeyword = True\n        \"\"\"\n        )\n        # with argparse the argument to an option cannot\n        # start with '-'\n        reprec = testdir.inline_run(\"-k\", \"-mykeyword\", p)\n        passed, skipped, failed = reprec.countoutcomes()\n        assert passed + skipped + failed == 0\n\n    @pytest.mark.parametrize(\n        \"keyword\", [\"__\", \"+\", \"..\"],\n    )\n    def test_no_magic_values(self, testdir, keyword: str) -> None:\n        \"\"\"Make sure the tests do not match on magic values,\n        no double underscored values, like '__dict__' and '+'.\n        \"\"\"\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_one(): assert 1\n        \"\"\"\n        )\n\n        reprec = testdir.inline_run(\"-k\", keyword, p)\n        passed, skipped, failed = reprec.countoutcomes()\n        dlist = reprec.getcalls(\"pytest_deselected\")\n        assert passed + skipped + failed == 0\n        deselected_tests = dlist[0].items\n        assert len(deselected_tests) == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestMarkDecorator_test_parameterset_for_parametrize_marks": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestMarkDecorator_test_parameterset_for_parametrize_marks", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 838, "end_line": 881, "span_ids": ["TestMarkDecorator", "TestMarkDecorator.test__eq__", "TestMarkDecorator.test_aliases", "test_parameterset_for_parametrize_marks"], "tokens": 322}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMarkDecorator:\n    @pytest.mark.parametrize(\n        \"lhs, rhs, expected\",\n        [\n            (pytest.mark.foo(), pytest.mark.foo(), True),\n            (pytest.mark.foo(), pytest.mark.bar(), False),\n            (pytest.mark.foo(), \"bar\", False),\n            (\"foo\", pytest.mark.bar(), False),\n        ],\n    )\n    def test__eq__(self, lhs, rhs, expected):\n        assert (lhs == rhs) == expected\n\n    def test_aliases(self) -> None:\n        md = pytest.mark.foo(1, \"2\", three=3)\n        assert md.name == \"foo\"\n        assert md.args == (1, \"2\")\n        assert md.kwargs == {\"three\": 3}\n\n\n@pytest.mark.parametrize(\"mark\", [None, \"\", \"skip\", \"xfail\"])\ndef test_parameterset_for_parametrize_marks(testdir, mark):\n    if mark is not None:\n        testdir.makeini(\n            \"\"\"\n        [pytest]\n        {}={}\n        \"\"\".format(\n                EMPTY_PARAMETERSET_OPTION, mark\n            )\n        )\n\n    config = testdir.parseconfig()\n    from _pytest.mark import pytest_configure, get_empty_parameterset_mark\n\n    pytest_configure(config)\n    result_mark = get_empty_parameterset_mark(config, [\"a\"], all)\n    if mark in (None, \"\"):\n        # normalize to the requested name\n        mark = \"skip\"\n    assert result_mark.name == mark\n    assert result_mark.kwargs[\"reason\"].startswith(\"got empty parameter set \")\n    if mark == \"xfail\":\n        assert result_mark.kwargs.get(\"run\") is False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_TestSetattrWithImportPath_TestSetattrWithImportPath.test_delattr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_TestSetattrWithImportPath_TestSetattrWithImportPath.test_delattr", "embedding": null, "metadata": {"file_path": "testing/test_monkeypatch.py", "file_name": "test_monkeypatch.py", "file_type": "text/x-python", "category": "test", "start_line": 43, "end_line": 81, "span_ids": ["TestSetattrWithImportPath", "TestSetattrWithImportPath.test_delattr", "TestSetattrWithImportPath.test_string_expression", "TestSetattrWithImportPath.test_string_expression_class", "TestSetattrWithImportPath.test_unicode_string", "TestSetattrWithImportPath.test_unknown_attr", "TestSetattrWithImportPath.test_unknown_attr_non_raising", "TestSetattrWithImportPath.test_unknown_import", "TestSetattrWithImportPath.test_wrong_target"], "tokens": 317}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSetattrWithImportPath:\n    def test_string_expression(self, monkeypatch):\n        monkeypatch.setattr(\"os.path.abspath\", lambda x: \"hello2\")\n        assert os.path.abspath(\"123\") == \"hello2\"\n\n    def test_string_expression_class(self, monkeypatch):\n        monkeypatch.setattr(\"_pytest.config.Config\", 42)\n        import _pytest\n\n        assert _pytest.config.Config == 42\n\n    def test_unicode_string(self, monkeypatch):\n        monkeypatch.setattr(\"_pytest.config.Config\", 42)\n        import _pytest\n\n        assert _pytest.config.Config == 42\n        monkeypatch.delattr(\"_pytest.config.Config\")\n\n    def test_wrong_target(self, monkeypatch):\n        pytest.raises(TypeError, lambda: monkeypatch.setattr(None, None))\n\n    def test_unknown_import(self, monkeypatch):\n        pytest.raises(ImportError, lambda: monkeypatch.setattr(\"unkn123.classx\", None))\n\n    def test_unknown_attr(self, monkeypatch):\n        pytest.raises(\n            AttributeError, lambda: monkeypatch.setattr(\"os.path.qweqwe\", None)\n        )\n\n    def test_unknown_attr_non_raising(self, monkeypatch):\n        # https://github.com/pytest-dev/pytest/issues/746\n        monkeypatch.setattr(\"os.path.qweqwe\", 42, raising=False)\n        assert os.path.qweqwe == 42\n\n    def test_delattr(self, monkeypatch):\n        monkeypatch.delattr(\"os.path.abspath\")\n        assert not hasattr(os.path, \"abspath\")\n        monkeypatch.undo()\n        assert os.path.abspath", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_delattr_test_setenv": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_delattr_test_setenv", "embedding": null, "metadata": {"file_path": "testing/test_monkeypatch.py", "file_name": "test_monkeypatch.py", "file_type": "text/x-python", "category": "test", "start_line": 84, "end_line": 172, "span_ids": ["test_delattr", "test_delitem", "test_setenv", "test_setenv_deleted_meanwhile", "test_setitem", "test_setitem_deleted_meanwhile"], "tokens": 658}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_delattr():\n    class A:\n        x = 1\n\n    monkeypatch = MonkeyPatch()\n    monkeypatch.delattr(A, \"x\")\n    assert not hasattr(A, \"x\")\n    monkeypatch.undo()\n    assert A.x == 1\n\n    monkeypatch = MonkeyPatch()\n    monkeypatch.delattr(A, \"x\")\n    pytest.raises(AttributeError, monkeypatch.delattr, A, \"y\")\n    monkeypatch.delattr(A, \"y\", raising=False)\n    monkeypatch.setattr(A, \"x\", 5, raising=False)\n    assert A.x == 5\n    monkeypatch.undo()\n    assert A.x == 1\n\n\ndef test_setitem():\n    d = {\"x\": 1}\n    monkeypatch = MonkeyPatch()\n    monkeypatch.setitem(d, \"x\", 2)\n    monkeypatch.setitem(d, \"y\", 1700)\n    monkeypatch.setitem(d, \"y\", 1700)\n    assert d[\"x\"] == 2\n    assert d[\"y\"] == 1700\n    monkeypatch.setitem(d, \"x\", 3)\n    assert d[\"x\"] == 3\n    monkeypatch.undo()\n    assert d[\"x\"] == 1\n    assert \"y\" not in d\n    d[\"x\"] = 5\n    monkeypatch.undo()\n    assert d[\"x\"] == 5\n\n\ndef test_setitem_deleted_meanwhile():\n    d = {}\n    monkeypatch = MonkeyPatch()\n    monkeypatch.setitem(d, \"x\", 2)\n    del d[\"x\"]\n    monkeypatch.undo()\n    assert not d\n\n\n@pytest.mark.parametrize(\"before\", [True, False])\ndef test_setenv_deleted_meanwhile(before):\n    key = \"qwpeoip123\"\n    if before:\n        os.environ[key] = \"world\"\n    monkeypatch = MonkeyPatch()\n    monkeypatch.setenv(key, \"hello\")\n    del os.environ[key]\n    monkeypatch.undo()\n    if before:\n        assert os.environ[key] == \"world\"\n        del os.environ[key]\n    else:\n        assert key not in os.environ\n\n\ndef test_delitem():\n    d = {\"x\": 1}\n    monkeypatch = MonkeyPatch()\n    monkeypatch.delitem(d, \"x\")\n    assert \"x\" not in d\n    monkeypatch.delitem(d, \"y\", raising=False)\n    pytest.raises(KeyError, monkeypatch.delitem, d, \"y\")\n    assert not d\n    monkeypatch.setitem(d, \"y\", 1700)\n    assert d[\"y\"] == 1700\n    d[\"hello\"] = \"world\"\n    monkeypatch.setitem(d, \"x\", 1500)\n    assert d[\"x\"] == 1500\n    monkeypatch.undo()\n    assert d == {\"hello\": \"world\", \"x\": 1}\n\n\ndef test_setenv():\n    monkeypatch = MonkeyPatch()\n    with pytest.warns(pytest.PytestWarning):\n        monkeypatch.setenv(\"XYZ123\", 2)\n    import os\n\n    assert os.environ[\"XYZ123\"] == \"2\"\n    monkeypatch.undo()\n    assert \"XYZ123\" not in os.environ", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_syspath_prepend_with_namespace_packages_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_syspath_prepend_with_namespace_packages_", "embedding": null, "metadata": {"file_path": "testing/test_monkeypatch.py", "file_name": "test_monkeypatch.py", "file_type": "text/x-python", "category": "test", "start_line": 442, "end_line": 472, "span_ids": ["test_syspath_prepend_with_namespace_packages"], "tokens": 230}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_syspath_prepend_with_namespace_packages(testdir, monkeypatch):\n    for dirname in \"hello\", \"world\":\n        d = testdir.mkdir(dirname)\n        ns = d.mkdir(\"ns_pkg\")\n        ns.join(\"__init__.py\").write(\n            \"__import__('pkg_resources').declare_namespace(__name__)\"\n        )\n        lib = ns.mkdir(dirname)\n        lib.join(\"__init__.py\").write(\"def check(): return %r\" % dirname)\n\n    monkeypatch.syspath_prepend(\"hello\")\n    import ns_pkg.hello\n\n    assert ns_pkg.hello.check() == \"hello\"\n\n    with pytest.raises(ImportError):\n        import ns_pkg.world\n\n    # Prepending should call fixup_namespace_packages.\n    monkeypatch.syspath_prepend(\"world\")\n    import ns_pkg.world\n\n    assert ns_pkg.world.check() == \"world\"\n\n    # Should invalidate caches via importlib.invalidate_caches.\n    tmpdir = testdir.tmpdir\n    modules_tmpdir = tmpdir.mkdir(\"modules_tmpdir\")\n    monkeypatch.syspath_prepend(str(modules_tmpdir))\n    modules_tmpdir.join(\"main_app.py\").write(\"app = True\")\n    from main_app import app  # noqa: F401", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_nose_setup_partial_test_apiwrapper_problem_issue260": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_nose_setup_partial_test_apiwrapper_problem_issue260", "embedding": null, "metadata": {"file_path": "testing/test_nose.py", "file_name": "test_nose.py", "file_type": "text/x-python", "category": "test", "start_line": 125, "end_line": 252, "span_ids": ["test_apiwrapper_problem_issue260", "test_module_level_setup", "test_nose_setup_ordering", "test_nose_setup_partial", "test_nose_style_setup_teardown"], "tokens": 674}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_nose_setup_partial(testdir):\n    pytest.importorskip(\"functools\")\n    p = testdir.makepyfile(\n        \"\"\"\n        from functools import partial\n\n        values = []\n\n        def my_setup(x):\n            a = x\n            values.append(a)\n\n        def my_teardown(x):\n            b = x\n            values.append(b)\n\n        my_setup_partial = partial(my_setup, 1)\n        my_teardown_partial = partial(my_teardown, 2)\n\n        def test_hello():\n            print(values)\n            assert values == [1]\n\n        def test_world():\n            print(values)\n            assert values == [1,2]\n\n        test_hello.setup = my_setup_partial\n        test_hello.teardown = my_teardown_partial\n    \"\"\"\n    )\n    result = testdir.runpytest(p, \"-p\", \"nose\")\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n\ndef test_module_level_setup(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        from nose.tools import with_setup\n        items = {}\n\n        def setup():\n            items[1]=1\n\n        def teardown():\n            del items[1]\n\n        def setup2():\n            items[2] = 2\n\n        def teardown2():\n            del items[2]\n\n        def test_setup_module_setup():\n            assert items[1] == 1\n\n        @with_setup(setup2, teardown2)\n        def test_local_setup():\n            assert items[2] == 2\n            assert 1 not in items\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-p\", \"nose\")\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n\ndef test_nose_style_setup_teardown(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        values = []\n\n        def setup_module():\n            values.append(1)\n\n        def teardown_module():\n            del values[0]\n\n        def test_hello():\n            assert values == [1]\n\n        def test_world():\n            assert values == [1]\n        \"\"\"\n    )\n    result = testdir.runpytest(\"-p\", \"nose\")\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n\ndef test_nose_setup_ordering(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def setup_module(mod):\n            mod.visited = True\n\n        class TestClass(object):\n            def setup(self):\n                assert visited\n            def test_first(self):\n                pass\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_apiwrapper_problem_issue260(testdir):\n    # this would end up trying a call an optional teardown on the class\n    # for plain unittests we don't want nose behaviour\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class TestCase(unittest.TestCase):\n            def setup(self):\n                #should not be called in unittest testcases\n                assert 0, 'setup'\n            def teardown(self):\n                #should not be called in unittest testcases\n                assert 0, 'teardown'\n            def setUp(self):\n                print('setup')\n            def tearDown(self):\n                print('teardown')\n            def test_fun(self):\n                pass\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_group_addoption_conflict_TestParser.test_parse_special_destination": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_group_addoption_conflict_TestParser.test_parse_special_destination", "embedding": null, "metadata": {"file_path": "testing/test_parseopt.py", "file_name": "test_parseopt.py", "file_type": "text/x-python", "category": "test", "start_line": 97, "end_line": 165, "span_ids": ["TestParser.test_group_addoption_conflict", "TestParser.test_group_shortopt_lowercase", "TestParser.test_parse", "TestParser.test_parse2", "TestParser.test_parse_known_and_unknown_args", "TestParser.test_parse_known_args", "TestParser.test_parse_setoption", "TestParser.test_parse_special_destination", "TestParser.test_parse_will_set_default", "TestParser.test_parser_addoption"], "tokens": 689}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestParser:\n\n    def test_group_addoption_conflict(self) -> None:\n        group = parseopt.OptionGroup(\"hello again\")\n        group.addoption(\"--option1\", \"--option-1\", action=\"store_true\")\n        with pytest.raises(ValueError) as err:\n            group.addoption(\"--option1\", \"--option-one\", action=\"store_true\")\n        assert str({\"--option1\"}) in str(err.value)\n\n    def test_group_shortopt_lowercase(self, parser: parseopt.Parser) -> None:\n        group = parser.getgroup(\"hello\")\n        with pytest.raises(ValueError):\n            group.addoption(\"-x\", action=\"store_true\")\n        assert len(group.options) == 0\n        group._addoption(\"-x\", action=\"store_true\")\n        assert len(group.options) == 1\n\n    def test_parser_addoption(self, parser: parseopt.Parser) -> None:\n        group = parser.getgroup(\"custom options\")\n        assert len(group.options) == 0\n        group.addoption(\"--option1\", action=\"store_true\")\n        assert len(group.options) == 1\n\n    def test_parse(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--hello\", dest=\"hello\", action=\"store\")\n        args = parser.parse([\"--hello\", \"world\"])\n        assert args.hello == \"world\"\n        assert not getattr(args, parseopt.FILE_OR_DIR)\n\n    def test_parse2(self, parser: parseopt.Parser) -> None:\n        args = parser.parse([py.path.local()])\n        assert getattr(args, parseopt.FILE_OR_DIR)[0] == py.path.local()\n\n    def test_parse_known_args(self, parser: parseopt.Parser) -> None:\n        parser.parse_known_args([py.path.local()])\n        parser.addoption(\"--hello\", action=\"store_true\")\n        ns = parser.parse_known_args([\"x\", \"--y\", \"--hello\", \"this\"])\n        assert ns.hello\n        assert ns.file_or_dir == [\"x\"]\n\n    def test_parse_known_and_unknown_args(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--hello\", action=\"store_true\")\n        ns, unknown = parser.parse_known_and_unknown_args(\n            [\"x\", \"--y\", \"--hello\", \"this\"]\n        )\n        assert ns.hello\n        assert ns.file_or_dir == [\"x\"]\n        assert unknown == [\"--y\", \"this\"]\n\n    def test_parse_will_set_default(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--hello\", dest=\"hello\", default=\"x\", action=\"store\")\n        option = parser.parse([])\n        assert option.hello == \"x\"\n        del option.hello\n        parser.parse_setoption([], option)\n        assert option.hello == \"x\"\n\n    def test_parse_setoption(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--hello\", dest=\"hello\", action=\"store\")\n        parser.addoption(\"--world\", dest=\"world\", default=42)\n\n        option = argparse.Namespace()\n        args = parser.parse_setoption([\"--hello\", \"world\"], option)\n        assert option.hello == \"world\"\n        assert option.world == 42\n        assert not args\n\n    def test_parse_special_destination(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--ultimate-answer\", type=int)\n        args = parser.parse([\"--ultimate-answer\", \"42\"])\n        assert args.ultimate_answer == 42", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_parse_split_positional_arguments_TestParser.test_parse_defaultgetter": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_parse_split_positional_arguments_TestParser.test_parse_defaultgetter", "embedding": null, "metadata": {"file_path": "testing/test_parseopt.py", "file_name": "test_parseopt.py", "file_type": "text/x-python", "category": "test", "start_line": 167, "end_line": 197, "span_ids": ["TestParser.test_parse_defaultgetter", "TestParser.test_parse_split_positional_arguments"], "tokens": 328}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestParser:\n\n    def test_parse_split_positional_arguments(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"-R\", action=\"store_true\")\n        parser.addoption(\"-S\", action=\"store_false\")\n        args = parser.parse([\"-R\", \"4\", \"2\", \"-S\"])\n        assert getattr(args, parseopt.FILE_OR_DIR) == [\"4\", \"2\"]\n        args = parser.parse([\"-R\", \"-S\", \"4\", \"2\", \"-R\"])\n        assert getattr(args, parseopt.FILE_OR_DIR) == [\"4\", \"2\"]\n        assert args.R is True\n        assert args.S is False\n        args = parser.parse([\"-R\", \"4\", \"-S\", \"2\"])\n        assert getattr(args, parseopt.FILE_OR_DIR) == [\"4\", \"2\"]\n        assert args.R is True\n        assert args.S is False\n\n    def test_parse_defaultgetter(self) -> None:\n        def defaultget(option):\n            if not hasattr(option, \"type\"):\n                return\n            if option.type is int:\n                option.default = 42\n            elif option.type is str:\n                option.default = \"world\"\n\n        parser = parseopt.Parser(processopt=defaultget)\n        parser.addoption(\"--this\", dest=\"this\", type=int, action=\"store\")\n        parser.addoption(\"--hello\", dest=\"hello\", type=str, action=\"store\")\n        parser.addoption(\"--no\", dest=\"no\", action=\"store_true\")\n        option = parser.parse([])\n        assert option.hello == \"world\"\n        assert option.this == 42\n        assert option.no is False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_drop_short_helper_TestParser.test_drop_short_helper.assert_join_args_file": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_drop_short_helper_TestParser.test_drop_short_helper.assert_join_args_file", "embedding": null, "metadata": {"file_path": "testing/test_parseopt.py", "file_name": "test_parseopt.py", "file_type": "text/x-python", "category": "test", "start_line": 199, "end_line": 234, "span_ids": ["TestParser.test_drop_short_helper"], "tokens": 382}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestParser:\n\n    def test_drop_short_helper(self) -> None:\n        parser = argparse.ArgumentParser(\n            formatter_class=parseopt.DropShorterLongHelpFormatter, allow_abbrev=False\n        )\n        parser.add_argument(\n            \"-t\", \"--twoword\", \"--duo\", \"--two-word\", \"--two\", help=\"foo\"\n        )\n        # throws error on --deux only!\n        parser.add_argument(\n            \"-d\", \"--deuxmots\", \"--deux-mots\", action=\"store_true\", help=\"foo\"\n        )\n        parser.add_argument(\"-s\", action=\"store_true\", help=\"single short\")\n        parser.add_argument(\"--abc\", \"-a\", action=\"store_true\", help=\"bar\")\n        parser.add_argument(\"--klm\", \"-k\", \"--kl-m\", action=\"store_true\", help=\"bar\")\n        parser.add_argument(\n            \"-P\", \"--pq-r\", \"-p\", \"--pqr\", action=\"store_true\", help=\"bar\"\n        )\n        parser.add_argument(\n            \"--zwei-wort\", \"--zweiwort\", \"--zweiwort\", action=\"store_true\", help=\"bar\"\n        )\n        parser.add_argument(\n            \"-x\", \"--exit-on-first\", \"--exitfirst\", action=\"store_true\", help=\"spam\"\n        )\n        parser.add_argument(\"files_and_dirs\", nargs=\"*\")\n        args = parser.parse_args([\"-k\", \"--duo\", \"hallo\", \"--exitfirst\"])\n        assert args.twoword == \"hallo\"\n        assert args.klm is True\n        assert args.zwei_wort is False\n        assert args.exit_on_first is True\n        assert args.s is False\n        args = parser.parse_args([\"--deux-mots\"])\n        with pytest.raises(AttributeError):\n            assert args.deux_mots is True\n        assert args.deuxmots is True\n        args = parser.parse_args([\"file\", \"dir\"])\n        assert \"|\".join(args.files_and_dirs) == \"file|dir\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_drop_short_0_TestParser.test_multiple_metavar_help": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_TestParser.test_drop_short_0_TestParser.test_multiple_metavar_help", "embedding": null, "metadata": {"file_path": "testing/test_parseopt.py", "file_name": "test_parseopt.py", "file_type": "text/x-python", "category": "test", "start_line": 236, "end_line": 287, "span_ids": ["TestParser.test_drop_short_0", "TestParser.test_drop_short_2", "TestParser.test_drop_short_3", "TestParser.test_drop_short_help0", "TestParser.test_drop_short_help1", "TestParser.test_multiple_metavar_help", "TestParser:2"], "tokens": 533}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestParser:\n\n    def test_drop_short_0(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--funcarg\", \"--func-arg\", action=\"store_true\")\n        parser.addoption(\"--abc-def\", \"--abc-def\", action=\"store_true\")\n        parser.addoption(\"--klm-hij\", action=\"store_true\")\n        with pytest.raises(UsageError):\n            parser.parse([\"--funcarg\", \"--k\"])\n\n    def test_drop_short_2(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--func-arg\", \"--doit\", action=\"store_true\")\n        args = parser.parse([\"--doit\"])\n        assert args.func_arg is True\n\n    def test_drop_short_3(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--func-arg\", \"--funcarg\", \"--doit\", action=\"store_true\")\n        args = parser.parse([\"abcd\"])\n        assert args.func_arg is False\n        assert args.file_or_dir == [\"abcd\"]\n\n    def test_drop_short_help0(self, parser: parseopt.Parser) -> None:\n        parser.addoption(\"--func-args\", \"--doit\", help=\"foo\", action=\"store_true\")\n        parser.parse([])\n        help = parser.optparser.format_help()\n        assert \"--func-args, --doit  foo\" in help\n\n    # testing would be more helpful with all help generated\n    def test_drop_short_help1(self, parser: parseopt.Parser) -> None:\n        group = parser.getgroup(\"general\")\n        group.addoption(\"--doit\", \"--func-args\", action=\"store_true\", help=\"foo\")\n        group._addoption(\n            \"-h\",\n            \"--help\",\n            action=\"store_true\",\n            dest=\"help\",\n            help=\"show help message and configuration info\",\n        )\n        parser.parse([\"-h\"])\n        help = parser.optparser.format_help()\n        assert \"-doit, --func-args  foo\" in help\n\n    def test_multiple_metavar_help(self, parser: parseopt.Parser) -> None:\n        \"\"\"\n        Help text for options with a metavar tuple should display help\n        in the form \"--preferences=value1 value2 value3\" (#2004).\n        \"\"\"\n        group = parser.getgroup(\"general\")\n        group.addoption(\n            \"--preferences\", metavar=(\"value1\", \"value2\", \"value3\"), nargs=3\n        )\n        group._addoption(\"-h\", \"--help\", action=\"store_true\", dest=\"help\")\n        parser.parse([\"-h\"])\n        help = parser.optparser.format_help()\n        assert \"--preferences=value1 value2 value3\" in help", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_test_argcomplete_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_test_argcomplete_", "embedding": null, "metadata": {"file_path": "testing/test_parseopt.py", "file_name": "test_parseopt.py", "file_type": "text/x-python", "category": "test", "start_line": 290, "end_line": 332, "span_ids": ["test_argcomplete"], "tokens": 441}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_argcomplete(testdir, monkeypatch) -> None:\n    if not shutil.which(\"bash\"):\n        pytest.skip(\"bash not available\")\n    script = str(testdir.tmpdir.join(\"test_argcomplete\"))\n\n    with open(str(script), \"w\") as fp:\n        # redirect output from argcomplete to stdin and stderr is not trivial\n        # http://stackoverflow.com/q/12589419/1307905\n        # so we use bash\n        fp.write(\n            'COMP_WORDBREAKS=\"$COMP_WORDBREAKS\" {} -m pytest 8>&1 9>&2'.format(\n                shlex.quote(sys.executable)\n            )\n        )\n    # alternative would be extended Testdir.{run(),_run(),popen()} to be able\n    # to handle a keyword argument env that replaces os.environ in popen or\n    # extends the copy, advantage: could not forget to restore\n    monkeypatch.setenv(\"_ARGCOMPLETE\", \"1\")\n    monkeypatch.setenv(\"_ARGCOMPLETE_IFS\", \"\\x0b\")\n    monkeypatch.setenv(\"COMP_WORDBREAKS\", \" \\\\t\\\\n\\\"\\\\'><=;|&(:\")\n\n    arg = \"--fu\"\n    monkeypatch.setenv(\"COMP_LINE\", \"pytest \" + arg)\n    monkeypatch.setenv(\"COMP_POINT\", str(len(\"pytest \" + arg)))\n    result = testdir.run(\"bash\", str(script), arg)\n    if result.ret == 255:\n        # argcomplete not found\n        pytest.skip(\"argcomplete not available\")\n    elif not result.stdout.str():\n        pytest.skip(\n            \"bash provided no output on stdout, argcomplete not available? (stderr={!r})\".format(\n                result.stderr.str()\n            )\n        )\n    else:\n        result.stdout.fnmatch_lines([\"--funcargs\", \"--fulltrace\"])\n    os.mkdir(\"test_argcomplete.d\")\n    arg = \"test_argc\"\n    monkeypatch.setenv(\"COMP_LINE\", \"pytest \" + arg)\n    monkeypatch.setenv(\"COMP_POINT\", str(len(\"pytest \" + arg)))\n    result = testdir.run(\"bash\", str(script), arg)\n    result.stdout.fnmatch_lines([\"test_argcomplete\", \"test_argcomplete.d/\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pastebin.py_TestPaste_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pastebin.py_TestPaste_", "embedding": null, "metadata": {"file_path": "testing/test_pastebin.py", "file_name": "test_pastebin.py", "file_type": "text/x-python", "category": "test", "start_line": 80, "end_line": 185, "span_ids": ["TestPaste", "TestPaste.mocked_urlopen", "TestPaste.mocked_urlopen_fail", "TestPaste.mocked_urlopen_invalid", "TestPaste.pastebin", "TestPaste.test_create_new_paste", "TestPaste.test_create_new_paste_failure", "TestPaste.test_pastebin_http_error", "TestPaste.test_pastebin_invalid_url"], "tokens": 778}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPaste:\n    @pytest.fixture\n    def pastebin(self, request):\n        return request.config.pluginmanager.getplugin(\"pastebin\")\n\n    @pytest.fixture\n    def mocked_urlopen_fail(self, monkeypatch):\n        \"\"\"\n        monkeypatch the actual urlopen call to emulate a HTTP Error 400\n        \"\"\"\n        calls = []\n\n        import urllib.error\n        import urllib.request\n\n        def mocked(url, data):\n            calls.append((url, data))\n            raise urllib.error.HTTPError(url, 400, \"Bad request\", None, None)\n\n        monkeypatch.setattr(urllib.request, \"urlopen\", mocked)\n        return calls\n\n    @pytest.fixture\n    def mocked_urlopen_invalid(self, monkeypatch):\n        \"\"\"\n        monkeypatch the actual urlopen calls done by the internal plugin\n        function that connects to bpaste service, but return a url in an\n        unexpected format\n        \"\"\"\n        calls = []\n\n        def mocked(url, data):\n            calls.append((url, data))\n\n            class DummyFile:\n                def read(self):\n                    # part of html of a normal response\n                    return b'View <a href=\"/invalid/3c0c6750bd\">raw</a>.'\n\n            return DummyFile()\n\n        import urllib.request\n\n        monkeypatch.setattr(urllib.request, \"urlopen\", mocked)\n        return calls\n\n    @pytest.fixture\n    def mocked_urlopen(self, monkeypatch):\n        \"\"\"\n        monkeypatch the actual urlopen calls done by the internal plugin\n        function that connects to bpaste service.\n        \"\"\"\n        calls = []\n\n        def mocked(url, data):\n            calls.append((url, data))\n\n            class DummyFile:\n                def read(self):\n                    # part of html of a normal response\n                    return b'View <a href=\"/raw/3c0c6750bd\">raw</a>.'\n\n            return DummyFile()\n\n        import urllib.request\n\n        monkeypatch.setattr(urllib.request, \"urlopen\", mocked)\n        return calls\n\n    def test_pastebin_invalid_url(self, pastebin, mocked_urlopen_invalid):\n        result = pastebin.create_new_paste(b\"full-paste-contents\")\n        assert (\n            result\n            == \"bad response: invalid format ('View <a href=\\\"/invalid/3c0c6750bd\\\">raw</a>.')\"\n        )\n        assert len(mocked_urlopen_invalid) == 1\n\n    def test_pastebin_http_error(self, pastebin, mocked_urlopen_fail):\n        result = pastebin.create_new_paste(b\"full-paste-contents\")\n        assert result == \"bad response: HTTP Error 400: Bad request\"\n        assert len(mocked_urlopen_fail) == 1\n\n    def test_create_new_paste(self, pastebin, mocked_urlopen):\n        result = pastebin.create_new_paste(b\"full-paste-contents\")\n        assert result == \"https://bpaste.net/show/3c0c6750bd\"\n        assert len(mocked_urlopen) == 1\n        url, data = mocked_urlopen[0]\n        assert type(data) is bytes\n        lexer = \"text\"\n        assert url == \"https://bpaste.net\"\n        assert \"lexer=%s\" % lexer in data.decode()\n        assert \"code=full-paste-contents\" in data.decode()\n        assert \"expiry=1week\" in data.decode()\n\n    def test_create_new_paste_failure(self, pastebin, monkeypatch):\n        import io\n        import urllib.request\n\n        def response(url, data):\n            stream = io.BytesIO(b\"something bad occurred\")\n            return stream\n\n        monkeypatch.setattr(urllib.request, \"urlopen\", response)\n        result = pastebin.create_new_paste(b\"full-paste-contents\")\n        assert result == \"bad response: invalid format ('something bad occurred')\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManager_TestPytestPluginManager.test_plugin_skip": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManager_TestPytestPluginManager.test_plugin_skip", "embedding": null, "metadata": {"file_path": "testing/test_pluginmanager.py", "file_name": "test_pluginmanager.py", "file_type": "text/x-python", "category": "test", "start_line": 197, "end_line": 263, "span_ids": ["TestPytestPluginManager", "TestPytestPluginManager.test_canonical_import", "TestPytestPluginManager.test_consider_env_fails_to_import", "TestPytestPluginManager.test_consider_module", "TestPytestPluginManager.test_consider_module_import_module", "TestPytestPluginManager.test_plugin_skip", "TestPytestPluginManager.test_register_imported_modules"], "tokens": 647}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPytestPluginManager:\n    def test_register_imported_modules(self):\n        pm = PytestPluginManager()\n        mod = types.ModuleType(\"x.y.pytest_hello\")\n        pm.register(mod)\n        assert pm.is_registered(mod)\n        values = pm.get_plugins()\n        assert mod in values\n        pytest.raises(ValueError, pm.register, mod)\n        pytest.raises(ValueError, lambda: pm.register(mod))\n        # assert not pm.is_registered(mod2)\n        assert pm.get_plugins() == values\n\n    def test_canonical_import(self, monkeypatch):\n        mod = types.ModuleType(\"pytest_xyz\")\n        monkeypatch.setitem(sys.modules, \"pytest_xyz\", mod)\n        pm = PytestPluginManager()\n        pm.import_plugin(\"pytest_xyz\")\n        assert pm.get_plugin(\"pytest_xyz\") == mod\n        assert pm.is_registered(mod)\n\n    def test_consider_module(self, testdir, pytestpm):\n        testdir.syspathinsert()\n        testdir.makepyfile(pytest_p1=\"#\")\n        testdir.makepyfile(pytest_p2=\"#\")\n        mod = types.ModuleType(\"temp\")\n        mod.pytest_plugins = [\"pytest_p1\", \"pytest_p2\"]\n        pytestpm.consider_module(mod)\n        assert pytestpm.get_plugin(\"pytest_p1\").__name__ == \"pytest_p1\"\n        assert pytestpm.get_plugin(\"pytest_p2\").__name__ == \"pytest_p2\"\n\n    def test_consider_module_import_module(self, testdir, _config_for_test):\n        pytestpm = _config_for_test.pluginmanager\n        mod = types.ModuleType(\"x\")\n        mod.pytest_plugins = \"pytest_a\"\n        aplugin = testdir.makepyfile(pytest_a=\"#\")\n        reprec = testdir.make_hook_recorder(pytestpm)\n        testdir.syspathinsert(aplugin.dirpath())\n        pytestpm.consider_module(mod)\n        call = reprec.getcall(pytestpm.hook.pytest_plugin_registered.name)\n        assert call.plugin.__name__ == \"pytest_a\"\n\n        # check that it is not registered twice\n        pytestpm.consider_module(mod)\n        values = reprec.getcalls(\"pytest_plugin_registered\")\n        assert len(values) == 1\n\n    def test_consider_env_fails_to_import(self, monkeypatch, pytestpm):\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"nonexisting\", prepend=\",\")\n        with pytest.raises(ImportError):\n            pytestpm.consider_env()\n\n    @pytest.mark.filterwarnings(\"always\")\n    def test_plugin_skip(self, testdir, monkeypatch):\n        p = testdir.makepyfile(\n            skipping1=\"\"\"\n            import pytest\n            pytest.skip(\"hello\", allow_module_level=True)\n        \"\"\"\n        )\n        p.copy(p.dirpath(\"skipping2.py\"))\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"skipping2\")\n        result = testdir.runpytest(\"-p\", \"skipping1\", syspathinsert=True)\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n        result.stdout.fnmatch_lines(\n            [\"*skipped plugin*skipping1*hello*\", \"*skipped plugin*skipping2*hello*\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManager.test_consider_env_plugin_instantiation_TestPytestPluginManager.test_consider_conftest_deps": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManager.test_consider_env_plugin_instantiation_TestPytestPluginManager.test_consider_conftest_deps", "embedding": null, "metadata": {"file_path": "testing/test_pluginmanager.py", "file_name": "test_pluginmanager.py", "file_type": "text/x-python", "category": "test", "start_line": 235, "end_line": 294, "span_ids": ["TestPytestPluginManager.test_consider_conftest_deps", "TestPytestPluginManager.test_consider_env_plugin_instantiation", "TestPytestPluginManager.test_import_plugin_dotted_name", "TestPytestPluginManager.test_import_plugin_importname", "TestPytestPluginManager.test_pluginmanager_ENV_startup"], "tokens": 599}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPytestPluginManager:\n\n    def test_consider_env_plugin_instantiation(self, testdir, monkeypatch, pytestpm):\n        testdir.syspathinsert()\n        testdir.makepyfile(xy123=\"#\")\n        monkeypatch.setitem(os.environ, \"PYTEST_PLUGINS\", \"xy123\")\n        l1 = len(pytestpm.get_plugins())\n        pytestpm.consider_env()\n        l2 = len(pytestpm.get_plugins())\n        assert l2 == l1 + 1\n        assert pytestpm.get_plugin(\"xy123\")\n        pytestpm.consider_env()\n        l3 = len(pytestpm.get_plugins())\n        assert l2 == l3\n\n    def test_pluginmanager_ENV_startup(self, testdir, monkeypatch):\n        testdir.makepyfile(pytest_x500=\"#\")\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_hello(pytestconfig):\n                plugin = pytestconfig.pluginmanager.get_plugin('pytest_x500')\n                assert plugin is not None\n        \"\"\"\n        )\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"pytest_x500\", prepend=\",\")\n        result = testdir.runpytest(p, syspathinsert=True)\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_import_plugin_importname(self, testdir, pytestpm):\n        pytest.raises(ImportError, pytestpm.import_plugin, \"qweqwex.y\")\n        pytest.raises(ImportError, pytestpm.import_plugin, \"pytest_qweqwx.y\")\n\n        testdir.syspathinsert()\n        pluginname = \"pytest_hello\"\n        testdir.makepyfile(**{pluginname: \"\"})\n        pytestpm.import_plugin(\"pytest_hello\")\n        len1 = len(pytestpm.get_plugins())\n        pytestpm.import_plugin(\"pytest_hello\")\n        len2 = len(pytestpm.get_plugins())\n        assert len1 == len2\n        plugin1 = pytestpm.get_plugin(\"pytest_hello\")\n        assert plugin1.__name__.endswith(\"pytest_hello\")\n        plugin2 = pytestpm.get_plugin(\"pytest_hello\")\n        assert plugin2 is plugin1\n\n    def test_import_plugin_dotted_name(self, testdir, pytestpm):\n        pytest.raises(ImportError, pytestpm.import_plugin, \"qweqwex.y\")\n        pytest.raises(ImportError, pytestpm.import_plugin, \"pytest_qweqwex.y\")\n\n        testdir.syspathinsert()\n        testdir.mkpydir(\"pkg\").join(\"plug.py\").write(\"x=3\")\n        pluginname = \"pkg.plug\"\n        pytestpm.import_plugin(pluginname)\n        mod = pytestpm.get_plugin(\"pkg.plug\")\n        assert mod.x == 3\n\n    def test_consider_conftest_deps(self, testdir, pytestpm):\n        mod = testdir.makepyfile(\"pytest_plugins='xyz'\").pyimport()\n        with pytest.raises(ImportError):\n            pytestpm.consider_conftest(mod)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManagerBootstrapming_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginManagerBootstrapming_", "embedding": null, "metadata": {"file_path": "testing/test_pluginmanager.py", "file_name": "test_pluginmanager.py", "file_type": "text/x-python", "category": "test", "start_line": 297, "end_line": 355, "span_ids": ["TestPytestPluginManagerBootstrapming", "TestPytestPluginManagerBootstrapming.test_blocked_plugin_can_be_used", "TestPytestPluginManagerBootstrapming.test_plugin_prevent_register", "TestPytestPluginManagerBootstrapming.test_plugin_prevent_register_stepwise_on_cacheprovider_unregister", "TestPytestPluginManagerBootstrapming.test_plugin_prevent_register_unregistered_alredy_registered", "TestPytestPluginManagerBootstrapming.test_preparse_args"], "tokens": 567}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPytestPluginManagerBootstrapming:\n    def test_preparse_args(self, pytestpm):\n        pytest.raises(\n            ImportError, lambda: pytestpm.consider_preparse([\"xyz\", \"-p\", \"hello123\"])\n        )\n\n        # Handles -p without space (#3532).\n        with pytest.raises(ImportError) as excinfo:\n            pytestpm.consider_preparse([\"-phello123\"])\n        assert '\"hello123\"' in excinfo.value.args[0]\n        pytestpm.consider_preparse([\"-pno:hello123\"])\n\n        # Handles -p without following arg (when used without argparse).\n        pytestpm.consider_preparse([\"-p\"])\n\n        with pytest.raises(UsageError, match=\"^plugin main cannot be disabled$\"):\n            pytestpm.consider_preparse([\"-p\", \"no:main\"])\n\n    def test_plugin_prevent_register(self, pytestpm):\n        pytestpm.consider_preparse([\"xyz\", \"-p\", \"no:abc\"])\n        l1 = pytestpm.get_plugins()\n        pytestpm.register(42, name=\"abc\")\n        l2 = pytestpm.get_plugins()\n        assert len(l2) == len(l1)\n        assert 42 not in l2\n\n    def test_plugin_prevent_register_unregistered_alredy_registered(self, pytestpm):\n        pytestpm.register(42, name=\"abc\")\n        l1 = pytestpm.get_plugins()\n        assert 42 in l1\n        pytestpm.consider_preparse([\"xyz\", \"-p\", \"no:abc\"])\n        l2 = pytestpm.get_plugins()\n        assert 42 not in l2\n\n    def test_plugin_prevent_register_stepwise_on_cacheprovider_unregister(\n        self, pytestpm\n    ):\n        \"\"\" From PR #4304 : The only way to unregister a module is documented at\n        the end of https://docs.pytest.org/en/latest/plugins.html.\n\n        When unregister cacheprovider, then unregister stepwise too\n        \"\"\"\n        pytestpm.register(42, name=\"cacheprovider\")\n        pytestpm.register(43, name=\"stepwise\")\n        l1 = pytestpm.get_plugins()\n        assert 42 in l1\n        assert 43 in l1\n        pytestpm.consider_preparse([\"xyz\", \"-p\", \"no:cacheprovider\"])\n        l2 = pytestpm.get_plugins()\n        assert 42 not in l2\n        assert 43 not in l2\n\n    def test_blocked_plugin_can_be_used(self, pytestpm):\n        pytestpm.consider_preparse([\"xyz\", \"-p\", \"no:abc\", \"-p\", \"abc\"])\n\n        assert pytestpm.has_plugin(\"abc\")\n        assert not pytestpm.is_blocked(\"abc\")\n        assert not pytestpm.is_blocked(\"pytest_abc\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_assert_outcomes_after_pytest_error_TestSysModulesSnapshot.test_preserve_container": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_assert_outcomes_after_pytest_error_TestSysModulesSnapshot.test_preserve_container", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 291, "end_line": 370, "span_ids": ["TestSysModulesSnapshot", "TestSysModulesSnapshot.test_add_removed", "TestSysModulesSnapshot.test_preserve_container", "TestSysModulesSnapshot.test_preserve_modules", "TestSysModulesSnapshot.test_remove_added", "TestSysModulesSnapshot.test_restore_reloaded", "test_assert_outcomes_after_pytest_error", "test_cwd_snapshot"], "tokens": 678}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_assert_outcomes_after_pytest_error(testdir) -> None:\n    testdir.makepyfile(\"def test_foo(): assert True\")\n\n    result = testdir.runpytest(\"--unexpected-argument\")\n    with pytest.raises(ValueError, match=\"Pytest terminal summary report not found\"):\n        result.assert_outcomes(passed=0)\n\n\ndef test_cwd_snapshot(testdir: Testdir) -> None:\n    tmpdir = testdir.tmpdir\n    foo = tmpdir.ensure(\"foo\", dir=1)\n    bar = tmpdir.ensure(\"bar\", dir=1)\n    foo.chdir()\n    snapshot = CwdSnapshot()\n    bar.chdir()\n    assert py.path.local() == bar\n    snapshot.restore()\n    assert py.path.local() == foo\n\n\nclass TestSysModulesSnapshot:\n    key = \"my-test-module\"\n\n    def test_remove_added(self) -> None:\n        original = dict(sys.modules)\n        assert self.key not in sys.modules\n        snapshot = SysModulesSnapshot()\n        sys.modules[self.key] = \"something\"  # type: ignore\n        assert self.key in sys.modules\n        snapshot.restore()\n        assert sys.modules == original\n\n    def test_add_removed(self, monkeypatch) -> None:\n        assert self.key not in sys.modules\n        monkeypatch.setitem(sys.modules, self.key, \"something\")\n        assert self.key in sys.modules\n        original = dict(sys.modules)\n        snapshot = SysModulesSnapshot()\n        del sys.modules[self.key]\n        assert self.key not in sys.modules\n        snapshot.restore()\n        assert sys.modules == original\n\n    def test_restore_reloaded(self, monkeypatch) -> None:\n        assert self.key not in sys.modules\n        monkeypatch.setitem(sys.modules, self.key, \"something\")\n        assert self.key in sys.modules\n        original = dict(sys.modules)\n        snapshot = SysModulesSnapshot()\n        sys.modules[self.key] = \"something else\"  # type: ignore\n        snapshot.restore()\n        assert sys.modules == original\n\n    def test_preserve_modules(self, monkeypatch) -> None:\n        key = [self.key + str(i) for i in range(3)]\n        assert not any(k in sys.modules for k in key)\n        for i, k in enumerate(key):\n            monkeypatch.setitem(sys.modules, k, \"something\" + str(i))\n        original = dict(sys.modules)\n\n        def preserve(name):\n            return name in (key[0], key[1], \"some-other-key\")\n\n        snapshot = SysModulesSnapshot(preserve=preserve)\n        sys.modules[key[0]] = original[key[0]] = \"something else0\"  # type: ignore\n        sys.modules[key[1]] = original[key[1]] = \"something else1\"  # type: ignore\n        sys.modules[key[2]] = \"something else2\"  # type: ignore\n        snapshot.restore()\n        assert sys.modules == original\n\n    def test_preserve_container(self, monkeypatch) -> None:\n        original = dict(sys.modules)\n        assert self.key not in original\n        replacement = dict(sys.modules)\n        replacement[self.key] = \"life of brian\"  # type: ignore\n        snapshot = SysModulesSnapshot()\n        monkeypatch.setattr(sys, \"modules\", replacement)\n        snapshot.restore()\n        assert sys.modules is replacement\n        assert sys.modules == original", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_TestSysPathsSnapshot_TestSysPathsSnapshot.test_preserve_container": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_TestSysPathsSnapshot_TestSysPathsSnapshot.test_preserve_container", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 373, "end_line": 416, "span_ids": ["TestSysPathsSnapshot", "TestSysPathsSnapshot.path", "TestSysPathsSnapshot.test_preserve_container", "TestSysPathsSnapshot.test_restore"], "tokens": 490}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"path_type\", (\"path\", \"meta_path\"))\nclass TestSysPathsSnapshot:\n    other_path = {\"path\": \"meta_path\", \"meta_path\": \"path\"}\n\n    @staticmethod\n    def path(n: int) -> str:\n        return \"my-dirty-little-secret-\" + str(n)\n\n    def test_restore(self, monkeypatch, path_type) -> None:\n        other_path_type = self.other_path[path_type]\n        for i in range(10):\n            assert self.path(i) not in getattr(sys, path_type)\n        sys_path = [self.path(i) for i in range(6)]\n        monkeypatch.setattr(sys, path_type, sys_path)\n        original = list(sys_path)\n        original_other = list(getattr(sys, other_path_type))\n        snapshot = SysPathsSnapshot()\n        transformation = {\"source\": (0, 1, 2, 3, 4, 5), \"target\": (6, 2, 9, 7, 5, 8)}\n        assert sys_path == [self.path(x) for x in transformation[\"source\"]]\n        sys_path[1] = self.path(6)\n        sys_path[3] = self.path(7)\n        sys_path.append(self.path(8))\n        del sys_path[4]\n        sys_path[3:3] = [self.path(9)]\n        del sys_path[0]\n        assert sys_path == [self.path(x) for x in transformation[\"target\"]]\n        snapshot.restore()\n        assert getattr(sys, path_type) is sys_path\n        assert getattr(sys, path_type) == original\n        assert getattr(sys, other_path_type) == original_other\n\n    def test_preserve_container(self, monkeypatch, path_type) -> None:\n        other_path_type = self.other_path[path_type]\n        original_data = list(getattr(sys, path_type))\n        original_other = getattr(sys, other_path_type)\n        original_other_data = list(original_other)\n        new = []  # type: List[object]\n        snapshot = SysPathsSnapshot()\n        monkeypatch.setattr(sys, path_type, new)\n        snapshot.restore()\n        assert getattr(sys, path_type) is new\n        assert getattr(sys, path_type) == original_data\n        assert getattr(sys, other_path_type) is original_other\n        assert getattr(sys, other_path_type) == original_other_data", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestDeprecatedCall_TestDeprecatedCall.test_deprecated_call_modes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestDeprecatedCall_TestDeprecatedCall.test_deprecated_call_modes", "embedding": null, "metadata": {"file_path": "testing/test_recwarn.py", "file_name": "test_recwarn.py", "file_type": "text/x-python", "category": "test", "start_line": 76, "end_line": 162, "span_ids": ["TestDeprecatedCall", "TestDeprecatedCall.dep", "TestDeprecatedCall.dep_explicit", "TestDeprecatedCall.test_deprecated_call", "TestDeprecatedCall.test_deprecated_call_modes", "TestDeprecatedCall.test_deprecated_call_no_warning", "TestDeprecatedCall.test_deprecated_call_preserves", "TestDeprecatedCall.test_deprecated_call_raises", "TestDeprecatedCall.test_deprecated_call_ret", "TestDeprecatedCall.test_deprecated_explicit_call", "TestDeprecatedCall.test_deprecated_explicit_call_raises"], "tokens": 733}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDeprecatedCall:\n    \"\"\"test pytest.deprecated_call()\"\"\"\n\n    def dep(self, i: int, j: Optional[int] = None) -> int:\n        if i == 0:\n            warnings.warn(\"is deprecated\", DeprecationWarning, stacklevel=1)\n        return 42\n\n    def dep_explicit(self, i: int) -> None:\n        if i == 0:\n            warnings.warn_explicit(\n                \"dep_explicit\", category=DeprecationWarning, filename=\"hello\", lineno=3\n            )\n\n    def test_deprecated_call_raises(self) -> None:\n        with pytest.raises(pytest.fail.Exception, match=\"No warnings of type\"):\n            pytest.deprecated_call(self.dep, 3, 5)\n\n    def test_deprecated_call(self) -> None:\n        pytest.deprecated_call(self.dep, 0, 5)\n\n    def test_deprecated_call_ret(self) -> None:\n        ret = pytest.deprecated_call(self.dep, 0)\n        assert ret == 42\n\n    def test_deprecated_call_preserves(self) -> None:\n        # Type ignored because `onceregistry` and `filters` are not\n        # documented API.\n        onceregistry = warnings.onceregistry.copy()  # type: ignore\n        filters = warnings.filters[:]  # type: ignore\n        warn = warnings.warn\n        warn_explicit = warnings.warn_explicit\n        self.test_deprecated_call_raises()\n        self.test_deprecated_call()\n        assert onceregistry == warnings.onceregistry  # type: ignore\n        assert filters == warnings.filters  # type: ignore\n        assert warn is warnings.warn\n        assert warn_explicit is warnings.warn_explicit\n\n    def test_deprecated_explicit_call_raises(self) -> None:\n        with pytest.raises(pytest.fail.Exception):\n            pytest.deprecated_call(self.dep_explicit, 3)\n\n    def test_deprecated_explicit_call(self) -> None:\n        pytest.deprecated_call(self.dep_explicit, 0)\n        pytest.deprecated_call(self.dep_explicit, 0)\n\n    @pytest.mark.parametrize(\"mode\", [\"context_manager\", \"call\"])\n    def test_deprecated_call_no_warning(self, mode) -> None:\n        \"\"\"Ensure deprecated_call() raises the expected failure when its block/function does\n        not raise a deprecation warning.\n        \"\"\"\n\n        def f():\n            pass\n\n        msg = \"No warnings of type (.*DeprecationWarning.*, .*PendingDeprecationWarning.*)\"\n        with pytest.raises(pytest.fail.Exception, match=msg):\n            if mode == \"call\":\n                pytest.deprecated_call(f)\n            else:\n                with pytest.deprecated_call():\n                    f()\n\n    @pytest.mark.parametrize(\n        \"warning_type\", [PendingDeprecationWarning, DeprecationWarning]\n    )\n    @pytest.mark.parametrize(\"mode\", [\"context_manager\", \"call\"])\n    @pytest.mark.parametrize(\"call_f_first\", [True, False])\n    @pytest.mark.filterwarnings(\"ignore\")\n    def test_deprecated_call_modes(self, warning_type, mode, call_f_first) -> None:\n        \"\"\"Ensure deprecated_call() captures a deprecation warning as expected inside its\n        block/function.\n        \"\"\"\n\n        def f():\n            warnings.warn(warning_type(\"hi\"))\n            return 10\n\n        # ensure deprecated_call() can capture the warning even if it has already been triggered\n        if call_f_first:\n            assert f() == 10\n        if mode == \"call\":\n            assert pytest.deprecated_call(f) == 10\n        else:\n            with pytest.deprecated_call():\n                assert f() == 10", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestDeprecatedCall.test_deprecated_call_exception_is_raised_TestDeprecatedCall.test_deprecated_call_supports_match": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestDeprecatedCall.test_deprecated_call_exception_is_raised_TestDeprecatedCall.test_deprecated_call_supports_match", "embedding": null, "metadata": {"file_path": "testing/test_recwarn.py", "file_name": "test_recwarn.py", "file_type": "text/x-python", "category": "test", "start_line": 164, "end_line": 207, "span_ids": ["TestDeprecatedCall.test_deprecated_call_exception_is_raised", "TestDeprecatedCall.test_deprecated_call_specificity", "TestDeprecatedCall.test_deprecated_call_supports_match"], "tokens": 290}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDeprecatedCall:\n\n    @pytest.mark.parametrize(\"mode\", [\"context_manager\", \"call\"])\n    def test_deprecated_call_exception_is_raised(self, mode) -> None:\n        \"\"\"If the block of the code being tested by deprecated_call() raises an exception,\n        it must raise the exception undisturbed.\n        \"\"\"\n\n        def f():\n            raise ValueError(\"some exception\")\n\n        with pytest.raises(ValueError, match=\"some exception\"):\n            if mode == \"call\":\n                pytest.deprecated_call(f)\n            else:\n                with pytest.deprecated_call():\n                    f()\n\n    def test_deprecated_call_specificity(self) -> None:\n        other_warnings = [\n            Warning,\n            UserWarning,\n            SyntaxWarning,\n            RuntimeWarning,\n            FutureWarning,\n            ImportWarning,\n            UnicodeWarning,\n        ]\n        for warning in other_warnings:\n\n            def f():\n                warnings.warn(warning(\"hi\"))\n\n            with pytest.raises(pytest.fail.Exception):\n                pytest.deprecated_call(f)\n            with pytest.raises(pytest.fail.Exception):\n                with pytest.deprecated_call():\n                    f()\n\n    def test_deprecated_call_supports_match(self) -> None:\n        with pytest.deprecated_call(match=r\"must be \\d+$\"):\n            warnings.warn(\"value must be 42\", DeprecationWarning)\n\n        with pytest.raises(pytest.fail.Exception):\n            with pytest.deprecated_call(match=r\"must be \\d+$\"):\n                warnings.warn(\"this is not here\", DeprecationWarning)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns_TestWarns.test_warning_tuple": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns_TestWarns.test_warning_tuple", "embedding": null, "metadata": {"file_path": "testing/test_recwarn.py", "file_name": "test_recwarn.py", "file_type": "text/x-python", "category": "test", "start_line": 210, "end_line": 241, "span_ids": ["TestWarns", "TestWarns.test_check_callable", "TestWarns.test_function", "TestWarns.test_several_messages", "TestWarns.test_warning_tuple"], "tokens": 275}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestWarns:\n    def test_check_callable(self) -> None:\n        source = \"warnings.warn('w1', RuntimeWarning)\"\n        with pytest.raises(TypeError, match=r\".* must be callable\"):\n            pytest.warns(RuntimeWarning, source)  # type: ignore\n\n    def test_several_messages(self) -> None:\n        # different messages, b/c Python suppresses multiple identical warnings\n        pytest.warns(RuntimeWarning, lambda: warnings.warn(\"w1\", RuntimeWarning))\n        with pytest.raises(pytest.fail.Exception):\n            pytest.warns(UserWarning, lambda: warnings.warn(\"w2\", RuntimeWarning))\n        pytest.warns(RuntimeWarning, lambda: warnings.warn(\"w3\", RuntimeWarning))\n\n    def test_function(self) -> None:\n        pytest.warns(\n            SyntaxWarning, lambda msg: warnings.warn(msg, SyntaxWarning), \"syntax\"\n        )\n\n    def test_warning_tuple(self) -> None:\n        pytest.warns(\n            (RuntimeWarning, SyntaxWarning), lambda: warnings.warn(\"w1\", RuntimeWarning)\n        )\n        pytest.warns(\n            (RuntimeWarning, SyntaxWarning), lambda: warnings.warn(\"w2\", SyntaxWarning)\n        )\n        pytest.raises(\n            pytest.fail.Exception,\n            lambda: pytest.warns(\n                (RuntimeWarning, SyntaxWarning),\n                lambda: warnings.warn(\"w3\", UserWarning),\n            ),\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns.test_as_contextmanager_TestWarns.test_as_contextmanager.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns.test_as_contextmanager_TestWarns.test_as_contextmanager.None_3", "embedding": null, "metadata": {"file_path": "testing/test_recwarn.py", "file_name": "test_recwarn.py", "file_type": "text/x-python", "category": "test", "start_line": 243, "end_line": 290, "span_ids": ["TestWarns.test_as_contextmanager"], "tokens": 386}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestWarns:\n\n    def test_as_contextmanager(self) -> None:\n        with pytest.warns(RuntimeWarning):\n            warnings.warn(\"runtime\", RuntimeWarning)\n\n        with pytest.warns(UserWarning):\n            warnings.warn(\"user\", UserWarning)\n\n        with pytest.raises(pytest.fail.Exception) as excinfo:\n            with pytest.warns(RuntimeWarning):\n                warnings.warn(\"user\", UserWarning)\n        excinfo.match(\n            r\"DID NOT WARN. No warnings of type \\(.+RuntimeWarning.+,\\) was emitted. \"\n            r\"The list of emitted warnings is: \\[UserWarning\\('user',?\\)\\].\"\n        )\n\n        with pytest.raises(pytest.fail.Exception) as excinfo:\n            with pytest.warns(UserWarning):\n                warnings.warn(\"runtime\", RuntimeWarning)\n        excinfo.match(\n            r\"DID NOT WARN. No warnings of type \\(.+UserWarning.+,\\) was emitted. \"\n            r\"The list of emitted warnings is: \\[RuntimeWarning\\('runtime',?\\)\\].\"\n        )\n\n        with pytest.raises(pytest.fail.Exception) as excinfo:\n            with pytest.warns(UserWarning):\n                pass\n        excinfo.match(\n            r\"DID NOT WARN. No warnings of type \\(.+UserWarning.+,\\) was emitted. \"\n            r\"The list of emitted warnings is: \\[\\].\"\n        )\n\n        warning_classes = (UserWarning, FutureWarning)\n        with pytest.raises(pytest.fail.Exception) as excinfo:\n            with pytest.warns(warning_classes) as warninfo:\n                warnings.warn(\"runtime\", RuntimeWarning)\n                warnings.warn(\"import\", ImportWarning)\n\n        message_template = (\n            \"DID NOT WARN. No warnings of type {0} was emitted. \"\n            \"The list of emitted warnings is: {1}.\"\n        )\n        excinfo.match(\n            re.escape(\n                message_template.format(\n                    warning_classes, [each.message for each in warninfo]\n                )\n            )\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns.test_record_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_TestWarns.test_record_", "embedding": null, "metadata": {"file_path": "testing/test_recwarn.py", "file_name": "test_recwarn.py", "file_type": "text/x-python", "category": "test", "start_line": 292, "end_line": 386, "span_ids": ["TestWarns.test_can_capture_previously_warned", "TestWarns.test_double_test", "TestWarns.test_match_regex", "TestWarns.test_none_of_multiple_warns", "TestWarns.test_one_from_multiple_warns", "TestWarns.test_record", "TestWarns.test_record_by_subclass", "TestWarns.test_record_only", "TestWarns.test_warns_context_manager_with_kwargs"], "tokens": 756}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestWarns:\n\n    def test_record(self) -> None:\n        with pytest.warns(UserWarning) as record:\n            warnings.warn(\"user\", UserWarning)\n\n        assert len(record) == 1\n        assert str(record[0].message) == \"user\"\n\n    def test_record_only(self) -> None:\n        with pytest.warns(None) as record:\n            warnings.warn(\"user\", UserWarning)\n            warnings.warn(\"runtime\", RuntimeWarning)\n\n        assert len(record) == 2\n        assert str(record[0].message) == \"user\"\n        assert str(record[1].message) == \"runtime\"\n\n    def test_record_by_subclass(self) -> None:\n        with pytest.warns(Warning) as record:\n            warnings.warn(\"user\", UserWarning)\n            warnings.warn(\"runtime\", RuntimeWarning)\n\n        assert len(record) == 2\n        assert str(record[0].message) == \"user\"\n        assert str(record[1].message) == \"runtime\"\n\n        class MyUserWarning(UserWarning):\n            pass\n\n        class MyRuntimeWarning(RuntimeWarning):\n            pass\n\n        with pytest.warns((UserWarning, RuntimeWarning)) as record:\n            warnings.warn(\"user\", MyUserWarning)\n            warnings.warn(\"runtime\", MyRuntimeWarning)\n\n        assert len(record) == 2\n        assert str(record[0].message) == \"user\"\n        assert str(record[1].message) == \"runtime\"\n\n    def test_double_test(self, testdir) -> None:\n        \"\"\"If a test is run again, the warning should still be raised\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            import warnings\n\n            @pytest.mark.parametrize('run', [1, 2])\n            def test(run):\n                with pytest.warns(RuntimeWarning):\n                    warnings.warn(\"runtime\", RuntimeWarning)\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*2 passed in*\"])\n\n    def test_match_regex(self) -> None:\n        with pytest.warns(UserWarning, match=r\"must be \\d+$\"):\n            warnings.warn(\"value must be 42\", UserWarning)\n\n        with pytest.raises(pytest.fail.Exception):\n            with pytest.warns(UserWarning, match=r\"must be \\d+$\"):\n                warnings.warn(\"this is not here\", UserWarning)\n\n        with pytest.raises(pytest.fail.Exception):\n            with pytest.warns(FutureWarning, match=r\"must be \\d+$\"):\n                warnings.warn(\"value must be 42\", UserWarning)\n\n    def test_one_from_multiple_warns(self) -> None:\n        with pytest.warns(UserWarning, match=r\"aaa\"):\n            warnings.warn(\"cccccccccc\", UserWarning)\n            warnings.warn(\"bbbbbbbbbb\", UserWarning)\n            warnings.warn(\"aaaaaaaaaa\", UserWarning)\n\n    def test_none_of_multiple_warns(self) -> None:\n        with pytest.raises(pytest.fail.Exception):\n            with pytest.warns(UserWarning, match=r\"aaa\"):\n                warnings.warn(\"bbbbbbbbbb\", UserWarning)\n                warnings.warn(\"cccccccccc\", UserWarning)\n\n    @pytest.mark.filterwarnings(\"ignore\")\n    def test_can_capture_previously_warned(self) -> None:\n        def f():\n            warnings.warn(UserWarning(\"ohai\"))\n            return 10\n\n        assert f() == 10\n        assert pytest.warns(UserWarning, f) == 10\n        assert pytest.warns(UserWarning, f) == 10\n\n    def test_warns_context_manager_with_kwargs(self) -> None:\n        with pytest.raises(TypeError) as excinfo:\n            with pytest.warns(UserWarning, foo=\"bar\"):  # type: ignore\n                pass\n        assert \"Unexpected keyword arguments\" in str(excinfo.value)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_xdist_report_longrepr_reprcrash_130_TestReportSerialization.test_xdist_report_longrepr_reprcrash_130.assert_added_section_in_a": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_xdist_report_longrepr_reprcrash_130_TestReportSerialization.test_xdist_report_longrepr_reprcrash_130.assert_added_section_in_a", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 33, "end_line": 66, "span_ids": ["TestReportSerialization.test_xdist_report_longrepr_reprcrash_130"], "tokens": 334}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportSerialization:\n\n    def test_xdist_report_longrepr_reprcrash_130(self, testdir):\n        \"\"\"Regarding issue pytest-xdist#130\n\n        This test came originally from test_remote.py in xdist (ca03269).\n        \"\"\"\n        reprec = testdir.inline_runsource(\n            \"\"\"\n                    def test_fail():\n                        assert False, 'Expected Message'\n                \"\"\"\n        )\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 3\n        rep = reports[1]\n        added_section = (\"Failure Metadata\", \"metadata metadata\", \"*\")\n        rep.longrepr.sections.append(added_section)\n        d = rep._to_json()\n        a = TestReport._from_json(d)\n        # Check assembled == rep\n        assert a.__dict__.keys() == rep.__dict__.keys()\n        for key in rep.__dict__.keys():\n            if key != \"longrepr\":\n                assert getattr(a, key) == getattr(rep, key)\n        assert rep.longrepr.reprcrash.lineno == a.longrepr.reprcrash.lineno\n        assert rep.longrepr.reprcrash.message == a.longrepr.reprcrash.message\n        assert rep.longrepr.reprcrash.path == a.longrepr.reprcrash.path\n        assert rep.longrepr.reprtraceback.entrysep == a.longrepr.reprtraceback.entrysep\n        assert (\n            rep.longrepr.reprtraceback.extraline == a.longrepr.reprtraceback.extraline\n        )\n        assert rep.longrepr.reprtraceback.style == a.longrepr.reprtraceback.style\n        assert rep.longrepr.sections == a.longrepr.sections\n        # Missing section attribute PR171\n        assert added_section in a.longrepr.sections", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_reprentries_serialization_170_TestReportSerialization.test_reprentries_serialization_170.for_i_in_range_len_a_entr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_reprentries_serialization_170_TestReportSerialization.test_reprentries_serialization_170.for_i_in_range_len_a_entr", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 68, "end_line": 101, "span_ids": ["TestReportSerialization.test_reprentries_serialization_170"], "tokens": 308}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportSerialization:\n\n    def test_reprentries_serialization_170(self, testdir):\n        \"\"\"Regarding issue pytest-xdist#170\n\n        This test came originally from test_remote.py in xdist (ca03269).\n        \"\"\"\n        from _pytest._code.code import ReprEntry\n\n        reprec = testdir.inline_runsource(\n            \"\"\"\n                            def test_repr_entry():\n                                x = 0\n                                assert x\n                        \"\"\",\n            \"--showlocals\",\n        )\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 3\n        rep = reports[1]\n        d = rep._to_json()\n        a = TestReport._from_json(d)\n\n        rep_entries = rep.longrepr.reprtraceback.reprentries\n        a_entries = a.longrepr.reprtraceback.reprentries\n        for i in range(len(a_entries)):\n            assert isinstance(rep_entries[i], ReprEntry)\n            assert rep_entries[i].lines == a_entries[i].lines\n            assert rep_entries[i].reprfileloc.lineno == a_entries[i].reprfileloc.lineno\n            assert (\n                rep_entries[i].reprfileloc.message == a_entries[i].reprfileloc.message\n            )\n            assert rep_entries[i].reprfileloc.path == a_entries[i].reprfileloc.path\n            assert rep_entries[i].reprfuncargs.args == a_entries[i].reprfuncargs.args\n            assert rep_entries[i].reprlocals.lines == a_entries[i].reprlocals.lines\n            assert rep_entries[i].style == a_entries[i].style", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_reprentries_serialization_196_TestReportSerialization.test_itemreport_outcomes.for_rep_in_reports_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_reprentries_serialization_196_TestReportSerialization.test_itemreport_outcomes.for_rep_in_reports_", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 103, "end_line": 163, "span_ids": ["TestReportSerialization.test_itemreport_outcomes", "TestReportSerialization.test_reprentries_serialization_196"], "tokens": 488}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportSerialization:\n\n    def test_reprentries_serialization_196(self, testdir):\n        \"\"\"Regarding issue pytest-xdist#196\n\n        This test came originally from test_remote.py in xdist (ca03269).\n        \"\"\"\n        from _pytest._code.code import ReprEntryNative\n\n        reprec = testdir.inline_runsource(\n            \"\"\"\n                            def test_repr_entry_native():\n                                x = 0\n                                assert x\n                        \"\"\",\n            \"--tb=native\",\n        )\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 3\n        rep = reports[1]\n        d = rep._to_json()\n        a = TestReport._from_json(d)\n\n        rep_entries = rep.longrepr.reprtraceback.reprentries\n        a_entries = a.longrepr.reprtraceback.reprentries\n        for i in range(len(a_entries)):\n            assert isinstance(rep_entries[i], ReprEntryNative)\n            assert rep_entries[i].lines == a_entries[i].lines\n\n    def test_itemreport_outcomes(self, testdir):\n        \"\"\"\n        This test came originally from test_remote.py in xdist (ca03269).\n        \"\"\"\n        reprec = testdir.inline_runsource(\n            \"\"\"\n            import pytest\n            def test_pass(): pass\n            def test_fail(): 0/0\n            @pytest.mark.skipif(\"True\")\n            def test_skip(): pass\n            def test_skip_imperative():\n                pytest.skip(\"hello\")\n            @pytest.mark.xfail(\"True\")\n            def test_xfail(): 0/0\n            def test_xfail_imperative():\n                pytest.xfail(\"hello\")\n        \"\"\"\n        )\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 17  # with setup/teardown \"passed\" reports\n        for rep in reports:\n            d = rep._to_json()\n            newrep = TestReport._from_json(d)\n            assert newrep.passed == rep.passed\n            assert newrep.failed == rep.failed\n            assert newrep.skipped == rep.skipped\n            if newrep.skipped and not hasattr(newrep, \"wasxfail\"):\n                assert len(newrep.longrepr) == 3\n            assert newrep.outcome == rep.outcome\n            assert newrep.when == rep.when\n            assert newrep.keywords == rep.keywords\n            if rep.failed:\n                assert newrep.longreprtext == rep.longreprtext", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestHooks_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestHooks_", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 400, "end_line": 468, "span_ids": ["TestHooks", "TestHooks.test_collect_report", "TestHooks.test_invalid_report_types", "TestHooks.test_test_report"], "tokens": 521}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestHooks:\n    \"\"\"Test that the hooks are working correctly for plugins\"\"\"\n\n    def test_test_report(self, testdir, pytestconfig):\n        testdir.makepyfile(\n            \"\"\"\n            def test_a(): assert False\n            def test_b(): pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 6\n        for rep in reports:\n            data = pytestconfig.hook.pytest_report_to_serializable(\n                config=pytestconfig, report=rep\n            )\n            assert data[\"$report_type\"] == \"TestReport\"\n            new_rep = pytestconfig.hook.pytest_report_from_serializable(\n                config=pytestconfig, data=data\n            )\n            assert new_rep.nodeid == rep.nodeid\n            assert new_rep.when == rep.when\n            assert new_rep.outcome == rep.outcome\n\n    def test_collect_report(self, testdir, pytestconfig):\n        testdir.makepyfile(\n            \"\"\"\n            def test_a(): assert False\n            def test_b(): pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reports = reprec.getreports(\"pytest_collectreport\")\n        assert len(reports) == 2\n        for rep in reports:\n            data = pytestconfig.hook.pytest_report_to_serializable(\n                config=pytestconfig, report=rep\n            )\n            assert data[\"$report_type\"] == \"CollectReport\"\n            new_rep = pytestconfig.hook.pytest_report_from_serializable(\n                config=pytestconfig, data=data\n            )\n            assert new_rep.nodeid == rep.nodeid\n            assert new_rep.when == \"collect\"\n            assert new_rep.outcome == rep.outcome\n\n    @pytest.mark.parametrize(\n        \"hook_name\", [\"pytest_runtest_logreport\", \"pytest_collectreport\"]\n    )\n    def test_invalid_report_types(self, testdir, pytestconfig, hook_name):\n        testdir.makepyfile(\n            \"\"\"\n            def test_a(): pass\n            \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reports = reprec.getreports(hook_name)\n        assert reports\n        rep = reports[0]\n        data = pytestconfig.hook.pytest_report_to_serializable(\n            config=pytestconfig, report=rep\n        )\n        data[\"$report_type\"] = \"Unknown\"\n        with pytest.raises(AssertionError):\n            _ = pytestconfig.hook.pytest_report_from_serializable(\n                config=pytestconfig, data=data\n            )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_TestWithFunctionIntegration_TestWithFunctionIntegration.test_collection_report": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_TestWithFunctionIntegration_TestWithFunctionIntegration.test_collection_report", "embedding": null, "metadata": {"file_path": "testing/test_resultlog.py", "file_name": "test_resultlog.py", "file_type": "text/x-python", "category": "test", "start_line": 53, "end_line": 76, "span_ids": ["TestWithFunctionIntegration", "TestWithFunctionIntegration.getresultlog", "TestWithFunctionIntegration.test_collection_report"], "tokens": 237}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestWithFunctionIntegration:\n    # XXX (hpk) i think that the resultlog plugin should\n    # provide a Parser object so that one can remain\n    # ignorant regarding formatting details.\n    def getresultlog(self, testdir, arg):\n        resultlog = testdir.tmpdir.join(\"resultlog\")\n        testdir.plugins.append(\"resultlog\")\n        args = [\"--resultlog=%s\" % resultlog] + [arg]\n        testdir.runpytest(*args)\n        return [x for x in resultlog.readlines(cr=0) if x]\n\n    def test_collection_report(self, testdir):\n        ok = testdir.makepyfile(test_collection_ok=\"\")\n        fail = testdir.makepyfile(test_collection_fail=\"XXX\")\n        lines = self.getresultlog(testdir, ok)\n        assert not lines\n\n        lines = self.getresultlog(testdir, fail)\n        assert lines\n        assert lines[0].startswith(\"F \")\n        assert lines[0].endswith(\"test_collection_fail.py\"), lines[0]\n        for x in lines[1:]:\n            assert x.startswith(\" \")\n        assert \"XXX\" in \"\".join(lines[1:])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_TestWithFunctionIntegration.test_log_test_outcomes_TestWithFunctionIntegration.test_internal_exception": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_TestWithFunctionIntegration.test_log_test_outcomes_TestWithFunctionIntegration.test_internal_exception", "embedding": null, "metadata": {"file_path": "testing/test_resultlog.py", "file_name": "test_resultlog.py", "file_type": "text/x-python", "category": "test", "start_line": 77, "end_line": 129, "span_ids": ["TestWithFunctionIntegration.test_internal_exception", "TestWithFunctionIntegration.test_log_test_outcomes"], "tokens": 435}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestWithFunctionIntegration:\n    # XXX (hpk) i think that the resultlog plugin should\n    # provide a Parser object so that one can remain\n\n    def test_log_test_outcomes(self, testdir):\n        mod = testdir.makepyfile(\n            test_mod=\"\"\"\n            import pytest\n            def test_pass(): pass\n            def test_skip(): pytest.skip(\"hello\")\n            def test_fail(): raise ValueError(\"FAIL\")\n\n            @pytest.mark.xfail\n            def test_xfail(): raise ValueError(\"XFAIL\")\n            @pytest.mark.xfail\n            def test_xpass(): pass\n\n        \"\"\"\n        )\n        lines = self.getresultlog(testdir, mod)\n        assert len(lines) >= 3\n        assert lines[0].startswith(\". \")\n        assert lines[0].endswith(\"test_pass\")\n        assert lines[1].startswith(\"s \"), lines[1]\n        assert lines[1].endswith(\"test_skip\")\n        assert lines[2].find(\"hello\") != -1\n\n        assert lines[3].startswith(\"F \")\n        assert lines[3].endswith(\"test_fail\")\n        tb = \"\".join(lines[4:8])\n        assert tb.find('raise ValueError(\"FAIL\")') != -1\n\n        assert lines[8].startswith(\"x \")\n        tb = \"\".join(lines[8:14])\n        assert tb.find('raise ValueError(\"XFAIL\")') != -1\n\n        assert lines[14].startswith(\"X \")\n        assert len(lines) == 15\n\n    @pytest.mark.parametrize(\"style\", (\"native\", \"long\", \"short\"))\n    def test_internal_exception(self, style):\n        # they are produced for example by a teardown failing\n        # at the end of the run or a failing hook invocation\n        try:\n            raise ValueError\n        except ValueError:\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n        reslog = ResultLog(None, StringIO())\n        reslog.pytest_internalerror(excinfo.getrepr(style=style))\n        entry = reslog.logfile.getvalue()\n        entry_lines = entry.splitlines()\n\n        assert entry_lines[0].startswith(\"! \")\n        if style != \"native\":\n            assert os.path.basename(__file__)[:-9] in entry_lines[0]  # .pyc/class\n        assert entry_lines[-1][0] == \" \"\n        assert \"ValueError\" in entry", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests_BaseFunctionalTests.test_failure_in_teardown_function": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests_BaseFunctionalTests.test_failure_in_teardown_function", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 112, "end_line": 217, "span_ids": ["BaseFunctionalTests", "BaseFunctionalTests.test_failfunction", "BaseFunctionalTests.test_failure_in_setup_function", "BaseFunctionalTests.test_failure_in_teardown_function", "BaseFunctionalTests.test_passfunction", "BaseFunctionalTests.test_skip_in_setup_function", "BaseFunctionalTests.test_skipfunction"], "tokens": 678}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class BaseFunctionalTests:\n    def test_passfunction(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            def test_func():\n                pass\n        \"\"\"\n        )\n        rep = reports[1]\n        assert rep.passed\n        assert not rep.failed\n        assert rep.outcome == \"passed\"\n        assert not rep.longrepr\n\n    def test_failfunction(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            def test_func():\n                assert 0\n        \"\"\"\n        )\n        rep = reports[1]\n        assert not rep.passed\n        assert not rep.skipped\n        assert rep.failed\n        assert rep.when == \"call\"\n        assert rep.outcome == \"failed\"\n        # assert isinstance(rep.longrepr, ReprExceptionInfo)\n\n    def test_skipfunction(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            import pytest\n            def test_func():\n                pytest.skip(\"hello\")\n        \"\"\"\n        )\n        rep = reports[1]\n        assert not rep.failed\n        assert not rep.passed\n        assert rep.skipped\n        assert rep.outcome == \"skipped\"\n        # assert rep.skipped.when == \"call\"\n        # assert rep.skipped.when == \"call\"\n        # assert rep.skipped == \"%sreason == \"hello\"\n        # assert rep.skipped.location.lineno == 3\n        # assert rep.skipped.location.path\n        # assert not rep.skipped.failurerepr\n\n    def test_skip_in_setup_function(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            import pytest\n            def setup_function(func):\n                pytest.skip(\"hello\")\n            def test_func():\n                pass\n        \"\"\"\n        )\n        print(reports)\n        rep = reports[0]\n        assert not rep.failed\n        assert not rep.passed\n        assert rep.skipped\n        # assert rep.skipped.reason == \"hello\"\n        # assert rep.skipped.location.lineno == 3\n        # assert rep.skipped.location.lineno == 3\n        assert len(reports) == 2\n        assert reports[1].passed  # teardown\n\n    def test_failure_in_setup_function(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            import pytest\n            def setup_function(func):\n                raise ValueError(42)\n            def test_func():\n                pass\n        \"\"\"\n        )\n        rep = reports[0]\n        assert not rep.skipped\n        assert not rep.passed\n        assert rep.failed\n        assert rep.when == \"setup\"\n        assert len(reports) == 2\n\n    def test_failure_in_teardown_function(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            import pytest\n            def teardown_function(func):\n                raise ValueError(42)\n            def test_func():\n                pass\n        \"\"\"\n        )\n        print(reports)\n        assert len(reports) == 3\n        rep = reports[2]\n        assert not rep.skipped\n        assert not rep.passed\n        assert rep.failed\n        assert rep.when == \"teardown\"\n        # assert rep.longrepr.reprcrash.lineno == 3\n        # assert rep.longrepr.reprtraceback.reprentries", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_custom_failure_repr_BaseFunctionalTests.test_logstart_logfinish_hooks": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_custom_failure_repr_BaseFunctionalTests.test_logstart_logfinish_hooks", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 219, "end_line": 270, "span_ids": ["BaseFunctionalTests.test_custom_failure_repr", "BaseFunctionalTests.test_logstart_logfinish_hooks", "BaseFunctionalTests.test_teardown_final_returncode"], "tokens": 352}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class BaseFunctionalTests:\n\n    def test_custom_failure_repr(self, testdir) -> None:\n        testdir.makepyfile(\n            conftest=\"\"\"\n            import pytest\n            class Function(pytest.Function):\n                def repr_failure(self, excinfo):\n                    return \"hello\"\n        \"\"\"\n        )\n        reports = testdir.runitem(\n            \"\"\"\n            import pytest\n            def test_func():\n                assert 0\n        \"\"\"\n        )\n        rep = reports[1]\n        assert not rep.skipped\n        assert not rep.passed\n        assert rep.failed\n        # assert rep.outcome.when == \"call\"\n        # assert rep.failed.where.lineno == 3\n        # assert rep.failed.where.path.basename == \"test_func.py\"\n        # assert rep.failed.failurerepr == \"hello\"\n\n    def test_teardown_final_returncode(self, testdir) -> None:\n        rec = testdir.inline_runsource(\n            \"\"\"\n            def test_func():\n                pass\n            def teardown_function(func):\n                raise ValueError(42)\n        \"\"\"\n        )\n        assert rec.ret == 1\n\n    def test_logstart_logfinish_hooks(self, testdir) -> None:\n        rec = testdir.inline_runsource(\n            \"\"\"\n            import pytest\n            def test_func():\n                pass\n        \"\"\"\n        )\n        reps = rec.getcalls(\"pytest_runtest_logstart pytest_runtest_logfinish\")\n        assert [x._name for x in reps] == [\n            \"pytest_runtest_logstart\",\n            \"pytest_runtest_logfinish\",\n        ]\n        for rep in reps:\n            assert rep.nodeid == \"test_logstart_logfinish_hooks.py::test_func\"\n            assert rep.location == (\"test_logstart_logfinish_hooks.py\", 1, \"test_func\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_exact_teardown_issue90_BaseFunctionalTests.test_exact_teardown_issue90.assert_reps_5_failed": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_exact_teardown_issue90_BaseFunctionalTests.test_exact_teardown_issue90.assert_reps_5_failed", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 272, "end_line": 310, "span_ids": ["BaseFunctionalTests.test_exact_teardown_issue90"], "tokens": 281}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class BaseFunctionalTests:\n\n    def test_exact_teardown_issue90(self, testdir) -> None:\n        rec = testdir.inline_runsource(\n            \"\"\"\n            import pytest\n\n            class TestClass(object):\n                def test_method(self):\n                    pass\n                def teardown_class(cls):\n                    raise Exception()\n\n            def test_func():\n                import sys\n                # on python2 exc_info is keept till a function exits\n                # so we would end up calling test functions while\n                # sys.exc_info would return the indexerror\n                # from guessing the lastitem\n                excinfo = sys.exc_info()\n                import traceback\n                assert excinfo[0] is None, \\\n                       traceback.format_exception(*excinfo)\n            def teardown_function(func):\n                raise ValueError(42)\n        \"\"\"\n        )\n        reps = rec.getreports(\"pytest_runtest_logreport\")\n        print(reps)\n        for i in range(2):\n            assert reps[i].nodeid.endswith(\"test_method\")\n            assert reps[i].passed\n        assert reps[2].when == \"teardown\"\n        assert reps[2].failed\n        assert len(reps) == 6\n        for i in range(3, 5):\n            assert reps[i].nodeid.endswith(\"test_func\")\n            assert reps[i].passed\n        assert reps[5].when == \"teardown\"\n        assert reps[5].nodeid.endswith(\"test_func\")\n        assert reps[5].failed", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_exact_teardown_issue1206_BaseFunctionalTests.test_exact_teardown_issue1206.assert_reps_2_longrepr_r": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_exact_teardown_issue1206_BaseFunctionalTests.test_exact_teardown_issue1206.assert_reps_2_longrepr_r", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 312, "end_line": 346, "span_ids": ["BaseFunctionalTests.test_exact_teardown_issue1206"], "tokens": 257}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class BaseFunctionalTests:\n\n    def test_exact_teardown_issue1206(self, testdir) -> None:\n        \"\"\"issue shadowing error with wrong number of arguments on teardown_method.\"\"\"\n        rec = testdir.inline_runsource(\n            \"\"\"\n            import pytest\n\n            class TestClass(object):\n                def teardown_method(self, x, y, z):\n                    pass\n\n                def test_method(self):\n                    assert True\n        \"\"\"\n        )\n        reps = rec.getreports(\"pytest_runtest_logreport\")\n        print(reps)\n        assert len(reps) == 3\n        #\n        assert reps[0].nodeid.endswith(\"test_method\")\n        assert reps[0].passed\n        assert reps[0].when == \"setup\"\n        #\n        assert reps[1].nodeid.endswith(\"test_method\")\n        assert reps[1].passed\n        assert reps[1].when == \"call\"\n        #\n        assert reps[2].nodeid.endswith(\"test_method\")\n        assert reps[2].failed\n        assert reps[2].when == \"teardown\"\n        assert reps[2].longrepr.reprcrash.message in (\n            # python3 error\n            \"TypeError: teardown_method() missing 2 required positional arguments: 'y' and 'z'\",\n            # python2 error\n            \"TypeError: teardown_method() takes exactly 4 arguments (2 given)\",\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_failure_in_setup_function_ignores_custom_repr_BaseFunctionalTests.test_exit_propagates": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_BaseFunctionalTests.test_failure_in_setup_function_ignores_custom_repr_BaseFunctionalTests.test_exit_propagates", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 348, "end_line": 402, "span_ids": ["BaseFunctionalTests.test_exit_propagates", "BaseFunctionalTests.test_failure_in_setup_function_ignores_custom_repr", "BaseFunctionalTests.test_systemexit_does_not_bail_out"], "tokens": 323}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class BaseFunctionalTests:\n\n    def test_failure_in_setup_function_ignores_custom_repr(self, testdir) -> None:\n        testdir.makepyfile(\n            conftest=\"\"\"\n            import pytest\n            class Function(pytest.Function):\n                def repr_failure(self, excinfo):\n                    assert 0\n        \"\"\"\n        )\n        reports = testdir.runitem(\n            \"\"\"\n            def setup_function(func):\n                raise ValueError(42)\n            def test_func():\n                pass\n        \"\"\"\n        )\n        assert len(reports) == 2\n        rep = reports[0]\n        print(rep)\n        assert not rep.skipped\n        assert not rep.passed\n        assert rep.failed\n        # assert rep.outcome.when == \"setup\"\n        # assert rep.outcome.where.lineno == 3\n        # assert rep.outcome.where.path.basename == \"test_func.py\"\n        # assert instanace(rep.failed.failurerepr, PythonFailureRepr)\n\n    def test_systemexit_does_not_bail_out(self, testdir) -> None:\n        try:\n            reports = testdir.runitem(\n                \"\"\"\n                def test_func():\n                    raise SystemExit(42)\n            \"\"\"\n            )\n        except SystemExit:\n            assert False, \"runner did not catch SystemExit\"\n        rep = reports[1]\n        assert rep.failed\n        assert rep.when == \"call\"\n\n    def test_exit_propagates(self, testdir) -> None:\n        try:\n            testdir.runitem(\n                \"\"\"\n                import pytest\n                def test_func():\n                    raise pytest.exit.Exception()\n            \"\"\"\n            )\n        except pytest.exit.Exception:\n            pass\n        else:\n            assert False, \"did not raise\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py__design_question_do_we__test_runtest_in_module_ordering.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py__design_question_do_we__test_runtest_in_module_ordering.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 491, "end_line": 524, "span_ids": ["impl:4", "test_runtest_in_module_ordering"], "tokens": 262}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# design question: do we want general hooks in python files?\n# then something like the following functional tests makes sense\n\n\n@pytest.mark.xfail\ndef test_runtest_in_module_ordering(testdir) -> None:\n    p1 = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def pytest_runtest_setup(item): # runs after class-level!\n            item.function.mylist.append(\"module\")\n        class TestClass(object):\n            def pytest_runtest_setup(self, item):\n                assert not hasattr(item.function, 'mylist')\n                item.function.mylist = ['class']\n            @pytest.fixture\n            def mylist(self, request):\n                return request.function.mylist\n            def pytest_runtest_call(self, item, __multicall__):\n                try:\n                    __multicall__.execute()\n                except ValueError:\n                    pass\n            def test_hello1(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n                raise ValueError()\n            def test_hello2(self, mylist):\n                assert mylist == ['class', 'module'], mylist\n        def pytest_runtest_teardown(item):\n            del item.function.mylist\n    \"\"\"\n    )\n    result = testdir.runpytest(p1)\n    result.stdout.fnmatch_lines([\"*2 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_current_test_env_var_test_current_test_env_var.assert_PYTEST_CURRENT_TE": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_current_test_env_var_test_current_test_env_var.assert_PYTEST_CURRENT_TE", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 903, "end_line": 932, "span_ids": ["test_current_test_env_var"], "tokens": 241}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_current_test_env_var(testdir, monkeypatch) -> None:\n    pytest_current_test_vars = []  # type: List[Tuple[str, str]]\n    monkeypatch.setattr(\n        sys, \"pytest_current_test_vars\", pytest_current_test_vars, raising=False\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import sys\n        import os\n\n        @pytest.fixture\n        def fix():\n            sys.pytest_current_test_vars.append(('setup', os.environ['PYTEST_CURRENT_TEST']))\n            yield\n            sys.pytest_current_test_vars.append(('teardown', os.environ['PYTEST_CURRENT_TEST']))\n\n        def test(fix):\n            sys.pytest_current_test_vars.append(('call', os.environ['PYTEST_CURRENT_TEST']))\n    \"\"\"\n    )\n    result = testdir.runpytest_inprocess()\n    assert result.ret == 0\n    test_id = \"test_current_test_env_var.py::test\"\n    assert pytest_current_test_vars == [\n        (\"setup\", test_id + \" (setup)\"),\n        (\"call\", test_id + \" (call)\"),\n        (\"teardown\", test_id + \" (teardown)\"),\n    ]\n    assert \"PYTEST_CURRENT_TEST\" not in os.environ", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_TestReportContents_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_TestReportContents_", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 935, "end_line": 1019, "span_ids": ["TestReportContents", "TestReportContents.getrunner", "TestReportContents.test_captured_text", "TestReportContents.test_longreprtext_failure", "TestReportContents.test_longreprtext_pass", "TestReportContents.test_no_captured_text", "test_outcome_exception_bad_msg"], "tokens": 555}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportContents:\n    \"\"\"\n    Test user-level API of ``TestReport`` objects.\n    \"\"\"\n\n    def getrunner(self):\n        return lambda item: runner.runtestprotocol(item, log=False)\n\n    def test_longreprtext_pass(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            def test_func():\n                pass\n        \"\"\"\n        )\n        rep = reports[1]\n        assert rep.longreprtext == \"\"\n\n    def test_longreprtext_failure(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            def test_func():\n                x = 1\n                assert x == 4\n        \"\"\"\n        )\n        rep = reports[1]\n        assert \"assert 1 == 4\" in rep.longreprtext\n\n    def test_captured_text(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            import pytest\n            import sys\n\n            @pytest.fixture\n            def fix():\n                sys.stdout.write('setup: stdout\\\\n')\n                sys.stderr.write('setup: stderr\\\\n')\n                yield\n                sys.stdout.write('teardown: stdout\\\\n')\n                sys.stderr.write('teardown: stderr\\\\n')\n                assert 0\n\n            def test_func(fix):\n                sys.stdout.write('call: stdout\\\\n')\n                sys.stderr.write('call: stderr\\\\n')\n                assert 0\n        \"\"\"\n        )\n        setup, call, teardown = reports\n        assert setup.capstdout == \"setup: stdout\\n\"\n        assert call.capstdout == \"setup: stdout\\ncall: stdout\\n\"\n        assert teardown.capstdout == \"setup: stdout\\ncall: stdout\\nteardown: stdout\\n\"\n\n        assert setup.capstderr == \"setup: stderr\\n\"\n        assert call.capstderr == \"setup: stderr\\ncall: stderr\\n\"\n        assert teardown.capstderr == \"setup: stderr\\ncall: stderr\\nteardown: stderr\\n\"\n\n    def test_no_captured_text(self, testdir) -> None:\n        reports = testdir.runitem(\n            \"\"\"\n            def test_func():\n                pass\n        \"\"\"\n        )\n        rep = reports[1]\n        assert rep.capstdout == \"\"\n        assert rep.capstderr == \"\"\n\n\ndef test_outcome_exception_bad_msg() -> None:\n    \"\"\"Check that OutcomeExceptions validate their input to prevent confusing errors (#5578)\"\"\"\n\n    def func() -> None:\n        raise NotImplementedError()\n\n    expected = (\n        \"OutcomeException expected string as 'msg' parameter, got 'function' instead.\\n\"\n        \"Perhaps you meant to use a mark?\"\n    )\n    with pytest.raises(TypeError) as excinfo:\n        OutcomeException(func)  # type: ignore\n    assert str(excinfo.value) == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py_test_setup_teardown_function_level_with_optional_argument_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py_test_setup_teardown_function_level_with_optional_argument_", "embedding": null, "metadata": {"file_path": "testing/test_runner_xunit.py", "file_name": "test_runner_xunit.py", "file_type": "text/x-python", "category": "test", "start_line": 247, "end_line": 300, "span_ids": ["test_setup_teardown_function_level_with_optional_argument"], "tokens": 340}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"arg\", [\"\", \"arg\"])\ndef test_setup_teardown_function_level_with_optional_argument(\n    testdir, monkeypatch, arg\n):\n    \"\"\"parameter to setup/teardown xunit-style functions parameter is now optional (#1728).\"\"\"\n    import sys\n\n    trace_setups_teardowns = []\n    monkeypatch.setattr(\n        sys, \"trace_setups_teardowns\", trace_setups_teardowns, raising=False\n    )\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import sys\n\n        trace = sys.trace_setups_teardowns.append\n\n        def setup_module({arg}): trace('setup_module')\n        def teardown_module({arg}): trace('teardown_module')\n\n        def setup_function({arg}): trace('setup_function')\n        def teardown_function({arg}): trace('teardown_function')\n\n        def test_function_1(): pass\n        def test_function_2(): pass\n\n        class Test(object):\n            def setup_method(self, {arg}): trace('setup_method')\n            def teardown_method(self, {arg}): trace('teardown_method')\n\n            def test_method_1(self): pass\n            def test_method_2(self): pass\n    \"\"\".format(\n            arg=arg\n        )\n    )\n    result = testdir.inline_run(p)\n    result.assertoutcome(passed=4)\n\n    expected = [\n        \"setup_module\",\n        \"setup_function\",\n        \"teardown_function\",\n        \"setup_function\",\n        \"teardown_function\",\n        \"setup_method\",\n        \"teardown_method\",\n        \"setup_method\",\n        \"teardown_method\",\n        \"teardown_module\",\n    ]\n    assert trace_setups_teardowns == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_nested_import_error_SessionTests.test_maxfail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_nested_import_error_SessionTests.test_maxfail", "embedding": null, "metadata": {"file_path": "testing/test_session.py", "file_name": "test_session.py", "file_type": "text/x-python", "category": "test", "start_line": 38, "end_line": 99, "span_ids": ["SessionTests.test_exit_first_problem", "SessionTests.test_maxfail", "SessionTests.test_nested_import_error", "SessionTests.test_raises_output", "SessionTests.test_syntax_error_module"], "tokens": 448}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class SessionTests:\n\n    def test_nested_import_error(self, testdir):\n        tfile = testdir.makepyfile(\n            \"\"\"\n            import import_fails\n            def test_this():\n                assert import_fails.a == 1\n        \"\"\",\n            import_fails=\"\"\"\n            import does_not_work\n            a = 1\n        \"\"\",\n        )\n        reprec = testdir.inline_run(tfile)\n        values = reprec.getfailedcollections()\n        assert len(values) == 1\n        out = str(values[0].longrepr)\n        assert out.find(\"does_not_work\") != -1\n\n    def test_raises_output(self, testdir):\n        reprec = testdir.inline_runsource(\n            \"\"\"\n            import pytest\n            def test_raises_doesnt():\n                pytest.raises(ValueError, int, \"3\")\n        \"\"\"\n        )\n        passed, skipped, failed = reprec.listoutcomes()\n        assert len(failed) == 1\n        out = failed[0].longrepr.reprcrash.message\n        assert \"DID NOT RAISE\" in out\n\n    def test_syntax_error_module(self, testdir):\n        reprec = testdir.inline_runsource(\"this is really not python\")\n        values = reprec.getfailedcollections()\n        assert len(values) == 1\n        out = str(values[0].longrepr)\n        assert out.find(\"not python\") != -1\n\n    def test_exit_first_problem(self, testdir):\n        reprec = testdir.inline_runsource(\n            \"\"\"\n            def test_one(): assert 0\n            def test_two(): assert 0\n        \"\"\",\n            \"--exitfirst\",\n        )\n        passed, skipped, failed = reprec.countoutcomes()\n        assert failed == 1\n        assert passed == skipped == 0\n\n    def test_maxfail(self, testdir):\n        reprec = testdir.inline_runsource(\n            \"\"\"\n            def test_one(): assert 0\n            def test_two(): assert 0\n            def test_three(): assert 0\n        \"\"\",\n            \"--maxfail=2\",\n        )\n        passed, skipped, failed = reprec.countoutcomes()\n        assert failed == 2\n        assert passed == skipped == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_broken_repr_with_showlocals_verbose_SessionTests.test_skip_file_by_conftest": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_broken_repr_with_showlocals_verbose_SessionTests.test_skip_file_by_conftest", "embedding": null, "metadata": {"file_path": "testing/test_session.py", "file_name": "test_session.py", "file_type": "text/x-python", "category": "test", "start_line": 133, "end_line": 174, "span_ids": ["SessionTests.test_broken_repr_with_showlocals_verbose", "SessionTests.test_skip_file_by_conftest"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class SessionTests:\n\n    def test_broken_repr_with_showlocals_verbose(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            class ObjWithErrorInRepr:\n                def __repr__(self):\n                    raise NotImplementedError\n\n            def test_repr_error():\n                x = ObjWithErrorInRepr()\n                assert x == \"value\"\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"--showlocals\", \"-vv\", p)\n        passed, skipped, failed = reprec.listoutcomes()\n        assert (len(passed), len(skipped), len(failed)) == (0, 0, 1)\n        entries = failed[0].longrepr.reprtraceback.reprentries\n        assert len(entries) == 1\n        repr_locals = entries[0].reprlocals\n        assert repr_locals.lines\n        assert len(repr_locals.lines) == 1\n        assert repr_locals.lines[0].startswith(\n            \"x          = <[NotImplementedError() raised in repr()] ObjWithErrorInRepr\"\n        )\n\n    def test_skip_file_by_conftest(self, testdir):\n        testdir.makepyfile(\n            conftest=\"\"\"\n            import pytest\n            def pytest_collect_file():\n                pytest.skip(\"intentional\")\n        \"\"\",\n            test_file=\"\"\"\n            def test_one(): pass\n        \"\"\",\n        )\n        try:\n            reprec = testdir.inline_run(testdir.tmpdir)\n        except pytest.skip.Exception:  # pragma: no cover\n            pytest.fail(\"wrong skipped caught\")\n        reports = reprec.getreports(\"pytest_collectreport\")\n        assert len(reports) == 1\n        assert reports[0].skipped", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_TestNewSession_TestNewSession.test_minus_x_overridden_by_maxfail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_TestNewSession_TestNewSession.test_minus_x_overridden_by_maxfail", "embedding": null, "metadata": {"file_path": "testing/test_session.py", "file_name": "test_session.py", "file_type": "text/x-python", "category": "test", "start_line": 181, "end_line": 250, "span_ids": ["TestNewSession", "TestNewSession.test_collect_only_with_various_situations", "TestNewSession.test_minus_x_import_error", "TestNewSession.test_minus_x_overridden_by_maxfail", "TestNewSession.test_order_of_execution"], "tokens": 575}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNewSession(SessionTests):\n    def test_order_of_execution(self, testdir):\n        reprec = testdir.inline_runsource(\n            \"\"\"\n            values = []\n            def test_1():\n                values.append(1)\n            def test_2():\n                values.append(2)\n            def test_3():\n                assert values == [1,2]\n            class Testmygroup(object):\n                reslist = values\n                def test_1(self):\n                    self.reslist.append(1)\n                def test_2(self):\n                    self.reslist.append(2)\n                def test_3(self):\n                    self.reslist.append(3)\n                def test_4(self):\n                    assert self.reslist == [1,2,1,2,3]\n        \"\"\"\n        )\n        passed, skipped, failed = reprec.countoutcomes()\n        assert failed == skipped == 0\n        assert passed == 7\n\n    def test_collect_only_with_various_situations(self, testdir):\n        p = testdir.makepyfile(\n            test_one=\"\"\"\n                def test_one():\n                    raise ValueError()\n\n                class TestX(object):\n                    def test_method_one(self):\n                        pass\n\n                class TestY(TestX):\n                    pass\n            \"\"\",\n            test_three=\"xxxdsadsadsadsa\",\n            __init__=\"\",\n        )\n        reprec = testdir.inline_run(\"--collect-only\", p.dirpath())\n\n        itemstarted = reprec.getcalls(\"pytest_itemcollected\")\n        assert len(itemstarted) == 3\n        assert not reprec.getreports(\"pytest_runtest_logreport\")\n        started = reprec.getcalls(\"pytest_collectstart\")\n        finished = reprec.getreports(\"pytest_collectreport\")\n        assert len(started) == len(finished)\n        assert len(started) == 8\n        colfail = [x for x in finished if x.failed]\n        assert len(colfail) == 1\n\n    def test_minus_x_import_error(self, testdir):\n        testdir.makepyfile(__init__=\"\")\n        testdir.makepyfile(test_one=\"xxxx\", test_two=\"yyyy\")\n        reprec = testdir.inline_run(\"-x\", testdir.tmpdir)\n        finished = reprec.getreports(\"pytest_collectreport\")\n        colfail = [x for x in finished if x.failed]\n        assert len(colfail) == 1\n\n    def test_minus_x_overridden_by_maxfail(self, testdir):\n        testdir.makepyfile(__init__=\"\")\n        testdir.makepyfile(test_one=\"xxxx\", test_two=\"yyyy\", test_third=\"zzz\")\n        reprec = testdir.inline_run(\"-x\", \"--maxfail=2\", testdir.tmpdir)\n        finished = reprec.getreports(\"pytest_collectreport\")\n        colfail = [x for x in finished if x.failed]\n        assert len(colfail) == 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_test_plugin_specify_test_sessionfinish_with_start": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_test_plugin_specify_test_sessionfinish_with_start", "embedding": null, "metadata": {"file_path": "testing/test_session.py", "file_name": "test_session.py", "file_type": "text/x-python", "category": "test", "start_line": 249, "end_line": 333, "span_ids": ["test_deselect", "test_exclude", "test_exclude_glob", "test_plugin_already_exists", "test_plugin_specify", "test_sessionfinish_with_start"], "tokens": 664}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_plugin_specify(testdir):\n    with pytest.raises(ImportError):\n        testdir.parseconfig(\"-p\", \"nqweotexistent\")\n    # pytest.raises(ImportError,\n    #    \"config.do_configure(config)\"\n    # )\n\n\ndef test_plugin_already_exists(testdir):\n    config = testdir.parseconfig(\"-p\", \"terminal\")\n    assert config.option.plugins == [\"terminal\"]\n    config._do_configure()\n    config._ensure_unconfigure()\n\n\ndef test_exclude(testdir):\n    hellodir = testdir.mkdir(\"hello\")\n    hellodir.join(\"test_hello.py\").write(\"x y syntaxerror\")\n    hello2dir = testdir.mkdir(\"hello2\")\n    hello2dir.join(\"test_hello2.py\").write(\"x y syntaxerror\")\n    testdir.makepyfile(test_ok=\"def test_pass(): pass\")\n    result = testdir.runpytest(\"--ignore=hello\", \"--ignore=hello2\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_exclude_glob(testdir):\n    hellodir = testdir.mkdir(\"hello\")\n    hellodir.join(\"test_hello.py\").write(\"x y syntaxerror\")\n    hello2dir = testdir.mkdir(\"hello2\")\n    hello2dir.join(\"test_hello2.py\").write(\"x y syntaxerror\")\n    hello3dir = testdir.mkdir(\"hallo3\")\n    hello3dir.join(\"test_hello3.py\").write(\"x y syntaxerror\")\n    subdir = testdir.mkdir(\"sub\")\n    subdir.join(\"test_hello4.py\").write(\"x y syntaxerror\")\n    testdir.makepyfile(test_ok=\"def test_pass(): pass\")\n    result = testdir.runpytest(\"--ignore-glob=*h[ea]llo*\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_deselect(testdir):\n    testdir.makepyfile(\n        test_a=\"\"\"\n        import pytest\n\n        def test_a1(): pass\n\n        @pytest.mark.parametrize('b', range(3))\n        def test_a2(b): pass\n\n        class TestClass:\n            def test_c1(self): pass\n\n            def test_c2(self): pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\n        \"-v\",\n        \"--deselect=test_a.py::test_a2[1]\",\n        \"--deselect=test_a.py::test_a2[2]\",\n        \"--deselect=test_a.py::TestClass::test_c1\",\n    )\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*3 passed, 3 deselected*\"])\n    for line in result.stdout.lines:\n        assert not line.startswith((\"test_a.py::test_a2[1]\", \"test_a.py::test_a2[2]\"))\n\n\ndef test_sessionfinish_with_start(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        import os\n        values = []\n        def pytest_sessionstart():\n            values.append(os.getcwd())\n            os.chdir(\"..\")\n\n        def pytest_sessionfinish():\n            assert values[0] == os.getcwd()\n\n    \"\"\"\n    )\n    res = testdir.runpytest(\"--collect-only\")\n    assert res.ret == ExitCode.NO_TESTS_COLLECTED", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_test_rootdir_option_arg_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_test_rootdir_option_arg_", "embedding": null, "metadata": {"file_path": "testing/test_session.py", "file_name": "test_session.py", "file_type": "text/x-python", "category": "test", "start_line": 336, "end_line": 366, "span_ids": ["test_rootdir_option_arg", "test_rootdir_wrong_option_arg"], "tokens": 226}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"path\", [\"root\", \"{relative}/root\", \"{environment}/root\"])\ndef test_rootdir_option_arg(testdir, monkeypatch, path):\n    monkeypatch.setenv(\"PY_ROOTDIR_PATH\", str(testdir.tmpdir))\n    path = path.format(relative=str(testdir.tmpdir), environment=\"$PY_ROOTDIR_PATH\")\n\n    rootdir = testdir.mkdir(\"root\")\n    rootdir.mkdir(\"tests\")\n    testdir.makepyfile(\n        \"\"\"\n        import os\n        def test_one():\n            assert 1\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--rootdir={}\".format(path))\n    result.stdout.fnmatch_lines(\n        [\n            \"*rootdir: {}/root\".format(testdir.tmpdir),\n            \"root/test_rootdir_option_arg.py *\",\n            \"*1 passed*\",\n        ]\n    )\n\n\ndef test_rootdir_wrong_option_arg(testdir):\n    result = testdir.runpytest(\"--rootdir=wrong_dir\")\n    result.stderr.fnmatch_lines(\n        [\"*Directory *wrong_dir* not found. Check your '--rootdir' option.*\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail_TestXFail.test_xfail_not_report_default": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail_TestXFail.test_xfail_not_report_default", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 134, "end_line": 243, "span_ids": ["TestXFail", "TestXFail.test_xfail_evalfalse_but_fails", "TestXFail.test_xfail_not_report_default", "TestXFail.test_xfail_run_anyway", "TestXFail.test_xfail_simple", "TestXFail.test_xfail_using_platform", "TestXFail.test_xfail_xpassed", "TestXFail.test_xfail_xpassed_strict"], "tokens": 728}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestXFail:\n    @pytest.mark.parametrize(\"strict\", [True, False])\n    def test_xfail_simple(self, testdir, strict):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(strict=%s)\n            def test_func():\n                assert 0\n        \"\"\"\n            % strict\n        )\n        reports = runtestprotocol(item, log=False)\n        assert len(reports) == 3\n        callreport = reports[1]\n        assert callreport.skipped\n        assert callreport.wasxfail == \"\"\n\n    def test_xfail_xpassed(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(reason=\"this is an xfail\")\n            def test_func():\n                assert 1\n        \"\"\"\n        )\n        reports = runtestprotocol(item, log=False)\n        assert len(reports) == 3\n        callreport = reports[1]\n        assert callreport.passed\n        assert callreport.wasxfail == \"this is an xfail\"\n\n    def test_xfail_using_platform(self, testdir):\n        \"\"\"\n        Verify that platform can be used with xfail statements.\n        \"\"\"\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(\"platform.platform() == platform.platform()\")\n            def test_func():\n                assert 0\n        \"\"\"\n        )\n        reports = runtestprotocol(item, log=False)\n        assert len(reports) == 3\n        callreport = reports[1]\n        assert callreport.wasxfail\n\n    def test_xfail_xpassed_strict(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(strict=True, reason=\"nope\")\n            def test_func():\n                assert 1\n        \"\"\"\n        )\n        reports = runtestprotocol(item, log=False)\n        assert len(reports) == 3\n        callreport = reports[1]\n        assert callreport.failed\n        assert callreport.longrepr == \"[XPASS(strict)] nope\"\n        assert not hasattr(callreport, \"wasxfail\")\n\n    def test_xfail_run_anyway(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test_func():\n                assert 0\n            def test_func2():\n                pytest.xfail(\"hello\")\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--runxfail\")\n        result.stdout.fnmatch_lines(\n            [\"*def test_func():*\", \"*assert 0*\", \"*1 failed*1 pass*\"]\n        )\n\n    def test_xfail_evalfalse_but_fails(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail('False')\n            def test_func():\n                assert 0\n        \"\"\"\n        )\n        reports = runtestprotocol(item, log=False)\n        callreport = reports[1]\n        assert callreport.failed\n        assert not hasattr(callreport, \"wasxfail\")\n        assert \"xfail\" in callreport.keywords\n\n    def test_xfail_not_report_default(self, testdir):\n        p = testdir.makepyfile(\n            test_one=\"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test_this():\n                assert 0\n        \"\"\"\n        )\n        testdir.runpytest(p, \"-v\")\n        # result.stdout.fnmatch_lines([\n        #    \"*HINT*use*-r*\"\n        # ])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.test_xfail_not_run_xfail_reporting_TestXFail.test_xfail_imperative_in_setup_function": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.test_xfail_not_run_xfail_reporting_TestXFail.test_xfail_imperative_in_setup_function", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 245, "end_line": 336, "span_ids": ["TestXFail.test_xfail_imperative", "TestXFail.test_xfail_imperative_in_setup_function", "TestXFail.test_xfail_not_run_no_setup_run", "TestXFail.test_xfail_not_run_xfail_reporting", "TestXFail.test_xfail_xpass"], "tokens": 654}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestXFail:\n\n    def test_xfail_not_run_xfail_reporting(self, testdir):\n        p = testdir.makepyfile(\n            test_one=\"\"\"\n            import pytest\n            @pytest.mark.xfail(run=False, reason=\"noway\")\n            def test_this():\n                assert 0\n            @pytest.mark.xfail(\"True\", run=False)\n            def test_this_true():\n                assert 0\n            @pytest.mark.xfail(\"False\", run=False, reason=\"huh\")\n            def test_this_false():\n                assert 1\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-rx\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_one*test_this*\",\n                \"*NOTRUN*noway\",\n                \"*test_one*test_this_true*\",\n                \"*NOTRUN*condition:*True*\",\n                \"*1 passed*\",\n            ]\n        )\n\n    def test_xfail_not_run_no_setup_run(self, testdir):\n        p = testdir.makepyfile(\n            test_one=\"\"\"\n            import pytest\n            @pytest.mark.xfail(run=False, reason=\"hello\")\n            def test_this():\n                assert 0\n            def setup_module(mod):\n                raise ValueError(42)\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-rx\")\n        result.stdout.fnmatch_lines(\n            [\"*test_one*test_this*\", \"*NOTRUN*hello\", \"*1 xfailed*\"]\n        )\n\n    def test_xfail_xpass(self, testdir):\n        p = testdir.makepyfile(\n            test_one=\"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test_that():\n                assert 1\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-rX\")\n        result.stdout.fnmatch_lines([\"*XPASS*test_that*\", \"*1 xpassed*\"])\n        assert result.ret == 0\n\n    def test_xfail_imperative(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_this():\n                pytest.xfail(\"hello\")\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"*1 xfailed*\"])\n        result = testdir.runpytest(p, \"-rx\")\n        result.stdout.fnmatch_lines([\"*XFAIL*test_this*\", \"*reason:*hello*\"])\n        result = testdir.runpytest(p, \"--runxfail\")\n        result.stdout.fnmatch_lines([\"*1 pass*\"])\n\n    def test_xfail_imperative_in_setup_function(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def setup_function(function):\n                pytest.xfail(\"hello\")\n\n            def test_this():\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"*1 xfailed*\"])\n        result = testdir.runpytest(p, \"-rx\")\n        result.stdout.fnmatch_lines([\"*XFAIL*test_this*\", \"*reason:*hello*\"])\n        result = testdir.runpytest(p, \"--runxfail\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *def test_this*\n            *1 fail*\n        \"\"\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.xtest_dynamic_xfail_set_during_setup_TestXFail.test_strict_sanity": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.xtest_dynamic_xfail_set_during_setup_TestXFail.test_strict_sanity", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 338, "end_line": 417, "span_ids": ["TestXFail.test_dynamic_xfail_no_run", "TestXFail.test_dynamic_xfail_set_during_funcarg_setup", "TestXFail.test_strict_sanity", "TestXFail.test_xfail_raises", "TestXFail.xtest_dynamic_xfail_set_during_setup"], "tokens": 568}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestXFail:\n\n    def xtest_dynamic_xfail_set_during_setup(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def setup_function(function):\n                pytest.mark.xfail(function)\n            def test_this():\n                assert 0\n            def test_that():\n                assert 1\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-rxX\")\n        result.stdout.fnmatch_lines([\"*XFAIL*test_this*\", \"*XPASS*test_that*\"])\n\n    def test_dynamic_xfail_no_run(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def arg(request):\n                request.applymarker(pytest.mark.xfail(run=False))\n            def test_this(arg):\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-rxX\")\n        result.stdout.fnmatch_lines([\"*XFAIL*test_this*\", \"*NOTRUN*\"])\n\n    def test_dynamic_xfail_set_during_funcarg_setup(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def arg(request):\n                request.applymarker(pytest.mark.xfail)\n            def test_this2(arg):\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"*1 xfailed*\"])\n\n    @pytest.mark.parametrize(\n        \"expected, actual, matchline\",\n        [\n            (\"TypeError\", \"TypeError\", \"*1 xfailed*\"),\n            (\"(AttributeError, TypeError)\", \"TypeError\", \"*1 xfailed*\"),\n            (\"TypeError\", \"IndexError\", \"*1 failed*\"),\n            (\"(AttributeError, TypeError)\", \"IndexError\", \"*1 failed*\"),\n        ],\n    )\n    def test_xfail_raises(self, expected, actual, matchline, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(raises=%s)\n            def test_raises():\n                raise %s()\n        \"\"\"\n            % (expected, actual)\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([matchline])\n\n    def test_strict_sanity(self, testdir):\n        \"\"\"sanity check for xfail(strict=True): a failing test should behave\n        exactly like a normal xfail.\n        \"\"\"\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(reason='unsupported feature', strict=True)\n            def test_foo():\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-rxX\")\n        result.stdout.fnmatch_lines([\"*XFAIL*\", \"*unsupported feature*\"])\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.test_strict_xfail_TestXFail.test_strict_xfail_default_from_file": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFail.test_strict_xfail_TestXFail.test_strict_xfail_default_from_file", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 419, "end_line": 498, "span_ids": ["TestXFail.test_strict_xfail", "TestXFail.test_strict_xfail_condition", "TestXFail.test_strict_xfail_default_from_file", "TestXFail.test_xfail_condition_keyword"], "tokens": 564}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestXFail:\n\n    @pytest.mark.parametrize(\"strict\", [True, False])\n    def test_strict_xfail(self, testdir, strict):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.xfail(reason='unsupported feature', strict=%s)\n            def test_foo():\n                with open('foo_executed', 'w'): pass  # make sure test executes\n        \"\"\"\n            % strict\n        )\n        result = testdir.runpytest(p, \"-rxX\")\n        if strict:\n            result.stdout.fnmatch_lines(\n                [\"*test_foo*\", \"*XPASS(strict)*unsupported feature*\"]\n            )\n        else:\n            result.stdout.fnmatch_lines(\n                [\n                    \"*test_strict_xfail*\",\n                    \"XPASS test_strict_xfail.py::test_foo unsupported feature\",\n                ]\n            )\n        assert result.ret == (1 if strict else 0)\n        assert testdir.tmpdir.join(\"foo_executed\").isfile()\n\n    @pytest.mark.parametrize(\"strict\", [True, False])\n    def test_strict_xfail_condition(self, testdir, strict):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.xfail(False, reason='unsupported feature', strict=%s)\n            def test_foo():\n                pass\n        \"\"\"\n            % strict\n        )\n        result = testdir.runpytest(p, \"-rxX\")\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        assert result.ret == 0\n\n    @pytest.mark.parametrize(\"strict\", [True, False])\n    def test_xfail_condition_keyword(self, testdir, strict):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.xfail(condition=False, reason='unsupported feature', strict=%s)\n            def test_foo():\n                pass\n        \"\"\"\n            % strict\n        )\n        result = testdir.runpytest(p, \"-rxX\")\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        assert result.ret == 0\n\n    @pytest.mark.parametrize(\"strict_val\", [\"true\", \"false\"])\n    def test_strict_xfail_default_from_file(self, testdir, strict_val):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            xfail_strict = %s\n        \"\"\"\n            % strict_val\n        )\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(reason='unsupported feature')\n            def test_foo():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-rxX\")\n        strict = strict_val == \"true\"\n        result.stdout.fnmatch_lines([\"*1 failed*\" if strict else \"*1 xpassed*\"])\n        assert result.ret == (1 if strict else 0)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFailwithSetupTeardown_TestSkip.test_strict_and_skip": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestXFailwithSetupTeardown_TestSkip.test_strict_and_skip", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 501, "end_line": 627, "span_ids": ["TestSkip", "TestSkip.test_arg_as_reason", "TestSkip.test_only_skips_marked_test", "TestSkip.test_skip_class", "TestSkip.test_skip_no_reason", "TestSkip.test_skip_with_reason", "TestSkip.test_skips_on_false_string", "TestSkip.test_strict_and_skip", "TestXFailwithSetupTeardown", "TestXFailwithSetupTeardown.test_failing_setup_issue9", "TestXFailwithSetupTeardown.test_failing_teardown_issue9"], "tokens": 701}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestXFailwithSetupTeardown:\n    def test_failing_setup_issue9(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def setup_function(func):\n                assert 0\n\n            @pytest.mark.xfail\n            def test_func():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 xfail*\"])\n\n    def test_failing_teardown_issue9(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def teardown_function(func):\n                assert 0\n\n            @pytest.mark.xfail\n            def test_func():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 xfail*\"])\n\n\nclass TestSkip:\n    def test_skip_class(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip\n            class TestSomething(object):\n                def test_foo(self):\n                    pass\n                def test_bar(self):\n                    pass\n\n            def test_baz():\n                pass\n        \"\"\"\n        )\n        rec = testdir.inline_run()\n        rec.assertoutcome(skipped=2, passed=1)\n\n    def test_skips_on_false_string(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip('False')\n            def test_foo():\n                pass\n        \"\"\"\n        )\n        rec = testdir.inline_run()\n        rec.assertoutcome(skipped=1)\n\n    def test_arg_as_reason(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip('testing stuff')\n            def test_bar():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rs\")\n        result.stdout.fnmatch_lines([\"*testing stuff*\", \"*1 skipped*\"])\n\n    def test_skip_no_reason(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip\n            def test_foo():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rs\")\n        result.stdout.fnmatch_lines([\"*unconditional skip*\", \"*1 skipped*\"])\n\n    def test_skip_with_reason(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip(reason=\"for lolz\")\n            def test_bar():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rs\")\n        result.stdout.fnmatch_lines([\"*for lolz*\", \"*1 skipped*\"])\n\n    def test_only_skips_marked_test(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip\n            def test_foo():\n                pass\n            @pytest.mark.skip(reason=\"nothing in particular\")\n            def test_bar():\n                pass\n            def test_baz():\n                assert True\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rs\")\n        result.stdout.fnmatch_lines([\"*nothing in particular*\", \"*1 passed*2 skipped*\"])\n\n    def test_strict_and_skip(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skip\n            def test_hello():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rs\")\n        result.stdout.fnmatch_lines([\"*unconditional skip*\", \"*1 skipped*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestSkipif_TestSkipif.test_skipif_using_platform": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestSkipif_TestSkipif.test_skipif_using_platform", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 630, "end_line": 669, "span_ids": ["TestSkipif", "TestSkipif.test_skipif_conditional", "TestSkipif.test_skipif_reporting", "TestSkipif.test_skipif_using_platform"], "tokens": 294}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSkipif:\n    def test_skipif_conditional(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.skipif(\"hasattr(os, 'sep')\")\n            def test_func():\n                pass\n        \"\"\"\n        )\n        x = pytest.raises(pytest.skip.Exception, lambda: pytest_runtest_setup(item))\n        assert x.value.msg == \"condition: hasattr(os, 'sep')\"\n\n    @pytest.mark.parametrize(\n        \"params\", [\"\\\"hasattr(sys, 'platform')\\\"\", 'True, reason=\"invalid platform\"']\n    )\n    def test_skipif_reporting(self, testdir, params):\n        p = testdir.makepyfile(\n            test_foo=\"\"\"\n            import pytest\n            @pytest.mark.skipif(%(params)s)\n            def test_that():\n                assert 0\n        \"\"\"\n            % dict(params=params)\n        )\n        result = testdir.runpytest(p, \"-s\", \"-rs\")\n        result.stdout.fnmatch_lines([\"*SKIP*1*test_foo.py*platform*\", \"*1 skipped*\"])\n        assert result.ret == 0\n\n    def test_skipif_using_platform(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.skipif(\"platform.platform() == platform.platform()\")\n            def test_func():\n                pass\n        \"\"\"\n        )\n        pytest.raises(pytest.skip.Exception, lambda: pytest_runtest_setup(item))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestSkipif.test_skipif_reporting_multiple_TestSkipif.test_skipif_reporting_multiple": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestSkipif.test_skipif_reporting_multiple_TestSkipif.test_skipif_reporting_multiple", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 671, "end_line": 694, "span_ids": ["TestSkipif.test_skipif_reporting_multiple"], "tokens": 201}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSkipif:\n\n    @pytest.mark.parametrize(\n        \"marker, msg1, msg2\",\n        [(\"skipif\", \"SKIP\", \"skipped\"), (\"xfail\", \"XPASS\", \"xpassed\")],\n    )\n    def test_skipif_reporting_multiple(self, testdir, marker, msg1, msg2):\n        testdir.makepyfile(\n            test_foo=\"\"\"\n            import pytest\n            @pytest.mark.{marker}(False, reason='first_condition')\n            @pytest.mark.{marker}(True, reason='second_condition')\n            def test_foobar():\n                assert 1\n        \"\"\".format(\n                marker=marker\n            )\n        )\n        result = testdir.runpytest(\"-s\", \"-rsxX\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*{msg1}*test_foo.py*second_condition*\".format(msg1=msg1),\n                \"*1 {msg2}*\".format(msg2=msg2),\n            ]\n        )\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_skip_not_report_default_test_reportchars_error": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_skip_not_report_default_test_reportchars_error", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 697, "end_line": 821, "span_ids": ["test_reportchars", "test_reportchars_error", "test_skip_not_report_default", "test_skipif_class", "test_skipped_folding", "test_skipped_reasons_functional"], "tokens": 691}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_skip_not_report_default(testdir):\n    p = testdir.makepyfile(\n        test_one=\"\"\"\n        import pytest\n        def test_this():\n            pytest.skip(\"hello\")\n    \"\"\"\n    )\n    result = testdir.runpytest(p, \"-v\")\n    result.stdout.fnmatch_lines(\n        [\n            # \"*HINT*use*-r*\",\n            \"*1 skipped*\"\n        ]\n    )\n\n\ndef test_skipif_class(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        class TestClass(object):\n            pytestmark = pytest.mark.skipif(\"True\")\n            def test_that(self):\n                assert 0\n            def test_though(self):\n                assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest(p)\n    result.stdout.fnmatch_lines([\"*2 skipped*\"])\n\n\ndef test_skipped_reasons_functional(testdir):\n    testdir.makepyfile(\n        test_one=\"\"\"\n            import pytest\n            from conftest import doskip\n\n            def setup_function(func):\n                doskip()\n\n            def test_func():\n                pass\n\n            class TestClass(object):\n                def test_method(self):\n                    doskip()\n\n                @pytest.mark.skip(\"via_decorator\")\n                def test_deco(self):\n                    assert 0\n        \"\"\",\n        conftest=\"\"\"\n            import pytest, sys\n            def doskip():\n                assert sys._getframe().f_lineno == 3\n                pytest.skip('test')\n        \"\"\",\n    )\n    result = testdir.runpytest(\"-rs\")\n    result.stdout.fnmatch_lines_random(\n        [\n            \"SKIPPED [[]2[]] conftest.py:4: test\",\n            \"SKIPPED [[]1[]] test_one.py:14: via_decorator\",\n        ]\n    )\n    assert result.ret == 0\n\n\ndef test_skipped_folding(testdir):\n    testdir.makepyfile(\n        test_one=\"\"\"\n            import pytest\n            pytestmark = pytest.mark.skip(\"Folding\")\n            def setup_function(func):\n                pass\n            def test_func():\n                pass\n            class TestClass(object):\n                def test_method(self):\n                    pass\n       \"\"\"\n    )\n    result = testdir.runpytest(\"-rs\")\n    result.stdout.fnmatch_lines([\"*SKIP*2*test_one.py: Folding\"])\n    assert result.ret == 0\n\n\ndef test_reportchars(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_1():\n            assert 0\n        @pytest.mark.xfail\n        def test_2():\n            assert 0\n        @pytest.mark.xfail\n        def test_3():\n            pass\n        def test_4():\n            pytest.skip(\"four\")\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-rfxXs\")\n    result.stdout.fnmatch_lines(\n        [\"FAIL*test_1*\", \"XFAIL*test_2*\", \"XPASS*test_3*\", \"SKIP*four*\"]\n    )\n\n\ndef test_reportchars_error(testdir):\n    testdir.makepyfile(\n        conftest=\"\"\"\n        def pytest_runtest_teardown():\n            assert 0\n        \"\"\",\n        test_simple=\"\"\"\n        def test_foo():\n            pass\n        \"\"\",\n    )\n    result = testdir.runpytest(\"-rE\")\n    result.stdout.fnmatch_lines([\"ERROR*test_foo*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_reportchars_all_test_reportchars_all_error": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_reportchars_all_test_reportchars_all_error", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 831, "end_line": 876, "span_ids": ["test_reportchars_all", "test_reportchars_all_error"], "tokens": 253}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_reportchars_all(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_1():\n            assert 0\n        @pytest.mark.xfail\n        def test_2():\n            assert 0\n        @pytest.mark.xfail\n        def test_3():\n            pass\n        def test_4():\n            pytest.skip(\"four\")\n        @pytest.fixture\n        def fail():\n            assert 0\n        def test_5(fail):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-ra\")\n    result.stdout.fnmatch_lines(\n        [\n            \"SKIP*four*\",\n            \"XFAIL*test_2*\",\n            \"XPASS*test_3*\",\n            \"ERROR*test_5*\",\n            \"FAIL*test_1*\",\n        ]\n    )\n\n\ndef test_reportchars_all_error(testdir):\n    testdir.makepyfile(\n        conftest=\"\"\"\n        def pytest_runtest_teardown():\n            assert 0\n        \"\"\",\n        test_simple=\"\"\"\n        def test_foo():\n            pass\n        \"\"\",\n    )\n    result = testdir.runpytest(\"-ra\")\n    result.stdout.fnmatch_lines([\"ERROR*test_foo*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_errors_in_xfail_skip_expressions_test_errors_in_xfail_skip_expressions.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_errors_in_xfail_skip_expressions_test_errors_in_xfail_skip_expressions.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 872, "end_line": 905, "span_ids": ["test_errors_in_xfail_skip_expressions"], "tokens": 230}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_errors_in_xfail_skip_expressions(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.skipif(\"asd\")\n        def test_nameerror():\n            pass\n        @pytest.mark.xfail(\"syntax error\")\n        def test_syntax():\n            pass\n\n        def test_func():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    markline = \"                ^\"\n    if hasattr(sys, \"pypy_version_info\") and sys.pypy_version_info < (6,):\n        markline = markline[5:]\n    elif sys.version_info >= (3, 8) or hasattr(sys, \"pypy_version_info\"):\n        markline = markline[4:]\n    result.stdout.fnmatch_lines(\n        [\n            \"*ERROR*test_nameerror*\",\n            \"*evaluating*skipif*expression*\",\n            \"*asd*\",\n            \"*ERROR*test_syntax*\",\n            \"*evaluating*xfail*expression*\",\n            \"    syntax error\",\n            markline,\n            \"SyntaxError: invalid syntax\",\n            \"*1 pass*2 errors*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_xfail_skipif_with_globals_test_imperativeskip_on_xfail_test.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_xfail_skipif_with_globals_test_imperativeskip_on_xfail_test.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 908, "end_line": 996, "span_ids": ["test_default_markers", "test_direct_gives_error", "test_imperativeskip_on_xfail_test", "test_xfail_skipif_with_globals", "test_xfail_test_setup_exception"], "tokens": 495}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_xfail_skipif_with_globals(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        x = 3\n        @pytest.mark.skipif(\"x == 3\")\n        def test_skip1():\n            pass\n        @pytest.mark.xfail(\"x == 3\")\n        def test_boolean():\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-rsx\")\n    result.stdout.fnmatch_lines([\"*SKIP*x == 3*\", \"*XFAIL*test_boolean*\", \"*x == 3*\"])\n\n\ndef test_direct_gives_error(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.skipif(True)\n        def test_skip1():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 error*\"])\n\n\ndef test_default_markers(testdir):\n    result = testdir.runpytest(\"--markers\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*skipif(*condition)*skip*\",\n            \"*xfail(*condition, reason=None, run=True, raises=None, strict=False)*expected failure*\",\n        ]\n    )\n\n\ndef test_xfail_test_setup_exception(testdir):\n    testdir.makeconftest(\n        \"\"\"\n            def pytest_runtest_setup():\n                0 / 0\n        \"\"\"\n    )\n    p = testdir.makepyfile(\n        \"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test_func():\n                assert 0\n        \"\"\"\n    )\n    result = testdir.runpytest(p)\n    assert result.ret == 0\n    assert \"xfailed\" in result.stdout.str()\n    result.stdout.no_fnmatch_line(\"*xpassed*\")\n\n\ndef test_imperativeskip_on_xfail_test(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.xfail\n        def test_that_fails():\n            assert 0\n\n        @pytest.mark.skipif(\"True\")\n        def test_hello():\n            pass\n    \"\"\"\n    )\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        def pytest_runtest_setup(item):\n            pytest.skip(\"abc\")\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-rsxX\")\n    result.stdout.fnmatch_lines_random(\n        \"\"\"\n        *SKIP*abc*\n        *SKIP*condition: True*\n        *2 skipped*\n    \"\"\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestBooleanCondition_TestBooleanCondition.test_xfail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_TestBooleanCondition_TestBooleanCondition.test_xfail", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 985, "end_line": 1037, "span_ids": ["TestBooleanCondition", "TestBooleanCondition.test_skipif", "TestBooleanCondition.test_skipif_noreason", "TestBooleanCondition.test_xfail"], "tokens": 266}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestBooleanCondition:\n    def test_skipif(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skipif(True, reason=\"True123\")\n            def test_func1():\n                pass\n            @pytest.mark.skipif(False, reason=\"True123\")\n            def test_func2():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *1 passed*1 skipped*\n        \"\"\"\n        )\n\n    def test_skipif_noreason(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.skipif(True)\n            def test_func():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rs\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *1 error*\n        \"\"\"\n        )\n\n    def test_xfail(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(True, reason=\"True123\")\n            def test_func():\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rxs\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *XFAIL*\n            *True123*\n            *1 xfail*\n        \"\"\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_xfail_item_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_test_xfail_item_", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 1054, "end_line": 1196, "span_ids": ["test_importorskip", "test_invalid_skip_keyword_parameter", "test_mark_xfail_item", "test_module_level_skip_error", "test_module_level_skip_with_allow_module_level", "test_relpath_rootdir", "test_summary_list_after_errors", "test_xfail_item"], "tokens": 835}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_xfail_item(testdir):\n    # Ensure pytest.xfail works with non-Python Item\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n\n        class MyItem(pytest.Item):\n            nodeid = 'foo'\n            def runtest(self):\n                pytest.xfail(\"Expected Failure\")\n\n        def pytest_collect_file(path, parent):\n            return MyItem(\"foo\", parent)\n    \"\"\"\n    )\n    result = testdir.inline_run()\n    passed, skipped, failed = result.listoutcomes()\n    assert not failed\n    xfailed = [r for r in skipped if hasattr(r, \"wasxfail\")]\n    assert xfailed\n\n\ndef test_module_level_skip_error(testdir):\n    \"\"\"\n    Verify that using pytest.skip at module level causes a collection error\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        pytest.skip(\"skip_module_level\")\n\n        def test_func():\n            assert True\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\"*Using pytest.skip outside of a test is not allowed*\"]\n    )\n\n\ndef test_module_level_skip_with_allow_module_level(testdir):\n    \"\"\"\n    Verify that using pytest.skip(allow_module_level=True) is allowed\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        pytest.skip(\"skip_module_level\", allow_module_level=True)\n\n        def test_func():\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-rxs\")\n    result.stdout.fnmatch_lines([\"*SKIP*skip_module_level\"])\n\n\ndef test_invalid_skip_keyword_parameter(testdir):\n    \"\"\"\n    Verify that using pytest.skip() with unknown parameter raises an error\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        pytest.skip(\"skip_module_level\", unknown=1)\n\n        def test_func():\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*TypeError:*['unknown']*\"])\n\n\ndef test_mark_xfail_item(testdir):\n    # Ensure pytest.mark.xfail works with non-Python Item\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n\n        class MyItem(pytest.Item):\n            nodeid = 'foo'\n            def setup(self):\n                marker = pytest.mark.xfail(True, reason=\"Expected failure\")\n                self.add_marker(marker)\n            def runtest(self):\n                assert False\n\n        def pytest_collect_file(path, parent):\n            return MyItem(\"foo\", parent)\n    \"\"\"\n    )\n    result = testdir.inline_run()\n    passed, skipped, failed = result.listoutcomes()\n    assert not failed\n    xfailed = [r for r in skipped if hasattr(r, \"wasxfail\")]\n    assert xfailed\n\n\ndef test_summary_list_after_errors(testdir):\n    \"\"\"Ensure the list of errors/fails/xfails/skips appears after tracebacks in terminal reporting.\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_fail():\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-ra\")\n    result.stdout.fnmatch_lines(\n        [\n            \"=* FAILURES *=\",\n            \"*= short test summary info =*\",\n            \"FAILED test_summary_list_after_errors.py::test_fail - assert 0\",\n        ]\n    )\n\n\ndef test_importorskip():\n    with pytest.raises(\n        pytest.skip.Exception,\n        match=\"^could not import 'doesnotexist': No module named .*\",\n    ):\n        pytest.importorskip(\"doesnotexist\")\n\n\ndef test_relpath_rootdir(testdir):\n    testdir.makepyfile(\n        **{\n            \"tests/test_1.py\": \"\"\"\n        import pytest\n        @pytest.mark.skip()\n        def test_pass():\n            pass\n            \"\"\",\n        }\n    )\n    result = testdir.runpytest(\"-rs\", \"tests/test_1.py\", \"--rootdir=tests\")\n    result.stdout.fnmatch_lines(\n        [\"SKIPPED [[]1[]] tests/test_1.py:2: unconditional skip\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_error_testdir_test_fail_and_continue_with_stepwise": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_error_testdir_test_fail_and_continue_with_stepwise", "embedding": null, "metadata": {"file_path": "testing/test_stepwise.py", "file_name": "test_stepwise.py", "file_type": "text/x-python", "category": "test", "start_line": 55, "end_line": 107, "span_ids": ["broken_testdir", "error_testdir", "test_fail_and_continue_with_stepwise", "test_run_without_stepwise"], "tokens": 390}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.fixture\ndef error_testdir(testdir):\n    testdir.makepyfile(\n        test_a=\"\"\"\ndef test_error(nonexisting_fixture):\n    assert 1\n\ndef test_success_after_fail():\n    assert 1\n\"\"\"\n    )\n\n    return testdir\n\n\n@pytest.fixture\ndef broken_testdir(testdir):\n    testdir.makepyfile(\n        working_testfile=\"def test_proper(): assert 1\", broken_testfile=\"foobar\"\n    )\n    return testdir\n\n\ndef test_run_without_stepwise(stepwise_testdir):\n    result = stepwise_testdir.runpytest(\"-v\", \"--strict-markers\", \"--fail\")\n\n    result.stdout.fnmatch_lines([\"*test_success_before_fail PASSED*\"])\n    result.stdout.fnmatch_lines([\"*test_fail_on_flag FAILED*\"])\n    result.stdout.fnmatch_lines([\"*test_success_after_fail PASSED*\"])\n\n\ndef test_fail_and_continue_with_stepwise(stepwise_testdir):\n    # Run the tests with a failing second test.\n    result = stepwise_testdir.runpytest(\n        \"-v\", \"--strict-markers\", \"--stepwise\", \"--fail\"\n    )\n    assert not result.stderr.str()\n\n    stdout = result.stdout.str()\n    # Make sure we stop after first failing test.\n    assert \"test_success_before_fail PASSED\" in stdout\n    assert \"test_fail_on_flag FAILED\" in stdout\n    assert \"test_success_after_fail\" not in stdout\n\n    # \"Fix\" the test that failed in the last run and run it again.\n    result = stepwise_testdir.runpytest(\"-v\", \"--strict-markers\", \"--stepwise\")\n    assert not result.stderr.str()\n\n    stdout = result.stdout.str()\n    # Make sure the latest failing test runs and then continues.\n    assert \"test_success_before_fail\" not in stdout\n    assert \"test_fail_on_flag PASSED\" in stdout\n    assert \"test_success_after_fail PASSED\" in stdout", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal_TestTerminal.test_runtest_location_shown_before_test_starts": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal_TestTerminal.test_runtest_location_shown_before_test_starts", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 73, "end_line": 142, "span_ids": ["TestTerminal", "TestTerminal.test_internalerror", "TestTerminal.test_pass_skip_fail", "TestTerminal.test_runtest_location_shown_before_test_starts", "TestTerminal.test_show_runtest_logstart", "TestTerminal.test_writeline"], "tokens": 583}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminal:\n    def test_pass_skip_fail(self, testdir, option):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_ok():\n                pass\n            def test_skip():\n                pytest.skip(\"xx\")\n            def test_func():\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(*option.args)\n        if option.verbosity > 0:\n            result.stdout.fnmatch_lines(\n                [\n                    \"*test_pass_skip_fail.py::test_ok PASS*\",\n                    \"*test_pass_skip_fail.py::test_skip SKIP*\",\n                    \"*test_pass_skip_fail.py::test_func FAIL*\",\n                ]\n            )\n        elif option.verbosity == 0:\n            result.stdout.fnmatch_lines([\"*test_pass_skip_fail.py .sF*\"])\n        else:\n            result.stdout.fnmatch_lines([\".sF*\"])\n        result.stdout.fnmatch_lines(\n            [\"    def test_func():\", \">       assert 0\", \"E       assert 0\"]\n        )\n\n    def test_internalerror(self, testdir, linecomp):\n        modcol = testdir.getmodulecol(\"def test_one(): pass\")\n        rep = TerminalReporter(modcol.config, file=linecomp.stringio)\n        with pytest.raises(ValueError) as excinfo:\n            raise ValueError(\"hello\")\n        rep.pytest_internalerror(excinfo.getrepr())\n        linecomp.assert_contains_lines([\"INTERNALERROR> *ValueError*hello*\"])\n\n    def test_writeline(self, testdir, linecomp):\n        modcol = testdir.getmodulecol(\"def test_one(): pass\")\n        rep = TerminalReporter(modcol.config, file=linecomp.stringio)\n        rep.write_fspath_result(modcol.nodeid, \".\")\n        rep.write_line(\"hello world\")\n        lines = linecomp.stringio.getvalue().split(\"\\n\")\n        assert not lines[0]\n        assert lines[1].endswith(modcol.name + \" .\")\n        assert lines[2] == \"hello world\"\n\n    def test_show_runtest_logstart(self, testdir, linecomp):\n        item = testdir.getitem(\"def test_func(): pass\")\n        tr = TerminalReporter(item.config, file=linecomp.stringio)\n        item.config.pluginmanager.register(tr)\n        location = item.reportinfo()\n        tr.config.hook.pytest_runtest_logstart(\n            nodeid=item.nodeid, location=location, fspath=str(item.fspath)\n        )\n        linecomp.assert_contains_lines([\"*test_show_runtest_logstart.py*\"])\n\n    def test_runtest_location_shown_before_test_starts(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                import time\n                time.sleep(20)\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"\")\n        child.expect(\".*test_runtest_location.*py\")\n        child.sendeof()\n        child.kill(15)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestCollectonly_TestCollectonly.test_collectonly_more_quiet": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestCollectonly_TestCollectonly.test_collectonly_more_quiet", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 333, "end_line": 454, "span_ids": ["TestCollectonly", "TestCollectonly.test_collectonly_basic", "TestCollectonly.test_collectonly_displays_test_description", "TestCollectonly.test_collectonly_error", "TestCollectonly.test_collectonly_failed_module", "TestCollectonly.test_collectonly_fatal", "TestCollectonly.test_collectonly_missing_path", "TestCollectonly.test_collectonly_more_quiet", "TestCollectonly.test_collectonly_quiet", "TestCollectonly.test_collectonly_simple", "TestCollectonly.test_collectonly_skipped_module"], "tokens": 839}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCollectonly:\n    def test_collectonly_basic(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_func():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines(\n            [\"<Module test_collectonly_basic.py>\", \"  <Function test_func>\"]\n        )\n\n    def test_collectonly_skipped_module(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            pytest.skip(\"hello\")\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\", \"-rs\")\n        result.stdout.fnmatch_lines([\"*ERROR collecting*\"])\n\n    def test_collectonly_displays_test_description(\n        self, testdir: Testdir, dummy_yaml_custom_test\n    ) -> None:\n        \"\"\"Used dummy_yaml_custom_test for an Item without ``obj``.\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def test_with_description():\n                '''  This test has a description.\n\n                  more1.\n                    more2.'''\n            \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\", \"--verbose\")\n        result.stdout.fnmatch_lines(\n            [\n                \"<YamlFile test1.yaml>\",\n                \"  <YamlItem test1.yaml>\",\n                \"<Module test_collectonly_displays_test_description.py>\",\n                \"  <Function test_with_description>\",\n                \"    This test has a description.\",\n                \"    \",\n                \"    more1.\",\n                \"      more2.\",\n            ],\n            consecutive=True,\n        )\n\n    def test_collectonly_failed_module(self, testdir):\n        testdir.makepyfile(\"\"\"raise ValueError(0)\"\"\")\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*raise ValueError*\", \"*1 error*\"])\n\n    def test_collectonly_fatal(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_collectstart(collector):\n                assert 0, \"urgs\"\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*INTERNAL*args*\"])\n        assert result.ret == 3\n\n    def test_collectonly_simple(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_func1():\n                pass\n            class TestClass(object):\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\", p)\n        # assert stderr.startswith(\"inserting into sys.path\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines(\n            [\n                \"*<Module *.py>\",\n                \"* <Function test_func1>\",\n                \"* <Class TestClass>\",\n                \"*   <Function test_method>\",\n            ]\n        )\n\n    def test_collectonly_error(self, testdir):\n        p = testdir.makepyfile(\"import Errlkjqweqwe\")\n        result = testdir.runpytest(\"--collect-only\", p)\n        assert result.ret == 2\n        result.stdout.fnmatch_lines(\n            textwrap.dedent(\n                \"\"\"\\\n                *ERROR*\n                *ImportError*\n                *No module named *Errlk*\n                *1 error*\n                \"\"\"\n            ).strip()\n        )\n\n    def test_collectonly_missing_path(self, testdir):\n        \"\"\"this checks issue 115,\n            failure in parseargs will cause session\n            not to have the items attribute\n        \"\"\"\n        result = testdir.runpytest(\"--collect-only\", \"uhm_missing_path\")\n        assert result.ret == 4\n        result.stderr.fnmatch_lines([\"*ERROR: file not found*\"])\n\n    def test_collectonly_quiet(self, testdir):\n        testdir.makepyfile(\"def test_foo(): pass\")\n        result = testdir.runpytest(\"--collect-only\", \"-q\")\n        result.stdout.fnmatch_lines([\"*test_foo*\"])\n\n    def test_collectonly_more_quiet(self, testdir):\n        testdir.makepyfile(test_fun=\"def test_foo(): pass\")\n        result = testdir.runpytest(\"--collect-only\", \"-qq\")\n        result.stdout.fnmatch_lines([\"*test_fun.py: 1*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestFixtureReporting_TestFixtureReporting.test_setup_teardown_output_and_test_failure.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestFixtureReporting_TestFixtureReporting.test_setup_teardown_output_and_test_failure.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 388, "end_line": 485, "span_ids": ["TestFixtureReporting", "TestFixtureReporting.test_setup_fixture_error", "TestFixtureReporting.test_setup_teardown_output_and_test_failure", "TestFixtureReporting.test_teardown_fixture_error", "TestFixtureReporting.test_teardown_fixture_error_and_test_failure"], "tokens": 533}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureReporting:\n    def test_setup_fixture_error(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def setup_function(function):\n                print(\"setup func\")\n                assert 0\n            def test_nada():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*ERROR at setup of test_nada*\",\n                \"*setup_function(function):*\",\n                \"*setup func*\",\n                \"*assert 0*\",\n                \"*1 error*\",\n            ]\n        )\n        assert result.ret != 0\n\n    def test_teardown_fixture_error(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_nada():\n                pass\n            def teardown_function(function):\n                print(\"teardown func\")\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*ERROR at teardown*\",\n                \"*teardown_function(function):*\",\n                \"*assert 0*\",\n                \"*Captured stdout*\",\n                \"*teardown func*\",\n                \"*1 passed*1 error*\",\n            ]\n        )\n\n    def test_teardown_fixture_error_and_test_failure(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_fail():\n                assert 0, \"failingfunc\"\n\n            def teardown_function(function):\n                print(\"teardown func\")\n                assert False\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*ERROR at teardown of test_fail*\",\n                \"*teardown_function(function):*\",\n                \"*assert False*\",\n                \"*Captured stdout*\",\n                \"*teardown func*\",\n                \"*test_fail*\",\n                \"*def test_fail():\",\n                \"*failingfunc*\",\n                \"*1 failed*1 error*\",\n            ]\n        )\n\n    def test_setup_teardown_output_and_test_failure(self, testdir):\n        \"\"\" Test for issue #442 \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def setup_function(function):\n                print(\"setup func\")\n\n            def test_fail():\n                assert 0, \"failingfunc\"\n\n            def teardown_function(function):\n                print(\"teardown func\")\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_fail*\",\n                \"*def test_fail():\",\n                \"*failingfunc*\",\n                \"*Captured stdout setup*\",\n                \"*setup func*\",\n                \"*Captured stdout teardown*\",\n                \"*teardown func*\",\n                \"*1 failed*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional_TestTerminalFunctional.test_passes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional_TestTerminalFunctional.test_passes", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 557, "end_line": 666, "span_ids": ["TestTerminalFunctional", "TestTerminalFunctional.test_deselected", "TestTerminalFunctional.test_deselected_with_hookwrapper", "TestTerminalFunctional.test_no_skip_summary_if_failure", "TestTerminalFunctional.test_passes", "TestTerminalFunctional.test_show_deselected_items_using_markexpr_before_test_execution"], "tokens": 652}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminalFunctional:\n    def test_deselected(self, testdir):\n        testpath = testdir.makepyfile(\n            \"\"\"\n                def test_one():\n                    pass\n                def test_two():\n                    pass\n                def test_three():\n                    pass\n           \"\"\"\n        )\n        result = testdir.runpytest(\"-k\", \"test_two:\", testpath)\n        result.stdout.fnmatch_lines(\n            [\"collected 3 items / 1 deselected / 2 selected\", \"*test_deselected.py ..*\"]\n        )\n        assert result.ret == 0\n\n    def test_deselected_with_hookwrapper(self, testdir):\n        testpath = testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.hookimpl(hookwrapper=True)\n            def pytest_collection_modifyitems(config, items):\n                yield\n                deselected = items.pop()\n                config.hook.pytest_deselected(items=[deselected])\n            \"\"\"\n        )\n        testpath = testdir.makepyfile(\n            \"\"\"\n                def test_one():\n                    pass\n                def test_two():\n                    pass\n                def test_three():\n                    pass\n           \"\"\"\n        )\n        result = testdir.runpytest(testpath)\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 3 items / 1 deselected / 2 selected\",\n                \"*= 2 passed, 1 deselected in*\",\n            ]\n        )\n        assert result.ret == 0\n\n    def test_show_deselected_items_using_markexpr_before_test_execution(self, testdir):\n        testdir.makepyfile(\n            test_show_deselected=\"\"\"\n            import pytest\n\n            @pytest.mark.foo\n            def test_foobar():\n                pass\n\n            @pytest.mark.bar\n            def test_bar():\n                pass\n\n            def test_pass():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-m\", \"not foo\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 3 items / 1 deselected / 2 selected\",\n                \"*test_show_deselected.py ..*\",\n                \"*= 2 passed, 1 deselected in * =*\",\n            ]\n        )\n        result.stdout.no_fnmatch_line(\"*= 1 deselected =*\")\n        assert result.ret == 0\n\n    def test_no_skip_summary_if_failure(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_ok():\n                pass\n            def test_fail():\n                assert 0\n            def test_skip():\n                pytest.skip(\"dontshow\")\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.stdout.str().find(\"skip test summary\") == -1\n        assert result.ret == 1\n\n    def test_passes(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_passes():\n                pass\n            class TestClass(object):\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        old = p1.dirpath().chdir()\n        try:\n            result = testdir.runpytest()\n        finally:\n            old.chdir()\n        result.stdout.fnmatch_lines([\"test_passes.py ..*\", \"* 2 pass*\"])\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_header_trailer_info_TestTerminalFunctional.test_header.None_7": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_header_trailer_info_TestTerminalFunctional.test_header.None_7", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 668, "end_line": 723, "span_ids": ["TestTerminalFunctional.test_header", "TestTerminalFunctional.test_header_trailer_info"], "tokens": 418}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminalFunctional:\n\n    def test_header_trailer_info(self, testdir, request):\n        testdir.monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n        testdir.makepyfile(\n            \"\"\"\n            def test_passes():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        verinfo = \".\".join(map(str, sys.version_info[:3]))\n        result.stdout.fnmatch_lines(\n            [\n                \"*===== test session starts ====*\",\n                \"platform %s -- Python %s*pytest-%s*py-%s*pluggy-%s\"\n                % (\n                    sys.platform,\n                    verinfo,\n                    pytest.__version__,\n                    py.__version__,\n                    pluggy.__version__,\n                ),\n                \"*test_header_trailer_info.py .*\",\n                \"=* 1 passed*in *.[0-9][0-9]s *=\",\n            ]\n        )\n        if request.config.pluginmanager.list_plugin_distinfo():\n            result.stdout.fnmatch_lines([\"plugins: *\"])\n\n    def test_header(self, testdir):\n        testdir.tmpdir.join(\"tests\").ensure_dir()\n        testdir.tmpdir.join(\"gui\").ensure_dir()\n\n        # no ini file\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"rootdir: *test_header0\"])\n\n        # with inifile\n        testdir.makeini(\"\"\"[pytest]\"\"\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"rootdir: *test_header0, inifile: tox.ini\"])\n\n        # with testpaths option, and not passing anything in the command-line\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            testpaths = tests gui\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\"rootdir: *test_header0, inifile: tox.ini, testpaths: tests, gui\"]\n        )\n\n        # with testpaths option, passing directory in command-line: do not show testpaths then\n        result = testdir.runpytest(\"tests\")\n        result.stdout.fnmatch_lines([\"rootdir: *test_header0, inifile: tox.ini\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_fail_extra_reporting_test_pass_reporting_on_fail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_fail_extra_reporting_test_pass_reporting_on_fail", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 878, "end_line": 909, "span_ids": ["test_fail_extra_reporting", "test_fail_reporting_on_pass", "test_pass_extra_reporting", "test_pass_reporting_on_fail"], "tokens": 283}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fail_extra_reporting(testdir, monkeypatch):\n    monkeypatch.setenv(\"COLUMNS\", \"80\")\n    testdir.makepyfile(\"def test_this(): assert 0, 'this_failed' * 100\")\n    result = testdir.runpytest(\"-rN\")\n    result.stdout.no_fnmatch_line(\"*short test summary*\")\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*test summary*\",\n            \"FAILED test_fail_extra_reporting.py::test_this - AssertionError: this_failedt...\",\n        ]\n    )\n\n\ndef test_fail_reporting_on_pass(testdir):\n    testdir.makepyfile(\"def test_this(): assert 1\")\n    result = testdir.runpytest(\"-rf\")\n    result.stdout.no_fnmatch_line(\"*short test summary*\")\n\n\ndef test_pass_extra_reporting(testdir):\n    testdir.makepyfile(\"def test_this(): assert 1\")\n    result = testdir.runpytest()\n    result.stdout.no_fnmatch_line(\"*short test summary*\")\n    result = testdir.runpytest(\"-rp\")\n    result.stdout.fnmatch_lines([\"*test summary*\", \"PASS*test_pass_extra_reporting*\"])\n\n\ndef test_pass_reporting_on_fail(testdir):\n    testdir.makepyfile(\"def test_this(): assert 0\")\n    result = testdir.runpytest(\"-rp\")\n    result.stdout.no_fnmatch_line(\"*short test summary*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_pass_output_reporting_test_pass_output_reporting.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_pass_output_reporting_test_pass_output_reporting.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 912, "end_line": 949, "span_ids": ["test_pass_output_reporting"], "tokens": 255}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_pass_output_reporting(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def setup_module():\n            print(\"setup_module\")\n\n        def teardown_module():\n            print(\"teardown_module\")\n\n        def test_pass_has_output():\n            print(\"Four score and seven years ago...\")\n\n        def test_pass_no_output():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    s = result.stdout.str()\n    assert \"test_pass_has_output\" not in s\n    assert \"Four score and seven years ago...\" not in s\n    assert \"test_pass_no_output\" not in s\n    result = testdir.runpytest(\"-rPp\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*= PASSES =*\",\n            \"*_ test_pass_has_output _*\",\n            \"*- Captured stdout setup -*\",\n            \"setup_module\",\n            \"*- Captured stdout call -*\",\n            \"Four score and seven years ago...\",\n            \"*- Captured stdout teardown -*\",\n            \"teardown_module\",\n            \"*= short test summary info =*\",\n            \"PASSED test_pass_output_reporting.py::test_pass_has_output\",\n            \"PASSED test_pass_output_reporting.py::test_pass_no_output\",\n            \"*= 2 passed in *\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_terminalreporter_reportopt_addopts_test_traceconfig": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_terminalreporter_reportopt_addopts_test_traceconfig", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1103, "end_line": 1149, "span_ids": ["test_tbstyle_short", "test_terminalreporter_reportopt_addopts", "test_traceconfig"], "tokens": 321}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_terminalreporter_reportopt_addopts(testdir):\n    testdir.makeini(\"[pytest]\\naddopts=-rs\")\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture\n        def tr(request):\n            tr = request.config.pluginmanager.getplugin(\"terminalreporter\")\n            return tr\n        def test_opt(tr):\n            assert tr.hasopt('skipped')\n            assert not tr.hasopt('qwe')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_tbstyle_short(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture\n        def arg(request):\n            return 42\n        def test_opt(arg):\n            x = 0\n            assert x\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--tb=short\")\n    s = result.stdout.str()\n    assert \"arg = 42\" not in s\n    assert \"x = 0\" not in s\n    result.stdout.fnmatch_lines([\"*%s:8*\" % p.basename, \"    assert x\", \"E   assert*\"])\n    result = testdir.runpytest()\n    s = result.stdout.str()\n    assert \"x = 0\" in s\n    assert \"assert x\" in s\n\n\ndef test_traceconfig(testdir):\n    result = testdir.runpytest(\"--traceconfig\")\n    result.stdout.fnmatch_lines([\"*active plugins*\"])\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_tb_crashline_TestGenericReporting.test_pytest_report_header": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_tb_crashline_TestGenericReporting.test_pytest_report_header", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 998, "end_line": 1035, "span_ids": ["TestGenericReporting.test_pytest_report_header", "TestGenericReporting.test_tb_crashline"], "tokens": 283}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGenericReporting:\n\n    def test_tb_crashline(self, testdir, option):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def g():\n                raise IndexError\n            def test_func1():\n                print(6*7)\n                g()  # --calling--\n            def test_func2():\n                assert 0, \"hello\"\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--tb=line\")\n        bn = p.basename\n        result.stdout.fnmatch_lines(\n            [\"*%s:3: IndexError*\" % bn, \"*%s:8: AssertionError: hello*\" % bn]\n        )\n        s = result.stdout.str()\n        assert \"def test_func2\" not in s\n\n    def test_pytest_report_header(self, testdir, option):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_sessionstart(session):\n                session.config._somevalue = 42\n            def pytest_report_header(config):\n                return \"hello: %s\" % config._somevalue\n        \"\"\"\n        )\n        testdir.mkdir(\"a\").join(\"conftest.py\").write(\n            \"\"\"\ndef pytest_report_header(config, startdir):\n    return [\"line1\", str(startdir)]\n\"\"\"\n        )\n        result = testdir.runpytest(\"a\")\n        result.stdout.fnmatch_lines([\"*hello: 42*\", \"line1\", str(testdir.tmpdir)])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_show_capture_TestGenericReporting.test_show_capture.None_11": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_show_capture_TestGenericReporting.test_show_capture.None_11", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1037, "end_line": 1086, "span_ids": ["TestGenericReporting.test_show_capture"], "tokens": 373}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGenericReporting:\n\n    def test_show_capture(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            import logging\n            def test_one():\n                sys.stdout.write('!This is stdout!')\n                sys.stderr.write('!This is stderr!')\n                logging.warning('!This is a warning log msg!')\n                assert False, 'Something failed'\n        \"\"\"\n        )\n\n        result = testdir.runpytest(\"--tb=short\")\n        result.stdout.fnmatch_lines(\n            [\n                \"!This is stdout!\",\n                \"!This is stderr!\",\n                \"*WARNING*!This is a warning log msg!\",\n            ]\n        )\n\n        result = testdir.runpytest(\"--show-capture=all\", \"--tb=short\")\n        result.stdout.fnmatch_lines(\n            [\n                \"!This is stdout!\",\n                \"!This is stderr!\",\n                \"*WARNING*!This is a warning log msg!\",\n            ]\n        )\n\n        stdout = testdir.runpytest(\"--show-capture=stdout\", \"--tb=short\").stdout.str()\n        assert \"!This is stderr!\" not in stdout\n        assert \"!This is stdout!\" in stdout\n        assert \"!This is a warning log msg!\" not in stdout\n\n        stdout = testdir.runpytest(\"--show-capture=stderr\", \"--tb=short\").stdout.str()\n        assert \"!This is stdout!\" not in stdout\n        assert \"!This is stderr!\" in stdout\n        assert \"!This is a warning log msg!\" not in stdout\n\n        stdout = testdir.runpytest(\"--show-capture=log\", \"--tb=short\").stdout.str()\n        assert \"!This is stdout!\" not in stdout\n        assert \"!This is stderr!\" not in stdout\n        assert \"!This is a warning log msg!\" in stdout\n\n        stdout = testdir.runpytest(\"--show-capture=no\", \"--tb=short\").stdout.str()\n        assert \"!This is stdout!\" not in stdout\n        assert \"!This is stderr!\" not in stdout\n        assert \"!This is a warning log msg!\" not in stdout", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_show_capture_with_teardown_logs_TestGenericReporting.test_show_capture_with_teardown_logs.None_11": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_show_capture_with_teardown_logs_TestGenericReporting.test_show_capture_with_teardown_logs.None_11", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1088, "end_line": 1126, "span_ids": ["TestGenericReporting.test_show_capture_with_teardown_logs"], "tokens": 267}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGenericReporting:\n\n    def test_show_capture_with_teardown_logs(self, testdir):\n        \"\"\"Ensure that the capturing of teardown logs honor --show-capture setting\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import logging\n            import sys\n            import pytest\n\n            @pytest.fixture(scope=\"function\", autouse=\"True\")\n            def hook_each_test(request):\n                yield\n                sys.stdout.write(\"!stdout!\")\n                sys.stderr.write(\"!stderr!\")\n                logging.warning(\"!log!\")\n\n            def test_func():\n                assert False\n        \"\"\"\n        )\n\n        result = testdir.runpytest(\"--show-capture=stdout\", \"--tb=short\").stdout.str()\n        assert \"!stdout!\" in result\n        assert \"!stderr!\" not in result\n        assert \"!log!\" not in result\n\n        result = testdir.runpytest(\"--show-capture=stderr\", \"--tb=short\").stdout.str()\n        assert \"!stdout!\" not in result\n        assert \"!stderr!\" in result\n        assert \"!log!\" not in result\n\n        result = testdir.runpytest(\"--show-capture=log\", \"--tb=short\").stdout.str()\n        assert \"!stdout!\" not in result\n        assert \"!stderr!\" not in result\n        assert \"!log!\" in result\n\n        result = testdir.runpytest(\"--show-capture=no\", \"--tb=short\").stdout.str()\n        assert \"!stdout!\" not in result\n        assert \"!stderr!\" not in result\n        assert \"!log!\" not in result", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_fdopen_kept_alive_issue124_test_terminal_summary": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_fdopen_kept_alive_issue124_test_terminal_summary", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1134, "end_line": 1188, "span_ids": ["test_fdopen_kept_alive_issue124", "test_tbstyle_native_setup_error", "test_terminal_summary"], "tokens": 322}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.xfail(\"not hasattr(os, 'dup')\")\ndef test_fdopen_kept_alive_issue124(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import os, sys\n        k = []\n        def test_open_file_and_keep_alive(capfd):\n            stdout = os.fdopen(1, 'w', 1)\n            k.append(stdout)\n\n        def test_close_kept_alive_file():\n            stdout = k.pop()\n            stdout.close()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n\ndef test_tbstyle_native_setup_error(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture\n        def setup_error_fixture():\n            raise Exception(\"error in exception\")\n\n        def test_error_fixture(setup_error_fixture):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--tb=native\")\n    result.stdout.fnmatch_lines(\n        ['*File *test_tbstyle_native_setup_error.py\", line *, in setup_error_fixture*']\n    )\n\n\ndef test_terminal_summary(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_terminal_summary(terminalreporter, exitstatus):\n            w = terminalreporter\n            w.section(\"hello\")\n            w.line(\"world\")\n            w.line(\"exitstatus: {0}\".format(exitstatus))\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *==== hello ====*\n        world\n        exitstatus: 5\n    \"\"\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_summary_stats_test_summary_stats.assert_color_exp_color": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_summary_stats_test_summary_stats.assert_color_exp_color", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1487, "end_line": 1640, "span_ids": ["test_summary_stats"], "tokens": 1397}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"exp_color, exp_line, stats_arg\",\n    [\n        # The method under test only cares about the length of each\n        # dict value, not the actual contents, so tuples of anything\n        # suffice\n        # Important statuses -- the highest priority of these always wins\n        (\"red\", [(\"1 failed\", {\"bold\": True, \"red\": True})], {\"failed\": (1,)}),\n        (\n            \"red\",\n            [\n                (\"1 failed\", {\"bold\": True, \"red\": True}),\n                (\"1 passed\", {\"bold\": False, \"green\": True}),\n            ],\n            {\"failed\": (1,), \"passed\": (1,)},\n        ),\n        (\"red\", [(\"1 error\", {\"bold\": True, \"red\": True})], {\"error\": (1,)}),\n        (\"red\", [(\"2 errors\", {\"bold\": True, \"red\": True})], {\"error\": (1, 2)}),\n        (\n            \"red\",\n            [\n                (\"1 passed\", {\"bold\": False, \"green\": True}),\n                (\"1 error\", {\"bold\": True, \"red\": True}),\n            ],\n            {\"error\": (1,), \"passed\": (1,)},\n        ),\n        # (a status that's not known to the code)\n        (\"yellow\", [(\"1 weird\", {\"bold\": True, \"yellow\": True})], {\"weird\": (1,)}),\n        (\n            \"yellow\",\n            [\n                (\"1 passed\", {\"bold\": False, \"green\": True}),\n                (\"1 weird\", {\"bold\": True, \"yellow\": True}),\n            ],\n            {\"weird\": (1,), \"passed\": (1,)},\n        ),\n        (\"yellow\", [(\"1 warning\", {\"bold\": True, \"yellow\": True})], {\"warnings\": (1,)}),\n        (\n            \"yellow\",\n            [\n                (\"1 passed\", {\"bold\": False, \"green\": True}),\n                (\"1 warning\", {\"bold\": True, \"yellow\": True}),\n            ],\n            {\"warnings\": (1,), \"passed\": (1,)},\n        ),\n        (\n            \"green\",\n            [(\"5 passed\", {\"bold\": True, \"green\": True})],\n            {\"passed\": (1, 2, 3, 4, 5)},\n        ),\n        # \"Boring\" statuses.  These have no effect on the color of the summary\n        # line.  Thus, if *every* test has a boring status, the summary line stays\n        # at its default color, i.e. yellow, to warn the user that the test run\n        # produced no useful information\n        (\"yellow\", [(\"1 skipped\", {\"bold\": True, \"yellow\": True})], {\"skipped\": (1,)}),\n        (\n            \"green\",\n            [\n                (\"1 passed\", {\"bold\": True, \"green\": True}),\n                (\"1 skipped\", {\"bold\": False, \"yellow\": True}),\n            ],\n            {\"skipped\": (1,), \"passed\": (1,)},\n        ),\n        (\n            \"yellow\",\n            [(\"1 deselected\", {\"bold\": True, \"yellow\": True})],\n            {\"deselected\": (1,)},\n        ),\n        (\n            \"green\",\n            [\n                (\"1 passed\", {\"bold\": True, \"green\": True}),\n                (\"1 deselected\", {\"bold\": False, \"yellow\": True}),\n            ],\n            {\"deselected\": (1,), \"passed\": (1,)},\n        ),\n        (\"yellow\", [(\"1 xfailed\", {\"bold\": True, \"yellow\": True})], {\"xfailed\": (1,)}),\n        (\n            \"green\",\n            [\n                (\"1 passed\", {\"bold\": True, \"green\": True}),\n                (\"1 xfailed\", {\"bold\": False, \"yellow\": True}),\n            ],\n            {\"xfailed\": (1,), \"passed\": (1,)},\n        ),\n        (\"yellow\", [(\"1 xpassed\", {\"bold\": True, \"yellow\": True})], {\"xpassed\": (1,)}),\n        (\n            \"yellow\",\n            [\n                (\"1 passed\", {\"bold\": False, \"green\": True}),\n                (\"1 xpassed\", {\"bold\": True, \"yellow\": True}),\n            ],\n            {\"xpassed\": (1,), \"passed\": (1,)},\n        ),\n        # Likewise if no tests were found at all\n        (\"yellow\", [(\"no tests ran\", {\"yellow\": True})], {}),\n        # Test the empty-key special case\n        (\"yellow\", [(\"no tests ran\", {\"yellow\": True})], {\"\": (1,)}),\n        (\n            \"green\",\n            [(\"1 passed\", {\"bold\": True, \"green\": True})],\n            {\"\": (1,), \"passed\": (1,)},\n        ),\n        # A couple more complex combinations\n        (\n            \"red\",\n            [\n                (\"1 failed\", {\"bold\": True, \"red\": True}),\n                (\"2 passed\", {\"bold\": False, \"green\": True}),\n                (\"3 xfailed\", {\"bold\": False, \"yellow\": True}),\n            ],\n            {\"passed\": (1, 2), \"failed\": (1,), \"xfailed\": (1, 2, 3)},\n        ),\n        (\n            \"green\",\n            [\n                (\"1 passed\", {\"bold\": True, \"green\": True}),\n                (\"2 skipped\", {\"bold\": False, \"yellow\": True}),\n                (\"3 deselected\", {\"bold\": False, \"yellow\": True}),\n                (\"2 xfailed\", {\"bold\": False, \"yellow\": True}),\n            ],\n            {\n                \"passed\": (1,),\n                \"skipped\": (1, 2),\n                \"deselected\": (1, 2, 3),\n                \"xfailed\": (1, 2),\n            },\n        ),\n    ],\n)\ndef test_summary_stats(\n    tr: TerminalReporter,\n    exp_line: List[Tuple[str, Dict[str, bool]]],\n    exp_color: str,\n    stats_arg: Dict[str, List],\n) -> None:\n    tr.stats = stats_arg\n\n    # Fake \"_is_last_item\" to be True.\n    class fake_session:\n        testscollected = 0\n\n    tr._session = fake_session  # type: ignore[assignment]  # noqa: F821\n    assert tr._is_last_item\n\n    # Reset cache.\n    tr._main_color = None\n\n    print(\"Based on stats: %s\" % stats_arg)\n    print('Expect summary: \"{}\"; with color \"{}\"'.format(exp_line, exp_color))\n    (line, color) = tr.build_summary_stats_line()\n    print('Actually got:   \"{}\"; with color \"{}\"'.format(line, color))\n    assert line == exp_line\n    assert color == exp_color", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_skip_counting_towards_summary_TestClassicOutputStyle.test_quiet": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_skip_counting_towards_summary_TestClassicOutputStyle.test_quiet", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1643, "end_line": 1704, "span_ids": ["TestClassicOutputStyle", "TestClassicOutputStyle.test_files", "TestClassicOutputStyle.test_normal_verbosity", "TestClassicOutputStyle.test_quiet", "TestClassicOutputStyle.test_verbose", "test_skip_counting_towards_summary"], "tokens": 537}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_skip_counting_towards_summary(tr):\n    class DummyReport(BaseReport):\n        count_towards_summary = True\n\n    r1 = DummyReport()\n    r2 = DummyReport()\n    tr.stats = {\"failed\": (r1, r2)}\n    tr._main_color = None\n    res = tr.build_summary_stats_line()\n    assert res == ([(\"2 failed\", {\"bold\": True, \"red\": True})], \"red\")\n\n    r1.count_towards_summary = False\n    tr.stats = {\"failed\": (r1, r2)}\n    tr._main_color = None\n    res = tr.build_summary_stats_line()\n    assert res == ([(\"1 failed\", {\"bold\": True, \"red\": True})], \"red\")\n\n\nclass TestClassicOutputStyle:\n    \"\"\"Ensure classic output style works as expected (#3883)\"\"\"\n\n    @pytest.fixture\n    def test_files(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"test_one.py\": \"def test_one(): pass\",\n                \"test_two.py\": \"def test_two(): assert 0\",\n                \"sub/test_three.py\": \"\"\"\n                    def test_three_1(): pass\n                    def test_three_2(): assert 0\n                    def test_three_3(): pass\n                \"\"\",\n            }\n        )\n\n    def test_normal_verbosity(self, testdir, test_files):\n        result = testdir.runpytest(\"-o\", \"console_output_style=classic\")\n        result.stdout.fnmatch_lines(\n            [\n                \"test_one.py .\",\n                \"test_two.py F\",\n                \"sub{}test_three.py .F.\".format(os.sep),\n                \"*2 failed, 3 passed in*\",\n            ]\n        )\n\n    def test_verbose(self, testdir, test_files):\n        result = testdir.runpytest(\"-o\", \"console_output_style=classic\", \"-v\")\n        result.stdout.fnmatch_lines(\n            [\n                \"test_one.py::test_one PASSED\",\n                \"test_two.py::test_two FAILED\",\n                \"sub{}test_three.py::test_three_1 PASSED\".format(os.sep),\n                \"sub{}test_three.py::test_three_2 FAILED\".format(os.sep),\n                \"sub{}test_three.py::test_three_3 PASSED\".format(os.sep),\n                \"*2 failed, 3 passed in*\",\n            ]\n        )\n\n    def test_quiet(self, testdir, test_files):\n        result = testdir.runpytest(\"-o\", \"console_output_style=classic\", \"-q\")\n        result.stdout.fnmatch_lines([\".F.F.\", \"*2 failed, 3 passed in*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressWithTeardown_test_skip_reasons_folding.assert_reason_message": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressWithTeardown_test_skip_reasons_folding.assert_reason_message", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1904, "end_line": 2026, "span_ids": ["TestProgressWithTeardown", "TestProgressWithTeardown.contest_with_teardown_fixture", "TestProgressWithTeardown.many_files", "TestProgressWithTeardown.test_teardown_many", "TestProgressWithTeardown.test_teardown_many_verbose", "TestProgressWithTeardown.test_teardown_simple", "TestProgressWithTeardown.test_teardown_with_test_also_failing", "TestProgressWithTeardown.test_xdist_normal", "test_skip_reasons_folding"], "tokens": 892}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestProgressWithTeardown:\n    \"\"\"Ensure we show the correct percentages for tests that fail during teardown (#3088)\"\"\"\n\n    @pytest.fixture\n    def contest_with_teardown_fixture(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def fail_teardown():\n                yield\n                assert False\n        \"\"\"\n        )\n\n    @pytest.fixture\n    def many_files(self, testdir, contest_with_teardown_fixture):\n        testdir.makepyfile(\n            test_bar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(5))\n                def test_bar(fail_teardown, i):\n                    pass\n            \"\"\",\n            test_foo=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(15))\n                def test_foo(fail_teardown, i):\n                    pass\n            \"\"\",\n        )\n\n    def test_teardown_simple(self, testdir, contest_with_teardown_fixture):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo(fail_teardown):\n                pass\n        \"\"\"\n        )\n        output = testdir.runpytest()\n        output.stdout.re_match_lines([r\"test_teardown_simple.py \\.E\\s+\\[100%\\]\"])\n\n    def test_teardown_with_test_also_failing(\n        self, testdir, contest_with_teardown_fixture\n    ):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo(fail_teardown):\n                assert 0\n        \"\"\"\n        )\n        output = testdir.runpytest(\"-rfE\")\n        output.stdout.re_match_lines(\n            [\n                r\"test_teardown_with_test_also_failing.py FE\\s+\\[100%\\]\",\n                \"FAILED test_teardown_with_test_also_failing.py::test_foo - assert 0\",\n                \"ERROR test_teardown_with_test_also_failing.py::test_foo - assert False\",\n            ]\n        )\n\n    def test_teardown_many(self, testdir, many_files):\n        output = testdir.runpytest()\n        output.stdout.re_match_lines(\n            [r\"test_bar.py (\\.E){5}\\s+\\[ 25%\\]\", r\"test_foo.py (\\.E){15}\\s+\\[100%\\]\"]\n        )\n\n    def test_teardown_many_verbose(\n        self, testdir: Testdir, many_files, color_mapping\n    ) -> None:\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            color_mapping.format_for_fnmatch(\n                [\n                    \"test_bar.py::test_bar[0] PASSED  * [  5%]\",\n                    \"test_bar.py::test_bar[0] ERROR   * [  5%]\",\n                    \"test_bar.py::test_bar[4] PASSED  * [ 25%]\",\n                    \"test_foo.py::test_foo[14] PASSED * [100%]\",\n                    \"test_foo.py::test_foo[14] ERROR  * [100%]\",\n                    \"=* 20 passed, 20 errors in *\",\n                ]\n            )\n        )\n\n    def test_xdist_normal(self, many_files, testdir, monkeypatch):\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        output = testdir.runpytest(\"-n2\")\n        output.stdout.re_match_lines([r\"[\\.E]{40} \\s+ \\[100%\\]\"])\n\n\ndef test_skip_reasons_folding():\n    path = \"xyz\"\n    lineno = 3\n    message = \"justso\"\n    longrepr = (path, lineno, message)\n\n    class X:\n        pass\n\n    ev1 = X()\n    ev1.when = \"execute\"\n    ev1.skipped = True\n    ev1.longrepr = longrepr\n\n    ev2 = X()\n    ev2.when = \"execute\"\n    ev2.longrepr = longrepr\n    ev2.skipped = True\n\n    # ev3 might be a collection report\n    ev3 = X()\n    ev3.when = \"collect\"\n    ev3.longrepr = longrepr\n    ev3.skipped = True\n\n    values = _folded_skips(py.path.local(), [ev1, ev2, ev3])\n    assert len(values) == 1\n    num, fspath, lineno, reason = values[0]\n    assert num == 3\n    assert fspath == path\n    assert lineno == lineno\n    assert reason == message", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_custom_exception_info_test_testcase_custom_exception_info.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_custom_exception_info_test_testcase_custom_exception_info.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 329, "end_line": 363, "span_ids": ["test_testcase_custom_exception_info"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"type\", [\"Error\", \"Failure\"])\ndef test_testcase_custom_exception_info(testdir, type):\n    testdir.makepyfile(\n        \"\"\"\n        from unittest import TestCase\n        import py, pytest\n        import _pytest._code\n        class MyTestCase(TestCase):\n            def run(self, result):\n                excinfo = pytest.raises(ZeroDivisionError, lambda: 0/0)\n                # we fake an incompatible exception info\n                from _pytest.monkeypatch import MonkeyPatch\n                mp = MonkeyPatch()\n                def t(*args):\n                    mp.undo()\n                    raise TypeError()\n                mp.setattr(_pytest._code, 'ExceptionInfo', t)\n                try:\n                    excinfo = excinfo._excinfo\n                    result.add%(type)s(self, excinfo)\n                finally:\n                    mp.undo()\n            def test_hello(self):\n                pass\n    \"\"\"\n        % locals()\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"NOTE: Incompatible Exception Representation*\",\n            \"*ZeroDivisionError*\",\n            \"*1 failed*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_totally_incompatible_exception_info_TestTrialUnittest.test_trial_testcase_runtest_not_collected": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_totally_incompatible_exception_info_TestTrialUnittest.test_trial_testcase_runtest_not_collected", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 385, "end_line": 443, "span_ids": ["TestTrialUnittest", "TestTrialUnittest.setup_class", "TestTrialUnittest.test_trial_testcase_runtest_not_collected", "test_module_level_pytestmark", "test_testcase_totally_incompatible_exception_info"], "tokens": 390}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_testcase_totally_incompatible_exception_info(testdir):\n    (item,) = testdir.getitems(\n        \"\"\"\n        from unittest import TestCase\n        class MyTestCase(TestCase):\n            def test_hello(self):\n                pass\n    \"\"\"\n    )\n    item.addError(None, 42)\n    excinfo = item._excinfo.pop(0)\n    assert \"ERROR: Unknown Incompatible\" in str(excinfo.getrepr())\n\n\ndef test_module_level_pytestmark(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        import pytest\n        pytestmark = pytest.mark.xfail\n        class MyTestCase(unittest.TestCase):\n            def test_func1(self):\n                assert 0\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath, \"-s\")\n    reprec.assertoutcome(skipped=1)\n\n\nclass TestTrialUnittest:\n    def setup_class(cls):\n        cls.ut = pytest.importorskip(\"twisted.trial.unittest\")\n        # on windows trial uses a socket for a reactor and apparently doesn't close it properly\n        # https://twistedmatrix.com/trac/ticket/9227\n        cls.ignore_unclosed_socket_warning = (\"-W\", \"always\")\n\n    def test_trial_testcase_runtest_not_collected(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            from twisted.trial.unittest import TestCase\n\n            class TC(TestCase):\n                def test_hello(self):\n                    pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(*self.ignore_unclosed_socket_warning)\n        reprec.assertoutcome(passed=1)\n        testdir.makepyfile(\n            \"\"\"\n            from twisted.trial.unittest import TestCase\n\n            class TC(TestCase):\n                def runTest(self):\n                    pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(*self.ignore_unclosed_socket_warning)\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_error_TestTrialUnittest.test_trial_error.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_error_TestTrialUnittest.test_trial_error.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 495, "end_line": 559, "span_ids": ["TestTrialUnittest.test_trial_error"], "tokens": 451}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTrialUnittest:\n\n    def test_trial_error(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            from twisted.trial.unittest import TestCase\n            from twisted.internet.defer import Deferred\n            from twisted.internet import reactor\n\n            class TC(TestCase):\n                def test_one(self):\n                    crash\n\n                def test_two(self):\n                    def f(_):\n                        crash\n\n                    d = Deferred()\n                    d.addCallback(f)\n                    reactor.callLater(0.3, d.callback, None)\n                    return d\n\n                def test_three(self):\n                    def f():\n                        pass # will never get called\n                    reactor.callLater(0.3, f)\n                # will crash at teardown\n\n                def test_four(self):\n                    def f(_):\n                        reactor.callLater(0.3, f)\n                        crash\n\n                    d = Deferred()\n                    d.addCallback(f)\n                    reactor.callLater(0.3, d.callback, None)\n                    return d\n                # will crash both at test time and at teardown\n        \"\"\"\n        )\n        # Ignore DeprecationWarning (for `cmp`) from attrs through twisted,\n        # for stable test results.\n        result = testdir.runpytest(\n            \"-vv\", \"-oconsole_output_style=classic\", \"-W\", \"ignore::DeprecationWarning\"\n        )\n        result.stdout.fnmatch_lines(\n            [\n                \"test_trial_error.py::TC::test_four FAILED\",\n                \"test_trial_error.py::TC::test_four ERROR\",\n                \"test_trial_error.py::TC::test_one FAILED\",\n                \"test_trial_error.py::TC::test_three FAILED\",\n                \"test_trial_error.py::TC::test_two FAILED\",\n                \"*ERRORS*\",\n                \"*_ ERROR at teardown of TC.test_four _*\",\n                \"*DelayedCalls*\",\n                \"*= FAILURES =*\",\n                \"*_ TC.test_four _*\",\n                \"*NameError*crash*\",\n                \"*_ TC.test_one _*\",\n                \"*NameError*crash*\",\n                \"*_ TC.test_three _*\",\n                \"*DelayedCalls*\",\n                \"*_ TC.test_two _*\",\n                \"*NameError*crash*\",\n                \"*= 4 failed, 1 error in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_pdb_TestTrialUnittest.test_trial_testfunction_todo_property": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_pdb_TestTrialUnittest.test_trial_testfunction_todo_property", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 549, "end_line": 615, "span_ids": ["TestTrialUnittest.test_trial_pdb", "TestTrialUnittest.test_trial_testcase_skip_property", "TestTrialUnittest.test_trial_testcase_todo_property", "TestTrialUnittest.test_trial_testfunction_skip_property", "TestTrialUnittest.test_trial_testfunction_todo_property"], "tokens": 432}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTrialUnittest:\n\n    def test_trial_pdb(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            from twisted.trial import unittest\n            import pytest\n            class TC(unittest.TestCase):\n                def test_hello(self):\n                    assert 0, \"hellopdb\"\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(p)\n        child.expect(\"hellopdb\")\n        child.sendeof()\n\n    def test_trial_testcase_skip_property(self, testdir):\n        testpath = testdir.makepyfile(\n            \"\"\"\n            from twisted.trial import unittest\n            class MyTestCase(unittest.TestCase):\n                skip = 'dont run'\n                def test_func(self):\n                    pass\n            \"\"\"\n        )\n        reprec = testdir.inline_run(testpath, \"-s\")\n        reprec.assertoutcome(skipped=1)\n\n    def test_trial_testfunction_skip_property(self, testdir):\n        testpath = testdir.makepyfile(\n            \"\"\"\n            from twisted.trial import unittest\n            class MyTestCase(unittest.TestCase):\n                def test_func(self):\n                    pass\n                test_func.skip = 'dont run'\n            \"\"\"\n        )\n        reprec = testdir.inline_run(testpath, \"-s\")\n        reprec.assertoutcome(skipped=1)\n\n    def test_trial_testcase_todo_property(self, testdir):\n        testpath = testdir.makepyfile(\n            \"\"\"\n            from twisted.trial import unittest\n            class MyTestCase(unittest.TestCase):\n                todo = 'dont run'\n                def test_func(self):\n                    assert 0\n            \"\"\"\n        )\n        reprec = testdir.inline_run(testpath, \"-s\")\n        reprec.assertoutcome(skipped=1)\n\n    def test_trial_testfunction_todo_property(self, testdir):\n        testpath = testdir.makepyfile(\n            \"\"\"\n            from twisted.trial import unittest\n            class MyTestCase(unittest.TestCase):\n                def test_func(self):\n                    assert 0\n                test_func.todo = 'dont run'\n            \"\"\"\n        )\n        reprec = testdir.inline_run(\n            testpath, \"-s\", *self.ignore_unclosed_socket_warning\n        )\n        reprec.assertoutcome(skipped=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_djangolike_testcase_test_djangolike_testcase.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_djangolike_testcase_test_djangolike_testcase.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 604, "end_line": 659, "span_ids": ["test_djangolike_testcase"], "tokens": 307}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_djangolike_testcase(testdir):\n    # contributed from Morten Breekevold\n    testdir.makepyfile(\n        \"\"\"\n        from unittest import TestCase, main\n\n        class DjangoLikeTestCase(TestCase):\n\n            def setUp(self):\n                print(\"setUp()\")\n\n            def test_presetup_has_been_run(self):\n                print(\"test_thing()\")\n                self.assertTrue(hasattr(self, 'was_presetup'))\n\n            def tearDown(self):\n                print(\"tearDown()\")\n\n            def __call__(self, result=None):\n                try:\n                    self._pre_setup()\n                except (KeyboardInterrupt, SystemExit):\n                    raise\n                except Exception:\n                    import sys\n                    result.addError(self, sys.exc_info())\n                    return\n                super(DjangoLikeTestCase, self).__call__(result)\n                try:\n                    self._post_teardown()\n                except (KeyboardInterrupt, SystemExit):\n                    raise\n                except Exception:\n                    import sys\n                    result.addError(self, sys.exc_info())\n                    return\n\n            def _pre_setup(self):\n                print(\"_pre_setup()\")\n                self.was_presetup = True\n\n            def _post_teardown(self):\n                print(\"_post_teardown()\")\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-s\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\n            \"*_pre_setup()*\",\n            \"*setUp()*\",\n            \"*test_thing()*\",\n            \"*tearDown()*\",\n            \"*_post_teardown()*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_setup_interaction_test_unittest_setup_interaction.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_setup_interaction_test_unittest_setup_interaction.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 765, "end_line": 797, "span_ids": ["test_unittest_setup_interaction"], "tokens": 236}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"fix_type, stmt\", [(\"fixture\", \"return\"), (\"yield_fixture\", \"yield\")]\n)\ndef test_unittest_setup_interaction(testdir, fix_type, stmt):\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        import pytest\n        class MyTestCase(unittest.TestCase):\n            @pytest.{fix_type}(scope=\"class\", autouse=True)\n            def perclass(self, request):\n                request.cls.hello = \"world\"\n                {stmt}\n            @pytest.{fix_type}(scope=\"function\", autouse=True)\n            def perfunction(self, request):\n                request.instance.funcname = request.function.__name__\n                {stmt}\n\n            def test_method1(self):\n                assert self.funcname == \"test_method1\"\n                assert self.hello == \"world\"\n\n            def test_method2(self):\n                assert self.funcname == \"test_method2\"\n\n            def test_classattr(self):\n                assert self.__class__.hello == \"world\"\n    \"\"\".format(\n            fix_type=fix_type, stmt=stmt\n        )\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*3 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_warning_captured_hook_test_warning_captured_hook.assert_collected_expec": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_warning_captured_hook_test_warning_captured_hook.assert_collected_expec", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 309, "end_line": 353, "span_ids": ["test_warning_captured_hook"], "tokens": 295}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"always\")\ndef test_warning_captured_hook(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        from _pytest.warnings import _issue_warning_captured\n        def pytest_configure(config):\n            _issue_warning_captured(UserWarning(\"config warning\"), config.hook, stacklevel=2)\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest, warnings\n\n        warnings.warn(UserWarning(\"collect warning\"))\n\n        @pytest.fixture\n        def fix():\n            warnings.warn(UserWarning(\"setup warning\"))\n            yield 1\n            warnings.warn(UserWarning(\"teardown warning\"))\n\n        def test_func(fix):\n            warnings.warn(UserWarning(\"call warning\"))\n            assert fix == 1\n        \"\"\"\n    )\n\n    collected = []\n\n    class WarningCollector:\n        def pytest_warning_captured(self, warning_message, when, item):\n            imge_name = item.name if item is not None else \"\"\n            collected.append((str(warning_message.message), when, imge_name))\n\n    result = testdir.runpytest(plugins=[WarningCollector()])\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    expected = [\n        (\"config warning\", \"config\", \"\"),\n        (\"collect warning\", \"collect\", \"\"),\n        (\"setup warning\", \"runtest\", \"test_func\"),\n        (\"call warning\", \"runtest\", \"test_func\"),\n        (\"teardown warning\", \"runtest\", \"test_func\"),\n    ]\n    assert collected == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_collection_warnings_test_mark_regex_escape": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_collection_warnings_test_mark_regex_escape", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 288, "end_line": 327, "span_ids": ["test_collection_warnings", "test_mark_regex_escape"], "tokens": 249}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"always\")\ndef test_collection_warnings(testdir):\n    \"\"\"\n    Check that we also capture warnings issued during test collection (#3251).\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import warnings\n\n        warnings.warn(UserWarning(\"collection warning\"))\n\n        def test_foo():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n            \"  *collection_warnings.py:3: UserWarning: collection warning\",\n            '    warnings.warn(UserWarning(\"collection warning\"))',\n            \"* 1 passed, 1 warning*\",\n        ]\n    )\n\n\n@pytest.mark.filterwarnings(\"always\")\ndef test_mark_regex_escape(testdir):\n    \"\"\"@pytest.mark.filterwarnings should not try to escape regex characters (#3936)\"\"\"\n    testdir.makepyfile(\n        r\"\"\"\n        import pytest, warnings\n\n        @pytest.mark.filterwarnings(r\"ignore:some \\(warning\\)\")\n        def test_foo():\n            warnings.warn(UserWarning(\"some (warning)\"))\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_hide_pytest_internal_warnings_test_hide_pytest_internal_warnings.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_hide_pytest_internal_warnings_test_hide_pytest_internal_warnings.None_1", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 330, "end_line": 367, "span_ids": ["test_hide_pytest_internal_warnings"], "tokens": 259}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"default\")\n@pytest.mark.parametrize(\"ignore_pytest_warnings\", [\"no\", \"ini\", \"cmdline\"])\ndef test_hide_pytest_internal_warnings(testdir, ignore_pytest_warnings):\n    \"\"\"Make sure we can ignore internal pytest warnings using a warnings filter.\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import warnings\n\n        warnings.warn(pytest.PytestWarning(\"some internal warning\"))\n\n        def test_bar():\n            pass\n    \"\"\"\n    )\n    if ignore_pytest_warnings == \"ini\":\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            filterwarnings = ignore::pytest.PytestWarning\n        \"\"\"\n        )\n    args = (\n        [\"-W\", \"ignore::pytest.PytestWarning\"]\n        if ignore_pytest_warnings == \"cmdline\"\n        else []\n    )\n    result = testdir.runpytest(*args)\n    if ignore_pytest_warnings != \"no\":\n        assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()\n    else:\n        result.stdout.fnmatch_lines(\n            [\n                \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n                \"*test_hide_pytest_internal_warnings.py:4: PytestWarning: some internal warning\",\n                \"* 1 passed, 1 warning *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_option_precedence_cmdline_over_ini_test_option_precedence_mark": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_option_precedence_cmdline_over_ini_test_option_precedence_mark", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 438, "end_line": 479, "span_ids": ["test_option_precedence_cmdline_over_ini", "test_option_precedence_mark"], "tokens": 283}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"ignore_on_cmdline\", [True, False])\ndef test_option_precedence_cmdline_over_ini(testdir, ignore_on_cmdline):\n    \"\"\"filters defined in the command-line should take precedence over filters in ini files (#3946).\"\"\"\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        filterwarnings = error\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import warnings\n        def test():\n            warnings.warn(UserWarning('hello'))\n    \"\"\"\n    )\n    args = [\"-W\", \"ignore\"] if ignore_on_cmdline else []\n    result = testdir.runpytest(*args)\n    if ignore_on_cmdline:\n        result.stdout.fnmatch_lines([\"* 1 passed in*\"])\n    else:\n        result.stdout.fnmatch_lines([\"* 1 failed in*\"])\n\n\ndef test_option_precedence_mark(testdir):\n    \"\"\"Filters defined by marks should always take precedence (#3946).\"\"\"\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        filterwarnings = ignore\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest, warnings\n        @pytest.mark.filterwarnings('error')\n        def test():\n            warnings.warn(UserWarning('hello'))\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-W\", \"ignore\")\n    result.stdout.fnmatch_lines([\"* 1 failed in*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestDeprecationWarningsByDefault_TestDeprecationWarningsByDefault.test_hidden_by_system": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestDeprecationWarningsByDefault_TestDeprecationWarningsByDefault.test_hidden_by_system", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 414, "end_line": 501, "span_ids": ["TestDeprecationWarningsByDefault", "TestDeprecationWarningsByDefault.create_file", "TestDeprecationWarningsByDefault.test_hidden_by_cmdline", "TestDeprecationWarningsByDefault.test_hidden_by_ini", "TestDeprecationWarningsByDefault.test_hidden_by_mark", "TestDeprecationWarningsByDefault.test_hidden_by_system", "TestDeprecationWarningsByDefault.test_shown_by_default"], "tokens": 621}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDeprecationWarningsByDefault:\n    \"\"\"\n    Note: all pytest runs are executed in a subprocess so we don't inherit warning filters\n    from pytest's own test suite\n    \"\"\"\n\n    def create_file(self, testdir, mark=\"\"):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest, warnings\n\n            warnings.warn(DeprecationWarning(\"collection\"))\n\n            {mark}\n            def test_foo():\n                warnings.warn(PendingDeprecationWarning(\"test run\"))\n        \"\"\".format(\n                mark=mark\n            )\n        )\n\n    @pytest.mark.parametrize(\"customize_filters\", [True, False])\n    def test_shown_by_default(self, testdir, customize_filters):\n        \"\"\"Show deprecation warnings by default, even if user has customized the warnings filters (#4013).\"\"\"\n        self.create_file(testdir)\n        if customize_filters:\n            testdir.makeini(\n                \"\"\"\n                [pytest]\n                filterwarnings =\n                    once::UserWarning\n            \"\"\"\n            )\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines(\n            [\n                \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n                \"*test_shown_by_default.py:3: DeprecationWarning: collection\",\n                \"*test_shown_by_default.py:7: PendingDeprecationWarning: test run\",\n                \"* 1 passed, 2 warnings*\",\n            ]\n        )\n\n    def test_hidden_by_ini(self, testdir):\n        self.create_file(testdir)\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            filterwarnings =\n                ignore::DeprecationWarning\n                ignore::PendingDeprecationWarning\n        \"\"\"\n        )\n        result = testdir.runpytest_subprocess()\n        assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()\n\n    def test_hidden_by_mark(self, testdir):\n        \"\"\"Should hide the deprecation warning from the function, but the warning during collection should\n        be displayed normally.\n        \"\"\"\n        self.create_file(\n            testdir,\n            mark='@pytest.mark.filterwarnings(\"ignore::PendingDeprecationWarning\")',\n        )\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines(\n            [\n                \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n                \"*test_hidden_by_mark.py:3: DeprecationWarning: collection\",\n                \"* 1 passed, 1 warning*\",\n            ]\n        )\n\n    def test_hidden_by_cmdline(self, testdir):\n        self.create_file(testdir)\n        result = testdir.runpytest_subprocess(\n            \"-W\",\n            \"ignore::DeprecationWarning\",\n            \"-W\",\n            \"ignore::PendingDeprecationWarning\",\n        )\n        assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()\n\n    def test_hidden_by_system(self, testdir, monkeypatch):\n        self.create_file(testdir)\n        monkeypatch.setenv(\"PYTHONWARNINGS\", \"once::UserWarning\")\n        result = testdir.runpytest_subprocess()\n        assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB_pytestPDB._import_pdb_cls.return_wrapped_cls": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB_pytestPDB._import_pdb_cls.return_wrapped_cls", "embedding": null, "metadata": {"file_path": "src/_pytest/debugging.py", "file_name": "debugging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 73, "end_line": 125, "span_ids": ["pytestPDB", "pytestPDB._import_pdb_cls", "pytestPDB._is_capturing"], "tokens": 351}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB._get_pdb_wrapper_class_pytestPDB._get_pdb_wrapper_class.return_PytestPdbWrapper": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB._get_pdb_wrapper_class_pytestPDB._get_pdb_wrapper_class.return_PytestPdbWrapper", "embedding": null, "metadata": {"file_path": "src/_pytest/debugging.py", "file_name": "debugging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 122, "end_line": 202, "span_ids": ["pytestPDB._get_pdb_wrapper_class"], "tokens": 557}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class pytestPDB:\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB._init_pdb_pytestPDB.set_trace": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py_pytestPDB._init_pdb_pytestPDB.set_trace", "embedding": null, "metadata": {"file_path": "src/_pytest/debugging.py", "file_name": "debugging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 204, "end_line": 249, "span_ids": ["pytestPDB._init_pdb", "pytestPDB.set_trace"], "tokens": 357}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class pytestPDB:\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureDef_FixtureDef.finish": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureDef_FixtureDef.finish", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 839, "end_line": 898, "span_ids": ["FixtureDef", "FixtureDef.__init__", "FixtureDef.addfinalizer", "FixtureDef.finish"], "tokens": 379}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureDef:\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        if callable(scope):\n            scope = _eval_scope_callable(scope, argname, fixturemanager.config)\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, name=argname, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self.cached_result = None\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exc = None\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except BaseException as e:\n                    # XXX Only first exception will be seen by user,\n                    #     ideally all should be reported.\n                    if exc is None:\n                        exc = e\n            if exc:\n                raise exc\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            self.cached_result = None\n            self._finalizers = []", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager_FixtureManager.getfixtureinfo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager_FixtureManager.getfixtureinfo", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1211, "end_line": 1285, "span_ids": ["FixtureManager", "FixtureManager.__init__", "FixtureManager._get_direct_parametrize_args", "FixtureManager.getfixtureinfo"], "tokens": 637}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureManager:\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, name=node.name, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = get_use_fixtures_for_node(node)\n        initialnames = usefixtures + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.pytest_plugin_registered_FixtureManager._getautousenames": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureManager.pytest_plugin_registered_FixtureManager._getautousenames", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1287, "end_line": 1317, "span_ids": ["FixtureManager._getautousenames", "FixtureManager.pytest_plugin_registered"], "tokens": 250}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureManager:\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            from _pytest import nodes\n\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_pytest_addoption_pytest_addoption.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py_pytest_addoption_pytest_addoption.None_6", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 366, "end_line": 408, "span_ids": ["pytest_addoption"], "tokens": 316}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_addoption(parser):\n    group = parser.getgroup(\"terminal reporting\")\n    group.addoption(\n        \"--junitxml\",\n        \"--junit-xml\",\n        action=\"store\",\n        dest=\"xmlpath\",\n        metavar=\"path\",\n        type=functools.partial(filename_arg, optname=\"--junitxml\"),\n        default=None,\n        help=\"create junit-xml style report file at given path.\",\n    )\n    group.addoption(\n        \"--junitprefix\",\n        \"--junit-prefix\",\n        action=\"store\",\n        metavar=\"str\",\n        default=None,\n        help=\"prepend prefix to classnames in junit-xml output\",\n    )\n    parser.addini(\n        \"junit_suite_name\", \"Test suite name for JUnit report\", default=\"pytest\"\n    )\n    parser.addini(\n        \"junit_logging\",\n        \"Write captured log messages to JUnit report: \"\n        \"one of no|log|system-out|system-err|out-err|all\",\n        default=\"no\",\n    )\n    parser.addini(\n        \"junit_log_passing_tests\",\n        \"Capture log information for passing tests to JUnit report: \",\n        type=\"bool\",\n        default=True,\n    )\n    parser.addini(\n        \"junit_duration_report\",\n        \"Duration time to report: one of total|call\",\n        default=\"total\",\n    )  # choices=['total', 'call'])\n    parser.addini(\n        \"junit_family\", \"Emit XML for schema: one of legacy|xunit1|xunit2\", default=None\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin_LoggingPlugin._create_formatter": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin_LoggingPlugin._create_formatter", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 482, "end_line": 552, "span_ids": ["LoggingPlugin", "LoggingPlugin.__init__", "LoggingPlugin._create_formatter"], "tokens": 567}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LoggingPlugin:\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config: Config) -> None:\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        if not self.print_logs:\n            from _pytest.warnings import _issue_warning_captured\n            from _pytest.deprecated import NO_PRINT_LOGS\n\n            _issue_warning_captured(NO_PRINT_LOGS, self._config.hook, stacklevel=2)\n\n        self.formatter = self._create_formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n            get_option_ini(config, \"log_auto_indent\"),\n        )\n        self.log_level = get_log_level_for_setting(config, \"log_level\")\n\n        self.log_file_level = get_log_level_for_setting(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )  # type: Optional[logging.FileHandler]\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: nullcontext()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _create_formatter(self, log_format, log_date_format, auto_indent):\n        # color option doesn't exist if terminal plugin is disabled\n        color = getattr(self._config.option, \"color\", \"no\")\n        if color != \"no\" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(\n            log_format\n        ):\n            formatter = ColoredLevelFormatter(\n                create_terminal_writer(self._config), log_format, log_date_format\n            )  # type: logging.Formatter\n        else:\n            formatter = logging.Formatter(log_format, log_date_format)\n\n        formatter._style = PercentStyleMultiline(\n            formatter._style._fmt, auto_indent=auto_indent\n        )\n\n        return formatter", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin._setup_cli_logging_LoggingPlugin._setup_cli_logging": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LoggingPlugin._setup_cli_logging_LoggingPlugin._setup_cli_logging", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 554, "end_line": 575, "span_ids": ["LoggingPlugin._setup_cli_logging"], "tokens": 213}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LoggingPlugin:\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n\n        log_cli_formatter = self._create_formatter(\n            get_option_ini(config, \"log_cli_format\", \"log_format\"),\n            get_option_ini(config, \"log_cli_date_format\", \"log_date_format\"),\n            get_option_ini(config, \"log_auto_indent\"),\n        )\n\n        log_cli_level = get_log_level_for_setting(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_ParameterSet_ParameterSet._parse_parametrize_parameters": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_ParameterSet_ParameterSet._parse_parametrize_parameters", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 62, "end_line": 110, "span_ids": ["ParameterSet", "ParameterSet._parse_parametrize_args", "ParameterSet._parse_parametrize_parameters", "ParameterSet.extract_from", "ParameterSet.param"], "tokens": 366}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ParameterSet(namedtuple(\"ParameterSet\", \"values, marks, id\")):\n    @classmethod\n    def param(cls, *values, marks=(), id=None):\n        if isinstance(marks, MarkDecorator):\n            marks = (marks,)\n        else:\n            assert isinstance(marks, (tuple, list, set))\n\n        if id is not None:\n            if not isinstance(id, str):\n                raise TypeError(\n                    \"Expected id to be a string, got {}: {!r}\".format(type(id), id)\n                )\n            id = ascii_escaped(id)\n        return cls(values, marks, id)\n\n    @classmethod\n    def extract_from(cls, parameterset, force_tuple=False):\n        \"\"\"\n        :param parameterset:\n            a legacy style parameterset that may or may not be a tuple,\n            and may or may not be wrapped into a mess of mark objects\n\n        :param force_tuple:\n            enforce tuple wrapping so single argument tuple values\n            don't get decomposed and break tests\n        \"\"\"\n\n        if isinstance(parameterset, cls):\n            return parameterset\n        if force_tuple:\n            return cls.param(parameterset)\n        else:\n            return cls(parameterset, marks=[], id=None)\n\n    @staticmethod\n    def _parse_parametrize_args(argnames, argvalues, *args, **kwargs):\n        if not isinstance(argnames, (tuple, list)):\n            argnames = [x.strip() for x in argnames.split(\",\") if x.strip()]\n            force_tuple = len(argnames) == 1\n        else:\n            force_tuple = False\n        return argnames, force_tuple\n\n    @staticmethod\n    def _parse_parametrize_parameters(argvalues, force_tuple):\n        return [\n            ParameterSet.extract_from(x, force_tuple=force_tuple) for x in argvalues\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.getmodulecol_Testdir.getmodulecol.return_self_getnode_confi": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.getmodulecol_Testdir.getmodulecol.return_self_getnode_confi", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1063, "end_line": 1088, "span_ids": ["Testdir.getmodulecol"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def getmodulecol(self, source, configargs=(), withinit=False):\n        \"\"\"Return the module collection node for ``source``.\n\n        This writes ``source`` to a file using :py:meth:`makepyfile` and then\n        runs the pytest collection on it, returning the collection node for the\n        test module.\n\n        :param source: the source code of the module to collect\n\n        :param configargs: any extra arguments to pass to\n            :py:meth:`parseconfigure`\n\n        :param withinit: whether to also write an ``__init__.py`` file to the\n            same directory to ensure it is a package\n\n        \"\"\"\n        if isinstance(source, Path):\n            path = self.tmpdir.join(str(source))\n            assert not withinit, \"not supported for paths\"\n        else:\n            kw = {self._name: Source(source).strip()}\n            path = self.makepyfile(**kw)\n        if withinit:\n            self.makepyfile(__init__=\"#\")\n        self.config = config = self.parseconfigure(path, *configargs)\n        return self.getnode(config, path)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.collect_by_name_Testdir.popen.return_popen": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.collect_by_name_Testdir.popen.return_popen", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1090, "end_line": 1144, "span_ids": ["Testdir.collect_by_name", "Testdir.popen"], "tokens": 364}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def collect_by_name(\n        self, modcol: Module, name: str\n    ) -> Optional[Union[Item, Collector]]:\n        \"\"\"Return the collection node for name from the module collection.\n\n        This will search a module collection node for a collection node\n        matching the given name.\n\n        :param modcol: a module collection node; see :py:meth:`getmodulecol`\n\n        :param name: the name of the node to return\n        \"\"\"\n        if modcol not in self._mod_collections:\n            self._mod_collections[modcol] = list(modcol.collect())\n        for colitem in self._mod_collections[modcol]:\n            if colitem.name == name:\n                return colitem\n        return None\n\n    def popen(\n        self,\n        cmdargs,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        stdin=CLOSE_STDIN,\n        **kw\n    ):\n        \"\"\"Invoke subprocess.Popen.\n\n        This calls subprocess.Popen making sure the current working directory\n        is in the PYTHONPATH.\n\n        You probably want to use :py:meth:`run` instead.\n\n        \"\"\"\n        env = os.environ.copy()\n        env[\"PYTHONPATH\"] = os.pathsep.join(\n            filter(None, [os.getcwd(), env.get(\"PYTHONPATH\", \"\")])\n        )\n        kw[\"env\"] = env\n\n        if stdin is Testdir.CLOSE_STDIN:\n            kw[\"stdin\"] = subprocess.PIPE\n        elif isinstance(stdin, bytes):\n            kw[\"stdin\"] = subprocess.PIPE\n        else:\n            kw[\"stdin\"] = stdin\n\n        popen = subprocess.Popen(cmdargs, stdout=stdout, stderr=stderr, **kw)\n        if stdin is Testdir.CLOSE_STDIN:\n            popen.stdin.close()\n        elif isinstance(stdin, bytes):\n            popen.stdin.write(stdin)\n\n        return popen", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_addoption_pytest_addoption.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_addoption_pytest_addoption.None_6", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 55, "end_line": 107, "span_ids": ["pytest_addoption"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--fixtures\",\n        \"--funcargs\",\n        action=\"store_true\",\n        dest=\"showfixtures\",\n        default=False,\n        help=\"show available fixtures, sorted by plugin appearance \"\n        \"(fixtures with leading '_' are only shown with '-v')\",\n    )\n    group.addoption(\n        \"--fixtures-per-test\",\n        action=\"store_true\",\n        dest=\"show_fixtures_per_test\",\n        default=False,\n        help=\"show fixtures per test\",\n    )\n    parser.addini(\n        \"python_files\",\n        type=\"args\",\n        # NOTE: default is also used in AssertionRewritingHook.\n        default=[\"test_*.py\", \"*_test.py\"],\n        help=\"glob-style file patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"],\n        help=\"prefixes or glob names for Python test function and method discovery\",\n    )\n    parser.addini(\n        \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\",\n        type=\"bool\",\n        default=False,\n        help=\"disable string escape non-ascii characters, might cause unwanted \"\n        \"side effects(use at your own risk)\",\n    )\n\n    group.addoption(\n        \"--import-mode\",\n        default=\"prepend\",\n        choices=[\"prepend\", \"append\"],\n        dest=\"importmode\",\n        help=\"prepend/append to sys.path when importing test modules, \"\n        \"default is to prepend.\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_collection_live_logging_test_collection_collect_only_live_logging.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_collection_live_logging_test_collection_collect_only_live_logging.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 908, "end_line": 956, "span_ids": ["test_collection_collect_only_live_logging", "test_collection_live_logging"], "tokens": 306}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collection_live_logging(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logging.getLogger().info(\"Normal message\")\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--log-cli-level=INFO\")\n    result.stdout.fnmatch_lines(\n        [\"*--- live log collection ---*\", \"*Normal message*\", \"collected 0 items\"]\n    )\n\n\n@pytest.mark.parametrize(\"verbose\", [\"\", \"-q\", \"-qq\"])\ndef test_collection_collect_only_live_logging(testdir, verbose):\n    testdir.makepyfile(\n        \"\"\"\n        def test_simple():\n            pass\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--collect-only\", \"--log-cli-level=INFO\", verbose)\n\n    expected_lines = []\n\n    if not verbose:\n        expected_lines.extend(\n            [\n                \"*collected 1 item*\",\n                \"*<Module test_collection_collect_only_live_logging.py>*\",\n                \"*no tests ran*\",\n            ]\n        )\n    elif verbose == \"-q\":\n        result.stdout.no_fnmatch_line(\"*collected 1 item**\")\n        expected_lines.extend(\n            [\n                \"*test_collection_collect_only_live_logging.py::test_simple*\",\n                \"no tests ran in [0-1].[0-9][0-9]s\",\n            ]\n        )\n    elif verbose == \"-qq\":\n        result.stdout.no_fnmatch_line(\"*collected 1 item**\")\n        expected_lines.extend([\"*test_collection_collect_only_live_logging.py: 1*\"])\n\n    result.stdout.fnmatch_lines(expected_lines)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_collection_logging_to_file_test_log_in_runtest_logreport.with_open_log_file_as_rf": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_collection_logging_to_file_test_log_in_runtest_logreport.with_open_log_file_as_rf", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 959, "end_line": 1064, "span_ids": ["test_collection_logging_to_file", "test_log_in_hooks", "test_log_in_runtest_logreport"], "tokens": 553}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collection_logging_to_file(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        \"\"\".format(\n            log_file\n        )\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logging.getLogger().info(\"Normal message\")\n\n        def test_simple():\n            logging.getLogger().debug(\"debug message in test_simple\")\n            logging.getLogger().info(\"info message in test_simple\")\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n\n    result.stdout.no_fnmatch_line(\"*--- live log collection ---*\")\n\n    assert result.ret == 0\n    assert os.path.isfile(log_file)\n    with open(log_file, encoding=\"utf-8\") as rfh:\n        contents = rfh.read()\n        assert \"Normal message\" in contents\n        assert \"debug message in test_simple\" not in contents\n        assert \"info message in test_simple\" in contents\n\n\ndef test_log_in_hooks(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        log_cli=true\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makeconftest(\n        \"\"\"\n        import logging\n\n        def pytest_runtestloop(session):\n            logging.info('runtestloop')\n\n        def pytest_sessionstart(session):\n            logging.info('sessionstart')\n\n        def pytest_sessionfinish(session, exitstatus):\n            logging.info('sessionfinish')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*sessionstart*\", \"*runtestloop*\", \"*sessionfinish*\"])\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert \"sessionstart\" in contents\n        assert \"runtestloop\" in contents\n        assert \"sessionfinish\" in contents\n\n\ndef test_log_in_runtest_logreport(testdir):\n    log_file = testdir.tmpdir.join(\"pytest.log\").strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file={}\n        log_file_level = INFO\n        log_cli=true\n        \"\"\".format(\n            log_file\n        )\n    )\n    testdir.makeconftest(\n        \"\"\"\n        import logging\n        logger = logging.getLogger(__name__)\n\n        def pytest_runtest_logreport(report):\n            logger.info(\"logreport\")\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n            def test_first():\n                assert True\n        \"\"\"\n    )\n    testdir.runpytest()\n    with open(log_file) as rfh:\n        contents = rfh.read()\n        assert contents.count(\"logreport\") == 3", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_set_path_test_log_set_path.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_set_path_test_log_set_path.None_1", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 1067, "end_line": 1112, "span_ids": ["test_log_set_path"], "tokens": 284}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_set_path(testdir):\n    report_dir_base = testdir.tmpdir.strpath\n\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_file_level = DEBUG\n        log_cli=true\n        \"\"\"\n    )\n    testdir.makeconftest(\n        \"\"\"\n            import os\n            import pytest\n            @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n            def pytest_runtest_setup(item):\n                config = item.config\n                logging_plugin = config.pluginmanager.get_plugin(\"logging-plugin\")\n                report_file = os.path.join({}, item._request.node.name)\n                logging_plugin.set_log_path(report_file)\n                yield\n        \"\"\".format(\n            repr(report_dir_base)\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n            import logging\n            logger = logging.getLogger(\"testcase-logger\")\n            def test_first():\n                logger.info(\"message from test 1\")\n                assert True\n\n            def test_second():\n                logger.debug(\"message from test 2\")\n                assert True\n        \"\"\"\n    )\n    testdir.runpytest()\n    with open(os.path.join(report_dir_base, \"test_first\")) as rfh:\n        content = rfh.read()\n        assert \"message from test 1\" in content\n\n    with open(os.path.join(report_dir_base, \"test_second\")) as rfh:\n        content = rfh.read()\n        assert \"message from test 2\" in content", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_colored_captured_log_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_colored_captured_log_", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 1115, "end_line": 1158, "span_ids": ["test_colored_ansi_esc_caplogtext", "test_colored_captured_log"], "tokens": 264}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_colored_captured_log(testdir):\n    \"\"\"\n    Test that the level names of captured log messages of a failing test are\n    colored.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            logger.info('text going to logger from call')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\", \"--color=yes\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        [\n            \"*-- Captured log call --*\",\n            \"\\x1b[32mINFO    \\x1b[0m*text going to logger from call\",\n        ]\n    )\n\n\ndef test_colored_ansi_esc_caplogtext(testdir):\n    \"\"\"\n    Make sure that caplog.text does not contain ANSI escape sequences.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo(caplog):\n            logger.info('text going to logger from call')\n            assert '\\x1b' not in caplog.text\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\", \"--color=yes\")\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_non_printable_characters_TestMetafunc.test_idmaker_idfn_unique_names": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_non_printable_characters_TestMetafunc.test_idmaker_idfn_unique_names", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 419, "end_line": 491, "span_ids": ["TestMetafunc.test_idmaker_enum", "TestMetafunc.test_idmaker_idfn", "TestMetafunc.test_idmaker_idfn_unique_names", "TestMetafunc.test_idmaker_manual_ids_must_be_printable", "TestMetafunc.test_idmaker_non_printable_characters"], "tokens": 551}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_idmaker_non_printable_characters(self) -> None:\n        from _pytest.python import idmaker\n\n        result = idmaker(\n            (\"s\", \"n\"),\n            [\n                pytest.param(\"\\x00\", 1),\n                pytest.param(\"\\x05\", 2),\n                pytest.param(b\"\\x00\", 3),\n                pytest.param(b\"\\x05\", 4),\n                pytest.param(\"\\t\", 5),\n                pytest.param(b\"\\t\", 6),\n            ],\n        )\n        assert result == [\"\\\\x00-1\", \"\\\\x05-2\", \"\\\\x00-3\", \"\\\\x05-4\", \"\\\\t-5\", \"\\\\t-6\"]\n\n    def test_idmaker_manual_ids_must_be_printable(self) -> None:\n        from _pytest.python import idmaker\n\n        result = idmaker(\n            (\"s\",),\n            [\n                pytest.param(\"x00\", id=\"hello \\x00\"),\n                pytest.param(\"x05\", id=\"hello \\x05\"),\n            ],\n        )\n        assert result == [\"hello \\\\x00\", \"hello \\\\x05\"]\n\n    def test_idmaker_enum(self) -> None:\n        from _pytest.python import idmaker\n\n        enum = pytest.importorskip(\"enum\")\n        e = enum.Enum(\"Foo\", \"one, two\")\n        result = idmaker((\"a\", \"b\"), [pytest.param(e.one, e.two)])\n        assert result == [\"Foo.one-Foo.two\"]\n\n    def test_idmaker_idfn(self) -> None:\n        \"\"\"#351\"\"\"\n        from _pytest.python import idmaker\n\n        def ids(val: object) -> Optional[str]:\n            if isinstance(val, Exception):\n                return repr(val)\n            return None\n\n        result = idmaker(\n            (\"a\", \"b\"),\n            [\n                pytest.param(10.0, IndexError()),\n                pytest.param(20, KeyError()),\n                pytest.param(\"three\", [1, 2, 3]),\n            ],\n            idfn=ids,\n        )\n        assert result == [\"10.0-IndexError()\", \"20-KeyError()\", \"three-b2\"]\n\n    def test_idmaker_idfn_unique_names(self) -> None:\n        \"\"\"#351\"\"\"\n        from _pytest.python import idmaker\n\n        def ids(val: object) -> str:\n            return \"a\"\n\n        result = idmaker(\n            (\"a\", \"b\"),\n            [\n                pytest.param(10.0, IndexError()),\n                pytest.param(20, KeyError()),\n                pytest.param(\"three\", [1, 2, 3]),\n            ],\n            idfn=ids,\n        )\n        assert result == [\"a-a0\", \"a-a1\", \"a-a2\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_idfn_and_config_TestMetafunc.test_idmaker_with_idfn_and_config.for_config_expected_in_v": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_idfn_and_config_TestMetafunc.test_idmaker_with_idfn_and_config.for_config_expected_in_v", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 493, "end_line": 524, "span_ids": ["TestMetafunc.test_idmaker_with_idfn_and_config"], "tokens": 218}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_idmaker_with_idfn_and_config(self) -> None:\n        \"\"\"unittest for expected behavior to create ids with idfn and\n        disable_test_id_escaping_and_forfeit_all_rights_to_community_support\n        option. (#5294)\n        \"\"\"\n        from _pytest.python import idmaker\n\n        class MockConfig:\n            def __init__(self, config):\n                self.config = config\n\n            @property\n            def hook(self):\n                return self\n\n            def pytest_make_parametrize_id(self, **kw):\n                pass\n\n            def getini(self, name):\n                return self.config[name]\n\n        option = \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\"\n\n        values = [\n            (MockConfig({option: True}), \"a\u00e7\u00e3o\"),\n            (MockConfig({option: False}), \"a\\\\xe7\\\\xe3o\"),\n        ]  # type: List[Tuple[Any, str]]\n        for config, expected in values:\n            result = idmaker(\n                (\"a\",), [pytest.param(\"string\")], idfn=lambda _: \"a\u00e7\u00e3o\", config=config,\n            )\n            assert result == [expected]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_with_known_failures_not_being_selected_TestLastFailed.test_lastfailed_with_known_failures_not_being_selected.None_7": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_with_known_failures_not_being_selected_TestLastFailed.test_lastfailed_with_known_failures_not_being_selected.None_7", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 810, "end_line": 853, "span_ids": ["TestLastFailed.test_lastfailed_with_known_failures_not_being_selected"], "tokens": 383}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_lastfailed_with_known_failures_not_being_selected(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"pkg1/test_1.py\": \"\"\"def test_1(): assert 0\"\"\",\n                \"pkg1/test_2.py\": \"\"\"def test_2(): pass\"\"\",\n            }\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"collected 2 items\", \"* 1 failed, 1 passed in *\"])\n\n        py.path.local(\"pkg1/test_1.py\").remove()\n        result = testdir.runpytest(\"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 1 item\",\n                \"run-last-failure: 1 known failures not in selected tests\",\n                \"* 1 passed in *\",\n            ]\n        )\n\n        # Recreate file with known failure.\n        testdir.makepyfile(**{\"pkg1/test_1.py\": \"\"\"def test_1(): assert 0\"\"\"})\n        result = testdir.runpytest(\"--lf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 1 item\",\n                \"run-last-failure: rerun previous 1 failure (skipped 1 file)\",\n                \"* 1 failed in *\",\n            ]\n        )\n\n        # Remove/rename test.\n        testdir.makepyfile(**{\"pkg1/test_1.py\": \"\"\"def test_renamed(): assert 0\"\"\"})\n        result = testdir.runpytest(\"--lf\", \"-rf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 2 items\",\n                \"run-last-failure: 1 known failures not in selected tests\",\n                \"pkg1/test_1.py F *\",\n                \"pkg1/test_2.py . *\",\n                \"FAILED pkg1/test_1.py::test_renamed - assert 0\",\n                \"* 1 failed, 1 passed in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_options_on_small_file_do_not_blow_up_test_importlib_metadata_broken_distribution": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_options_on_small_file_do_not_blow_up_test_importlib_metadata_broken_distribution", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 501, "end_line": 605, "span_ids": ["test_importlib_metadata_broken_distribution", "test_options_on_small_file_do_not_blow_up", "test_preparse_ordering_with_setuptools", "test_setuptools_importerror_issue1479"], "tokens": 602}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_options_on_small_file_do_not_blow_up(testdir):\n    def runfiletest(opts):\n        reprec = testdir.inline_run(*opts)\n        passed, skipped, failed = reprec.countoutcomes()\n        assert failed == 2\n        assert skipped == passed == 0\n\n    path = testdir.makepyfile(\n        \"\"\"\n        def test_f1(): assert 0\n        def test_f2(): assert 0\n    \"\"\"\n    )\n\n    for opts in (\n        [],\n        [\"-l\"],\n        [\"-s\"],\n        [\"--tb=no\"],\n        [\"--tb=short\"],\n        [\"--tb=long\"],\n        [\"--fulltrace\"],\n        [\"--traceconfig\"],\n        [\"-v\"],\n        [\"-v\", \"-v\"],\n    ):\n        runfiletest(opts + [path])\n\n\ndef test_preparse_ordering_with_setuptools(testdir, monkeypatch):\n    monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n\n    class EntryPoint:\n        name = \"mytestplugin\"\n        group = \"pytest11\"\n\n        def load(self):\n            class PseudoPlugin:\n                x = 42\n\n            return PseudoPlugin()\n\n    class Dist:\n        files = ()\n        entry_points = (EntryPoint(),)\n\n    def my_dists():\n        return (Dist,)\n\n    monkeypatch.setattr(importlib_metadata, \"distributions\", my_dists)\n    testdir.makeconftest(\n        \"\"\"\n        pytest_plugins = \"mytestplugin\",\n    \"\"\"\n    )\n    monkeypatch.setenv(\"PYTEST_PLUGINS\", \"mytestplugin\")\n    config = testdir.parseconfig()\n    plugin = config.pluginmanager.getplugin(\"mytestplugin\")\n    assert plugin.x == 42\n\n\ndef test_setuptools_importerror_issue1479(testdir, monkeypatch):\n    monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n\n    class DummyEntryPoint:\n        name = \"mytestplugin\"\n        group = \"pytest11\"\n\n        def load(self):\n            raise ImportError(\"Don't hide me!\")\n\n    class Distribution:\n        version = \"1.0\"\n        files = (\"foo.txt\",)\n        entry_points = (DummyEntryPoint(),)\n\n    def distributions():\n        return (Distribution(),)\n\n    monkeypatch.setattr(importlib_metadata, \"distributions\", distributions)\n    with pytest.raises(ImportError):\n        testdir.parseconfig()\n\n\ndef test_importlib_metadata_broken_distribution(testdir, monkeypatch):\n    \"\"\"Integration test for broken distributions with 'files' metadata being None (#5389)\"\"\"\n    monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n\n    class DummyEntryPoint:\n        name = \"mytestplugin\"\n        group = \"pytest11\"\n\n        def load(self):\n            return object()\n\n    class Distribution:\n        version = \"1.0\"\n        files = None\n        entry_points = (DummyEntryPoint(),)\n\n    def distributions():\n        return (Distribution(),)\n\n    monkeypatch.setattr(importlib_metadata, \"distributions\", distributions)\n    testdir.parseconfig()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_plugin_preparse_prevents_setuptools_loading_test_plugin_preparse_prevents_setuptools_loading.if_block_it_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_plugin_preparse_prevents_setuptools_loading_test_plugin_preparse_prevents_setuptools_loading.if_block_it_", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 608, "end_line": 639, "span_ids": ["test_plugin_preparse_prevents_setuptools_loading"], "tokens": 217}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"block_it\", [True, False])\ndef test_plugin_preparse_prevents_setuptools_loading(testdir, monkeypatch, block_it):\n    monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n\n    plugin_module_placeholder = object()\n\n    class DummyEntryPoint:\n        name = \"mytestplugin\"\n        group = \"pytest11\"\n\n        def load(self):\n            return plugin_module_placeholder\n\n    class Distribution:\n        version = \"1.0\"\n        files = (\"foo.txt\",)\n        entry_points = (DummyEntryPoint(),)\n\n    def distributions():\n        return (Distribution(),)\n\n    monkeypatch.setattr(importlib_metadata, \"distributions\", distributions)\n    args = (\"-p\", \"no:mytestplugin\") if block_it else ()\n    config = testdir.parseconfig(*args)\n    config.pluginmanager.import_plugin(\"mytestplugin\")\n    if block_it:\n        assert \"mytestplugin\" not in sys.modules\n        assert config.pluginmanager.get_plugin(\"mytestplugin\") is None\n    else:\n        assert (\n            config.pluginmanager.get_plugin(\"mytestplugin\") is plugin_module_placeholder\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_consider_args_after_options_for_rootdir_test_consider_args_after_options_for_rootdir.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_consider_args_after_options_for_rootdir_test_consider_args_after_options_for_rootdir.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 695, "end_line": 720, "span_ids": ["test_consider_args_after_options_for_rootdir"], "tokens": 225}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"args\",\n    [\n        [\"dir1\", \"dir2\", \"-v\"],\n        [\"dir1\", \"-v\", \"dir2\"],\n        [\"dir2\", \"-v\", \"dir1\"],\n        [\"-v\", \"dir2\", \"dir1\"],\n    ],\n)\ndef test_consider_args_after_options_for_rootdir(testdir, args):\n    \"\"\"\n    Consider all arguments in the command-line for rootdir\n    discovery, even if they happen to occur after an option. #949\n    \"\"\"\n    # replace \"dir1\" and \"dir2\" from \"args\" into their real directory\n    root = testdir.tmpdir.mkdir(\"myroot\")\n    d1 = root.mkdir(\"dir1\")\n    d2 = root.mkdir(\"dir2\")\n    for i, arg in enumerate(args):\n        if arg == \"dir1\":\n            args[i] = d1\n        elif arg == \"dir2\":\n            args[i] = d2\n    with root.as_cwd():\n        result = testdir.runpytest(*args)\n    result.stdout.fnmatch_lines([\"*rootdir: *myroot\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestReportingOption_TestDoctestReportingOption.test_doctest_report_invalid": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctestReportingOption_TestDoctestReportingOption.test_doctest_report_invalid", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1278, "end_line": 1359, "span_ids": ["TestDoctestReportingOption", "TestDoctestReportingOption._run_doctest_report", "TestDoctestReportingOption.test_doctest_report_cdiff", "TestDoctestReportingOption.test_doctest_report_invalid", "TestDoctestReportingOption.test_doctest_report_ndiff", "TestDoctestReportingOption.test_doctest_report_none_or_only_first_failure", "TestDoctestReportingOption.test_doctest_report_udiff"], "tokens": 715}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctestReportingOption:\n    def _run_doctest_report(self, testdir, format):\n        testdir.makepyfile(\n            \"\"\"\n            def foo():\n                '''\n                >>> foo()\n                   a  b\n                0  1  4\n                1  2  4\n                2  3  6\n                '''\n                print('   a  b\\\\n'\n                      '0  1  4\\\\n'\n                      '1  2  5\\\\n'\n                      '2  3  6')\n            \"\"\"\n        )\n        return testdir.runpytest(\"--doctest-modules\", \"--doctest-report\", format)\n\n    @pytest.mark.parametrize(\"format\", [\"udiff\", \"UDIFF\", \"uDiFf\"])\n    def test_doctest_report_udiff(self, testdir, format):\n        result = self._run_doctest_report(testdir, format)\n        result.stdout.fnmatch_lines(\n            [\"     0  1  4\", \"    -1  2  4\", \"    +1  2  5\", \"     2  3  6\"]\n        )\n\n    def test_doctest_report_cdiff(self, testdir):\n        result = self._run_doctest_report(testdir, \"cdiff\")\n        result.stdout.fnmatch_lines(\n            [\n                \"         a  b\",\n                \"      0  1  4\",\n                \"    ! 1  2  4\",\n                \"      2  3  6\",\n                \"    --- 1,4 ----\",\n                \"         a  b\",\n                \"      0  1  4\",\n                \"    ! 1  2  5\",\n                \"      2  3  6\",\n            ]\n        )\n\n    def test_doctest_report_ndiff(self, testdir):\n        result = self._run_doctest_report(testdir, \"ndiff\")\n        result.stdout.fnmatch_lines(\n            [\n                \"         a  b\",\n                \"      0  1  4\",\n                \"    - 1  2  4\",\n                \"    ?       ^\",\n                \"    + 1  2  5\",\n                \"    ?       ^\",\n                \"      2  3  6\",\n            ]\n        )\n\n    @pytest.mark.parametrize(\"format\", [\"none\", \"only_first_failure\"])\n    def test_doctest_report_none_or_only_first_failure(self, testdir, format):\n        result = self._run_doctest_report(testdir, format)\n        result.stdout.fnmatch_lines(\n            [\n                \"Expected:\",\n                \"       a  b\",\n                \"    0  1  4\",\n                \"    1  2  4\",\n                \"    2  3  6\",\n                \"Got:\",\n                \"       a  b\",\n                \"    0  1  4\",\n                \"    1  2  5\",\n                \"    2  3  6\",\n            ]\n        )\n\n    def test_doctest_report_invalid(self, testdir):\n        result = self._run_doctest_report(testdir, \"obviously_invalid_format\")\n        result.stderr.fnmatch_lines(\n            [\n                \"*error: argument --doctest-report: invalid choice: 'obviously_invalid_format' (choose from*\"\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_test_doctest_mock_objects_dont_recurse_missbehaved_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_test_doctest_mock_objects_dont_recurse_missbehaved_", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1453, "end_line": 1515, "span_ids": ["Broken", "Broken.__getattr__", "test_doctest_mock_objects_dont_recurse_missbehaved", "test_is_setup_py_different_encoding", "test_is_setup_py_is_a_setup_py", "test_is_setup_py_not_named_setup_py", "test_warning_on_unwrap_of_broken_object"], "tokens": 515}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"mock_module\", [\"mock\", \"unittest.mock\"])\ndef test_doctest_mock_objects_dont_recurse_missbehaved(mock_module, testdir):\n    pytest.importorskip(mock_module)\n    testdir.makepyfile(\n        \"\"\"\n        from {mock_module} import call\n        class Example(object):\n            '''\n            >>> 1 + 1\n            2\n            '''\n        \"\"\".format(\n            mock_module=mock_module\n        )\n    )\n    result = testdir.runpytest(\"--doctest-modules\")\n    result.stdout.fnmatch_lines([\"* 1 passed *\"])\n\n\nclass Broken:\n    def __getattr__(self, _):\n        raise KeyError(\"This should be an AttributeError\")\n\n\n@pytest.mark.parametrize(  # pragma: no branch (lambdas are not called)\n    \"stop\", [None, _is_mocked, lambda f: None, lambda f: False, lambda f: True]\n)\ndef test_warning_on_unwrap_of_broken_object(stop):\n    bad_instance = Broken()\n    assert inspect.unwrap.__module__ == \"inspect\"\n    with _patch_unwrap_mock_aware():\n        assert inspect.unwrap.__module__ != \"inspect\"\n        with pytest.warns(\n            pytest.PytestWarning, match=\"^Got KeyError.* when unwrapping\"\n        ):\n            with pytest.raises(KeyError):\n                inspect.unwrap(bad_instance, stop=stop)\n    assert inspect.unwrap.__module__ == \"inspect\"\n\n\ndef test_is_setup_py_not_named_setup_py(tmpdir):\n    not_setup_py = tmpdir.join(\"not_setup.py\")\n    not_setup_py.write('from setuptools import setup; setup(name=\"foo\")')\n    assert not _is_setup_py(not_setup_py)\n\n\n@pytest.mark.parametrize(\"mod\", (\"setuptools\", \"distutils.core\"))\ndef test_is_setup_py_is_a_setup_py(tmpdir, mod):\n    setup_py = tmpdir.join(\"setup.py\")\n    setup_py.write('from {} import setup; setup(name=\"foo\")'.format(mod))\n    assert _is_setup_py(setup_py)\n\n\n@pytest.mark.parametrize(\"mod\", (\"setuptools\", \"distutils.core\"))\ndef test_is_setup_py_different_encoding(tmpdir, mod):\n    setup_py = tmpdir.join(\"setup.py\")\n    contents = (\n        \"# -*- coding: cp1252 -*-\\n\"\n        'from {} import setup; setup(name=\"foo\", description=\"\u20ac\")\\n'.format(mod)\n    )\n    setup_py.write_binary(contents.encode(\"cp1252\"))\n    assert _is_setup_py(setup_py)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_test_run_with_skip_option_test_stop_on_collection_errors": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_test_run_with_skip_option_test_stop_on_collection_errors", "embedding": null, "metadata": {"file_path": "testing/test_stepwise.py", "file_name": "test_stepwise.py", "file_type": "text/x-python", "category": "test", "start_line": 110, "end_line": 167, "span_ids": ["test_change_testfile", "test_fail_on_errors", "test_run_with_skip_option", "test_stop_on_collection_errors"], "tokens": 466}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_run_with_skip_option(stepwise_testdir):\n    result = stepwise_testdir.runpytest(\n        \"-v\",\n        \"--strict-markers\",\n        \"--stepwise\",\n        \"--stepwise-skip\",\n        \"--fail\",\n        \"--fail-last\",\n    )\n    assert not result.stderr.str()\n\n    stdout = result.stdout.str()\n    # Make sure first fail is ignore and second fail stops the test run.\n    assert \"test_fail_on_flag FAILED\" in stdout\n    assert \"test_success_after_fail PASSED\" in stdout\n    assert \"test_fail_last_on_flag FAILED\" in stdout\n    assert \"test_success_after_last_fail\" not in stdout\n\n\ndef test_fail_on_errors(error_testdir):\n    result = error_testdir.runpytest(\"-v\", \"--strict-markers\", \"--stepwise\")\n\n    assert not result.stderr.str()\n    stdout = result.stdout.str()\n\n    assert \"test_error ERROR\" in stdout\n    assert \"test_success_after_fail\" not in stdout\n\n\ndef test_change_testfile(stepwise_testdir):\n    result = stepwise_testdir.runpytest(\n        \"-v\", \"--strict-markers\", \"--stepwise\", \"--fail\", \"test_a.py\"\n    )\n    assert not result.stderr.str()\n\n    stdout = result.stdout.str()\n    assert \"test_fail_on_flag FAILED\" in stdout\n\n    # Make sure the second test run starts from the beginning, since the\n    # test to continue from does not exist in testfile_b.\n    result = stepwise_testdir.runpytest(\n        \"-v\", \"--strict-markers\", \"--stepwise\", \"test_b.py\"\n    )\n    assert not result.stderr.str()\n\n    stdout = result.stdout.str()\n    assert \"test_success PASSED\" in stdout\n\n\n@pytest.mark.parametrize(\"broken_first\", [True, False])\ndef test_stop_on_collection_errors(broken_testdir, broken_first):\n    \"\"\"Stop during collection errors. Broken test first or broken test last\n    actually surfaced a bug (#5444), so we test both situations.\"\"\"\n    files = [\"working_testfile.py\", \"broken_testfile.py\"]\n    if broken_first:\n        files.reverse()\n    result = broken_testdir.runpytest(\"-v\", \"--strict-markers\", \"--stepwise\", *files)\n    result.stdout.fnmatch_lines(\"*error during collection*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_test_xfail_handling_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_test_xfail_handling_", "embedding": null, "metadata": {"file_path": "testing/test_stepwise.py", "file_name": "test_stepwise.py", "file_type": "text/x-python", "category": "test", "start_line": 170, "end_line": 220, "span_ids": ["test_xfail_handling"], "tokens": 350}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_xfail_handling(testdir, monkeypatch):\n    \"\"\"Ensure normal xfail is ignored, and strict xfail interrupts the session in sw mode\n\n    (#5547)\n    \"\"\"\n    monkeypatch.setattr(\"sys.dont_write_bytecode\", True)\n\n    contents = \"\"\"\n        import pytest\n        def test_a(): pass\n\n        @pytest.mark.xfail(strict={strict})\n        def test_b(): assert {assert_value}\n\n        def test_c(): pass\n        def test_d(): pass\n    \"\"\"\n    testdir.makepyfile(contents.format(assert_value=\"0\", strict=\"False\"))\n    result = testdir.runpytest(\"--sw\", \"-v\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*::test_a PASSED *\",\n            \"*::test_b XFAIL *\",\n            \"*::test_c PASSED *\",\n            \"*::test_d PASSED *\",\n            \"* 3 passed, 1 xfailed in *\",\n        ]\n    )\n\n    testdir.makepyfile(contents.format(assert_value=\"1\", strict=\"True\"))\n    result = testdir.runpytest(\"--sw\", \"-v\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*::test_a PASSED *\",\n            \"*::test_b FAILED *\",\n            \"* Interrupted*\",\n            \"* 1 failed, 1 passed in *\",\n        ]\n    )\n\n    testdir.makepyfile(contents.format(assert_value=\"0\", strict=\"True\"))\n    result = testdir.runpytest(\"--sw\", \"-v\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*::test_b XFAIL *\",\n            \"*::test_c PASSED *\",\n            \"*::test_d PASSED *\",\n            \"* 2 passed, 1 deselected, 1 xfailed in *\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_attempt_symlink_to_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_attempt_symlink_to_", "embedding": null, "metadata": {"file_path": "testing/test_tmpdir.py", "file_name": "test_tmpdir.py", "file_type": "text/x-python", "category": "test", "start_line": 397, "end_line": 429, "span_ids": ["attempt_symlink_to", "test_basetemp_with_read_only_files", "test_tmpdir_equals_tmp_path"], "tokens": 246}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def attempt_symlink_to(path, to_path):\n    \"\"\"Try to make a symlink from \"path\" to \"to_path\", skipping in case this platform\n    does not support it or we don't have sufficient privileges (common on Windows).\"\"\"\n    try:\n        Path(path).symlink_to(Path(to_path))\n    except OSError:\n        pytest.skip(\"could not create symbolic link\")\n\n\ndef test_tmpdir_equals_tmp_path(tmpdir, tmp_path):\n    assert Path(tmpdir) == tmp_path\n\n\ndef test_basetemp_with_read_only_files(testdir):\n    \"\"\"Integration test for #5524\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import os\n        import stat\n\n        def test(tmp_path):\n            fn = tmp_path / 'foo.txt'\n            fn.write_text('hello')\n            mode = os.stat(str(fn)).st_mode\n            os.chmod(str(fn), mode & ~stat.S_IREAD)\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--basetemp=tmp\")\n    assert result.ret == 0\n    # running a second time and ensure we don't crash\n    result = testdir.runpytest(\"--basetemp=tmp\")\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_new_instances_test_method_and_teardown_failing_reporting": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_new_instances_test_method_and_teardown_failing_reporting", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 127, "end_line": 254, "span_ids": ["test_function_item_obj_is_instance", "test_method_and_teardown_failing_reporting", "test_new_instances", "test_teardown", "test_teardown_issue1649", "test_unittest_skip_issue148"], "tokens": 739}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_new_instances(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCase(unittest.TestCase):\n            def test_func1(self):\n                self.x = 2\n            def test_func2(self):\n                assert not hasattr(self, 'x')\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    reprec.assertoutcome(passed=2)\n\n\ndef test_function_item_obj_is_instance(testdir):\n    \"\"\"item.obj should be a bound method on unittest.TestCase function items (#5390).\"\"\"\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_runtest_makereport(item, call):\n            if call.when == 'call':\n                class_ = item.parent.obj\n                assert isinstance(item.obj.__self__, class_)\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n\n        class Test(unittest.TestCase):\n            def test_foo(self):\n                pass\n    \"\"\"\n    )\n    result = testdir.runpytest_inprocess()\n    result.stdout.fnmatch_lines([\"* 1 passed in*\"])\n\n\ndef test_teardown(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCase(unittest.TestCase):\n            values = []\n            def test_one(self):\n                pass\n            def tearDown(self):\n                self.values.append(None)\n        class Second(unittest.TestCase):\n            def test_check(self):\n                self.assertEqual(MyTestCase.values, [None])\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    passed, skipped, failed = reprec.countoutcomes()\n    assert failed == 0, failed\n    assert passed == 2\n    assert passed + skipped + failed == 2\n\n\ndef test_teardown_issue1649(testdir):\n    \"\"\"\n    Are TestCase objects cleaned up? Often unittest TestCase objects set\n    attributes that are large and expensive during setUp.\n\n    The TestCase will not be cleaned up if the test fails, because it\n    would then exist in the stackframe.\n    \"\"\"\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class TestCaseObjectsShouldBeCleanedUp(unittest.TestCase):\n            def setUp(self):\n                self.an_expensive_object = 1\n            def test_demo(self):\n                pass\n\n    \"\"\"\n    )\n    testdir.inline_run(\"-s\", testpath)\n    gc.collect()\n    for obj in gc.get_objects():\n        assert type(obj).__name__ != \"TestCaseObjectsShouldBeCleanedUp\"\n\n\ndef test_unittest_skip_issue148(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n\n        @unittest.skip(\"hello\")\n        class MyTestCase(unittest.TestCase):\n            @classmethod\n            def setUpClass(self):\n                xxx\n            def test_one(self):\n                pass\n            @classmethod\n            def tearDownClass(self):\n                xxx\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    reprec.assertoutcome(skipped=1)\n\n\ndef test_method_and_teardown_failing_reporting(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class TC(unittest.TestCase):\n            def tearDown(self):\n                assert 0, \"down1\"\n            def test_method(self):\n                assert False, \"down2\"\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-s\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        [\n            \"*tearDown*\",\n            \"*assert 0*\",\n            \"*test_method*\",\n            \"*assert False*\",\n            \"*1 failed*1 error*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_setup_failure_is_shown_test_testcase_adderrorandfailure_defers": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_setup_failure_is_shown_test_testcase_adderrorandfailure_defers", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 257, "end_line": 345, "span_ids": ["test_setup_class", "test_setup_failure_is_shown", "test_setup_setUpClass", "test_testcase_adderrorandfailure_defers"], "tokens": 558}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_setup_failure_is_shown(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        import pytest\n        class TC(unittest.TestCase):\n            def setUp(self):\n                assert 0, \"down1\"\n            def test_method(self):\n                print(\"never42\")\n                xyz\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-s\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*setUp*\", \"*assert 0*down1*\", \"*1 failed*\"])\n    result.stdout.no_fnmatch_line(\"*never42*\")\n\n\ndef test_setup_setUpClass(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        import pytest\n        class MyTestCase(unittest.TestCase):\n            x = 0\n            @classmethod\n            def setUpClass(cls):\n                cls.x += 1\n            def test_func1(self):\n                assert self.x == 1\n            def test_func2(self):\n                assert self.x == 1\n            @classmethod\n            def tearDownClass(cls):\n                cls.x -= 1\n        def test_teareddown():\n            assert MyTestCase.x == 0\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    reprec.assertoutcome(passed=3)\n\n\ndef test_setup_class(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        import pytest\n        class MyTestCase(unittest.TestCase):\n            x = 0\n            def setup_class(cls):\n                cls.x += 1\n            def test_func1(self):\n                assert self.x == 1\n            def test_func2(self):\n                assert self.x == 1\n            def teardown_class(cls):\n                cls.x -= 1\n        def test_teareddown():\n            assert MyTestCase.x == 0\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    reprec.assertoutcome(passed=3)\n\n\n@pytest.mark.parametrize(\"type\", [\"Error\", \"Failure\"])\ndef test_testcase_adderrorandfailure_defers(testdir, type):\n    testdir.makepyfile(\n        \"\"\"\n        from unittest import TestCase\n        import pytest\n        class MyTestCase(TestCase):\n            def run(self, result):\n                excinfo = pytest.raises(ZeroDivisionError, lambda: 0/0)\n                try:\n                    result.add%s(self, excinfo._excinfo)\n                except KeyboardInterrupt:\n                    raise\n                except:\n                    pytest.fail(\"add%s should not raise\")\n            def test_hello(self):\n                pass\n    \"\"\"\n        % (type, type)\n    )\n    result = testdir.runpytest()\n    result.stdout.no_fnmatch_line(\"*should not raise*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__builtin_pytest_approx_h_ApproxBase._check_type": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__builtin_pytest_approx_h_ApproxBase._check_type", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 44, "end_line": 98, "span_ids": ["ApproxBase", "ApproxBase.__eq__", "ApproxBase.__init__", "ApproxBase.__ne__", "ApproxBase.__repr__", "ApproxBase._approx_scalar", "ApproxBase._check_type", "ApproxBase._yield_comparisons", "ApproxBase:5", "impl:3"], "tokens": 390}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# builtin pytest.approx helper\n\n\nclass ApproxBase:\n    \"\"\"\n    Provide shared utilities for making approximate comparisons between numbers\n    or sequences of numbers.\n    \"\"\"\n\n    # Tell numpy to use our `__eq__` operator instead of its.\n    __array_ufunc__ = None\n    __array_priority__ = 100\n\n    def __init__(self, expected, rel=None, abs=None, nan_ok=False):\n        __tracebackhide__ = True\n        self.expected = expected\n        self.abs = abs\n        self.rel = rel\n        self.nan_ok = nan_ok\n        self._check_type()\n\n    def __repr__(self):\n        raise NotImplementedError\n\n    def __eq__(self, actual):\n        return all(\n            a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)\n        )\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    def __ne__(self, actual):\n        return not (actual == self)\n\n    def _approx_scalar(self, x):\n        return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n\n    def _yield_comparisons(self, actual):\n        \"\"\"\n        Yield all the pairs of numbers to be compared.  This is used to\n        implement the `__eq__` method.\n        \"\"\"\n        raise NotImplementedError\n\n    def _check_type(self):\n        \"\"\"\n        Raise a TypeError if the expected value is not a valid type.\n        \"\"\"\n        # This is only a concern if the expected value is a sequence.  In every\n        # other case, the approx() function ensures that the expected value has\n        # a numeric type.  For this reason, the default is to do nothing.  The\n        # classes that deal with sequences should reimplement this method to\n        # raise if there are any non-numeric elements in the sequence.\n        pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_allow_bytes_TestLiterals.test_allow_bytes.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_allow_bytes_TestLiterals.test_allow_bytes.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 776, "end_line": 813, "span_ids": ["TestLiterals.test_allow_bytes"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLiterals:\n\n    @pytest.mark.parametrize(\"config_mode\", [\"ini\", \"comment\"])\n    def test_allow_bytes(self, testdir, config_mode):\n        \"\"\"Test that doctests which output bytes work in all python versions\n        tested by pytest when the ALLOW_BYTES option is used (either in\n        the ini file or by an inline comment)(#1287).\n        \"\"\"\n        if config_mode == \"ini\":\n            testdir.makeini(\n                \"\"\"\n            [pytest]\n            doctest_optionflags = ALLOW_BYTES\n            \"\"\"\n            )\n            comment = \"\"\n        else:\n            comment = \"#doctest: +ALLOW_BYTES\"\n\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> b'foo'  {comment}\n            'foo'\n        \"\"\".format(\n                comment=comment\n            )\n        )\n        testdir.makepyfile(\n            foo=\"\"\"\n            def foo():\n              '''\n              >>> b'foo'  {comment}\n              'foo'\n              '''\n        \"\"\".format(\n                comment=comment\n            )\n        )\n        reprec = testdir.inline_run(\"--doctest-modules\")\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestNumberedDir_TestNumberedDir.test_removal_accepts_lock": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestNumberedDir_TestNumberedDir.test_removal_accepts_lock", "embedding": null, "metadata": {"file_path": "testing/test_tmpdir.py", "file_name": "test_tmpdir.py", "file_type": "text/x-python", "category": "test", "start_line": 242, "end_line": 323, "span_ids": ["TestNumberedDir", "TestNumberedDir._do_cleanup", "TestNumberedDir.test_cleanup_ignores_symlink", "TestNumberedDir.test_cleanup_keep", "TestNumberedDir.test_cleanup_lock_create", "TestNumberedDir.test_cleanup_locked", "TestNumberedDir.test_lock_register_cleanup_removal", "TestNumberedDir.test_make", "TestNumberedDir.test_removal_accepts_lock"], "tokens": 540}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNumberedDir:\n    PREFIX = \"fun-\"\n\n    def test_make(self, tmp_path):\n        for i in range(10):\n            d = make_numbered_dir(root=tmp_path, prefix=self.PREFIX)\n            assert d.name.startswith(self.PREFIX)\n            assert d.name.endswith(str(i))\n\n        symlink = tmp_path.joinpath(self.PREFIX + \"current\")\n        if symlink.exists():\n            # unix\n            assert symlink.is_symlink()\n            assert symlink.resolve() == d.resolve()\n\n    def test_cleanup_lock_create(self, tmp_path):\n        d = tmp_path.joinpath(\"test\")\n        d.mkdir()\n        lockfile = create_cleanup_lock(d)\n        with pytest.raises(OSError, match=\"cannot create lockfile in .*\"):\n            create_cleanup_lock(d)\n\n        lockfile.unlink()\n\n    def test_lock_register_cleanup_removal(self, tmp_path):\n        lock = create_cleanup_lock(tmp_path)\n\n        registry = []\n        register_cleanup_lock_removal(lock, register=registry.append)\n\n        (cleanup_func,) = registry\n\n        assert lock.is_file()\n\n        cleanup_func(original_pid=\"intentionally_different\")\n\n        assert lock.is_file()\n\n        cleanup_func()\n\n        assert not lock.exists()\n\n        cleanup_func()\n\n        assert not lock.exists()\n\n    def _do_cleanup(self, tmp_path):\n        self.test_make(tmp_path)\n        cleanup_numbered_dir(\n            root=tmp_path,\n            prefix=self.PREFIX,\n            keep=2,\n            consider_lock_dead_if_created_before=0,\n        )\n\n    def test_cleanup_keep(self, tmp_path):\n        self._do_cleanup(tmp_path)\n        a, b = (x for x in tmp_path.iterdir() if not x.is_symlink())\n        print(a, b)\n\n    def test_cleanup_locked(self, tmp_path):\n        p = make_numbered_dir(root=tmp_path, prefix=self.PREFIX)\n\n        create_cleanup_lock(p)\n\n        assert not pathlib.ensure_deletable(\n            p, consider_lock_dead_if_created_before=p.stat().st_mtime - 1\n        )\n        assert pathlib.ensure_deletable(\n            p, consider_lock_dead_if_created_before=p.stat().st_mtime + 1\n        )\n\n    def test_cleanup_ignores_symlink(self, tmp_path):\n        the_symlink = tmp_path / (self.PREFIX + \"current\")\n        attempt_symlink_to(the_symlink, tmp_path / (self.PREFIX + \"5\"))\n        self._do_cleanup(tmp_path)\n\n    def test_removal_accepts_lock(self, tmp_path):\n        folder = make_numbered_dir(root=tmp_path, prefix=self.PREFIX)\n        create_cleanup_lock(folder)\n        maybe_delete_a_numbered_dir(folder)\n        assert folder.is_dir()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/_themes/flask_theme_support.py__flasky_extensions_fla_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/_themes/flask_theme_support.py__flasky_extensions_fla_", "embedding": null, "metadata": {"file_path": "doc/en/_themes/flask_theme_support.py", "file_name": "flask_theme_support.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 88, "span_ids": ["FlaskyStyle", "docstring"], "tokens": 1256}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# flasky extensions.  flasky pygments style based on tango style\nfrom pygments.style import Style\nfrom pygments.token import Comment\nfrom pygments.token import Error\nfrom pygments.token import Generic\nfrom pygments.token import Keyword\nfrom pygments.token import Literal\nfrom pygments.token import Name\nfrom pygments.token import Number\nfrom pygments.token import Operator\nfrom pygments.token import Other\nfrom pygments.token import Punctuation\nfrom pygments.token import String\nfrom pygments.token import Whitespace\n\n\nclass FlaskyStyle(Style):\n    background_color = \"#f8f8f8\"\n    default_style = \"\"\n\n    styles = {\n        # No corresponding class for the following:\n        # Text:                     \"\", # class:  ''\n        Whitespace: \"underline #f8f8f8\",  # class: 'w'\n        Error: \"#a40000 border:#ef2929\",  # class: 'err'\n        Other: \"#000000\",  # class 'x'\n        Comment: \"italic #8f5902\",  # class: 'c'\n        Comment.Preproc: \"noitalic\",  # class: 'cp'\n        Keyword: \"bold #004461\",  # class: 'k'\n        Keyword.Constant: \"bold #004461\",  # class: 'kc'\n        Keyword.Declaration: \"bold #004461\",  # class: 'kd'\n        Keyword.Namespace: \"bold #004461\",  # class: 'kn'\n        Keyword.Pseudo: \"bold #004461\",  # class: 'kp'\n        Keyword.Reserved: \"bold #004461\",  # class: 'kr'\n        Keyword.Type: \"bold #004461\",  # class: 'kt'\n        Operator: \"#582800\",  # class: 'o'\n        Operator.Word: \"bold #004461\",  # class: 'ow' - like keywords\n        Punctuation: \"bold #000000\",  # class: 'p'\n        # because special names such as Name.Class, Name.Function, etc.\n        # are not recognized as such later in the parsing, we choose them\n        # to look the same as ordinary variables.\n        Name: \"#000000\",  # class: 'n'\n        Name.Attribute: \"#c4a000\",  # class: 'na' - to be revised\n        Name.Builtin: \"#004461\",  # class: 'nb'\n        Name.Builtin.Pseudo: \"#3465a4\",  # class: 'bp'\n        Name.Class: \"#000000\",  # class: 'nc' - to be revised\n        Name.Constant: \"#000000\",  # class: 'no' - to be revised\n        Name.Decorator: \"#888\",  # class: 'nd' - to be revised\n        Name.Entity: \"#ce5c00\",  # class: 'ni'\n        Name.Exception: \"bold #cc0000\",  # class: 'ne'\n        Name.Function: \"#000000\",  # class: 'nf'\n        Name.Property: \"#000000\",  # class: 'py'\n        Name.Label: \"#f57900\",  # class: 'nl'\n        Name.Namespace: \"#000000\",  # class: 'nn' - to be revised\n        Name.Other: \"#000000\",  # class: 'nx'\n        Name.Tag: \"bold #004461\",  # class: 'nt' - like a keyword\n        Name.Variable: \"#000000\",  # class: 'nv' - to be revised\n        Name.Variable.Class: \"#000000\",  # class: 'vc' - to be revised\n        Name.Variable.Global: \"#000000\",  # class: 'vg' - to be revised\n        Name.Variable.Instance: \"#000000\",  # class: 'vi' - to be revised\n        Number: \"#990000\",  # class: 'm'\n        Literal: \"#000000\",  # class: 'l'\n        Literal.Date: \"#000000\",  # class: 'ld'\n        String: \"#4e9a06\",  # class: 's'\n        String.Backtick: \"#4e9a06\",  # class: 'sb'\n        String.Char: \"#4e9a06\",  # class: 'sc'\n        String.Doc: \"italic #8f5902\",  # class: 'sd' - like a comment\n        String.Double: \"#4e9a06\",  # class: 's2'\n        String.Escape: \"#4e9a06\",  # class: 'se'\n        String.Heredoc: \"#4e9a06\",  # class: 'sh'\n        String.Interpol: \"#4e9a06\",  # class: 'si'\n        String.Other: \"#4e9a06\",  # class: 'sx'\n        String.Regex: \"#4e9a06\",  # class: 'sr'\n        String.Single: \"#4e9a06\",  # class: 's1'\n        String.Symbol: \"#4e9a06\",  # class: 'ss'\n        Generic: \"#000000\",  # class: 'g'\n        Generic.Deleted: \"#a40000\",  # class: 'gd'\n        Generic.Emph: \"italic #000000\",  # class: 'ge'\n        Generic.Error: \"#ef2929\",  # class: 'gr'\n        Generic.Heading: \"bold #000080\",  # class: 'gh'\n        Generic.Inserted: \"#00A000\",  # class: 'gi'\n        Generic.Output: \"#888\",  # class: 'go'\n        Generic.Prompt: \"#745334\",  # class: 'gp'\n        Generic.Strong: \"bold #000000\",  # class: 'gs'\n        Generic.Subheading: \"bold #800080\",  # class: 'gu'\n        Generic.Traceback: \"bold #a40000\",  # class: 'gt'\n    }", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py__pytest._code_TestSpecialisedExplanations.test_eq_attrs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/failure_demo.py__pytest._code_TestSpecialisedExplanations.test_eq_attrs", "embedding": null, "metadata": {"file_path": "doc/en/example/assertion/failure_demo.py", "file_name": "failure_demo.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 121, "span_ids": ["TestFailing", "TestFailing.test_not", "TestFailing.test_simple", "TestFailing.test_simple_multiline", "TestSpecialisedExplanations", "TestSpecialisedExplanations.test_eq_attrs", "TestSpecialisedExplanations.test_eq_dataclass", "TestSpecialisedExplanations.test_eq_dict", "TestSpecialisedExplanations.test_eq_list", "TestSpecialisedExplanations.test_eq_list_long", "TestSpecialisedExplanations.test_eq_long_text", "TestSpecialisedExplanations.test_eq_long_text_multiline", "TestSpecialisedExplanations.test_eq_longer_list", "TestSpecialisedExplanations.test_eq_multiline_text", "TestSpecialisedExplanations.test_eq_set", "TestSpecialisedExplanations.test_eq_similar_text", "TestSpecialisedExplanations.test_eq_text", "TestSpecialisedExplanations.test_in_list", "TestSpecialisedExplanations.test_not_in_text_multiline", "TestSpecialisedExplanations.test_not_in_text_single", "TestSpecialisedExplanations.test_not_in_text_single_long", "TestSpecialisedExplanations.test_not_in_text_single_long_term", "imports", "otherfunc", "otherfunc_multi", "somefunc", "test_generative"], "tokens": 815}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import _pytest._code\nimport pytest\nfrom pytest import raises\n\n\ndef otherfunc(a, b):\n    assert a == b\n\n\ndef somefunc(x, y):\n    otherfunc(x, y)\n\n\ndef otherfunc_multi(a, b):\n    assert a == b\n\n\n@pytest.mark.parametrize(\"param1, param2\", [(3, 6)])\ndef test_generative(param1, param2):\n    assert param1 * 2 < param2\n\n\nclass TestFailing:\n    def test_simple(self):\n        def f():\n            return 42\n\n        def g():\n            return 43\n\n        assert f() == g()\n\n    def test_simple_multiline(self):\n        otherfunc_multi(42, 6 * 9)\n\n    def test_not(self):\n        def f():\n            return 42\n\n        assert not f()\n\n\nclass TestSpecialisedExplanations:\n    def test_eq_text(self):\n        assert \"spam\" == \"eggs\"\n\n    def test_eq_similar_text(self):\n        assert \"foo 1 bar\" == \"foo 2 bar\"\n\n    def test_eq_multiline_text(self):\n        assert \"foo\\nspam\\nbar\" == \"foo\\neggs\\nbar\"\n\n    def test_eq_long_text(self):\n        a = \"1\" * 100 + \"a\" + \"2\" * 100\n        b = \"1\" * 100 + \"b\" + \"2\" * 100\n        assert a == b\n\n    def test_eq_long_text_multiline(self):\n        a = \"1\\n\" * 100 + \"a\" + \"2\\n\" * 100\n        b = \"1\\n\" * 100 + \"b\" + \"2\\n\" * 100\n        assert a == b\n\n    def test_eq_list(self):\n        assert [0, 1, 2] == [0, 1, 3]\n\n    def test_eq_list_long(self):\n        a = [0] * 100 + [1] + [3] * 100\n        b = [0] * 100 + [2] + [3] * 100\n        assert a == b\n\n    def test_eq_dict(self):\n        assert {\"a\": 0, \"b\": 1, \"c\": 0} == {\"a\": 0, \"b\": 2, \"d\": 0}\n\n    def test_eq_set(self):\n        assert {0, 10, 11, 12} == {0, 20, 21}\n\n    def test_eq_longer_list(self):\n        assert [1, 2] == [1, 2, 3]\n\n    def test_in_list(self):\n        assert 1 in [0, 2, 3, 4, 5]\n\n    def test_not_in_text_multiline(self):\n        text = \"some multiline\\ntext\\nwhich\\nincludes foo\\nand a\\ntail\"\n        assert \"foo\" not in text\n\n    def test_not_in_text_single(self):\n        text = \"single foo line\"\n        assert \"foo\" not in text\n\n    def test_not_in_text_single_long(self):\n        text = \"head \" * 50 + \"foo \" + \"tail \" * 20\n        assert \"foo\" not in text\n\n    def test_not_in_text_single_long_term(self):\n        text = \"head \" * 50 + \"f\" * 70 + \"tail \" * 20\n        assert \"f\" * 70 not in text\n\n    def test_eq_dataclass(self):\n        from dataclasses import dataclass\n\n        @dataclass\n        class Foo:\n            a: int\n            b: str\n\n        left = Foo(1, \"b\")\n        right = Foo(1, \"c\")\n        assert left == right\n\n    def test_eq_attrs(self):\n        import attr\n\n        @attr.s\n        class Foo:\n            a = attr.ib()\n            b = attr.ib()\n\n        left = Foo(1, \"b\")\n        right = Foo(1, \"c\")\n        assert left == right", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/test_setup_flow_example.py_setup_module_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/assertion/test_setup_flow_example.py_setup_module_", "embedding": null, "metadata": {"file_path": "doc/en/example/assertion/test_setup_flow_example.py", "file_name": "test_setup_flow_example.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 45, "span_ids": ["TestStateFullThing", "TestStateFullThing.setup_class", "TestStateFullThing.setup_method", "TestStateFullThing.teardown_class", "TestStateFullThing.test_23", "TestStateFullThing.test_42", "impl", "setup_module", "teardown_module"], "tokens": 267}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def setup_module(module):\n    module.TestStateFullThing.classcount = 0\n\n\nclass TestStateFullThing:\n    def setup_class(cls):\n        cls.classcount += 1\n\n    def teardown_class(cls):\n        cls.classcount -= 1\n\n    def setup_method(self, method):\n        self.id = eval(method.__name__[5:])\n\n    def test_42(self):\n        assert self.classcount == 1\n        assert self.id == 42\n\n    def test_23(self):\n        assert self.classcount == 1\n        assert self.id == 23\n\n\ndef teardown_module(module):\n    assert module.TestStateFullThing.classcount == 0\n\n\n\"\"\" For this example the control flow happens as follows::\n    import test_setup_flow_example\n    setup_module(test_setup_flow_example)\n       setup_class(TestStateFullThing)\n           instance = TestStateFullThing()\n           setup_method(instance, instance.test_42)\n              instance.test_42()\n           setup_method(instance, instance.test_23)\n              instance.test_23()\n       teardown_class(TestStateFullThing)\n    teardown_module(test_setup_flow_example)\n\nNote that ``setup_class(TestStateFullThing)`` is called and not\n``TestStateFullThing.setup_class()`` which would require you\nto insert ``setup_class = classmethod(setup_class)`` to make\nyour setup function callable.\n\"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/fixtures/test_fixtures_order.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/fixtures/test_fixtures_order.py__", "embedding": null, "metadata": {"file_path": "doc/en/example/fixtures/test_fixtures_order.py", "file_name": "test_fixtures_order.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 39, "span_ids": ["a1", "f1", "f2", "f3", "imports", "m1", "s1", "test_order"], "tokens": 149}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n# fixtures documentation order example\norder = []\n\n\n@pytest.fixture(scope=\"session\")\ndef s1():\n    order.append(\"s1\")\n\n\n@pytest.fixture(scope=\"module\")\ndef m1():\n    order.append(\"m1\")\n\n\n@pytest.fixture\ndef f1(f3):\n    order.append(\"f1\")\n\n\n@pytest.fixture\ndef f3():\n    order.append(\"f3\")\n\n\n@pytest.fixture(autouse=True)\ndef a1():\n    order.append(\"a1\")\n\n\n@pytest.fixture\ndef f2():\n    order.append(\"f2\")\n\n\ndef test_order(f1, m1, f2, s1):\n    assert order == [\"s1\", \"m1\", \"a1\", \"f3\", \"f1\", \"f2\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/multipython.py___": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/multipython.py___", "embedding": null, "metadata": {"file_path": "doc/en/example/multipython.py", "file_name": "multipython.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 73, "span_ids": ["Python", "Python.__init__", "Python.dumps", "Python.load_and_is_true", "docstring", "python1", "python2", "test_basic_objects"], "tokens": 429}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nmodule containing a parametrized tests testing cross-python\nserialization via the pickle module.\n\"\"\"\nimport shutil\nimport subprocess\nimport textwrap\n\nimport pytest\n\npythonlist = [\"python3.5\", \"python3.6\", \"python3.7\"]\n\n\n@pytest.fixture(params=pythonlist)\ndef python1(request, tmpdir):\n    picklefile = tmpdir.join(\"data.pickle\")\n    return Python(request.param, picklefile)\n\n\n@pytest.fixture(params=pythonlist)\ndef python2(request, python1):\n    return Python(request.param, python1.picklefile)\n\n\nclass Python:\n    def __init__(self, version, picklefile):\n        self.pythonpath = shutil.which(version)\n        if not self.pythonpath:\n            pytest.skip(\"{!r} not found\".format(version))\n        self.picklefile = picklefile\n\n    def dumps(self, obj):\n        dumpfile = self.picklefile.dirpath(\"dump.py\")\n        dumpfile.write(\n            textwrap.dedent(\n                r\"\"\"\n                import pickle\n                f = open({!r}, 'wb')\n                s = pickle.dump({!r}, f, protocol=2)\n                f.close()\n                \"\"\".format(\n                    str(self.picklefile), obj\n                )\n            )\n        )\n        subprocess.check_call((self.pythonpath, str(dumpfile)))\n\n    def load_and_is_true(self, expression):\n        loadfile = self.picklefile.dirpath(\"load.py\")\n        loadfile.write(\n            textwrap.dedent(\n                r\"\"\"\n                import pickle\n                f = open({!r}, 'rb')\n                obj = pickle.load(f)\n                f.close()\n                res = eval({!r})\n                if not res:\n                    raise SystemExit(1)\n                \"\"\".format(\n                    str(self.picklefile), expression\n                )\n            )\n        )\n        print(loadfile)\n        subprocess.check_call((self.pythonpath, str(loadfile)))\n\n\n@pytest.mark.parametrize(\"obj\", [42, {}, {1: 3}])\ndef test_basic_objects(python1, python2, obj):\n    python1.dumps(obj)\n    python2.load_and_is_true(\"obj == {}\".format(obj))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/nonpython/conftest.py__content_of_conftest_py_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/example/nonpython/conftest.py__content_of_conftest_py_", "embedding": null, "metadata": {"file_path": "doc/en/example/nonpython/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 47, "span_ids": ["YamlException", "YamlFile", "YamlFile.collect", "YamlItem", "YamlItem.__init__", "YamlItem.reportinfo", "YamlItem.repr_failure", "YamlItem.runtest", "docstring", "pytest_collect_file"], "tokens": 314}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# content of conftest.py\nimport pytest\n\n\ndef pytest_collect_file(parent, path):\n    if path.ext == \".yaml\" and path.basename.startswith(\"test\"):\n        return YamlFile.from_parent(parent, fspath=path)\n\n\nclass YamlFile(pytest.File):\n    def collect(self):\n        import yaml  # we need a yaml parser, e.g. PyYAML\n\n        raw = yaml.safe_load(self.fspath.open())\n        for name, spec in sorted(raw.items()):\n            yield YamlItem.from_parent(self, name=name, spec=spec)\n\n\nclass YamlItem(pytest.Item):\n    def __init__(self, name, parent, spec):\n        super().__init__(name, parent)\n        self.spec = spec\n\n    def runtest(self):\n        for name, value in sorted(self.spec.items()):\n            # some custom test execution (dumb example follows)\n            if name != value:\n                raise YamlException(self, name, value)\n\n    def repr_failure(self, excinfo):\n        \"\"\" called when self.runtest() raises an exception. \"\"\"\n        if isinstance(excinfo.value, YamlException):\n            return \"\\n\".join(\n                [\n                    \"usecase execution failed\",\n                    \"   spec failed: {1!r}: {2!r}\".format(*excinfo.value.args),\n                    \"   no further details known at this point.\",\n                ]\n            )\n\n    def reportinfo(self):\n        return self.fspath, 0, \"usecase: {}\".format(self.name)\n\n\nclass YamlException(Exception):\n    \"\"\" custom exception for error reporting. \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/extra/get_issues.py_json_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/extra/get_issues.py_json_", "embedding": null, "metadata": {"file_path": "extra/get_issues.py", "file_name": "get_issues.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 86, "span_ids": ["_get_kind", "get_issues", "impl:2", "imports", "main", "report"], "tokens": 539}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import json\n\nimport py\nimport requests\n\nissues_url = \"https://api.github.com/repos/pytest-dev/pytest/issues\"\n\n\ndef get_issues():\n    issues = []\n    url = issues_url\n    while 1:\n        get_data = {\"state\": \"all\"}\n        r = requests.get(url, params=get_data)\n        data = r.json()\n        if r.status_code == 403:\n            # API request limit exceeded\n            print(data[\"message\"])\n            exit(1)\n        issues.extend(data)\n\n        # Look for next page\n        links = requests.utils.parse_header_links(r.headers[\"Link\"])\n        another_page = False\n        for link in links:\n            if link[\"rel\"] == \"next\":\n                url = link[\"url\"]\n                another_page = True\n        if not another_page:\n            return issues\n\n\ndef main(args):\n    cachefile = py.path.local(args.cache)\n    if not cachefile.exists() or args.refresh:\n        issues = get_issues()\n        cachefile.write(json.dumps(issues))\n    else:\n        issues = json.loads(cachefile.read())\n\n    open_issues = [x for x in issues if x[\"state\"] == \"open\"]\n\n    open_issues.sort(key=lambda x: x[\"number\"])\n    report(open_issues)\n\n\ndef _get_kind(issue):\n    labels = [l[\"name\"] for l in issue[\"labels\"]]\n    for key in (\"bug\", \"enhancement\", \"proposal\"):\n        if key in labels:\n            return key\n    return \"issue\"\n\n\ndef report(issues):\n    for issue in issues:\n        title = issue[\"title\"]\n        # body = issue[\"body\"]\n        kind = _get_kind(issue)\n        status = issue[\"state\"]\n        number = issue[\"number\"]\n        link = \"https://github.com/pytest-dev/pytest/issues/%s/\" % number\n        print(\"----\")\n        print(status, kind, link)\n        print(title)\n        # print()\n        # lines = body.split(\"\\n\")\n        # print(\"\\n\".join(lines[:3]))\n        # if len(lines) > 3 or len(body) > 240:\n        #    print(\"...\")\n    print(\"\\n\\nFound %s open issues\" % len(issues))\n\n\nif __name__ == \"__main__\":\n    import argparse\n\n    parser = argparse.ArgumentParser(\"process bitbucket issues\")\n    parser.add_argument(\n        \"--refresh\", action=\"store_true\", help=\"invalidate cache, refresh issues\"\n    )\n    parser.add_argument(\n        \"--cache\", action=\"store\", default=\"issues.json\", help=\"cache file\"\n    )\n    args = parser.parse_args()\n    main(args)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release.py___announce.check_call_git_add_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release.py___announce.check_call_git_add_", "embedding": null, "metadata": {"file_path": "scripts/release.py", "file_name": "release.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 65, "span_ids": ["announce", "docstring"], "tokens": 466}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nInvoke development tasks.\n\"\"\"\nimport argparse\nfrom pathlib import Path\nfrom subprocess import call\nfrom subprocess import check_call\nfrom subprocess import check_output\n\nfrom colorama import Fore\nfrom colorama import init\n\n\ndef announce(version):\n    \"\"\"Generates a new release announcement entry in the docs.\"\"\"\n    stdout = check_output([\"git\", \"describe\", \"--abbrev=0\", \"--tags\"])\n    stdout = stdout.decode(\"utf-8\")\n    last_version = stdout.strip()\n\n    stdout = check_output(\n        [\"git\", \"log\", \"{}..HEAD\".format(last_version), \"--format=%aN\"]\n    )\n    stdout = stdout.decode(\"utf-8\")\n\n    contributors = set(stdout.splitlines())\n\n    template_name = (\n        \"release.minor.rst\" if version.endswith(\".0\") else \"release.patch.rst\"\n    )\n    template_text = (\n        Path(__file__).parent.joinpath(template_name).read_text(encoding=\"UTF-8\")\n    )\n\n    contributors_text = (\n        \"\\n\".join(\"* {}\".format(name) for name in sorted(contributors)) + \"\\n\"\n    )\n    text = template_text.format(version=version, contributors=contributors_text)\n\n    target = Path(__file__).parent.joinpath(\n        \"../doc/en/announce/release-{}.rst\".format(version)\n    )\n    target.write_text(text, encoding=\"UTF-8\")\n    print(f\"{Fore.CYAN}[generate.announce] {Fore.RESET}Generated {target.name}\")\n\n    # Update index with the new release entry\n    index_path = Path(__file__).parent.joinpath(\"../doc/en/announce/index.rst\")\n    lines = index_path.read_text(encoding=\"UTF-8\").splitlines()\n    indent = \"   \"\n    for index, line in enumerate(lines):\n        if line.startswith(\"{}release-\".format(indent)):\n            new_line = indent + target.stem\n            if line != new_line:\n                lines.insert(index, new_line)\n                index_path.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"UTF-8\")\n                print(\n                    f\"{Fore.CYAN}[generate.announce] {Fore.RESET}Updated {index_path.name}\"\n                )\n            else:\n                print(\n                    f\"{Fore.CYAN}[generate.announce] {Fore.RESET}Skip {index_path.name} (already contains release)\"\n                )\n            break\n\n    check_call([\"git\", \"add\", str(target)])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/setup.py_from_setuptools_import_se_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/setup.py_from_setuptools_import_se_", "embedding": null, "metadata": {"file_path": "setup.py", "file_name": "setup.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 43, "span_ids": ["impl:2", "imports", "main"], "tokens": 308}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from setuptools import setup\n\n# TODO: if py gets upgrade to >=1.6,\n#       remove _width_of_current_line in terminal.py\nINSTALL_REQUIRES = [\n    \"py>=1.5.0\",\n    \"packaging\",\n    \"attrs>=17.4.0\",  # should match oldattrs tox env.\n    \"more-itertools>=4.0.0\",\n    'atomicwrites>=1.0;sys_platform==\"win32\"',\n    'pathlib2>=2.2.0;python_version<\"3.6\"',\n    'colorama;sys_platform==\"win32\"',\n    \"pluggy>=0.12,<1.0\",\n    'importlib-metadata>=0.12;python_version<\"3.8\"',\n    \"wcwidth\",\n]\n\n\ndef main():\n    setup(\n        use_scm_version={\"write_to\": \"src/_pytest/_version.py\"},\n        setup_requires=[\"setuptools-scm\", \"setuptools>=40.0\"],\n        package_dir={\"\": \"src\"},\n        extras_require={\n            \"testing\": [\n                \"argcomplete\",\n                \"hypothesis>=3.56\",\n                \"mock\",\n                \"nose\",\n                \"requests\",\n                \"xmlschema\",\n            ],\n            \"checkqa-mypy\": [\n                \"mypy==v0.770\",  # keep this in sync with .pre-commit-config.yaml.\n            ],\n        },\n        install_requires=INSTALL_REQUIRES,\n    )\n\n\nif __name__ == \"__main__\":\n    main()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback.recursionindex__E": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback.recursionindex__E", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 386, "end_line": 420, "span_ids": ["Traceback.recursionindex", "impl:2"], "tokens": 271}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Traceback(List[TracebackEntry]):\n\n    def recursionindex(self) -> Optional[int]:\n        \"\"\" return the index of the frame/TracebackEntry where recursion\n            originates if appropriate, None if no recursion occurred\n        \"\"\"\n        cache = {}  # type: Dict[Tuple[Any, int, int], List[Dict[str, Any]]]\n        for i, entry in enumerate(self):\n            # id for the code.raw is needed to work around\n            # the strange metaprogramming in the decorator lib from pypi\n            # which generates code objects that have hash/value equality\n            # XXX needs a test\n            key = entry.frame.code.path, id(entry.frame.code.raw), entry.lineno\n            # print \"checking for recursion at\", key\n            values = cache.setdefault(key, [])\n            if values:\n                f = entry.frame\n                loc = f.f_locals\n                for otherloc in values:\n                    if f.is_true(\n                        f.eval(\n                            co_equal,\n                            __recursioncache_locals_1=loc,\n                            __recursioncache_locals_2=otherloc,\n                        )\n                    ):\n                        return i\n            values.append(entry.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo_ExceptionInfo.tb": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo_ExceptionInfo.tb", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 423, "end_line": 517, "span_ids": ["ExceptionInfo", "ExceptionInfo.fill_unfilled", "ExceptionInfo.for_later", "ExceptionInfo.from_current", "ExceptionInfo.from_exc_info", "ExceptionInfo.tb", "ExceptionInfo.type", "ExceptionInfo.value"], "tokens": 728}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, default=\"\")\n    _traceback = attr.ib(type=Optional[Traceback], default=None)\n\n    @classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)\n\n    @classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return ExceptionInfo.from_exc_info(exc_info, exprinfo)\n\n    @classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info\n\n    @property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]\n\n    @property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo.typename_ExceptionInfo._getreprcrash": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo.typename_ExceptionInfo._getreprcrash", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 519, "end_line": 571, "span_ids": ["ExceptionInfo.__repr__", "ExceptionInfo._getreprcrash", "ExceptionInfo.errisinstance", "ExceptionInfo.exconly", "ExceptionInfo.traceback", "ExceptionInfo.traceback_9", "ExceptionInfo.typename"], "tokens": 449}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n\n    @property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__\n\n    @property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value\n\n    def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<{} {} tblen={}>\".format(\n            self.__class__.__name__, saferepr(self._excinfo[1]), len(self.traceback)\n        )\n\n    def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo.getrepr_ExceptionInfo.match": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ExceptionInfo.getrepr_ExceptionInfo.match", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 573, "end_line": 644, "span_ids": ["ExceptionInfo.getrepr", "ExceptionInfo.match"], "tokens": 524}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n\n    def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def match(self, regexp: \"Union[str, Pattern]\") -> \"Literal[True]\":\n        \"\"\"\n        Check whether the regular expression `regexp` matches the string\n        representation of the exception using :func:`python:re.search`.\n        If it matches `True` is returned.\n        If it doesn't match an `AssertionError` is raised.\n        \"\"\"\n        __tracebackhide__ = True\n        assert re.search(\n            regexp, str(self.value)\n        ), \"Pattern {!r} does not match {!r}\".format(regexp, str(self.value))\n        # Return True to allow for \"assert excinfo.match()\".\n        return True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_excinfo_FormattedExcinfo.repr_excinfo.return_ExceptionChainRepr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_excinfo_FormattedExcinfo.repr_excinfo.return_ExceptionChainRepr", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 860, "end_line": 903, "span_ids": ["FormattedExcinfo.repr_excinfo"], "tokens": 384}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass FormattedExcinfo:\n\n    def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook.find_spec_AssertionRewritingHook.create_module": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook.find_spec_AssertionRewritingHook.create_module", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 74, "end_line": 112, "span_ids": ["AssertionRewritingHook.create_module", "AssertionRewritingHook.find_spec"], "tokens": 282}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def find_spec(self, name, path=None, target=None):\n        if self._writing_pyc:\n            return None\n        state = self.config._store[assertstate_key]\n        if self._early_rewrite_bailout(name, state):\n            return None\n        state.trace(\"find_module called for: %s\" % name)\n\n        spec = self._find_spec(name, path)\n        if (\n            # the import machinery could not find a file to import\n            spec is None\n            # this is a namespace package (without `__init__.py`)\n            # there's nothing to rewrite there\n            # python3.5 - python3.6: `namespace`\n            # python3.7+: `None`\n            or spec.origin == \"namespace\"\n            or spec.origin is None\n            # we can only rewrite source files\n            or not isinstance(spec.loader, importlib.machinery.SourceFileLoader)\n            # if the file doesn't exist, we can't rewrite it\n            or not os.path.exists(spec.origin)\n        ):\n            return None\n        else:\n            fn = spec.origin\n\n        if not self._should_rewrite(name, fn, state):\n            return None\n\n        return importlib.util.spec_from_file_location(\n            name,\n            fn,\n            loader=self,\n            submodule_search_locations=spec.submodule_search_locations,\n        )\n\n    def create_module(self, spec):\n        return None  # default behaviour is fine", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook.exec_module_AssertionRewritingHook.exec_module.exec_co_module___dict___": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook.exec_module_AssertionRewritingHook.exec_module.exec_co_module___dict___", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 114, "end_line": 152, "span_ids": ["AssertionRewritingHook.exec_module"], "tokens": 369}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def exec_module(self, module):\n        fn = Path(module.__spec__.origin)\n        state = self.config._store[assertstate_key]\n\n        self._rewritten_names.add(module.__name__)\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(\"read only directory: {}\".format(cache_dir))\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(\"rewriting {!r}\".format(fn))\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(\"found cached rewritten pyc for {}\".format(fn))\n        exec(co, module.__dict__)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook._should_rewrite_AssertionRewritingHook.get_data": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook._should_rewrite_AssertionRewritingHook.get_data", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 193, "end_line": 264, "span_ids": ["AssertionRewritingHook._is_marked_for_rewrite", "AssertionRewritingHook._should_rewrite", "AssertionRewritingHook._warn_already_imported", "AssertionRewritingHook.get_data", "AssertionRewritingHook.mark_rewrite"], "tokens": 550}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n\n    def _should_rewrite(self, name, fn, state):\n        # always rewrite conftest files\n        if os.path.basename(fn) == \"conftest.py\":\n            state.trace(\"rewriting conftest file: {!r}\".format(fn))\n            return True\n\n        if self.session is not None:\n            if self.session.isinitpath(fn):\n                state.trace(\n                    \"matched test file (was specified on cmdline): {!r}\".format(fn)\n                )\n                return True\n\n        # modules not passed explicitly on the command line are only\n        # rewritten if they match the naming convention for test files\n        fn_path = PurePath(fn)\n        for pat in self.fnpats:\n            if fnmatch_ex(pat, fn_path):\n                state.trace(\"matched test file {!r}\".format(fn))\n                return True\n\n        return self._is_marked_for_rewrite(name, state)\n\n    def _is_marked_for_rewrite(self, name: str, state):\n        try:\n            return self._marked_for_rewrite_cache[name]\n        except KeyError:\n            for marked in self._must_rewrite:\n                if name == marked or name.startswith(marked + \".\"):\n                    state.trace(\n                        \"matched marked file {!r} (from {!r})\".format(name, marked)\n                    )\n                    self._marked_for_rewrite_cache[name] = True\n                    return True\n\n            self._marked_for_rewrite_cache[name] = False\n            return False\n\n    def mark_rewrite(self, *names: str) -> None:\n        \"\"\"Mark import names as needing to be rewritten.\n\n        The named module or package as well as any nested modules will\n        be rewritten on import.\n        \"\"\"\n        already_imported = (\n            set(names).intersection(sys.modules).difference(self._rewritten_names)\n        )\n        for name in already_imported:\n            mod = sys.modules[name]\n            if not AssertionRewriter.is_rewrite_disabled(\n                mod.__doc__ or \"\"\n            ) and not isinstance(mod.__loader__, type(self)):\n                self._warn_already_imported(name)\n        self._must_rewrite.update(names)\n        self._marked_for_rewrite_cache.clear()\n\n    def _warn_already_imported(self, name):\n        from _pytest.warning_types import PytestAssertRewriteWarning\n        from _pytest.warnings import _issue_warning_captured\n\n        _issue_warning_captured(\n            PytestAssertRewriteWarning(\n                \"Module already imported so cannot be rewritten: %s\" % name\n            ),\n            self.config.hook,\n            stacklevel=5,\n        )\n\n    def get_data(self, pathname):\n        \"\"\"Optional PEP302 get_data API.\"\"\"\n        with open(pathname, \"rb\") as f:\n            return f.read()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__read_pyc__read_pyc.with_fp_.return_co": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__read_pyc__read_pyc.with_fp_.return_co", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 334, "end_line": 368, "span_ids": ["_read_pyc"], "tokens": 279}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _read_pyc(source, pyc, trace=lambda x: None):\n    \"\"\"Possibly read a pytest pyc containing rewritten code.\n\n    Return rewritten code if successful or None if not.\n    \"\"\"\n    try:\n        fp = open(fspath(pyc), \"rb\")\n    except OSError:\n        return None\n    with fp:\n        try:\n            stat_result = os.stat(fspath(source))\n            mtime = int(stat_result.st_mtime)\n            size = stat_result.st_size\n            data = fp.read(12)\n        except OSError as e:\n            trace(\"_read_pyc({}): OSError {}\".format(source, e))\n            return None\n        # Check for invalid or out of date pyc file.\n        if (\n            len(data) != 12\n            or data[:4] != importlib.util.MAGIC_NUMBER\n            or struct.unpack(\"<LL\", data[4:]) != (mtime & 0xFFFFFFFF, size & 0xFFFFFFFF)\n        ):\n            trace(\"_read_pyc(%s): invalid or out of date pyc\" % source)\n            return None\n        try:\n            co = marshal.load(fp)\n        except Exception as e:\n            trace(\"_read_pyc({}): marshal.load error {}\".format(source, e))\n            return None\n        if not isinstance(co, types.CodeType):\n            trace(\"_read_pyc(%s): not a code object\" % source)\n            return None\n        return co", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_rewrite_asserts_UNARY_MAP": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_rewrite_asserts_UNARY_MAP", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 371, "end_line": 460, "span_ids": ["_call_assertion_pass", "_call_reprcompare", "_check_if_assertion_pass_impl", "_format_assertmsg", "_format_boolop", "_saferepr", "_should_repr_global_name", "impl:9", "rewrite_asserts"], "tokens": 732}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def rewrite_asserts(mod, source, module_path=None, config=None):\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config, source).run(mod)\n\n\ndef _saferepr(obj):\n    \"\"\"Get a safe repr of an object for assertion error messages.\n\n    The assertion formatting (util.format_explanation()) requires\n    newlines to be escaped since they are a special character for it.\n    Normally assertion.util.format_explanation() does this but for a\n    custom repr it is possible to contain one of the special escape\n    sequences, especially '\\n{' and '\\n}' are likely to be present in\n    JSON reprs.\n\n    \"\"\"\n    return saferepr(obj).replace(\"\\n\", \"\\\\n\")\n\n\ndef _format_assertmsg(obj):\n    \"\"\"Format the custom assertion message given.\n\n    For strings this simply replaces newlines with '\\n~' so that\n    util.format_explanation() will preserve them instead of escaping\n    newlines.  For other objects saferepr() is used first.\n\n    \"\"\"\n    # reprlib appears to have a bug which means that if a string\n    # contains a newline it gets escaped, however if an object has a\n    # .__repr__() which contains newlines it does not get escaped.\n    # However in either case we want to preserve the newline.\n    replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n    if not isinstance(obj, str):\n        obj = saferepr(obj)\n        replaces.append((\"\\\\n\", \"\\n~\"))\n\n    for r1, r2 in replaces:\n        obj = obj.replace(r1, r2)\n\n    return obj\n\n\ndef _should_repr_global_name(obj):\n    if callable(obj):\n        return False\n\n    try:\n        return not hasattr(obj, \"__name__\")\n    except Exception:\n        return True\n\n\ndef _format_boolop(explanations, is_or):\n    explanation = \"(\" + (is_or and \" or \" or \" and \").join(explanations) + \")\"\n    if isinstance(explanation, str):\n        return explanation.replace(\"%\", \"%%\")\n    else:\n        return explanation.replace(b\"%\", b\"%%\")\n\n\ndef _call_reprcompare(ops, results, expls, each_obj):\n    # type: (Tuple[str, ...], Tuple[bool, ...], Tuple[str, ...], Tuple[object, ...]) -> str\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl\n\n\ndef _call_assertion_pass(lineno, orig, expl):\n    # type: (int, str, str) -> None\n    if util._assertion_pass is not None:\n        util._assertion_pass(lineno, orig, expl)\n\n\ndef _check_if_assertion_pass_impl():\n    # type: () -> bool\n    \"\"\"Checks if any plugins implement the pytest_assertion_pass hook\n    in order not to generate explanation unecessarily (might be expensive)\"\"\"\n    return True if util._assertion_pass else False\n\n\nUNARY_MAP = {ast.Not: \"not %s\", ast.Invert: \"~%s\", ast.USub: \"-%s\", ast.UAdd: \"+%s\"}", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_BINOP_MAP_set_location": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_BINOP_MAP_set_location", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 462, "end_line": 501, "span_ids": ["impl:9", "set_location"], "tokens": 279}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "BINOP_MAP = {\n    ast.BitOr: \"|\",\n    ast.BitXor: \"^\",\n    ast.BitAnd: \"&\",\n    ast.LShift: \"<<\",\n    ast.RShift: \">>\",\n    ast.Add: \"+\",\n    ast.Sub: \"-\",\n    ast.Mult: \"*\",\n    ast.Div: \"/\",\n    ast.FloorDiv: \"//\",\n    ast.Mod: \"%%\",  # escaped for string formatting\n    ast.Eq: \"==\",\n    ast.NotEq: \"!=\",\n    ast.Lt: \"<\",\n    ast.LtE: \"<=\",\n    ast.Gt: \">\",\n    ast.GtE: \">=\",\n    ast.Pow: \"**\",\n    ast.Is: \"is\",\n    ast.IsNot: \"is not\",\n    ast.In: \"in\",\n    ast.NotIn: \"not in\",\n    ast.MatMult: \"@\",\n}\n\n\ndef set_location(node, lineno, col_offset):\n    \"\"\"Set node location information recursively.\"\"\"\n\n    def _fix(node, lineno, col_offset):\n        if \"lineno\" in node._attributes:\n            node.lineno = lineno\n        if \"col_offset\" in node._attributes:\n            node.col_offset = col_offset\n        for child in ast.iter_child_nodes(node):\n            _fix(child, lineno, col_offset)\n\n    _fix(node, lineno, col_offset)\n    return node", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__get_assertion_exprs__get_assertion_exprs.return_ret": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__get_assertion_exprs__get_assertion_exprs.return_ret", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 453, "end_line": 504, "span_ids": ["_get_assertion_exprs"], "tokens": 446}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n    \"\"\"Returns a mapping from {lineno: \"assertion test expression\"}\"\"\"\n    ret = {}  # type: Dict[int, str]\n\n    depth = 0\n    lines = []  # type: List[str]\n    assert_lineno = None  # type: Optional[int]\n    seen_lines = set()  # type: Set[int]\n\n    def _write_and_reset() -> None:\n        nonlocal depth, lines, assert_lineno, seen_lines\n        assert assert_lineno is not None\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n        depth = 0\n        lines = []\n        assert_lineno = None\n        seen_lines = set()\n\n    tokens = tokenize.tokenize(io.BytesIO(src).readline)\n    for tp, source, (lineno, offset), _, line in tokens:\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # keep track of depth for the assert-message `,` lookup\n            if tp == tokenize.OP and source in \"([{\":\n                depth += 1\n            elif tp == tokenize.OP and source in \")]}\":\n                depth -= 1\n\n            if not lines:\n                lines.append(line[offset:])\n                seen_lines.add(lineno)\n            # a non-nested comma separates the expression from the message\n            elif depth == 0 and tp == tokenize.OP and source == \",\":\n                # one line assert with message\n                if lineno in seen_lines and len(lines) == 1:\n                    offset_in_trimmed = offset + len(lines[-1]) - len(line)\n                    lines[-1] = lines[-1][:offset_in_trimmed]\n                # multi-line assert with message\n                elif lineno in seen_lines:\n                    lines[-1] = lines[-1][:offset]\n                # multi line assert with escapd newline before message\n                else:\n                    lines.append(line[:offset])\n                _write_and_reset()\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n            elif lines and lineno not in seen_lines:\n                lines.append(line)\n                seen_lines.add(lineno)\n\n    return ret", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter_AssertionRewriter._assert_expr_to_lineno": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter_AssertionRewriter._assert_expr_to_lineno", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 507, "end_line": 575, "span_ids": ["AssertionRewriter", "AssertionRewriter.__init__", "AssertionRewriter._assert_expr_to_lineno"], "tokens": 642}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false and calls pytest_assertion_pass hook\n    if expression is true.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :expl_stmts: The AST statements which will be executed to get\n       data from the assertion.  This is the code which will construct\n       the detailed assertion message that is used in the AssertionError\n       or for the pytest_assertion_pass hook.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    This state is reset on every new assert statement visited and used\n    by the other visitors.\n\n    \"\"\"\n\n    def __init__(self, module_path, config, source):\n        super().__init__()\n        self.module_path = module_path\n        self.config = config\n        if config is not None:\n            self.enable_assertion_pass_hook = config.getini(\n                \"enable_assertion_pass_hook\"\n            )\n        else:\n            self.enable_assertion_pass_hook = False\n        self.source = source\n\n    @functools.lru_cache(maxsize=1)\n    def _assert_expr_to_lineno(self):\n        return _get_assertion_exprs(self.source)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.is_rewrite_disabled_AssertionRewriter.push_format_context": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.is_rewrite_disabled_AssertionRewriter.push_format_context", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 647, "end_line": 704, "span_ids": ["AssertionRewriter.assign", "AssertionRewriter.builtin", "AssertionRewriter.display", "AssertionRewriter.explanation_param", "AssertionRewriter.helper", "AssertionRewriter.is_rewrite_disabled", "AssertionRewriter.push_format_context", "AssertionRewriter.variable"], "tokens": 482}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    @staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring\n\n    def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name\n\n    def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())\n\n    def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)\n\n    def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast.Call(attr, list(args), [])\n\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n\n    def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"\n\n    def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}  # type: Dict[str, ast.expr]\n        self.stack.append(self.explanation_specifiers)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.pop_format_context_AssertionRewriter.generic_visit": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.pop_format_context_AssertionRewriter.generic_visit", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 701, "end_line": 726, "span_ids": ["AssertionRewriter.generic_visit", "AssertionRewriter.pop_format_context"], "tokens": 250}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .expl_stmts and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        if self.enable_assertion_pass_hook:\n            self.format_variables.append(name)\n        self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_UnaryOp_AssertionRewriter.visit_Attribute": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_UnaryOp_AssertionRewriter.visit_Attribute", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 919, "end_line": 974, "span_ids": ["AssertionRewriter.visit_Attribute", "AssertionRewriter.visit_BinOp", "AssertionRewriter.visit_Call", "AssertionRewriter.visit_Starred", "AssertionRewriter.visit_UnaryOp"], "tokens": 558}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_UnaryOp(self, unary):\n        pattern = UNARY_MAP[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)\n\n    def visit_BinOp(self, binop):\n        symbol = BINOP_MAP[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"({} {} {})\".format(left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation\n\n    def visit_Call(self, call):\n        \"\"\"\n        visit `ast.Call` nodes\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"{}({})\".format(func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"{}\\n{{{} = {}\\n}}\".format(res_expl, res_expl, expl)\n        return res, outer_expl\n\n    def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl\n\n    def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/truncate.py____running_on_ci": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/truncate.py____running_on_ci", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/truncate.py", "file_name": "truncate.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 34, "span_ids": ["_running_on_ci", "_should_truncate_item", "docstring", "truncate_if_required"], "tokens": 205}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nUtilities for truncating assertion output.\n\nCurrent default behaviour is to truncate assertion explanations at\n~8 terminal lines, unless running in \"-vv\" mode or running on CI.\n\"\"\"\nimport os\n\nDEFAULT_MAX_LINES = 8\nDEFAULT_MAX_CHARS = 8 * 80\nUSAGE_MSG = \"use '-vv' to show\"\n\n\ndef truncate_if_required(explanation, item, max_length=None):\n    \"\"\"\n    Truncate this assertion explanation if the given test item is eligible.\n    \"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation\n\n\ndef _should_truncate_item(item):\n    \"\"\"\n    Whether or not this test item is eligible for truncation.\n    \"\"\"\n    verbose = item.config.option.verbose\n    return verbose < 2 and not _running_on_ci()\n\n\ndef _running_on_ci():\n    \"\"\"Check if we're currently running on a CI system.\"\"\"\n    env_vars = [\"CI\", \"BUILD_NUMBER\"]\n    return any(var in os.environ for var in env_vars)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__Utilities_for_assertio__split_explanation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__Utilities_for_assertio__split_explanation", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 61, "span_ids": ["_split_explanation", "docstring", "format_explanation"], "tokens": 494}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Utilities for assertion debugging\"\"\"\nimport collections.abc\nimport pprint\nfrom typing import AbstractSet\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\n\nimport _pytest._code\nfrom _pytest import outcomes\nfrom _pytest._io.saferepr import _pformat_dispatch\nfrom _pytest._io.saferepr import safeformat\nfrom _pytest._io.saferepr import saferepr\nfrom _pytest.compat import ATTRS_EQ_FIELD\n\n# The _reprcompare attribute on the util module is used by the new assertion\n# interpretation code and assertion rewriter to detect this plugin was\n# loaded and in turn call the hooks defined here as part of the\n# DebugInterpreter.\n_reprcompare = None  # type: Optional[Callable[[str, object, object], Optional[str]]]\n\n# Works similarly as _reprcompare attribute. Is populated with the hook call\n# when pytest_runtest_setup is called.\n_assertion_pass = None  # type: Optional[Callable[[int, str, str], None]]\n\n\ndef format_explanation(explanation: str) -> str:\n    \"\"\"This formats an explanation\n\n    Normally all embedded newlines are escaped, however there are\n    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n    cover nested explanations, see function and attribute explanations\n    for examples (.visit_Call(), visit_Attribute()).  The last one is\n    for when one explanation needs to span multiple lines, e.g. when\n    displaying diffs.\n    \"\"\"\n    lines = _split_explanation(explanation)\n    result = _format_lines(lines)\n    return \"\\n\".join(result)\n\n\ndef _split_explanation(explanation: str) -> List[str]:\n    \"\"\"Return a list of individual lines in the explanation\n\n    This will return a list of lines split on '\\n{', '\\n}' and '\\n~'.\n    Any other newlines will be escaped and appear in the line as the\n    literal '\\n' characters.\n    \"\"\"\n    raw_lines = (explanation or \"\").split(\"\\n\")\n    lines = [raw_lines[0]]\n    for values in raw_lines[1:]:\n        if values and values[0] in [\"{\", \"}\", \"~\", \">\"]:\n            lines.append(values)\n        else:\n            lines[-1] += \"\\\\n\" + values\n    return lines", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_set__compare_eq_dict.return_explanation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_set__compare_eq_dict.return_explanation", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 350, "end_line": 405, "span_ids": ["_compare_eq_dict", "_compare_eq_set"], "tokens": 486}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _compare_eq_set(\n    left: AbstractSet[Any], right: AbstractSet[Any], verbose: int = 0\n) -> List[str]:\n    explanation = []\n    diff_left = left - right\n    diff_right = right - left\n    if diff_left:\n        explanation.append(\"Extra items in the left set:\")\n        for item in diff_left:\n            explanation.append(saferepr(item))\n    if diff_right:\n        explanation.append(\"Extra items in the right set:\")\n        for item in diff_right:\n            explanation.append(saferepr(item))\n    return explanation\n\n\ndef _compare_eq_dict(\n    left: Mapping[Any, Any], right: Mapping[Any, Any], verbose: int = 0\n) -> List[str]:\n    explanation = []  # type: List[str]\n    set_left = set(left)\n    set_right = set(right)\n    common = set_left.intersection(set_right)\n    same = {k: left[k] for k in common if left[k] == right[k]}\n    if same and verbose < 2:\n        explanation += [\"Omitting %s identical items, use -vv to show\" % len(same)]\n    elif same:\n        explanation += [\"Common items:\"]\n        explanation += pprint.pformat(same).splitlines()\n    diff = {k for k in common if left[k] != right[k]}\n    if diff:\n        explanation += [\"Differing items:\"]\n        for k in diff:\n            explanation += [saferepr({k: left[k]}) + \" != \" + saferepr({k: right[k]})]\n    extra_left = set_left - set_right\n    len_extra_left = len(extra_left)\n    if len_extra_left:\n        explanation.append(\n            \"Left contains %d more item%s:\"\n            % (len_extra_left, \"\" if len_extra_left == 1 else \"s\")\n        )\n        explanation.extend(\n            pprint.pformat({k: left[k] for k in extra_left}).splitlines()\n        )\n    extra_right = set_right - set_left\n    len_extra_right = len(extra_right)\n    if len_extra_right:\n        explanation.append(\n            \"Right contains %d more item%s:\"\n            % (len_extra_right, \"\" if len_extra_right == 1 else \"s\")\n        )\n        explanation.extend(\n            pprint.pformat({k: right[k] for k in extra_right}).splitlines()\n        )\n    return explanation", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py___CACHEDIR_TAG_CONTENT": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py___CACHEDIR_TAG_CONTENT", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 46, "span_ids": ["docstring"], "tokens": 265}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nmerged implementation of the cache provider\n\nthe name cache was not chosen to ensure pluggy automatically\nignores the external pytest-cache\n\"\"\"\nimport json\nimport os\nfrom typing import Dict\nfrom typing import Generator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Set\n\nimport attr\nimport py\n\nimport pytest\nfrom .pathlib import Path\nfrom .pathlib import resolve_from_str\nfrom .pathlib import rm_rf\nfrom .reports import CollectReport\nfrom _pytest import nodes\nfrom _pytest._io import TerminalWriter\nfrom _pytest.compat import order_preserving_dict\nfrom _pytest.config import Config\nfrom _pytest.main import Session\nfrom _pytest.python import Module\n\nREADME_CONTENT = \"\"\"\\\n# pytest cache directory #\n\nThis directory contains data from the pytest's cache plugin,\nwhich provides the `--lf` and `--ff` options, as well as the `cache` fixture.\n\n**Do not** commit this to version control.\n\nSee [the docs](https://docs.pytest.org/en/latest/cache.html) for more information.\n\"\"\"\n\nCACHEDIR_TAG_CONTENT = b\"\"\"\\\nSignature: 8a477f597d28d172789f06886806bc55\n# This file is a cache directory tag created by pytest.\n# For information about cache directory tags, see:\n#\thttp://www.bford.info/cachedir/spec.html\n\"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_ascii_escaped__PytestWrapper.obj": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_ascii_escaped__PytestWrapper.obj", "embedding": null, "metadata": {"file_path": "src/_pytest/compat.py", "file_name": "compat.py", "file_type": "text/x-python", "category": "implementation", "start_line": 235, "end_line": 269, "span_ids": ["_PytestWrapper", "ascii_escaped"], "tokens": 294}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def ascii_escaped(val: Union[bytes, str]) -> str:\n    \"\"\"If val is pure ascii, returns it as a str().  Otherwise, escapes\n    bytes objects into a sequence of escaped bytes:\n\n    b'\\xc3\\xb4\\xc5\\xd6' -> '\\\\xc3\\\\xb4\\\\xc5\\\\xd6'\n\n    and escapes unicode objects into a sequence of escaped unicode\n    ids, e.g.:\n\n    '4\\\\nV\\\\U00043efa\\\\x0eMXWB\\\\x1e\\\\u3028\\\\u15fd\\\\xcd\\\\U0007d944'\n\n    note:\n       the obvious \"v.decode('unicode-escape')\" will return\n       valid utf-8 unicode if it finds them in bytes, but we\n       want to return escaped bytes for any byte, even if they match\n       a utf-8 string.\n\n    \"\"\"\n    if isinstance(val, bytes):\n        ret = _bytes_to_ascii(val)\n    else:\n        ret = val.encode(\"unicode_escape\").decode(\"ascii\")\n    return _translate_non_printable(ret)\n\n\n@attr.s\nclass _PytestWrapper:\n    \"\"\"Dummy wrapper around a function object for internal use only.\n\n    Used to correctly unwrap the underlying function object\n    when we are creating fixtures, because we wrap the function object ourselves with a decorator\n    to issue warnings when the fixture function is called directly.\n    \"\"\"\n\n    obj = attr.ib()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_get_real_func_get_real_func.return_obj": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_get_real_func_get_real_func.return_obj", "embedding": null, "metadata": {"file_path": "src/_pytest/compat.py", "file_name": "compat.py", "file_type": "text/x-python", "category": "implementation", "start_line": 225, "end_line": 250, "span_ids": ["get_real_func"], "tokens": 229}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def get_real_func(obj):\n    \"\"\" gets the real function object of the (possibly) wrapped object by\n    functools.wraps or functools.partial.\n    \"\"\"\n    start_obj = obj\n    for i in range(100):\n        # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function\n        # to trigger a warning if it gets called directly instead of by pytest: we don't\n        # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)\n        new_obj = getattr(obj, \"__pytest_wrapped__\", None)\n        if isinstance(new_obj, _PytestWrapper):\n            obj = new_obj.obj\n            break\n        new_obj = getattr(obj, \"__wrapped__\", None)\n        if new_obj is None:\n            break\n        obj = new_obj\n    else:\n        raise ValueError(\n            (\"could not find real function of {start}\\nstopped at {current}\").format(\n                start=saferepr(start_obj), current=saferepr(obj)\n            )\n        )\n    if isinstance(obj, functools.partial):\n        obj = obj.func\n    return obj", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_get_real_method_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_get_real_method_", "embedding": null, "metadata": {"file_path": "src/_pytest/compat.py", "file_name": "compat.py", "file_type": "text/x-python", "category": "implementation", "start_line": 300, "end_line": 396, "span_ids": ["get_real_method", "getimfunc", "impl:15", "safe_getattr", "safe_isclass"], "tokens": 673}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def get_real_method(obj, holder):\n    \"\"\"\n    Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time\n    returning a bound method to ``holder`` if the original object was a bound method.\n    \"\"\"\n    try:\n        is_method = hasattr(obj, \"__func__\")\n        obj = get_real_func(obj)\n    except Exception:  # pragma: no cover\n        return obj\n    if is_method and hasattr(obj, \"__get__\") and callable(obj.__get__):\n        obj = obj.__get__(holder)\n    return obj\n\n\ndef getimfunc(func):\n    try:\n        return func.__func__\n    except AttributeError:\n        return func\n\n\ndef safe_getattr(object: Any, name: str, default: Any) -> Any:\n    \"\"\" Like getattr but return default upon any Exception or any OutcomeException.\n\n    Attribute access can potentially fail for 'evil' Python objects.\n    See issue #214.\n    It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException\n    instead of Exception (for more details check #2707)\n    \"\"\"\n    try:\n        return getattr(object, name, default)\n    except TEST_OUTCOME:\n        return default\n\n\ndef safe_isclass(obj: object) -> bool:\n    \"\"\"Ignore any exception via isinstance on Python 3.\"\"\"\n    try:\n        return inspect.isclass(obj)\n    except Exception:\n        return False\n\n\nif sys.version_info < (3, 5, 2):\n\n    def overload(f):  # noqa: F811\n        return f\n\n\nif getattr(attr, \"__version_info__\", ()) >= (19, 2):\n    ATTRS_EQ_FIELD = \"eq\"\nelse:\n    ATTRS_EQ_FIELD = \"cmp\"\n\n\nif sys.version_info >= (3, 8):\n    from functools import cached_property\nelse:\n\n    class cached_property(Generic[_S, _T]):\n        __slots__ = (\"func\", \"__doc__\")\n\n        def __init__(self, func: Callable[[_S], _T]) -> None:\n            self.func = func\n            self.__doc__ = func.__doc__\n\n        @overload\n        def __get__(\n            self, instance: None, owner: Optional[\"Type[_S]\"] = ...\n        ) -> \"cached_property[_S, _T]\":\n            raise NotImplementedError()\n\n        @overload  # noqa: F811\n        def __get__(  # noqa: F811\n            self, instance: _S, owner: Optional[\"Type[_S]\"] = ...\n        ) -> _T:\n            raise NotImplementedError()\n\n        def __get__(self, instance, owner=None):  # noqa: F811\n            if instance is None:\n                return self\n            value = instance.__dict__[self.func.__name__] = self.func(instance)\n            return value\n\n\n# Sometimes an algorithm needs a dict which yields items in the order in which\n# they were inserted when iterated. Since Python 3.7, `dict` preserves\n# insertion order. Since `dict` is faster and uses less memory than\n# `OrderedDict`, prefer to use it if possible.\nif sys.version_info >= (3, 7):\n    order_preserving_dict = dict\nelse:\n    from collections import OrderedDict\n\n    order_preserving_dict = OrderedDict", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__command_line_options__ConftestImportFailure.__init__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__command_line_options__ConftestImportFailure.__init__", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 92, "span_ids": ["ConftestImportFailure", "ConftestImportFailure.__init__", "ExitCode", "docstring"], "tokens": 491}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" command line options, ini-file and conftest.py processing. \"\"\"\nimport argparse\nimport copy\nimport enum\nimport inspect\nimport os\nimport shlex\nimport sys\nimport types\nimport warnings\nfrom functools import lru_cache\nfrom types import TracebackType\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Union\n\nimport attr\nimport py\nfrom packaging.version import Version\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\n\nimport _pytest._code\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest._io import TerminalWriter\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pathlib import Path\nfrom _pytest.store import Store\nfrom _pytest.warning_types import PytestConfigWarning\n\nif TYPE_CHECKING:\n    from typing import Type\n\n    from .argparsing import Argument\n\n\n_PluggyPlugin = object\n\"\"\"A type to represent plugin objects.\nPlugins can be any namespace, so we can't narrow it down much, but we use an\nalias to make the intent clear.\nIdeally this type would be provided by pluggy itself.\"\"\"\n\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo  # type: Tuple[Type[Exception], Exception, TracebackType]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._try_load_conftest_PytestPluginManager._rget_with_confmod": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._try_load_conftest_PytestPluginManager._rget_with_confmod", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 402, "end_line": 441, "span_ids": ["PytestPluginManager._getconftestmodules", "PytestPluginManager._rget_with_confmod", "PytestPluginManager._try_load_conftest"], "tokens": 315}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.realpath().parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._importconftest_PytestPluginManager._importconftest.try_.except_KeyError_.return_mod": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager._importconftest_PytestPluginManager._importconftest.try_.except_KeyError_.return_mod", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 507, "end_line": 541, "span_ids": ["PytestPluginManager._importconftest"], "tokens": 328}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n\n    def _importconftest(self, conftestpath):\n        # Use a resolved Path object as key to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file systems (#5792)\n        key = Path(str(conftestpath)).resolve()\n        try:\n            return self._conftestpath2mod[key]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[key] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loading conftestmodule {!r}\".format(mod))\n            self.consider_conftest(mod)\n            return mod", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._consider_importhook_Config._validate_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._consider_importhook_Config._validate_args", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 947, "end_line": 999, "span_ids": ["Config._consider_importhook", "Config._mark_plugins_for_rewrite", "Config._validate_args"], "tokens": 398}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Config:\n\n    def _consider_importhook(self, args: Sequence[str]) -> None:\n        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n\n        Needs to parse the --assert=<mode> option from the commandline\n        and find all the installed plugins to mark them for rewriting\n        by the importhook.\n        \"\"\"\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n        mode = getattr(ns, \"assertmode\", \"plain\")\n        if mode == \"rewrite\":\n            import _pytest.assertion\n\n            try:\n                hook = _pytest.assertion.install_importhook(self)\n            except SystemError:\n                mode = \"plain\"\n            else:\n                self._mark_plugins_for_rewrite(hook)\n        _warn_about_missing_assertion(mode)\n\n    def _mark_plugins_for_rewrite(self, hook):\n        \"\"\"\n        Given an importhook, mark for rewrite any top-level\n        modules or packages in the distribution package for\n        all pytest plugins.\n        \"\"\"\n        self.pluginmanager.rewrite_hook = hook\n\n        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # We don't autoload from setuptools entry points, no need to continue.\n            return\n\n        package_files = (\n            str(file)\n            for dist in importlib_metadata.distributions()\n            if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n            for file in dist.files or []\n        )\n\n        for name in _iter_rewritable_modules(package_files):\n            hook.mark_rewrite(name)\n\n    def _validate_args(self, args: List[str], via: str) -> List[str]:\n        \"\"\"Validate known args.\"\"\"\n        self._parser._config_source_hint = via  # type: ignore\n        try:\n            self._parser.parse_known_and_unknown_args(\n                args, namespace=copy.copy(self.option)\n            )\n        finally:\n            del self._parser._config_source_hint  # type: ignore\n\n        return args", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._preparse_Config._preparse.try_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config._preparse_Config._preparse.try_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1001, "end_line": 1047, "span_ids": ["Config._preparse"], "tokens": 411}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Config:\n\n    def _preparse(self, args: List[str], addopts: bool = True) -> None:\n        if addopts:\n            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n            if len(env_addopts):\n                args[:] = (\n                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n                    + args\n                )\n        self._initini(args)\n        if addopts:\n            args[:] = (\n                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n            )\n\n        self._checkversion()\n        self._consider_importhook(args)\n        self.pluginmanager.consider_preparse(args, exclude_only=False)\n        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n            # Don't autoload from setuptools entry point. Only explicitly specified\n            # plugins are going to be loaded.\n            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n        self.pluginmanager.consider_env()\n        self.known_args_namespace = ns = self._parser.parse_known_args(\n            args, namespace=copy.copy(self.option)\n        )\n        if self.known_args_namespace.confcutdir is None and self.inifile:\n            confcutdir = py.path.local(self.inifile).dirname\n            self.known_args_namespace.confcutdir = confcutdir\n        try:\n            self.hook.pytest_load_initial_conftests(\n                early_config=self, args=args, parser=self._parser\n            )\n        except ConftestImportFailure as e:\n            if ns.help or ns.version:\n                # we don't want to prevent --help/--version to work\n                # so just let is pass and print a warning at the end\n                from _pytest.warnings import _issue_warning_captured\n\n                _issue_warning_captured(\n                    PytestConfigWarning(\n                        \"could not load initial conftests: {}\".format(e.path)\n                    ),\n                    self.hook,\n                    stacklevel=2,\n                )\n            else:\n                raise", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_os_getcfg.return_None_None_None": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_os_getcfg.return_None_None_None", "embedding": null, "metadata": {"file_path": "src/_pytest/config/findpaths.py", "file_name": "findpaths.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 63, "span_ids": ["exists", "getcfg", "imports"], "tokens": 402}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nfrom typing import Any\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\nimport py\n\nfrom .exceptions import UsageError\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.outcomes import fail\n\nif TYPE_CHECKING:\n    from . import Config  # noqa: F401\n\n\ndef exists(path, ignore=OSError):\n    try:\n        return path.check()\n    except ignore:\n        return False\n\n\ndef getcfg(args, config=None):\n    \"\"\"\n    Search the list of arguments for a valid ini-file for pytest,\n    and return a tuple of (rootdir, inifile, cfg-dict).\n\n    note: config is optional and used only to issue warnings explicitly (#2891).\n    \"\"\"\n    inibasenames = [\"pytest.ini\", \"tox.ini\", \"setup.cfg\"]\n    args = [x for x in args if not str(x).startswith(\"-\")]\n    if not args:\n        args = [py.path.local()]\n    for arg in args:\n        arg = py.path.local(arg)\n        for base in arg.parts(reverse=True):\n            for inibasename in inibasenames:\n                p = base.join(inibasename)\n                if exists(p):\n                    try:\n                        iniconfig = py.iniconfig.IniConfig(p)\n                    except py.iniconfig.ParseError as exc:\n                        raise UsageError(str(exc))\n\n                    if (\n                        inibasename == \"setup.cfg\"\n                        and \"tool:pytest\" in iniconfig.sections\n                    ):\n                        return base, p, iniconfig[\"tool:pytest\"]\n                    elif \"pytest\" in iniconfig.sections:\n                        if inibasename == \"setup.cfg\" and config is not None:\n\n                            fail(\n                                CFG_PYTEST_SECTION.format(filename=inibasename),\n                                pytrace=False,\n                            )\n                        return base, p, iniconfig[\"pytest\"]\n                    elif inibasename == \"pytest.ini\":\n                        # allowed to be empty\n                        return base, p, {}\n    return None, None, None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_get_common_ancestor_CFG_PYTEST_SECTION": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/findpaths.py_get_common_ancestor_CFG_PYTEST_SECTION", "embedding": null, "metadata": {"file_path": "src/_pytest/config/findpaths.py", "file_name": "findpaths.py", "file_type": "text/x-python", "category": "implementation", "start_line": 66, "end_line": 111, "span_ids": ["get_common_ancestor", "get_dirs_from_args", "impl:2"], "tokens": 340}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def get_common_ancestor(paths: Iterable[py.path.local]) -> py.path.local:\n    common_ancestor = None\n    for path in paths:\n        if not path.exists():\n            continue\n        if common_ancestor is None:\n            common_ancestor = path\n        else:\n            if path.relto(common_ancestor) or path == common_ancestor:\n                continue\n            elif common_ancestor.relto(path):\n                common_ancestor = path\n            else:\n                shared = path.common(common_ancestor)\n                if shared is not None:\n                    common_ancestor = shared\n    if common_ancestor is None:\n        common_ancestor = py.path.local()\n    elif common_ancestor.isfile():\n        common_ancestor = common_ancestor.dirpath()\n    return common_ancestor\n\n\ndef get_dirs_from_args(args: Iterable[str]) -> List[py.path.local]:\n    def is_option(x: str) -> bool:\n        return x.startswith(\"-\")\n\n    def get_file_part_from_node_id(x: str) -> str:\n        return x.split(\"::\")[0]\n\n    def get_dir_from_path(path: py.path.local) -> py.path.local:\n        if path.isdir():\n            return path\n        return py.path.local(path.dirname)\n\n    # These look like paths but may not exist\n    possible_paths = (\n        py.path.local(get_file_part_from_node_id(arg))\n        for arg in args\n        if not is_option(arg)\n    )\n\n    return [get_dir_from_path(path) for path in possible_paths if path.exists()]\n\n\nCFG_PYTEST_SECTION = \"[pytest] section in {filename} files is no longer supported, change to [tool:pytest] instead.\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py__interactive_debugging_pytest_configure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/debugging.py__interactive_debugging_pytest_configure", "embedding": null, "metadata": {"file_path": "src/_pytest/debugging.py", "file_name": "debugging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 70, "span_ids": ["_validate_usepdb_cls", "docstring", "pytest_addoption", "pytest_configure"], "tokens": 450}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" interactive debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/deprecated.py___": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/deprecated.py___", "embedding": null, "metadata": {"file_path": "src/_pytest/deprecated.py", "file_name": "deprecated.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 78, "span_ids": ["docstring", "impl:7"], "tokens": 698}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nThis module contains deprecation messages and bits of code used elsewhere in the codebase\nthat is planned to be removed in the next pytest release.\n\nKeeping it in a central location makes it easy to track what is deprecated and should\nbe removed when the time comes.\n\nAll constants defined in this module should be either instances of\n:class:`PytestWarning`, or :class:`UnformattedWarning`\nin case of warnings which need to format their messages.\n\"\"\"\nfrom _pytest.warning_types import PytestDeprecationWarning\nfrom _pytest.warning_types import UnformattedWarning\n\n# set of plugins which have been integrated into the core; we use this list to ignore\n# them during registration to avoid conflicts\nDEPRECATED_EXTERNAL_PLUGINS = {\n    \"pytest_catchlog\",\n    \"pytest_capturelog\",\n    \"pytest_faulthandler\",\n}\n\nFUNCARGNAMES = PytestDeprecationWarning(\n    \"The `funcargnames` attribute was an alias for `fixturenames`, \"\n    \"since pytest 2.3 - use the newer attribute instead.\"\n)\n\nFILLFUNCARGS = PytestDeprecationWarning(\n    \"The `_fillfuncargs` function is deprecated, use \"\n    \"function._request._fillfixtures() instead if you cannot avoid reaching into internals.\"\n)\n\nRESULT_LOG = PytestDeprecationWarning(\n    \"--result-log is deprecated, please try the new pytest-reportlog plugin.\\n\"\n    \"See https://docs.pytest.org/en/latest/deprecations.html#result-log-result-log for more information.\"\n)\n\nFIXTURE_POSITIONAL_ARGUMENTS = PytestDeprecationWarning(\n    \"Passing arguments to pytest.fixture() as positional arguments is deprecated - pass them \"\n    \"as a keyword argument instead.\"\n)\n\nNODE_USE_FROM_PARENT = UnformattedWarning(\n    PytestDeprecationWarning,\n    \"Direct construction of {name} has been deprecated, please use {name}.from_parent.\\n\"\n    \"See \"\n    \"https://docs.pytest.org/en/latest/deprecations.html#node-construction-changed-to-node-from-parent\"\n    \" for more details.\",\n)\n\nJUNIT_XML_DEFAULT_FAMILY = PytestDeprecationWarning(\n    \"The 'junit_family' default value will change to 'xunit2' in pytest 6.0. See:\\n\"\n    \"  https://docs.pytest.org/en/latest/deprecations.html#junit-family-default-value-change-to-xunit2\\n\"\n    \"for more information.\"\n)\n\nNO_PRINT_LOGS = PytestDeprecationWarning(\n    \"--no-print-logs is deprecated and scheduled for removal in pytest 6.0.\\n\"\n    \"Please use --show-capture instead.\"\n)\n\nCOLLECT_DIRECTORY_HOOK = PytestDeprecationWarning(\n    \"The pytest_collect_directory hook is not working.\\n\"\n    \"Please use collect_ignore in conftests or pytest_collection_modifyitems.\"\n)\n\nPYTEST_COLLECT_MODULE = UnformattedWarning(\n    PytestDeprecationWarning,\n    \"pytest.collect.{name} was moved to pytest.{name}\\n\"\n    \"Please update to the new name.\",\n)\n\n\nTERMINALWRITER_WRITER = PytestDeprecationWarning(\n    \"The TerminalReporter.writer attribute is deprecated, use TerminalReporter._tw instead at your own risk.\\n\"\n    \"See https://docs.pytest.org/en/latest/deprecations.html#terminalreporter-writer for more information.\"\n)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__get_flag_lookup__is_mocked": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__get_flag_lookup__is_mocked", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 329, "end_line": 413, "span_ids": ["DoctestTextfile", "DoctestTextfile.collect", "_check_all_skipped", "_get_continue_on_failure", "_get_flag_lookup", "_is_mocked", "get_optionflags"], "tokens": 594}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _get_flag_lookup() -> Dict[str, int]:\n    import doctest\n\n    return dict(\n        DONT_ACCEPT_TRUE_FOR_1=doctest.DONT_ACCEPT_TRUE_FOR_1,\n        DONT_ACCEPT_BLANKLINE=doctest.DONT_ACCEPT_BLANKLINE,\n        NORMALIZE_WHITESPACE=doctest.NORMALIZE_WHITESPACE,\n        ELLIPSIS=doctest.ELLIPSIS,\n        IGNORE_EXCEPTION_DETAIL=doctest.IGNORE_EXCEPTION_DETAIL,\n        COMPARISON_FLAGS=doctest.COMPARISON_FLAGS,\n        ALLOW_UNICODE=_get_allow_unicode_flag(),\n        ALLOW_BYTES=_get_allow_bytes_flag(),\n        NUMBER=_get_number_flag(),\n    )\n\n\ndef get_optionflags(parent):\n    optionflags_str = parent.config.getini(\"doctest_optionflags\")\n    flag_lookup_table = _get_flag_lookup()\n    flag_acc = 0\n    for flag in optionflags_str:\n        flag_acc |= flag_lookup_table[flag]\n    return flag_acc\n\n\ndef _get_continue_on_failure(config):\n    continue_on_failure = config.getvalue(\"doctest_continue_on_failure\")\n    if continue_on_failure:\n        # We need to turn off this if we use pdb since we should stop at\n        # the first failure\n        if config.getvalue(\"usepdb\"):\n            continue_on_failure = False\n    return continue_on_failure\n\n\nclass DoctestTextfile(pytest.Module):\n    obj = None\n\n    def collect(self):\n        import doctest\n\n        # inspired by doctest.testfile; ideally we would use it directly,\n        # but it doesn't support passing a custom checker\n        encoding = self.config.getini(\"doctest_encoding\")\n        text = self.fspath.read_text(encoding)\n        filename = str(self.fspath)\n        name = self.fspath.basename\n        globs = {\"__name__\": \"__main__\"}\n\n        optionflags = get_optionflags(self)\n\n        runner = _get_runner(\n            verbose=False,\n            optionflags=optionflags,\n            checker=_get_checker(),\n            continue_on_failure=_get_continue_on_failure(self.config),\n        )\n\n        parser = doctest.DocTestParser()\n        test = parser.get_doctest(text, globs, name, filename, 0)\n        if test.examples:\n            yield DoctestItem.from_parent(\n                self, name=test.name, runner=runner, dtest=test\n            )\n\n\ndef _check_all_skipped(test):\n    \"\"\"raises pytest.skip() if all examples in the given DocTest have the SKIP\n    option set.\n    \"\"\"\n    import doctest\n\n    all_skipped = all(x.options.get(doctest.SKIP, False) for x in test.examples)\n    if all_skipped:\n        pytest.skip(\"all tests skipped by +SKIP option\")\n\n\ndef _is_mocked(obj):\n    \"\"\"\n    returns if a object is possibly a mock object by checking the existence of a highly improbable attribute\n    \"\"\"\n    return (\n        safe_getattr(obj, \"pytest_mock_example_attribute_that_shouldnt_exist\", None)\n        is not None\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__patch_unwrap_mock_aware__patch_unwrap_mock_aware.try_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__patch_unwrap_mock_aware__patch_unwrap_mock_aware.try_", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 363, "end_line": 389, "span_ids": ["_patch_unwrap_mock_aware"], "tokens": 210}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@contextmanager\ndef _patch_unwrap_mock_aware():\n    \"\"\"\n    contextmanager which replaces ``inspect.unwrap`` with a version\n    that's aware of mock objects and doesn't recurse on them\n    \"\"\"\n    real_unwrap = inspect.unwrap\n\n    def _mock_aware_unwrap(obj, stop=None):\n        try:\n            if stop is None or stop is _is_mocked:\n                return real_unwrap(obj, stop=_is_mocked)\n            return real_unwrap(obj, stop=lambda obj: _is_mocked(obj) or stop(obj))\n        except Exception as e:\n            warnings.warn(\n                \"Got %r when unwrapping %r.  This is usually caused \"\n                \"by a violation of Python's object protocol; see e.g. \"\n                \"https://github.com/pytest-dev/pytest/issues/5080\" % (e, obj),\n                PytestWarning,\n            )\n            raise\n\n    inspect.unwrap = _mock_aware_unwrap\n    try:\n        yield\n    finally:\n        inspect.unwrap = real_unwrap", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_functools_get_scope_node": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_functools_get_scope_node", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 112, "span_ids": ["PseudoFixtureDef", "get_scope_node", "get_scope_package", "impl:2", "imports", "pytest_sessionstart", "scopeproperty"], "tokens": 699}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import functools\nimport inspect\nimport sys\nimport warnings\nfrom collections import defaultdict\nfrom collections import deque\nfrom typing import Dict\nfrom typing import List\nfrom typing import Tuple\n\nimport attr\nimport py\n\nimport _pytest\nfrom _pytest._code import getfslineno\nfrom _pytest._code.code import FormattedExcinfo\nfrom _pytest._code.code import TerminalRepr\nfrom _pytest._io import TerminalWriter\nfrom _pytest.compat import _format_args\nfrom _pytest.compat import _PytestWrapper\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import get_real_method\nfrom _pytest.compat import getfuncargnames\nfrom _pytest.compat import getimfunc\nfrom _pytest.compat import getlocation\nfrom _pytest.compat import is_generator\nfrom _pytest.compat import NOTSET\nfrom _pytest.compat import order_preserving_dict\nfrom _pytest.compat import safe_getattr\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.deprecated import FILLFUNCARGS\nfrom _pytest.deprecated import FIXTURE_POSITIONAL_ARGUMENTS\nfrom _pytest.deprecated import FUNCARGNAMES\nfrom _pytest.mark import ParameterSet\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import TEST_OUTCOME\n\nif TYPE_CHECKING:\n    from typing import Type\n\n    from _pytest import nodes\n    from _pytest.main import Session\n\n\n@attr.s(frozen=True)\nclass PseudoFixtureDef:\n    cached_result = attr.ib()\n    scope = attr.ib()\n\n\ndef pytest_sessionstart(session: \"Session\"):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"function\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)\n\n\nscopename2class = {}  # type: Dict[str, Type[nodes.Node]]\n\nscope2props = dict(session=())  # type: Dict[str, Tuple[str, ...]]\nscope2props[\"package\"] = (\"fspath\",)\nscope2props[\"module\"] = (\"fspath\", \"module\")\nscope2props[\"class\"] = scope2props[\"module\"] + (\"cls\",)\nscope2props[\"instance\"] = scope2props[\"class\"] + (\"instance\",)\nscope2props[\"function\"] = scope2props[\"instance\"] + (\"function\", \"keywords\")\n\n\ndef scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"{} not available in {}-scoped context\".format(scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"{}/{}\".format(fixturedef.baseid, \"__init__.py\")\n    while current and (\n        type(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current\n\n\ndef get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_resolve_fixture_function_resolve_fixture_function": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_resolve_fixture_function_resolve_fixture_function", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 889, "end_line": 912, "span_ids": ["resolve_fixture_function"], "tokens": 235}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def resolve_fixture_function(fixturedef, request):\n    \"\"\"Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific\n    instances and bound methods.\n    \"\"\"\n    fixturefunc = fixturedef.func\n    if fixturedef.unittest:\n        if request.instance is not None:\n            # bind the unbound method to the TestCase instance\n            fixturefunc = fixturedef.func.__get__(request.instance)\n    else:\n        # the fixture function needs to be bound to the actual\n        # request.instance so that code working with \"fixturedef\" behaves\n        # as expected.\n        if request.instance is not None:\n            # handle the case where fixture is defined not in a test class, but some other class\n            # (for example a plugin class with a fixture), see #2270\n            if hasattr(fixturefunc, \"__self__\") and not isinstance(\n                request.instance, fixturefunc.__self__.__class__\n            ):\n                return fixturefunc\n            fixturefunc = getimfunc(fixturedef.func)\n            if fixturefunc != fixturedef.func:\n                fixturefunc = fixturefunc.__get__(request.instance)\n    return fixturefunc", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/freeze_support.py___": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/freeze_support.py___", "embedding": null, "metadata": {"file_path": "src/_pytest/freeze_support.py", "file_name": "freeze_support.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 42, "span_ids": ["_iter_all_modules", "docstring", "freeze_includes"], "tokens": 246}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nProvides a function to report all internal modules for using freezing tools\npytest\n\"\"\"\n\n\ndef freeze_includes():\n    \"\"\"\n    Returns a list of module names used by pytest that should be\n    included by cx_freeze.\n    \"\"\"\n    import py\n    import _pytest\n\n    result = list(_iter_all_modules(py))\n    result += list(_iter_all_modules(_pytest))\n    return result\n\n\ndef _iter_all_modules(package, prefix=\"\"):\n    \"\"\"\n    Iterates over the names of all modules that can be found in the given\n    package, recursively.\n\n        >>> import _pytest\n        >>> list(_iter_all_modules(_pytest))\n        ['_pytest._argcomplete', '_pytest._code.code', ...]\n    \"\"\"\n    import os\n    import pkgutil\n\n    if type(package) is not str:\n        path, prefix = package.__path__[0], package.__name__ + \".\"\n    else:\n        path = package\n    for _, name, is_package in pkgutil.iter_modules([path]):\n        if is_package:\n            for m in _iter_all_modules(os.path.join(path, name), prefix=name + \".\"):\n                yield prefix + m\n        else:\n            yield prefix + name", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py__version_info_help_me_HelpAction.__call__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/helpconfig.py__version_info_help_me_HelpAction.__call__", "embedding": null, "metadata": {"file_path": "src/_pytest/helpconfig.py", "file_name": "helpconfig.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 36, "span_ids": ["HelpAction", "HelpAction.__call__", "HelpAction.__init__", "docstring"], "tokens": 233}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" version info, help messages, tracing configuration.  \"\"\"\nimport os\nimport sys\nfrom argparse import Action\n\nimport py\n\nimport pytest\nfrom _pytest.config import PrintHelp\n\n\nclass HelpAction(Action):\n    \"\"\"This is an argparse Action that will raise an exception in\n    order to skip the rest of the argument parsing when --help is passed.\n    This prevents argparse from quitting due to missing required arguments\n    when any are defined, for example by ``pytest_addoption``.\n    This is similar to the way that the builtin argparse --help option is\n    implemented by raising SystemExit.\n    \"\"\"\n\n    def __init__(self, option_strings, dest=None, default=False, help=None):\n        super().__init__(\n            option_strings=option_strings,\n            dest=dest,\n            const=True,\n            default=default,\n            nargs=0,\n            help=help,\n        )\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        setattr(namespace, self.dest, self.const)\n\n        # We should only skip the rest of the parsing after preparse is done\n        if getattr(parser._parser, \"after_preparse\", False):\n            raise PrintHelp", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_assertion_pass_pytest_assertion_pass._": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_assertion_pass_pytest_assertion_pass._", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 487, "end_line": 522, "span_ids": ["pytest_assertion_pass"], "tokens": 264}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_assertion_pass(item, lineno, orig, expl):\n    \"\"\"\n    **(Experimental)**\n\n    .. versionadded:: 5.0\n\n    Hook called whenever an assertion *passes*.\n\n    Use this hook to do some processing after a passing assertion.\n    The original assertion information is available in the `orig` string\n    and the pytest introspected assertion information is available in the\n    `expl` string.\n\n    This hook must be explicitly enabled by the ``enable_assertion_pass_hook``\n    ini-file option:\n\n    .. code-block:: ini\n\n        [pytest]\n        enable_assertion_pass_hook=true\n\n    You need to **clean the .pyc** files in your project directory and interpreter libraries\n    when enabling this option, as assertions will require to be re-written.\n\n    :param _pytest.nodes.Item item: pytest item object of current test\n    :param int lineno: line number of the assert statement\n    :param string orig: string with original assertion\n    :param string expl: string with assert explanation\n\n    .. note::\n\n        This hook is **experimental**, so its parameters or even the hook itself might\n        be changed/removed without warning in any future pytest release.\n\n        If you find this hook useful, please share your feedback opening an issue.\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_30_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_30_", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 651, "end_line": 703, "span_ids": ["impl:18", "pytest_doctest_prepare_content", "pytest_enter_pdb", "pytest_exception_interact", "pytest_internalerror", "pytest_keyboard_interrupt", "pytest_leave_pdb", "pytest_warning_captured"], "tokens": 292}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# -------------------------------------------------------------------------\n# doctest hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_doctest_prepare_content(content):\n    \"\"\" return processed content for a given doctest\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# error handling and internal debugging hooks\n# -------------------------------------------------------------------------\n\n\ndef pytest_internalerror(excrepr, excinfo):\n    \"\"\" called for internal errors. \"\"\"\n\n\ndef pytest_keyboard_interrupt(excinfo):\n    \"\"\" called for keyboard interrupt. \"\"\"\n\n\ndef pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"\n\n\ndef pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"\n\n\ndef pytest_leave_pdb(config, pdb):\n    \"\"\" called when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py___families_xunit2_fami": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py___families_xunit2_fami", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 87, "span_ids": ["Junit", "bin_xml_escape", "docstring", "impl:11", "impl:2", "merge_family"], "tokens": 634}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\n    report test results in JUnit-XML format,\n    for use with Jenkins and build integration servers.\n\n\nBased on initial code from Ross Lawley.\n\nOutput conforms to https://github.com/jenkinsci/xunit-plugin/blob/master/\nsrc/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd\n\"\"\"\nimport functools\nimport os\nimport platform\nimport re\nimport sys\nimport time\nfrom datetime import datetime\n\nimport py\n\nimport pytest\nfrom _pytest import deprecated\nfrom _pytest import nodes\nfrom _pytest.config import filename_arg\nfrom _pytest.store import StoreKey\nfrom _pytest.warnings import _issue_warning_captured\n\n\nxml_key = StoreKey[\"LogXML\"]()\n\n\nclass Junit(py.xml.Namespace):\n    pass\n\n\n# We need to get the subset of the invalid unicode ranges according to\n# XML 1.0 which are valid in this python build.  Hence we calculate\n# this dynamically instead of hardcoding it.  The spec range of valid\n# chars is: Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n#                    | [#x10000-#x10FFFF]\n_legal_chars = (0x09, 0x0A, 0x0D)\n_legal_ranges = ((0x20, 0x7E), (0x80, 0xD7FF), (0xE000, 0xFFFD), (0x10000, 0x10FFFF))\n_legal_xml_re = [\n    \"{}-{}\".format(chr(low), chr(high))\n    for (low, high) in _legal_ranges\n    if low < sys.maxunicode\n]\n_legal_xml_re = [chr(x) for x in _legal_chars] + _legal_xml_re\nillegal_xml_re = re.compile(\"[^%s]\" % \"\".join(_legal_xml_re))\ndel _legal_chars\ndel _legal_ranges\ndel _legal_xml_re\n\n_py_ext_re = re.compile(r\"\\.py$\")\n\n\ndef bin_xml_escape(arg):\n    def repl(matchobj):\n        i = ord(matchobj.group())\n        if i <= 0xFF:\n            return \"#x%02X\" % i\n        else:\n            return \"#x%04X\" % i\n\n    return py.xml.raw(illegal_xml_re.sub(repl, py.xml.escape(arg)))\n\n\ndef merge_family(left, right):\n    result = {}\n    for kl, vl in left.items():\n        for kr, vr in right.items():\n            if not isinstance(vl, list):\n                raise TypeError(type(vl))\n            result[kl] = vl + vr\n    left.update(result)\n\n\nfamilies = {}\nfamilies[\"_base\"] = {\"testcase\": [\"classname\", \"name\"]}\nfamilies[\"_base_legacy\"] = {\"testcase\": [\"file\", \"line\", \"url\"]}\n\n# xUnit 1.x inherits legacy attributes\nfamilies[\"xunit1\"] = families[\"_base\"].copy()\nmerge_family(families[\"xunit1\"], families[\"_base_legacy\"])\n\n# xUnit 2.x uses strict base attributes\nfamilies[\"xunit2\"] = families[\"_base\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py__Access_and_control_lo_ColoredLevelFormatter.format": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py__Access_and_control_lo_ColoredLevelFormatter.format", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 74, "span_ids": ["ColoredLevelFormatter", "ColoredLevelFormatter.__init__", "ColoredLevelFormatter.format", "_remove_ansi_escape_sequences", "docstring"], "tokens": 556}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" Access and control log capturing. \"\"\"\nimport logging\nimport re\nfrom contextlib import contextmanager\nfrom io import StringIO\nfrom typing import AbstractSet\nfrom typing import Dict\nfrom typing import Generator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\n\nimport pytest\nfrom _pytest import nodes\nfrom _pytest.compat import nullcontext\nfrom _pytest.config import _strtobool\nfrom _pytest.config import Config\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n_ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\n\n\ndef _remove_ansi_escape_sequences(text):\n    return _ANSI_ESCAPE_SEQ.sub(\"\", text)\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }  # type: Mapping[int, AbstractSet[str]]\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}  # type: Dict[int, str]\n\n        assert self._fmt is not None\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        self._style._fmt = fmt\n        return super().format(record)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py__core_implementation_o_pytest_addoption.None_17": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py__core_implementation_o_pytest_addoption.None_17", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 175, "span_ids": ["docstring", "pytest_addoption"], "tokens": 1058}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" core implementation of testing process: init, session, runtest loop. \"\"\"\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import FrozenSet\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import directory_arg\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.reports import CollectReport\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nif TYPE_CHECKING:\n    from typing import Type\n    from typing_extensions import Literal\n\n    from _pytest.python import Package\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    )\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        \"--co\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item (via node id prefix) during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files.\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests.\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_wrap_session_wrap_session.return_session_exitstatus": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_wrap_session_wrap_session.return_session_exitstatus", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 178, "end_line": 236, "span_ids": ["wrap_session"], "tokens": 479}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_collection_modifyitems__bestrelpath_cache.__missing__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_collection_modifyitems__bestrelpath_cache.__missing__", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 326, "end_line": 365, "span_ids": ["Failed", "Interrupted", "NoMatch", "_bestrelpath_cache", "_bestrelpath_cache.__missing__", "pytest_collection_modifyitems"], "tokens": 222}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_collection_modifyitems(items, config):\n    deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n    if not deselect_prefixes:\n        return\n\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if colitem.nodeid.startswith(deselect_prefixes):\n            deselected.append(colitem)\n        else:\n            remaining.append(colitem)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\nclass NoMatch(Exception):\n    \"\"\" raised if matching cannot locate a matching names. \"\"\"\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\" signals an interrupted test run. \"\"\"\n\n    __module__ = \"builtins\"  # for py3\n\n\nclass Failed(Exception):\n    \"\"\" signals a stop as failed test run. \"\"\"\n\n\n@attr.s\nclass _bestrelpath_cache(dict):\n    path = attr.ib(type=py.path.local)\n\n    def __missing__(self, path: py.path.local) -> str:\n        r = self.path.bestrelpath(path)  # type: str\n        self[path] = r\n        return r", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._collect_Session._collect.if_argpath_check_dir_1_.else_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._collect_Session._collect.if_argpath_check_dir_1_.else_", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 511, "end_line": 588, "span_ids": ["Session._collect"], "tokens": 712}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Session(nodes.FSCollector):\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py__generic_mechanism_for_param": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/__init__.py__generic_mechanism_for_param", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 41, "span_ids": ["docstring", "param"], "tokens": 308}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" generic mechanism for marking and selecting python functions. \"\"\"\nfrom typing import Optional\n\nfrom .legacy import matchkeyword\nfrom .legacy import matchmark\nfrom .structures import EMPTY_PARAMETERSET_OPTION\nfrom .structures import get_empty_parameterset_mark\nfrom .structures import Mark\nfrom .structures import MARK_GEN\nfrom .structures import MarkDecorator\nfrom .structures import MarkGenerator\nfrom .structures import ParameterSet\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.store import StoreKey\n\n__all__ = [\"Mark\", \"MarkDecorator\", \"MarkGenerator\", \"get_empty_parameterset_mark\"]\n\n\nold_mark_config_key = StoreKey[Optional[Config]]()\n\n\ndef param(*values, **kw):\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [(\"3+5\", 8), pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),],\n        )\n        def test_eval(test_input, expected):\n            assert eval(test_input) == expected\n\n    :param values: variable args of the values of the parameter set, in order.\n    :keyword marks: a single mark or a list of marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, **kw)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/evaluate.py_os_MarkEvaluator._getglobals": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/evaluate.py_os_MarkEvaluator._getglobals", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/evaluate.py", "file_name": "evaluate.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 76, "span_ids": ["MarkEvaluator", "MarkEvaluator.__bool__", "MarkEvaluator.__init__", "MarkEvaluator._get_marks", "MarkEvaluator._getglobals", "MarkEvaluator.invalidraise", "MarkEvaluator.istrue", "MarkEvaluator.wasvalid", "cached_eval", "imports"], "tokens": 506}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport platform\nimport sys\nimport traceback\nfrom typing import Any\nfrom typing import Dict\n\nfrom ..outcomes import fail\nfrom ..outcomes import TEST_OUTCOME\nfrom _pytest.config import Config\nfrom _pytest.store import StoreKey\n\n\nevalcache_key = StoreKey[Dict[str, Any]]()\n\n\ndef cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n    default = {}  # type: Dict[str, object]\n    evalcache = config._store.setdefault(evalcache_key, default)\n    try:\n        return evalcache[expr]\n    except KeyError:\n        import _pytest._code\n\n        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n        evalcache[expr] = x = eval(exprcode, d)\n        return x\n\n\nclass MarkEvaluator:\n    def __init__(self, item, name):\n        self.item = item\n        self._marks = None\n        self._mark = None\n        self._mark_name = name\n\n    def __bool__(self):\n        # don't cache here to prevent staleness\n        return bool(self._get_marks())\n\n    def wasvalid(self):\n        return not hasattr(self, \"exc\")\n\n    def _get_marks(self):\n        return list(self.item.iter_markers(name=self._mark_name))\n\n    def invalidraise(self, exc):\n        raises = self.get(\"raises\")\n        if not raises:\n            return\n        return not isinstance(exc, raises)\n\n    def istrue(self):\n        try:\n            return self._istrue()\n        except TEST_OUTCOME:\n            self.exc = sys.exc_info()\n            if isinstance(self.exc[1], SyntaxError):\n                # TODO: Investigate why SyntaxError.offset is Optional, and if it can be None here.\n                assert self.exc[1].offset is not None\n                msg = [\" \" * (self.exc[1].offset + 4) + \"^\"]\n                msg.append(\"SyntaxError: invalid syntax\")\n            else:\n                msg = traceback.format_exception_only(*self.exc[:2])\n            fail(\n                \"Error evaluating %r expression\\n\"\n                \"    %s\\n\"\n                \"%s\" % (self._mark_name, self.expr, \"\\n\".join(msg)),\n                pytrace=False,\n            )\n\n    def _getglobals(self):\n        d = {\"os\": os, \"sys\": sys, \"platform\": platform, \"config\": self.item.config}\n        if hasattr(self.item, \"obj\"):\n            d.update(self.item.obj.__globals__)\n        return d", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_inspect_get_empty_parameterset_mark": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_inspect_get_empty_parameterset_mark", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 56, "span_ids": ["get_empty_parameterset_mark", "imports", "istestfunc"], "tokens": 342}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import inspect\nimport warnings\nfrom collections import namedtuple\nfrom collections.abc import MutableMapping\nfrom typing import Any\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Union\n\nimport attr\n\nfrom .._code import getfslineno\nfrom ..compat import ascii_escaped\nfrom ..compat import NOTSET\nfrom _pytest.outcomes import fail\nfrom _pytest.warning_types import PytestUnknownMarkWarning\n\nEMPTY_PARAMETERSET_OPTION = \"empty_parameter_set_mark\"\n\n\ndef istestfunc(func):\n    return (\n        hasattr(func, \"__call__\")\n        and getattr(func, \"__name__\", \"<lambda>\") != \"<lambda>\"\n    )\n\n\ndef get_empty_parameterset_mark(config, argnames, func):\n    from ..nodes import Collector\n\n    requested_mark = config.getini(EMPTY_PARAMETERSET_OPTION)\n    if requested_mark in (\"\", None, \"skip\"):\n        mark = MARK_GEN.skip\n    elif requested_mark == \"xfail\":\n        mark = MARK_GEN.xfail(run=False)\n    elif requested_mark == \"fail_at_collect\":\n        f_name = func.__name__\n        _, lineno = getfslineno(func)\n        raise Collector.CollectError(\n            \"Empty parameter set in '%s' at line %d\" % (f_name, lineno + 1)\n        )\n    else:\n        raise LookupError(requested_mark)\n    fs, lineno = getfslineno(func)\n    reason = \"got empty parameter set %r, function %s at %s:%d\" % (\n        argnames,\n        func.__name__,\n        fs,\n        lineno,\n    )\n    return mark(reason=reason)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py__monkeypatching_and_mo_notset": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/monkeypatch.py__monkeypatching_and_mo_notset", "embedding": null, "metadata": {"file_path": "src/_pytest/monkeypatch.py", "file_name": "monkeypatch.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 98, "span_ids": ["Notset", "Notset.__repr__", "annotated_getattr", "derive_importpath", "docstring", "impl:2", "monkeypatch", "resolve"], "tokens": 585}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" monkeypatching and mocking functionality.  \"\"\"\nimport os\nimport re\nimport sys\nimport warnings\nfrom contextlib import contextmanager\nfrom typing import Generator\n\nimport pytest\nfrom _pytest.fixtures import fixture\nfrom _pytest.pathlib import Path\n\nRE_IMPORT_ERROR_NAME = re.compile(r\"^No module named (.*)$\")\n\n\n@fixture\ndef monkeypatch():\n    \"\"\"The returned ``monkeypatch`` fixture provides these\n    helper methods to modify objects, dictionaries or os.environ::\n\n        monkeypatch.setattr(obj, name, value, raising=True)\n        monkeypatch.delattr(obj, name, raising=True)\n        monkeypatch.setitem(mapping, name, value)\n        monkeypatch.delitem(obj, name, raising=True)\n        monkeypatch.setenv(name, value, prepend=False)\n        monkeypatch.delenv(name, raising=True)\n        monkeypatch.syspath_prepend(path)\n        monkeypatch.chdir(path)\n\n    All modifications will be undone after the requesting\n    test function or fixture has finished. The ``raising``\n    parameter determines if a KeyError or AttributeError\n    will be raised if the set/deletion operation has no target.\n    \"\"\"\n    mpatch = MonkeyPatch()\n    yield mpatch\n    mpatch.undo()\n\n\ndef resolve(name):\n    # simplified from zope.dottedname\n    parts = name.split(\".\")\n\n    used = parts.pop(0)\n    found = __import__(used)\n    for part in parts:\n        used += \".\" + part\n        try:\n            found = getattr(found, part)\n        except AttributeError:\n            pass\n        else:\n            continue\n        # we use explicit un-nesting of the handling block in order\n        # to avoid nested exceptions on python 3\n        try:\n            __import__(used)\n        except ImportError as ex:\n            # str is used for py2 vs py3\n            expected = str(ex).split()[-1]\n            if expected == used:\n                raise\n            else:\n                raise ImportError(\"import error in {}: {}\".format(used, ex))\n        found = annotated_getattr(found, part, used)\n    return found\n\n\ndef annotated_getattr(obj, name, ann):\n    try:\n        obj = getattr(obj, name)\n    except AttributeError:\n        raise AttributeError(\n            \"{!r} object at {} has no attribute {!r}\".format(\n                type(obj).__name__, ann, name\n            )\n        )\n    return obj\n\n\ndef derive_importpath(import_path, raising):\n    if not isinstance(import_path, str) or \".\" not in import_path:\n        raise TypeError(\n            \"must be absolute import path string, not {!r}\".format(import_path)\n        )\n    module, attr = import_path.rsplit(\".\", 1)\n    target = resolve(module)\n    if raising:\n        annotated_getattr(target, attr, ann=module)\n    return attr, target\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<notset>\"\n\n\nnotset = Notset()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nose.py__run_test_suites_writt_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nose.py__run_test_suites_writt_", "embedding": null, "metadata": {"file_path": "src/_pytest/nose.py", "file_name": "nose.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 39, "span_ids": ["call_optional", "docstring", "is_potential_nosetest", "pytest_runtest_setup", "teardown_nose"], "tokens": 282}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" run test suites written for nose. \"\"\"\nfrom _pytest import python\nfrom _pytest import unittest\nfrom _pytest.config import hookimpl\n\n\n@hookimpl(trylast=True)\ndef pytest_runtest_setup(item):\n    if is_potential_nosetest(item):\n        if not call_optional(item.obj, \"setup\"):\n            # call module level setup if there is no object level one\n            call_optional(item.parent.obj, \"setup\")\n        # XXX this implies we only call teardown when setup worked\n        item.session._setupstate.addfinalizer((lambda: teardown_nose(item)), item)\n\n\ndef teardown_nose(item):\n    if is_potential_nosetest(item):\n        if not call_optional(item.obj, \"teardown\"):\n            call_optional(item.parent.obj, \"teardown\")\n\n\ndef is_potential_nosetest(item):\n    # extra check needed since we do not do nose style setup/teardown\n    # on direct unittest style classes\n    return isinstance(item, python.Function) and not isinstance(\n        item, unittest.TestCaseFunction\n    )\n\n\ndef call_optional(obj, name):\n    method = getattr(obj, name, None)\n    isfixture = hasattr(method, \"_pytestfixturefunction\")\n    if method is not None and not isfixture and callable(method):\n        # If there's any problems allow the exception to raise rather than\n        # silently ignoring them\n        method()\n        return True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_rm_rf_create_cleanup_lock": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_rm_rf_create_cleanup_lock", "embedding": null, "metadata": {"file_path": "src/_pytest/pathlib.py", "file_name": "pathlib.py", "file_type": "text/x-python", "category": "implementation", "start_line": 103, "end_line": 201, "span_ids": ["_force_symlink", "create_cleanup_lock", "extract_suffixes", "find_prefixed", "find_suffixes", "make_numbered_dir", "parse_num", "rm_rf"], "tokens": 741}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def rm_rf(path: Path) -> None:\n    \"\"\"Remove the path contents recursively, even if some elements\n    are read-only.\n    \"\"\"\n    onerror = partial(on_rm_rf_error, start_path=path)\n    shutil.rmtree(str(path), onerror=onerror)\n\n\ndef find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\n    \"\"\"finds all elements in root that begin with the prefix, case insensitive\"\"\"\n    l_prefix = prefix.lower()\n    for x in root.iterdir():\n        if x.name.lower().startswith(l_prefix):\n            yield x\n\n\ndef extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\n    \"\"\"\n    :param iter: iterator over path names\n    :param prefix: expected prefix of the path names\n    :returns: the parts of the paths following the prefix\n    \"\"\"\n    p_len = len(prefix)\n    for p in iter:\n        yield p.name[p_len:]\n\n\ndef find_suffixes(root: Path, prefix: str) -> Iterator[str]:\n    \"\"\"combines find_prefixes and extract_suffixes\n    \"\"\"\n    return extract_suffixes(find_prefixed(root, prefix), prefix)\n\n\ndef parse_num(maybe_num) -> int:\n    \"\"\"parses number path suffixes, returns -1 on error\"\"\"\n    try:\n        return int(maybe_num)\n    except ValueError:\n        return -1\n\n\ndef _force_symlink(\n    root: Path, target: Union[str, PurePath], link_to: Union[str, Path]\n) -> None:\n    \"\"\"helper to create the current symlink\n\n    it's full of race conditions that are reasonably ok to ignore\n    for the context of best effort linking to the latest test run\n\n    the presumption being that in case of much parallelism\n    the inaccuracy is going to be acceptable\n    \"\"\"\n    current_symlink = root.joinpath(target)\n    try:\n        current_symlink.unlink()\n    except OSError:\n        pass\n    try:\n        current_symlink.symlink_to(link_to)\n    except Exception:\n        pass\n\n\ndef make_numbered_dir(root: Path, prefix: str) -> Path:\n    \"\"\"create a directory with an increased number as suffix for the given prefix\"\"\"\n    for i in range(10):\n        # try up to 10 times to create the folder\n        max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n        new_number = max_existing + 1\n        new_path = root.joinpath(\"{}{}\".format(prefix, new_number))\n        try:\n            new_path.mkdir()\n        except Exception:\n            pass\n        else:\n            _force_symlink(root, prefix + \"current\", new_path)\n            return new_path\n    else:\n        raise OSError(\n            \"could not create numbered dir with prefix \"\n            \"{prefix} in {root} after 10 tries\".format(prefix=prefix, root=root)\n        )\n\n\ndef create_cleanup_lock(p: Path) -> Path:\n    \"\"\"crates a lock to prevent premature folder cleanup\"\"\"\n    lock_path = get_lock_path(p)\n    try:\n        fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)\n    except FileExistsError as e:\n        raise OSError(\"cannot create lockfile in {path}\".format(path=p)) from e\n    else:\n        pid = os.getpid()\n        spid = str(pid).encode()\n        os.write(fd, spid)\n        os.close(fd)\n        if not lock_path.is_file():\n            raise OSError(\"lock path got renamed after successful creation\")\n        return lock_path", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_register_cleanup_lock_removal_cleanup_numbered_dir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_register_cleanup_lock_removal_cleanup_numbered_dir", "embedding": null, "metadata": {"file_path": "src/_pytest/pathlib.py", "file_name": "pathlib.py", "file_type": "text/x-python", "category": "implementation", "start_line": 204, "end_line": 291, "span_ids": ["cleanup_candidates", "cleanup_numbered_dir", "ensure_deletable", "maybe_delete_a_numbered_dir", "register_cleanup_lock_removal", "try_cleanup"], "tokens": 682}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):\n    \"\"\"registers a cleanup function for removing a lock, by default on atexit\"\"\"\n    pid = os.getpid()\n\n    def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:\n        current_pid = os.getpid()\n        if current_pid != original_pid:\n            # fork\n            return\n        try:\n            lock_path.unlink()\n        except OSError:\n            pass\n\n    return register(cleanup_on_exit)\n\n\ndef maybe_delete_a_numbered_dir(path: Path) -> None:\n    \"\"\"removes a numbered directory if its lock can be obtained and it does not seem to be in use\"\"\"\n    lock_path = None\n    try:\n        lock_path = create_cleanup_lock(path)\n        parent = path.parent\n\n        garbage = parent.joinpath(\"garbage-{}\".format(uuid.uuid4()))\n        path.rename(garbage)\n        rm_rf(garbage)\n    except OSError:\n        #  known races:\n        #  * other process did a cleanup at the same time\n        #  * deletable folder was found\n        #  * process cwd (Windows)\n        return\n    finally:\n        # if we created the lock, ensure we remove it even if we failed\n        # to properly remove the numbered dir\n        if lock_path is not None:\n            try:\n                lock_path.unlink()\n            except OSError:\n                pass\n\n\ndef ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:\n    \"\"\"checks if a lock exists and breaks it if its considered dead\"\"\"\n    if path.is_symlink():\n        return False\n    lock = get_lock_path(path)\n    if not lock.exists():\n        return True\n    try:\n        lock_time = lock.stat().st_mtime\n    except Exception:\n        return False\n    else:\n        if lock_time < consider_lock_dead_if_created_before:\n            lock.unlink()\n            return True\n        else:\n            return False\n\n\ndef try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:\n    \"\"\"tries to cleanup a folder if we can ensure it's deletable\"\"\"\n    if ensure_deletable(path, consider_lock_dead_if_created_before):\n        maybe_delete_a_numbered_dir(path)\n\n\ndef cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\n    \"\"\"lists candidates for numbered directories to be removed - follows py.path\"\"\"\n    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n    max_delete = max_existing - keep\n    paths = find_prefixed(root, prefix)\n    paths, paths2 = itertools.tee(paths)\n    numbers = map(parse_num, extract_suffixes(paths2, prefix))\n    for path, number in zip(paths, numbers):\n        if number <= max_delete:\n            yield path\n\n\ndef cleanup_numbered_dir(\n    root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float\n) -> None:\n    \"\"\"cleanup for lock driven numbered directories\"\"\"\n    for path in cleanup_candidates(root, prefix, keep):\n        try_cleanup(path, consider_lock_dead_if_created_before)\n    for path in root.glob(\"garbage-*\"):\n        try_cleanup(path, consider_lock_dead_if_created_before)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_make_numbered_dir_with_cleanup_resolve_from_str": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_make_numbered_dir_with_cleanup_resolve_from_str", "embedding": null, "metadata": {"file_path": "src/_pytest/pathlib.py", "file_name": "pathlib.py", "file_type": "text/x-python", "category": "implementation", "start_line": 294, "end_line": 327, "span_ids": ["make_numbered_dir_with_cleanup", "resolve_from_str"], "tokens": 237}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def make_numbered_dir_with_cleanup(\n    root: Path, prefix: str, keep: int, lock_timeout: float\n) -> Path:\n    \"\"\"creates a numbered dir with a cleanup lock and removes old ones\"\"\"\n    e = None\n    for i in range(10):\n        try:\n            p = make_numbered_dir(root, prefix)\n            lock_path = create_cleanup_lock(p)\n            register_cleanup_lock_removal(lock_path)\n        except Exception as exc:\n            e = exc\n        else:\n            consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout\n            cleanup_numbered_dir(\n                root=root,\n                prefix=prefix,\n                keep=keep,\n                consider_lock_dead_if_created_before=consider_lock_dead_if_created_before,\n            )\n            return p\n    assert e is not None\n    raise e\n\n\ndef resolve_from_str(input, root):\n    assert not isinstance(input, Path), \"would break on py2\"\n    root = Path(root)\n    input = expanduser(input)\n    input = expandvars(input)\n    if isabs(input):\n        return Path(input)\n    else:\n        return root.joinpath(input)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py__disabled_by_default__pytest_configure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py__disabled_by_default__pytest_configure", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 91, "span_ids": ["docstring", "pytest_addoption", "pytest_configure"], "tokens": 487}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"(disabled by default) support for testing pytest and pytest plugins.\"\"\"\nimport collections.abc\nimport gc\nimport importlib\nimport os\nimport platform\nimport re\nimport subprocess\nimport sys\nimport time\nimport traceback\nfrom fnmatch import fnmatch\nfrom io import StringIO\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\nfrom weakref import WeakKeyDictionary\n\nimport py\n\nimport pytest\nfrom _pytest._code import Source\nfrom _pytest.capture import MultiCapture\nfrom _pytest.capture import SysCapture\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import _PluggyPlugin\nfrom _pytest.config import Config\nfrom _pytest.config import ExitCode\nfrom _pytest.fixtures import FixtureRequest\nfrom _pytest.main import Session\nfrom _pytest.monkeypatch import MonkeyPatch\nfrom _pytest.nodes import Collector\nfrom _pytest.nodes import Item\nfrom _pytest.pathlib import make_numbered_dir\nfrom _pytest.pathlib import Path\nfrom _pytest.python import Module\nfrom _pytest.reports import TestReport\nfrom _pytest.tmpdir import TempdirFactory\n\nif TYPE_CHECKING:\n    from typing import Type\n\n    import pexpect\n\n\nIGNORE_PAM = [  # filenames added when obtaining details about the current user\n    \"/var/lib/sss/mc/passwd\"\n]\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\n        \"--lsof\",\n        action=\"store_true\",\n        dest=\"lsof\",\n        default=False,\n        help=\"run FD checks if lsof is available\",\n    )\n\n    parser.addoption(\n        \"--runpytest\",\n        default=\"inprocess\",\n        dest=\"runpytest\",\n        choices=(\"inprocess\", \"subprocess\"),\n        help=(\n            \"run pytest sub runs in tests using an 'inprocess' \"\n            \"or 'subprocess' (python -m main) method\"\n        ),\n    )\n\n    parser.addini(\n        \"pytester_example_dir\", help=\"directory to take the pytester example files from\"\n    )\n\n\ndef pytest_configure(config):\n    if config.getvalue(\"lsof\"):\n        checker = LsofFdLeakChecker()\n        if checker.matching_platform():\n            config.pluginmanager.register(checker)\n\n    config.addinivalue_line(\n        \"markers\",\n        \"pytester_example_path(*path_segments): join the given path \"\n        \"segments to `pytester_example_dir` for this test.\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder_HookRecorder.getreports": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder_HookRecorder.getreports", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 207, "end_line": 279, "span_ids": ["HookRecorder", "HookRecorder.__init__", "HookRecorder.assert_contains", "HookRecorder.finish_recording", "HookRecorder.getcall", "HookRecorder.getcalls", "HookRecorder.getreports", "HookRecorder.popcall", "HookRecorder:3"], "tokens": 588}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class HookRecorder:\n    \"\"\"Record all hooks called in a plugin manager.\n\n    This wraps all the hook calls in the plugin manager, recording each call\n    before propagating the normal calls.\n\n    \"\"\"\n\n    def __init__(self, pluginmanager) -> None:\n        self._pluginmanager = pluginmanager\n        self.calls = []  # type: List[ParsedCall]\n\n        def before(hook_name: str, hook_impls, kwargs) -> None:\n            self.calls.append(ParsedCall(hook_name, kwargs))\n\n        def after(outcome, hook_name: str, hook_impls, kwargs) -> None:\n            pass\n\n        self._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)\n\n    def finish_recording(self) -> None:\n        self._undo_wrapping()\n\n    def getcalls(self, names: Union[str, Iterable[str]]) -> List[ParsedCall]:\n        if isinstance(names, str):\n            names = names.split()\n        return [call for call in self.calls if call._name in names]\n\n    def assert_contains(self, entries) -> None:\n        __tracebackhide__ = True\n        i = 0\n        entries = list(entries)\n        backlocals = sys._getframe(1).f_locals\n        while entries:\n            name, check = entries.pop(0)\n            for ind, call in enumerate(self.calls[i:]):\n                if call._name == name:\n                    print(\"NAMEMATCH\", name, call)\n                    if eval(check, backlocals, call.__dict__):\n                        print(\"CHECKERMATCH\", repr(check), \"->\", call)\n                    else:\n                        print(\"NOCHECKERMATCH\", repr(check), \"-\", call)\n                        continue\n                    i += ind + 1\n                    break\n                print(\"NONAMEMATCH\", name, \"with\", call)\n            else:\n                pytest.fail(\"could not find {!r} check {!r}\".format(name, check))\n\n    def popcall(self, name: str) -> ParsedCall:\n        __tracebackhide__ = True\n        for i, call in enumerate(self.calls):\n            if call._name == name:\n                del self.calls[i]\n                return call\n        lines = [\"could not find call {!r}, in:\".format(name)]\n        lines.extend([\"  %s\" % x for x in self.calls])\n        pytest.fail(\"\\n\".join(lines))\n\n    def getcall(self, name: str) -> ParsedCall:\n        values = self.getcalls(name)\n        assert len(values) == 1, (name, values)\n        return values[0]\n\n    # functionality for test reports\n\n    def getreports(\n        self,\n        names: Union[\n            str, Iterable[str]\n        ] = \"pytest_runtest_logreport pytest_collectreport\",\n    ) -> List[TestReport]:\n        return [x.report for x in self.getcalls(names)]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder.matchreport_HookRecorder.matchreport.return_values_0_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder.matchreport_HookRecorder.matchreport.return_values_0_", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 281, "end_line": 310, "span_ids": ["HookRecorder.matchreport"], "tokens": 216}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class HookRecorder:\n\n    def matchreport(\n        self,\n        inamepart: str = \"\",\n        names: Union[\n            str, Iterable[str]\n        ] = \"pytest_runtest_logreport pytest_collectreport\",\n        when=None,\n    ):\n        \"\"\"return a testreport whose dotted import path matches\"\"\"\n        values = []\n        for rep in self.getreports(names=names):\n            if not when and rep.when != \"call\" and rep.passed:\n                # setup/teardown passing reports - let's ignore those\n                continue\n            if when and rep.when != when:\n                continue\n            if not inamepart or inamepart in rep.nodeid.split(\"::\"):\n                values.append(rep)\n        if not values:\n            raise ValueError(\n                \"could not find test report matching %r: \"\n                \"no test reports at all!\" % (inamepart,)\n            )\n        if len(values) > 1:\n            raise ValueError(\n                \"found 2 or more testreports matching {!r}: {}\".format(\n                    inamepart, values\n                )\n            )\n        return values[0]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder.getfailures_HookRecorder.clear": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_HookRecorder.getfailures_HookRecorder.clear", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 312, "end_line": 357, "span_ids": ["HookRecorder.assertoutcome", "HookRecorder.clear", "HookRecorder.countoutcomes", "HookRecorder.getfailedcollections", "HookRecorder.getfailures", "HookRecorder.listoutcomes"], "tokens": 347}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class HookRecorder:\n\n    def getfailures(\n        self,\n        names: Union[\n            str, Iterable[str]\n        ] = \"pytest_runtest_logreport pytest_collectreport\",\n    ) -> List[TestReport]:\n        return [rep for rep in self.getreports(names) if rep.failed]\n\n    def getfailedcollections(self) -> List[TestReport]:\n        return self.getfailures(\"pytest_collectreport\")\n\n    def listoutcomes(\n        self,\n    ) -> Tuple[List[TestReport], List[TestReport], List[TestReport]]:\n        passed = []\n        skipped = []\n        failed = []\n        for rep in self.getreports(\"pytest_collectreport pytest_runtest_logreport\"):\n            if rep.passed:\n                if rep.when == \"call\":\n                    passed.append(rep)\n            elif rep.skipped:\n                skipped.append(rep)\n            else:\n                assert rep.failed, \"Unexpected outcome: {!r}\".format(rep)\n                failed.append(rep)\n        return passed, skipped, failed\n\n    def countoutcomes(self) -> List[int]:\n        return [len(x) for x in self.listoutcomes()]\n\n    def assertoutcome(self, passed: int = 0, skipped: int = 0, failed: int = 0) -> None:\n        __tracebackhide__ = True\n\n        outcomes = self.listoutcomes()\n        realpassed, realskipped, realfailed = outcomes\n        obtained = {\n            \"passed\": len(realpassed),\n            \"skipped\": len(realskipped),\n            \"failed\": len(realfailed),\n        }\n        expected = {\"passed\": passed, \"skipped\": skipped, \"failed\": failed}\n        assert obtained == expected, outcomes\n\n    def clear(self) -> None:\n        self.calls[:] = []", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_linecomp_rex_outcome": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_linecomp_rex_outcome", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 360, "end_line": 413, "span_ids": ["LineMatcher_fixture", "_config_for_test", "_sys_snapshot", "impl:4", "linecomp", "testdir"], "tokens": 367}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.fixture\ndef linecomp() -> \"LineComp\":\n    \"\"\"\n    A :class: `LineComp` instance for checking that an input linearly\n    contains a sequence of strings.\n    \"\"\"\n    return LineComp()\n\n\n@pytest.fixture(name=\"LineMatcher\")\ndef LineMatcher_fixture(request: FixtureRequest) -> \"Type[LineMatcher]\":\n    \"\"\"\n    A reference to the :class: `LineMatcher`.\n\n    This is instantiable with a list of lines (without their trailing newlines).\n    This is useful for testing large texts, such as the output of commands.\n    \"\"\"\n    return LineMatcher\n\n\n@pytest.fixture\ndef testdir(request: FixtureRequest, tmpdir_factory) -> \"Testdir\":\n    \"\"\"\n    A :class: `TestDir` instance, that can be used to run and test pytest itself.\n\n    It is particularly useful for testing plugins. It is similar to the `tmpdir` fixture\n    but provides methods which aid in testing pytest itself.\n\n    \"\"\"\n    return Testdir(request, tmpdir_factory)\n\n\n@pytest.fixture\ndef _sys_snapshot():\n    snappaths = SysPathsSnapshot()\n    snapmods = SysModulesSnapshot()\n    yield\n    snapmods.restore()\n    snappaths.restore()\n\n\n@pytest.fixture\ndef _config_for_test():\n    from _pytest.config import get_config\n\n    config = get_config()\n    yield config\n    config._ensure_unconfigure()  # cleanup, e.g. capman closing tmpfiles.\n\n\n# regex to match the session duration string in the summary: \"74.34s\"\nrex_session_duration = re.compile(r\"\\d+\\.\\d\\ds\")\n# regex to match all the counts and phrases in the summary line: \"34 passed, 111 skipped\"\nrex_outcome = re.compile(r\"(\\d+) (\\w+)\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir._dump_lines_Testdir.runpytest_subprocess": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir._dump_lines_Testdir.runpytest_subprocess", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1223, "end_line": 1267, "span_ids": ["Testdir._dump_lines", "Testdir._getpytestargs", "Testdir.runpytest_subprocess", "Testdir.runpython", "Testdir.runpython_c"], "tokens": 413}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def _dump_lines(self, lines, fp):\n        try:\n            for line in lines:\n                print(line, file=fp)\n        except UnicodeEncodeError:\n            print(\"couldn't print to {} because of encoding\".format(fp))\n\n    def _getpytestargs(self):\n        return sys.executable, \"-mpytest\"\n\n    def runpython(self, script) -> RunResult:\n        \"\"\"Run a python script using sys.executable as interpreter.\n\n        Returns a :py:class:`RunResult`.\n\n        \"\"\"\n        return self.run(sys.executable, script)\n\n    def runpython_c(self, command):\n        \"\"\"Run python -c \"command\", return a :py:class:`RunResult`.\"\"\"\n        return self.run(sys.executable, \"-c\", command)\n\n    def runpytest_subprocess(self, *args, timeout=None) -> RunResult:\n        \"\"\"Run pytest as a subprocess with given arguments.\n\n        Any plugins added to the :py:attr:`plugins` list will be added using the\n        ``-p`` command line option.  Additionally ``--basetemp`` is used to put\n        any temporary files and directories in a numbered directory prefixed\n        with \"runpytest-\" to not conflict with the normal numbered pytest\n        location for temporary files and directories.\n\n        :param args: the sequence of arguments to pass to the pytest subprocess\n        :param timeout: the period in seconds after which to timeout and raise\n            :py:class:`Testdir.TimeoutExpired`\n\n        Returns a :py:class:`RunResult`.\n        \"\"\"\n        __tracebackhide__ = True\n        p = make_numbered_dir(root=Path(self.tmpdir), prefix=\"runpytest-\")\n        args = (\"--basetemp=%s\" % p,) + args\n        plugins = [x for x in self.plugins if isinstance(x, str)]\n        if plugins:\n            args = (\"-p\", plugins[0]) + args\n        args = self._getpytestargs() + args\n        return self.run(*args, timeout=timeout)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__Python_test_discovery_pyobj_property": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__Python_test_discovery_pyobj_property", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 69, "span_ids": ["docstring", "pyobj_property"], "tokens": 426}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" Python test discovery, setup and run of test functions. \"\"\"\nimport enum\nimport fnmatch\nimport inspect\nimport itertools\nimport os\nimport sys\nimport typing\nimport warnings\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections.abc import Sequence\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n\nimport py\n\nimport _pytest\nfrom _pytest import fixtures\nfrom _pytest import nodes\nfrom _pytest._code import filter_traceback\nfrom _pytest._code import getfslineno\nfrom _pytest._code.code import ExceptionInfo\nfrom _pytest._io import TerminalWriter\nfrom _pytest._io.saferepr import saferepr\nfrom _pytest.compat import ascii_escaped\nfrom _pytest.compat import get_default_arg_names\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import getimfunc\nfrom _pytest.compat import getlocation\nfrom _pytest.compat import is_async_function\nfrom _pytest.compat import is_generator\nfrom _pytest.compat import NOTSET\nfrom _pytest.compat import REGEX_TYPE\nfrom _pytest.compat import safe_getattr\nfrom _pytest.compat import safe_isclass\nfrom _pytest.compat import STRING_TYPES\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.deprecated import FUNCARGNAMES\nfrom _pytest.fixtures import FuncFixtureInfo\nfrom _pytest.mark import MARK_GEN\nfrom _pytest.mark import ParameterSet\nfrom _pytest.mark.structures import get_unpacked_marks\nfrom _pytest.mark.structures import Mark\nfrom _pytest.mark.structures import normalize_mark_list\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.pathlib import parts\nfrom _pytest.warning_types import PytestCollectionWarning\nfrom _pytest.warning_types import PytestUnhandledCoroutineWarning\n\n\ndef pyobj_property(name):\n    def get(self):\n        node = self.getparent(getattr(__import__(\"pytest\"), name))\n        if node is not None:\n            return node.obj\n\n    doc = \"python {} object this node was collected from (can be None).\".format(\n        name.lower()\n    )\n    return property(get, None, None, doc)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_CallSpec2_CallSpec2.setmulti2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_CallSpec2_CallSpec2.setmulti2", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 767, "end_line": 809, "span_ids": ["CallSpec2", "CallSpec2.__init__", "CallSpec2._checkargnotcontained", "CallSpec2.copy", "CallSpec2.getparam", "CallSpec2.id", "CallSpec2.setmulti2"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class CallSpec2:\n    def __init__(self, metafunc):\n        self.metafunc = metafunc\n        self.funcargs = {}\n        self._idlist = []\n        self.params = {}\n        self._arg2scopenum = {}  # used for sorting parametrized resources\n        self.marks = []\n        self.indices = {}\n\n    def copy(self):\n        cs = CallSpec2(self.metafunc)\n        cs.funcargs.update(self.funcargs)\n        cs.params.update(self.params)\n        cs.marks.extend(self.marks)\n        cs.indices.update(self.indices)\n        cs._arg2scopenum.update(self._arg2scopenum)\n        cs._idlist = list(self._idlist)\n        return cs\n\n    def _checkargnotcontained(self, arg):\n        if arg in self.params or arg in self.funcargs:\n            raise ValueError(\"duplicate {!r}\".format(arg))\n\n    def getparam(self, name):\n        try:\n            return self.params[name]\n        except KeyError:\n            raise ValueError(name)\n\n    @property\n    def id(self):\n        return \"-\".join(map(str, self._idlist))\n\n    def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):\n        for arg, val in zip(argnames, valset):\n            self._checkargnotcontained(arg)\n            valtype_for_arg = valtypes[arg]\n            getattr(self, valtype_for_arg)[arg] = val\n            self.indices[arg] = param_index\n            self._arg2scopenum[arg] = scopenum\n        self._idlist.append(id)\n        self.marks.extend(normalize_mark_list(marks))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_inspect__non_numeric_type_error": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_inspect__non_numeric_type_error", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 42, "span_ids": ["_non_numeric_type_error", "imports"], "tokens": 209}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import inspect\nimport math\nimport pprint\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sized\nfrom decimal import Decimal\nfrom itertools import filterfalse\nfrom numbers import Number\nfrom types import TracebackType\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import Pattern\nfrom typing import Tuple\nfrom typing import TypeVar\nfrom typing import Union\n\nfrom more_itertools.more import always_iterable\n\nimport _pytest._code\nfrom _pytest.compat import overload\nfrom _pytest.compat import STRING_TYPES\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.outcomes import fail\n\nif TYPE_CHECKING:\n    from typing import Type  # noqa: F401 (used in type string)\n\n\nBASE_TYPE = (type, STRING_TYPES)\n\n\ndef _non_numeric_type_error(value, at):\n    at_str = \" at {}\".format(at) if at else \"\"\n    return TypeError(\n        \"cannot make approximate comparisons to non-numeric values: {!r} {}\".format(\n            value, at_str\n        )\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar_ApproxScalar.__repr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar_ApproxScalar.__repr__", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 214, "end_line": 244, "span_ids": ["ApproxScalar", "ApproxScalar.__repr__"], "tokens": 313}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ApproxScalar(ApproxBase):\n    \"\"\"\n    Perform approximate comparisons where the expected value is a single number.\n    \"\"\"\n\n    # Using Real should be better than this Union, but not possible yet:\n    # https://github.com/python/typeshed/pull/3108\n    DEFAULT_ABSOLUTE_TOLERANCE = 1e-12  # type: Union[float, Decimal]\n    DEFAULT_RELATIVE_TOLERANCE = 1e-6  # type: Union[float, Decimal]\n\n    def __repr__(self):\n        \"\"\"\n        Return a string communicating both the expected value and the tolerance\n        for the comparison being made, e.g. '1.0 \u00b1 1e-6', '(3+4j) \u00b1 5e-6 \u2220 \u00b1180\u00b0'.\n        \"\"\"\n\n        # Infinities aren't compared using tolerances, so don't show a\n        # tolerance. Need to call abs to handle complex numbers, e.g. (inf + 1j)\n        if math.isinf(abs(self.expected)):\n            return str(self.expected)\n\n        # If a sensible tolerance can't be calculated, self.tolerance will\n        # raise a ValueError.  In this case, display '???'.\n        try:\n            vetted_tolerance = \"{:.1e}\".format(self.tolerance)\n            if isinstance(self.expected, complex) and not math.isinf(self.tolerance):\n                vetted_tolerance += \" \u2220 \u00b1180\u00b0\"\n        except ValueError:\n            vetted_tolerance = \"???\"\n\n        return \"{} \u00b1 {}\".format(self.expected, vetted_tolerance)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar.__eq___ApproxScalar._type_ignore": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_ApproxScalar.__eq___ApproxScalar._type_ignore", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 247, "end_line": 280, "span_ids": ["ApproxScalar.__eq__", "ApproxScalar:5"], "tokens": 291}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ApproxScalar(ApproxBase):\n\n    def __eq__(self, actual):\n        \"\"\"\n        Return true if the given value is equal to the expected value within\n        the pre-specified tolerance.\n        \"\"\"\n        if _is_numpy_array(actual):\n            # Call ``__eq__()`` manually to prevent infinite-recursion with\n            # numpy<1.13.  See #3748.\n            return all(self.__eq__(a) for a in actual.flat)\n\n        # Short-circuit exact equality.\n        if actual == self.expected:\n            return True\n\n        # Allow the user to control whether NaNs are considered equal to each\n        # other or not.  The abs() calls are for compatibility with complex\n        # numbers.\n        if math.isnan(abs(self.expected)):\n            return self.nan_ok and math.isnan(abs(actual))\n\n        # Infinity shouldn't be approximately equal to anything but itself, but\n        # if there's a relative tolerance, it will be infinite and infinity\n        # will seem approximately equal to everything.  The equal-to-itself\n        # case would have been short circuited above, so here we can just\n        # return false if the expected value is infinite.  The abs() call is\n        # for compatibility with complex numbers.\n        if math.isinf(abs(self.expected)):\n            return False\n\n        # Return true if the two numbers are within the tolerance.\n        return abs(self.expected - actual) <= self.tolerance\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_approx._Delegate_the_comparison_approx.return_cls_expected_rel_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_approx._Delegate_the_comparison_approx.return_cls_expected_rel_", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 492, "end_line": 526, "span_ids": ["approx"], "tokens": 296}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def approx(expected, rel=None, abs=None, nan_ok=False):\n\n    # Delegate the comparison to a class that knows how to deal with the type\n    # of the expected value (e.g. int, float, list, dict, numpy.array, etc).\n    #\n    # The primary responsibility of these classes is to implement ``__eq__()``\n    # and ``__repr__()``.  The former is used to actually check if some\n    # \"actual\" value is equivalent to the given expected value within the\n    # allowed tolerance.  The latter is used to show the user the expected\n    # value and tolerance, in the case that a test failed.\n    #\n    # The actual logic for making approximate comparisons can be found in\n    # ApproxScalar, which is used to compare individual numbers.  All of the\n    # other Approx classes eventually delegate to this class.  The ApproxBase\n    # class provides some convenient methods and overloads, but isn't really\n    # essential.\n\n    __tracebackhide__ = True\n\n    if isinstance(expected, Decimal):\n        cls = ApproxDecimal\n    elif isinstance(expected, Number):\n        cls = ApproxScalar\n    elif isinstance(expected, Mapping):\n        cls = ApproxMapping\n    elif _is_numpy_array(expected):\n        cls = ApproxNumpy\n    elif (\n        isinstance(expected, Iterable)\n        and isinstance(expected, Sized)\n        and not isinstance(expected, STRING_TYPES)\n    ):\n        cls = ApproxSequencelike\n    else:\n        raise _non_numeric_type_error(expected, at=None)\n\n    return cls(expected, rel, abs, nan_ok)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__is_numpy_array_raises_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__is_numpy_array_raises_5", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 528, "end_line": 562, "span_ids": ["_is_numpy_array", "impl:4", "raises", "raises_5"], "tokens": 220}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _is_numpy_array(obj):\n    \"\"\"\n    Return true if the given object is a numpy array.  Make a special effort to\n    avoid importing numpy unless it's really necessary.\n    \"\"\"\n    import sys\n\n    np = sys.modules.get(\"numpy\")\n    if np is not None:\n        return isinstance(obj, np.ndarray)\n    return False\n\n\n# builtin pytest.raises helper\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@overload\ndef raises(\n    expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n    *,\n    match: \"Optional[Union[str, Pattern]]\" = ...\n) -> \"RaisesContext[_E]\":\n    ...  # pragma: no cover\n\n\n@overload  # noqa: F811\ndef raises(  # noqa: F811\n    expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n    func: Callable,\n    *args: Any,\n    **kwargs: Any\n) -> _pytest._code.ExceptionInfo[_E]:\n    ...  # pragma: no cover", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_raises_6_raises_6.r_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_raises_6_raises_6.r_", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 565, "end_line": 678, "span_ids": ["raises_6"], "tokens": 1005}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def raises(  # noqa: F811\n    expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n    *args: Any,\n    **kwargs: Any\n) -> Union[\"RaisesContext[_E]\", _pytest._code.ExceptionInfo[_E]]:\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n        (This is only used when ``pytest.raises`` is used as a context manager,\n        and passed through to the function otherwise.\n        When using ``pytest.raises`` as a function, you can use:\n        ``pytest.raises(Exc, func, match=\"passed on\").match(\"my pattern\")``.)\n\n        __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run.\n        More detailed information can be found in the official Python\n        documentation for :ref:`the try statement <python:try>`.\n    \"\"\"\n    # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_raises_6.__tracebackhide___raises.Exception": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py_raises_6.__tracebackhide___raises.Exception", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 679, "end_line": 713, "span_ids": ["impl:6", "raises_6"], "tokens": 253}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def raises(  # noqa: F811\n    expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n    *args: Any,\n    **kwargs: Any\n) -> Union[\"RaisesContext[_E]\", _pytest._code.ExceptionInfo[_E]]:\n    __tracebackhide__ = True\n    for exc in filterfalse(\n        inspect.isclass, always_iterable(expected_exception, BASE_TYPE)\n    ):\n        msg = \"exceptions must be derived from BaseException, not %s\"\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n\n    if not args:\n        match = kwargs.pop(\"match\", None)\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            msg += \"\\nUse context-manager form instead?\"\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match)\n    else:\n        func = args[0]\n        if not callable(func):\n            raise TypeError(\n                \"{!r} object (type: {}) must be callable\".format(func, type(func))\n            )\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception as e:\n            # We just caught the exception - there is a traceback.\n            assert e.__traceback__ is not None\n            return _pytest._code.ExceptionInfo.from_exc_info(\n                (type(e), e, e.__traceback__)\n            )\n    fail(message)\n\n\nraises.Exception = fail.Exception", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__type_ignore_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python_api.py__type_ignore_", "embedding": null, "metadata": {"file_path": "src/_pytest/python_api.py", "file_name": "python_api.py", "file_type": "text/x-python", "category": "implementation", "start_line": 720, "end_line": 759, "span_ids": ["RaisesContext", "RaisesContext.__enter__", "RaisesContext.__exit__", "RaisesContext.__init__", "impl:6"], "tokens": 306}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "  # type: ignore\n\n\nclass RaisesContext(Generic[_E]):\n    def __init__(\n        self,\n        expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n        message: str,\n        match_expr: Optional[Union[str, \"Pattern\"]] = None,\n    ) -> None:\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None  # type: Optional[_pytest._code.ExceptionInfo[_E]]\n\n    def __enter__(self) -> _pytest._code.ExceptionInfo[_E]:\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(\n        self,\n        exc_type: Optional[\"Type[BaseException]\"],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> bool:\n        __tracebackhide__ = True\n        if exc_type is None:\n            fail(self.message)\n        assert self.excinfo is not None\n        if not issubclass(exc_type, self.expected_exception):\n            return False\n        # Cast to narrow the exception type now that it's verified.\n        exc_info = cast(\n            Tuple[\"Type[_E]\", _E, TracebackType], (exc_type, exc_val, exc_tb)\n        )\n        self.excinfo.fill_unfilled(exc_info)\n        if self.match_expr is not None:\n            self.excinfo.match(self.match_expr)\n        return True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py__recording_warnings_du_warns_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py__recording_warnings_du_warns_3", "embedding": null, "metadata": {"file_path": "src/_pytest/recwarn.py", "file_name": "recwarn.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 75, "span_ids": ["deprecated_call", "docstring", "recwarn", "warns", "warns_3"], "tokens": 499}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" recording warnings during test function execution. \"\"\"\nimport re\nimport warnings\nfrom types import TracebackType\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Pattern\nfrom typing import Tuple\nfrom typing import Union\n\nfrom _pytest.compat import overload\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.fixtures import yield_fixture\nfrom _pytest.outcomes import fail\n\nif TYPE_CHECKING:\n    from typing import Type\n\n\n@yield_fixture\ndef recwarn():\n    \"\"\"Return a :class:`WarningsRecorder` instance that records all warnings emitted by test functions.\n\n    See http://docs.python.org/library/warnings.html for information\n    on warning categories.\n    \"\"\"\n    wrec = WarningsRecorder()\n    with wrec:\n        warnings.simplefilter(\"default\")\n        yield wrec\n\n\ndef deprecated_call(func=None, *args, **kwargs):\n    \"\"\"context manager that can be used to ensure a block of code triggers a\n    ``DeprecationWarning`` or ``PendingDeprecationWarning``::\n\n        >>> import warnings\n        >>> def api_call_v2():\n        ...     warnings.warn('use v3 of this api', DeprecationWarning)\n        ...     return 200\n\n        >>> with deprecated_call():\n        ...    assert api_call_v2() == 200\n\n    ``deprecated_call`` can also be used by passing a function and ``*args`` and ``*kwargs``,\n    in which case it will ensure calling ``func(*args, **kwargs)`` produces one of the warnings\n    types above.\n    \"\"\"\n    __tracebackhide__ = True\n    if func is not None:\n        args = (func,) + args\n    return warns((DeprecationWarning, PendingDeprecationWarning), *args, **kwargs)\n\n\n@overload\ndef warns(\n    expected_warning: Optional[Union[\"Type[Warning]\", Tuple[\"Type[Warning]\", ...]]],\n    *,\n    match: \"Optional[Union[str, Pattern]]\" = ...\n) -> \"WarningsChecker\":\n    raise NotImplementedError()\n\n\n@overload  # noqa: F811\ndef warns(  # noqa: F811\n    expected_warning: Optional[Union[\"Type[Warning]\", Tuple[\"Type[Warning]\", ...]]],\n    func: Callable,\n    *args: Any,\n    match: Optional[Union[str, \"Pattern\"]] = ...,\n    **kwargs: Any\n) -> Union[Any]:\n    raise NotImplementedError()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_warns_4_warns_4.if_not_args_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_warns_4_warns_4.if_not_args_", "embedding": null, "metadata": {"file_path": "src/_pytest/recwarn.py", "file_name": "recwarn.py", "file_type": "text/x-python", "category": "implementation", "start_line": 78, "end_line": 130, "span_ids": ["warns_4"], "tokens": 470}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def warns(  # noqa: F811\n    expected_warning: Optional[Union[\"Type[Warning]\", Tuple[\"Type[Warning]\", ...]]],\n    *args: Any,\n    match: Optional[Union[str, \"Pattern\"]] = None,\n    **kwargs: Any\n) -> Union[\"WarningsChecker\", Any]:\n    r\"\"\"Assert that code raises a particular class of warning.\n\n    Specifically, the parameter ``expected_warning`` can be a warning class or\n    sequence of warning classes, and the inside the ``with`` block must issue a warning of that class or\n    classes.\n\n    This helper produces a list of :class:`warnings.WarningMessage` objects,\n    one for each warning raised.\n\n    This function can be used as a context manager, or any of the other ways\n    ``pytest.raises`` can be used::\n\n        >>> with warns(RuntimeWarning):\n        ...    warnings.warn(\"my warning\", RuntimeWarning)\n\n    In the context manager form you may use the keyword argument ``match`` to assert\n    that the exception matches a text or regex::\n\n        >>> with warns(UserWarning, match='must be 0 or None'):\n        ...     warnings.warn(\"value must be 0 or None\", UserWarning)\n\n        >>> with warns(UserWarning, match=r'must be \\d+$'):\n        ...     warnings.warn(\"value must be 42\", UserWarning)\n\n        >>> with warns(UserWarning, match=r'must be \\d+$'):\n        ...     warnings.warn(\"this is not here\", UserWarning)\n        Traceback (most recent call last):\n          ...\n        Failed: DID NOT WARN. No warnings of type ...UserWarning... was emitted...\n\n    \"\"\"\n    __tracebackhide__ = True\n    if not args:\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.warns: \"\n            msg += \", \".join(sorted(kwargs))\n            msg += \"\\nUse context-manager form instead?\"\n            raise TypeError(msg)\n        return WarningsChecker(expected_warning, match_expr=match)\n    else:\n        func = args[0]\n        if not callable(func):\n            raise TypeError(\n                \"{!r} object (type: {}) must be callable\".format(func, type(func))\n            )\n        with WarningsChecker(expected_warning):\n            return func(*args[1:], **kwargs)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_WarningsRecorder_WarningsRecorder.__exit__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/recwarn.py_WarningsRecorder_WarningsRecorder.__exit__", "embedding": null, "metadata": {"file_path": "src/_pytest/recwarn.py", "file_name": "recwarn.py", "file_type": "text/x-python", "category": "implementation", "start_line": 133, "end_line": 200, "span_ids": ["WarningsRecorder", "WarningsRecorder.__enter__", "WarningsRecorder.__exit__", "WarningsRecorder.__getitem__", "WarningsRecorder.__init__", "WarningsRecorder.__iter__", "WarningsRecorder.__len__", "WarningsRecorder.clear", "WarningsRecorder.list", "WarningsRecorder.pop", "WarningsRecorder:3"], "tokens": 522}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class WarningsRecorder(warnings.catch_warnings):\n    \"\"\"A context manager to record raised warnings.\n\n    Adapted from `warnings.catch_warnings`.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(record=True)\n        self._entered = False\n        self._list = []  # type: List[warnings.WarningMessage]\n\n    @property\n    def list(self) -> List[\"warnings.WarningMessage\"]:\n        \"\"\"The list of recorded warnings.\"\"\"\n        return self._list\n\n    def __getitem__(self, i: int) -> \"warnings.WarningMessage\":\n        \"\"\"Get a recorded warning by index.\"\"\"\n        return self._list[i]\n\n    def __iter__(self) -> Iterator[\"warnings.WarningMessage\"]:\n        \"\"\"Iterate through the recorded warnings.\"\"\"\n        return iter(self._list)\n\n    def __len__(self) -> int:\n        \"\"\"The number of recorded warnings.\"\"\"\n        return len(self._list)\n\n    def pop(self, cls: \"Type[Warning]\" = Warning) -> \"warnings.WarningMessage\":\n        \"\"\"Pop the first recorded warning, raise exception if not exists.\"\"\"\n        for i, w in enumerate(self._list):\n            if issubclass(w.category, cls):\n                return self._list.pop(i)\n        __tracebackhide__ = True\n        raise AssertionError(\"%r not found in warning list\" % cls)\n\n    def clear(self) -> None:\n        \"\"\"Clear the list of recorded warnings.\"\"\"\n        self._list[:] = []\n\n    # Type ignored because it doesn't exactly warnings.catch_warnings.__enter__\n    # -- it returns a List but we only emulate one.\n    def __enter__(self) -> \"WarningsRecorder\":  # type: ignore\n        if self._entered:\n            __tracebackhide__ = True\n            raise RuntimeError(\"Cannot enter %r twice\" % self)\n        _list = super().__enter__()\n        # record=True means it's None.\n        assert _list is not None\n        self._list = _list\n        warnings.simplefilter(\"always\")\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[\"Type[BaseException]\"],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        if not self._entered:\n            __tracebackhide__ = True\n            raise RuntimeError(\"Cannot exit %r without entering first\" % self)\n\n        super().__exit__(exc_type, exc_val, exc_tb)\n\n        # Built-in catch_warnings does not reset entered state so we do it\n        # manually here for this context manager to become reusable.\n        self._entered = False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_BaseReport_BaseReport._from_json": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_BaseReport_BaseReport._from_json", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 41, "end_line": 195, "span_ids": ["BaseReport", "BaseReport.__init__", "BaseReport._from_json", "BaseReport._get_verbose_word", "BaseReport._to_json", "BaseReport.caplog", "BaseReport.capstderr", "BaseReport.capstdout", "BaseReport.count_towards_summary", "BaseReport.fspath", "BaseReport.get_sections", "BaseReport.head_line", "BaseReport.longreprtext", "BaseReport.toterminal", "BaseReport:7", "BaseReport:8"], "tokens": 930}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class BaseReport:\n    when = None  # type: Optional[str]\n    location = None  # type: Optional[Tuple[str, Optional[int], str]]\n    longrepr = None\n    sections = []  # type: List[Tuple[str, str]]\n    nodeid = None  # type: str\n\n    def __init__(self, **kw: Any) -> None:\n        self.__dict__.update(kw)\n\n    if TYPE_CHECKING:\n        # Can have arbitrary fields given to __init__().\n        def __getattr__(self, key: str) -> Any:\n            raise NotImplementedError()\n\n    def toterminal(self, out) -> None:\n        if hasattr(self, \"node\"):\n            out.line(getslaveinfoline(self.node))\n\n        longrepr = self.longrepr\n        if longrepr is None:\n            return\n\n        if hasattr(longrepr, \"toterminal\"):\n            longrepr.toterminal(out)\n        else:\n            try:\n                out.line(longrepr)\n            except UnicodeEncodeError:\n                out.line(\"<unprintable longrepr>\")\n\n    def get_sections(self, prefix):\n        for name, content in self.sections:\n            if name.startswith(prefix):\n                yield prefix, content\n\n    @property\n    def longreprtext(self):\n        \"\"\"\n        Read-only property that returns the full string representation\n        of ``longrepr``.\n\n        .. versionadded:: 3.0\n        \"\"\"\n        file = StringIO()\n        tw = TerminalWriter(file)\n        tw.hasmarkup = False\n        self.toterminal(tw)\n        exc = file.getvalue()\n        return exc.strip()\n\n    @property\n    def caplog(self):\n        \"\"\"Return captured log lines, if log capturing is enabled\n\n        .. versionadded:: 3.5\n        \"\"\"\n        return \"\\n\".join(\n            content for (prefix, content) in self.get_sections(\"Captured log\")\n        )\n\n    @property\n    def capstdout(self):\n        \"\"\"Return captured text from stdout, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stdout\")\n        )\n\n    @property\n    def capstderr(self):\n        \"\"\"Return captured text from stderr, if capturing is enabled\n\n        .. versionadded:: 3.0\n        \"\"\"\n        return \"\".join(\n            content for (prefix, content) in self.get_sections(\"Captured stderr\")\n        )\n\n    passed = property(lambda x: x.outcome == \"passed\")\n    failed = property(lambda x: x.outcome == \"failed\")\n    skipped = property(lambda x: x.outcome == \"skipped\")\n\n    @property\n    def fspath(self) -> str:\n        return self.nodeid.split(\"::\")[0]\n\n    @property\n    def count_towards_summary(self):\n        \"\"\"\n        **Experimental**\n\n        ``True`` if this report should be counted towards the totals shown at the end of the\n        test session: \"1 passed, 1 failure, etc\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        return True\n\n    @property\n    def head_line(self):\n        \"\"\"\n        **Experimental**\n\n        Returns the head line shown with longrepr output for this report, more commonly during\n        traceback representation during failures::\n\n            ________ Test.foo ________\n\n\n        In the example above, the head_line is \"Test.foo\".\n\n        .. note::\n\n            This function is considered **experimental**, so beware that it is subject to changes\n            even in patch releases.\n        \"\"\"\n        if self.location is not None:\n            fspath, lineno, domain = self.location\n            return domain\n\n    def _get_verbose_word(self, config):\n        _category, _short, verbose = config.hook.pytest_report_teststatus(\n            report=self, config=config\n        )\n        return verbose\n\n    def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n        return _report_to_json(self)\n\n    @classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        kwargs = _report_kwargs_from_json(reportdict)\n        return cls(**kwargs)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_CollectReport_pytest_report_from_serializable": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_CollectReport_pytest_report_from_serializable", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 315, "end_line": 361, "span_ids": ["CollectErrorRepr", "CollectErrorRepr.__init__", "CollectErrorRepr.toterminal", "CollectReport", "CollectReport.__init__", "CollectReport.__repr__", "CollectReport.location", "pytest_report_from_serializable", "pytest_report_to_serializable"], "tokens": 320}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(\n        self, nodeid: str, outcome, longrepr, result: List[Node], sections=(), **extra\n    ) -> None:\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n        return (self.fspath, None, self.fspath)\n\n    def __repr__(self):\n        return \"<CollectReport {!r} lenresult={} outcome={!r}>\".format(\n            self.nodeid, len(self.result), self.outcome\n        )\n\n\nclass CollectErrorRepr(TerminalRepr):\n    def __init__(self, msg):\n        self.longrepr = msg\n\n    def toterminal(self, out) -> None:\n        out.line(self.longrepr, red=True)\n\n\ndef pytest_report_to_serializable(report):\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()\n        data[\"$report_type\"] = report.__class__.__name__\n        return data\n\n\ndef pytest_report_from_serializable(data):\n    if \"$report_type\" in data:\n        if data[\"$report_type\"] == \"TestReport\":\n            return TestReport._from_json(data)\n        elif data[\"$report_type\"] == \"CollectReport\":\n            return CollectReport._from_json(data)\n        assert False, \"Unknown report_type unserialize data: {}\".format(\n            data[\"$report_type\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_to_json__report_to_json.return_d": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_to_json__report_to_json.return_d", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 364, "end_line": 427, "span_ids": ["_report_to_json"], "tokens": 486}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _report_to_json(report):\n    \"\"\"\n    This was originally the serialize_report() function from xdist (ca03269).\n\n    Returns the contents of this report as a dict of builtin entries, suitable for\n    serialization.\n    \"\"\"\n\n    def serialize_repr_entry(entry):\n        entry_data = {\"type\": type(entry).__name__, \"data\": attr.asdict(entry)}\n        for key, value in entry_data[\"data\"].items():\n            if hasattr(value, \"__dict__\"):\n                entry_data[\"data\"][key] = attr.asdict(value)\n        return entry_data\n\n    def serialize_repr_traceback(reprtraceback: ReprTraceback):\n        result = attr.asdict(reprtraceback)\n        result[\"reprentries\"] = [\n            serialize_repr_entry(x) for x in reprtraceback.reprentries\n        ]\n        return result\n\n    def serialize_repr_crash(reprcrash: Optional[ReprFileLocation]):\n        if reprcrash is not None:\n            return attr.asdict(reprcrash)\n        else:\n            return None\n\n    def serialize_longrepr(rep):\n        result = {\n            \"reprcrash\": serialize_repr_crash(rep.longrepr.reprcrash),\n            \"reprtraceback\": serialize_repr_traceback(rep.longrepr.reprtraceback),\n            \"sections\": rep.longrepr.sections,\n        }\n        if isinstance(rep.longrepr, ExceptionChainRepr):\n            result[\"chain\"] = []\n            for repr_traceback, repr_crash, description in rep.longrepr.chain:\n                result[\"chain\"].append(\n                    (\n                        serialize_repr_traceback(repr_traceback),\n                        serialize_repr_crash(repr_crash),\n                        description,\n                    )\n                )\n        else:\n            result[\"chain\"] = None\n        return result\n\n    d = report.__dict__.copy()\n    if hasattr(report.longrepr, \"toterminal\"):\n        if hasattr(report.longrepr, \"reprtraceback\") and hasattr(\n            report.longrepr, \"reprcrash\"\n        ):\n            d[\"longrepr\"] = serialize_longrepr(report)\n        else:\n            d[\"longrepr\"] = str(report.longrepr)\n    else:\n        d[\"longrepr\"] = report.longrepr\n    for name in d:\n        if isinstance(d[name], (py.path.local, Path)):\n            d[name] = str(d[name])\n        elif name == \"result\":\n            d[name] = None  # for now\n    return d", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_kwargs_from_json__report_kwargs_from_json.deserialize_repr_entry.return_reprentry": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_kwargs_from_json__report_kwargs_from_json.deserialize_repr_entry.return_reprentry", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 430, "end_line": 462, "span_ids": ["_report_kwargs_from_json"], "tokens": 277}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _report_kwargs_from_json(reportdict):\n    \"\"\"\n    This was originally the serialize_report() function from xdist (ca03269).\n\n    Returns **kwargs that can be used to construct a TestReport or CollectReport instance.\n    \"\"\"\n\n    def deserialize_repr_entry(entry_data):\n        data = entry_data[\"data\"]\n        entry_type = entry_data[\"type\"]\n        if entry_type == \"ReprEntry\":\n            reprfuncargs = None\n            reprfileloc = None\n            reprlocals = None\n            if data[\"reprfuncargs\"]:\n                reprfuncargs = ReprFuncArgs(**data[\"reprfuncargs\"])\n            if data[\"reprfileloc\"]:\n                reprfileloc = ReprFileLocation(**data[\"reprfileloc\"])\n            if data[\"reprlocals\"]:\n                reprlocals = ReprLocals(data[\"reprlocals\"][\"lines\"])\n\n            reprentry = ReprEntry(\n                lines=data[\"lines\"],\n                reprfuncargs=reprfuncargs,\n                reprlocals=reprlocals,\n                reprfileloc=reprfileloc,\n                style=data[\"style\"],\n            )  # type: Union[ReprEntry, ReprEntryNative]\n        elif entry_type == \"ReprEntryNative\":\n            reprentry = ReprEntryNative(data[\"lines\"])\n        else:\n            _report_unserialization_failure(entry_type, TestReport, reportdict)\n        return reprentry\n    # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_kwargs_from_json.deserialize_repr_traceback_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py__report_kwargs_from_json.deserialize_repr_traceback_", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 464, "end_line": 509, "span_ids": ["_report_kwargs_from_json"], "tokens": 333}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _report_kwargs_from_json(reportdict):\n    # ... other code\n\n    def deserialize_repr_traceback(repr_traceback_dict):\n        repr_traceback_dict[\"reprentries\"] = [\n            deserialize_repr_entry(x) for x in repr_traceback_dict[\"reprentries\"]\n        ]\n        return ReprTraceback(**repr_traceback_dict)\n\n    def deserialize_repr_crash(repr_crash_dict: Optional[dict]):\n        if repr_crash_dict is not None:\n            return ReprFileLocation(**repr_crash_dict)\n        else:\n            return None\n\n    if (\n        reportdict[\"longrepr\"]\n        and \"reprcrash\" in reportdict[\"longrepr\"]\n        and \"reprtraceback\" in reportdict[\"longrepr\"]\n    ):\n\n        reprtraceback = deserialize_repr_traceback(\n            reportdict[\"longrepr\"][\"reprtraceback\"]\n        )\n        reprcrash = deserialize_repr_crash(reportdict[\"longrepr\"][\"reprcrash\"])\n        if reportdict[\"longrepr\"][\"chain\"]:\n            chain = []\n            for repr_traceback_data, repr_crash_data, description in reportdict[\n                \"longrepr\"\n            ][\"chain\"]:\n                chain.append(\n                    (\n                        deserialize_repr_traceback(repr_traceback_data),\n                        deserialize_repr_crash(repr_crash_data),\n                        description,\n                    )\n                )\n            exception_info = ExceptionChainRepr(\n                chain\n            )  # type: Union[ExceptionChainRepr,ReprExceptionInfo]\n        else:\n            exception_info = ReprExceptionInfo(reprtraceback, reprcrash)\n\n        for section in reportdict[\"longrepr\"][\"sections\"]:\n            exception_info.addsection(*section)\n        reportdict[\"longrepr\"] = exception_info\n\n    return reportdict", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/resultlog.py__log_machine_parseable_pytest_unconfigure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/resultlog.py__log_machine_parseable_pytest_unconfigure", "embedding": null, "metadata": {"file_path": "src/_pytest/resultlog.py", "file_name": "resultlog.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 48, "span_ids": ["docstring", "pytest_addoption", "pytest_configure", "pytest_unconfigure"], "tokens": 305}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" log machine-parseable test session result information in a plain\ntext file.\n\"\"\"\nimport os\n\nimport py\n\nfrom _pytest.store import StoreKey\n\n\nresultlog_key = StoreKey[\"ResultLog\"]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"terminal reporting\", \"resultlog plugin options\")\n    group.addoption(\n        \"--resultlog\",\n        \"--result-log\",\n        action=\"store\",\n        metavar=\"path\",\n        default=None,\n        help=\"DEPRECATED path for machine-readable result log.\",\n    )\n\n\ndef pytest_configure(config):\n    resultlog = config.option.resultlog\n    # prevent opening resultlog on slave nodes (xdist)\n    if resultlog and not hasattr(config, \"slaveinput\"):\n        dirname = os.path.dirname(os.path.abspath(resultlog))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(resultlog, \"w\", 1)  # line buffered\n        config._store[resultlog_key] = ResultLog(config, logfile)\n        config.pluginmanager.register(config._store[resultlog_key])\n\n        from _pytest.deprecated import RESULT_LOG\n        from _pytest.warnings import _issue_warning_captured\n\n        _issue_warning_captured(RESULT_LOG, config.hook, stacklevel=2)\n\n\ndef pytest_unconfigure(config):\n    resultlog = config._store.get(resultlog_key, None)\n    if resultlog:\n        resultlog.logfile.close()\n        del config._store[resultlog_key]\n        config.pluginmanager.unregister(resultlog)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py__support_for_skip_xfai_pytest_configure.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/skipping.py__support_for_skip_xfai_pytest_configure.None_2", "embedding": null, "metadata": {"file_path": "src/_pytest/skipping.py", "file_name": "skipping.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 71, "span_ids": ["docstring", "pytest_addoption", "pytest_configure"], "tokens": 553}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" support for skip/xfail functions and markers. \"\"\"\nfrom _pytest.config import hookimpl\nfrom _pytest.mark.evaluate import MarkEvaluator\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.store import StoreKey\n\n\nskipped_by_mark_key = StoreKey[bool]()\nevalxfail_key = StoreKey[MarkEvaluator]()\nunexpectedsuccess_key = StoreKey[str]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n        dest=\"runxfail\",\n        default=False,\n        help=\"report the results of xfail tests as if they were not marked\",\n    )\n\n    parser.addini(\n        \"xfail_strict\",\n        \"default for the strict parameter of xfail \"\n        \"markers when not given explicitly (default: False)\",\n        default=False,\n        type=\"bool\",\n    )\n\n\ndef pytest_configure(config):\n    if config.option.runxfail:\n        # yay a hack\n        import pytest\n\n        old = pytest.xfail\n        config._cleanup.append(lambda: setattr(pytest, \"xfail\", old))\n\n        def nop(*args, **kwargs):\n            pass\n\n        nop.Exception = xfail.Exception\n        setattr(pytest, \"xfail\", nop)\n\n    config.addinivalue_line(\n        \"markers\",\n        \"skip(reason=None): skip the given test function with an optional reason. \"\n        'Example: skip(reason=\"no way of currently testing this\") skips the '\n        \"test.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"skipif(condition): skip the given test function if eval(condition) \"\n        \"results in a True value.  Evaluation happens within the \"\n        \"module global context. Example: skipif('sys.platform == \\\"win32\\\"') \"\n        \"skips the test if we are on the win32 platform. see \"\n        \"https://docs.pytest.org/en/latest/skipping.html\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"xfail(condition, reason=None, run=True, raises=None, strict=False): \"\n        \"mark the test function as an expected failure if eval(condition) \"\n        \"has a True value. Optionally specify a reason for better reporting \"\n        \"and run=False if you don't even want to execute the test function. \"\n        \"If only specific exception(s) are expected, you can list them in \"\n        \"raises, and if the test fails in other ways, it will be reported as \"\n        \"a true failure. See https://docs.pytest.org/en/latest/skipping.html\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/stepwise.py_pytest_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/stepwise.py_pytest_", "embedding": null, "metadata": {"file_path": "src/_pytest/stepwise.py", "file_name": "stepwise.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 109, "span_ids": ["StepwisePlugin", "StepwisePlugin.__init__", "StepwisePlugin.pytest_collection_modifyitems", "StepwisePlugin.pytest_report_collectionfinish", "StepwisePlugin.pytest_runtest_logreport", "StepwisePlugin.pytest_sessionfinish", "StepwisePlugin.pytest_sessionstart", "imports", "pytest_addoption", "pytest_configure"], "tokens": 690}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--sw\",\n        \"--stepwise\",\n        action=\"store_true\",\n        dest=\"stepwise\",\n        help=\"exit on test failure and continue from last failing test next time\",\n    )\n    group.addoption(\n        \"--stepwise-skip\",\n        action=\"store_true\",\n        dest=\"stepwise_skip\",\n        help=\"ignore the first failing test but stop on the next failing test\",\n    )\n\n\n@pytest.hookimpl\ndef pytest_configure(config):\n    config.pluginmanager.register(StepwisePlugin(config), \"stepwiseplugin\")\n\n\nclass StepwisePlugin:\n    def __init__(self, config):\n        self.config = config\n        self.active = config.getvalue(\"stepwise\")\n        self.session = None\n        self.report_status = \"\"\n\n        if self.active:\n            self.lastfailed = config.cache.get(\"cache/stepwise\", None)\n            self.skip = config.getvalue(\"stepwise_skip\")\n\n    def pytest_sessionstart(self, session):\n        self.session = session\n\n    def pytest_collection_modifyitems(self, session, config, items):\n        if not self.active:\n            return\n        if not self.lastfailed:\n            self.report_status = \"no previously failed tests, not skipping.\"\n            return\n\n        already_passed = []\n        found = False\n\n        # Make a list of all tests that have been run before the last failing one.\n        for item in items:\n            if item.nodeid == self.lastfailed:\n                found = True\n                break\n            else:\n                already_passed.append(item)\n\n        # If the previously failed test was not found among the test items,\n        # do not skip any tests.\n        if not found:\n            self.report_status = \"previously failed test not found, not skipping.\"\n            already_passed = []\n        else:\n            self.report_status = \"skipping {} already passed items.\".format(\n                len(already_passed)\n            )\n\n        for item in already_passed:\n            items.remove(item)\n\n        config.hook.pytest_deselected(items=already_passed)\n\n    def pytest_runtest_logreport(self, report):\n        if not self.active:\n            return\n\n        if report.failed:\n            if self.skip:\n                # Remove test from the failed ones (if it exists) and unset the skip option\n                # to make sure the following tests will not be skipped.\n                if report.nodeid == self.lastfailed:\n                    self.lastfailed = None\n\n                self.skip = False\n            else:\n                # Mark test as the last failing and interrupt the test session.\n                self.lastfailed = report.nodeid\n                self.session.shouldstop = (\n                    \"Test failed, continuing from this test next run.\"\n                )\n\n        else:\n            # If the test was actually run and did pass.\n            if report.when == \"call\":\n                # Remove test from the failed ones, if exists.\n                if report.nodeid == self.lastfailed:\n                    self.lastfailed = None\n\n    def pytest_report_collectionfinish(self):\n        if self.active and self.config.getoption(\"verbose\") >= 0 and self.report_status:\n            return \"stepwise: %s\" % self.report_status\n\n    def pytest_sessionfinish(self, session):\n        if self.active:\n            self.config.cache.set(\"cache/stepwise\", self.lastfailed)\n        else:\n            # Clear the list of failing tests if the plugin is not active.\n            self.config.cache.set(\"cache/stepwise\", [])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__terminal_reporting_of_MoreQuietAction.__call__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__terminal_reporting_of_MoreQuietAction.__call__", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 76, "span_ids": ["MoreQuietAction", "MoreQuietAction.__call__", "MoreQuietAction.__init__", "docstring"], "tokens": 389}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" terminal reporting of the full testing process.\n\nThis is a good source for looking at the various reporting hooks.\n\"\"\"\nimport argparse\nimport datetime\nimport inspect\nimport platform\nimport sys\nimport time\nimport warnings\nfrom functools import partial\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Set\nfrom typing import Tuple\n\nimport attr\nimport pluggy\nimport py\nfrom more_itertools import collapse\n\nimport pytest\nfrom _pytest import nodes\nfrom _pytest._io import TerminalWriter\nfrom _pytest.compat import order_preserving_dict\nfrom _pytest.config import Config\nfrom _pytest.config import ExitCode\nfrom _pytest.deprecated import TERMINALWRITER_WRITER\nfrom _pytest.main import Session\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\n\nREPORT_COLLECTING_RESOLUTION = 0.5\n\nKNOWN_TYPES = (\n    \"failed\",\n    \"passed\",\n    \"skipped\",\n    \"deselected\",\n    \"xfailed\",\n    \"xpassed\",\n    \"warnings\",\n    \"error\",\n)\n\n_REPORTCHARS_DEFAULT = \"fE\"\n\n\nclass MoreQuietAction(argparse.Action):\n    \"\"\"\n    a modified copy of the argparse count action which counts down and updates\n    the legacy quiet attribute at the same time\n\n    used to unify verbosity handling\n    \"\"\"\n\n    def __init__(self, option_strings, dest, default=None, required=False, help=None):\n        super().__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=0,\n            default=default,\n            required=required,\n            help=help,\n        )\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        new_count = getattr(namespace, self.dest, 0) - 1\n        setattr(namespace, self.dest, new_count)\n        # todo Deprecate config.quiet\n        namespace.quiet = getattr(namespace, \"quiet\", 0) + 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempdirFactory_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempdirFactory_", "embedding": null, "metadata": {"file_path": "src/_pytest/tmpdir.py", "file_name": "tmpdir.py", "file_type": "text/x-python", "category": "implementation", "start_line": 106, "end_line": 204, "span_ids": ["TempdirFactory", "TempdirFactory.getbasetemp", "TempdirFactory.mktemp", "_mk_tmp", "get_user", "pytest_configure", "tmp_path", "tmp_path_factory", "tmpdir", "tmpdir_factory"], "tokens": 747}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass TempdirFactory:\n    \"\"\"\n    backward comptibility wrapper that implements\n    :class:``py.path.local`` for :class:``TempPathFactory``\n    \"\"\"\n\n    _tmppath_factory = attr.ib(type=TempPathFactory)\n\n    def mktemp(self, basename: str, numbered: bool = True) -> py.path.local:\n        \"\"\"\n        Same as :meth:`TempPathFactory.mkdir`, but returns a ``py.path.local`` object.\n        \"\"\"\n        return py.path.local(self._tmppath_factory.mktemp(basename, numbered).resolve())\n\n    def getbasetemp(self):\n        \"\"\"backward compat wrapper for ``_tmppath_factory.getbasetemp``\"\"\"\n        return py.path.local(self._tmppath_factory.getbasetemp().resolve())\n\n\ndef get_user() -> Optional[str]:\n    \"\"\"Return the current user name, or None if getuser() does not work\n    in the current environment (see #1010).\n    \"\"\"\n    import getpass\n\n    try:\n        return getpass.getuser()\n    except (ImportError, KeyError):\n        return None\n\n\ndef pytest_configure(config) -> None:\n    \"\"\"Create a TempdirFactory and attach it to the config object.\n\n    This is to comply with existing plugins which expect the handler to be\n    available at pytest_configure time, but ideally should be moved entirely\n    to the tmpdir_factory session fixture.\n    \"\"\"\n    mp = MonkeyPatch()\n    tmppath_handler = TempPathFactory.from_config(config)\n    t = TempdirFactory(tmppath_handler)\n    config._cleanup.append(mp.undo)\n    mp.setattr(config, \"_tmp_path_factory\", tmppath_handler, raising=False)\n    mp.setattr(config, \"_tmpdirhandler\", t, raising=False)\n\n\n@pytest.fixture(scope=\"session\")\ndef tmpdir_factory(request: FixtureRequest) -> TempdirFactory:\n    \"\"\"Return a :class:`_pytest.tmpdir.TempdirFactory` instance for the test session.\n    \"\"\"\n    # Set dynamically by pytest_configure() above.\n    return request.config._tmpdirhandler  # type: ignore\n\n\n@pytest.fixture(scope=\"session\")\ndef tmp_path_factory(request: FixtureRequest) -> TempPathFactory:\n    \"\"\"Return a :class:`_pytest.tmpdir.TempPathFactory` instance for the test session.\n    \"\"\"\n    # Set dynamically by pytest_configure() above.\n    return request.config._tmp_path_factory  # type: ignore\n\n\ndef _mk_tmp(request: FixtureRequest, factory: TempPathFactory) -> Path:\n    name = request.node.name\n    name = re.sub(r\"[\\W]\", \"_\", name)\n    MAXVAL = 30\n    name = name[:MAXVAL]\n    return factory.mktemp(name, numbered=True)\n\n\n@pytest.fixture\ndef tmpdir(tmp_path):\n    \"\"\"Return a temporary directory path object\n    which is unique to each test function invocation,\n    created as a sub directory of the base temporary\n    directory.  The returned object is a `py.path.local`_\n    path object.\n\n    .. _`py.path.local`: https://py.readthedocs.io/en/latest/path.html\n    \"\"\"\n    return py.path.local(tmp_path)\n\n\n@pytest.fixture\ndef tmp_path(request: FixtureRequest, tmp_path_factory: TempPathFactory) -> Path:\n    \"\"\"Return a temporary directory path object\n    which is unique to each test function invocation,\n    created as a sub directory of the base temporary\n    directory.  The returned object is a :class:`pathlib.Path`\n    object.\n\n    .. note::\n\n        in python < 3.6 this is a pathlib2.Path\n    \"\"\"\n\n    return _mk_tmp(request, tmp_path_factory)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py__discovery_and_running_UnitTestCase._inject_setup_teardown_fixtures": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py__discovery_and_running_UnitTestCase._inject_setup_teardown_fixtures", "embedding": null, "metadata": {"file_path": "src/_pytest/unittest.py", "file_name": "unittest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 81, "span_ids": ["UnitTestCase", "UnitTestCase._inject_setup_teardown_fixtures", "UnitTestCase.collect", "docstring", "pytest_pycollect_makeitem"], "tokens": 586}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" discovery and running of std-library \"unittest\" style tests. \"\"\"\nimport sys\nimport traceback\n\nimport _pytest._code\nimport pytest\nfrom _pytest.compat import getimfunc\nfrom _pytest.compat import is_async_function\nfrom _pytest.config import hookimpl\nfrom _pytest.outcomes import exit\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.python import Class\nfrom _pytest.python import Function\nfrom _pytest.runner import CallInfo\nfrom _pytest.skipping import skipped_by_mark_key\nfrom _pytest.skipping import unexpectedsuccess_key\n\n\ndef pytest_pycollect_makeitem(collector, name, obj):\n    # has unittest been imported and is obj a subclass of its TestCase?\n    try:\n        if not issubclass(obj, sys.modules[\"unittest\"].TestCase):\n            return\n    except Exception:\n        return\n    # yes, so let's collect it\n    return UnitTestCase.from_parent(collector, name=name, obj=obj)\n\n\nclass UnitTestCase(Class):\n    # marker for fixturemanger.getfixtureinfo()\n    # to declare that our children do not support funcargs\n    nofuncargs = True\n\n    def collect(self):\n        from unittest import TestLoader\n\n        cls = self.obj\n        if not getattr(cls, \"__test__\", True):\n            return\n\n        skipped = getattr(cls, \"__unittest_skip__\", False)\n        if not skipped:\n            self._inject_setup_teardown_fixtures(cls)\n            self._inject_setup_class_fixture()\n\n        self.session._fixturemanager.parsefactories(self, unittest=True)\n        loader = TestLoader()\n        foundsomething = False\n        for name in loader.getTestCaseNames(self.obj):\n            x = getattr(self.obj, name)\n            if not getattr(x, \"__test__\", True):\n                continue\n            funcobj = getimfunc(x)\n            yield TestCaseFunction.from_parent(self, name=name, callobj=funcobj)\n            foundsomething = True\n\n        if not foundsomething:\n            runtest = getattr(self.obj, \"runTest\", None)\n            if runtest is not None:\n                ut = sys.modules.get(\"twisted.trial.unittest\", None)\n                if ut is None or runtest != ut.TestCase.runTest:\n                    # TODO: callobj consistency\n                    yield TestCaseFunction.from_parent(self, name=\"runTest\")\n\n    def _inject_setup_teardown_fixtures(self, cls):\n        \"\"\"Injects a hidden auto-use fixture to invoke setUpClass/setup_method and corresponding\n        teardown functions (#517)\"\"\"\n        class_fixture = _make_xunit_fixture(\n            cls, \"setUpClass\", \"tearDownClass\", scope=\"class\", pass_self=False\n        )\n        if class_fixture:\n            cls.__pytest_class_setup = class_fixture\n\n        method_fixture = _make_xunit_fixture(\n            cls, \"setup_method\", \"teardown_method\", scope=\"function\", pass_self=True\n        )\n        if method_fixture:\n            cls.__pytest_method_setup = method_fixture", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py__make_xunit_fixture_TestCaseFunction._addexcinfo.self___dict___setdefault_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py__make_xunit_fixture_TestCaseFunction._addexcinfo.self___dict___setdefault_", "embedding": null, "metadata": {"file_path": "src/_pytest/unittest.py", "file_name": "unittest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 84, "end_line": 164, "span_ids": ["TestCaseFunction", "TestCaseFunction._addexcinfo", "TestCaseFunction.setup", "TestCaseFunction.startTest", "TestCaseFunction.teardown", "_make_xunit_fixture"], "tokens": 538}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _make_xunit_fixture(obj, setup_name, teardown_name, scope, pass_self):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    @pytest.fixture(scope=scope, autouse=True)\n    def fixture(self, request):\n        if getattr(self, \"__unittest_skip__\", None):\n            reason = self.__unittest_skip_why__\n            pytest.skip(reason)\n        if setup is not None:\n            if pass_self:\n                setup(self, request.function)\n            else:\n                setup()\n        yield\n        if teardown is not None:\n            if pass_self:\n                teardown(self, request.function)\n            else:\n                teardown()\n\n    return fixture\n\n\nclass TestCaseFunction(Function):\n    nofuncargs = True\n    _excinfo = None\n    _testcase = None\n\n    def setup(self):\n        # a bound method to be called during teardown() if set (see 'runtest()')\n        self._explicit_tearDown = None\n        self._testcase = self.parent.obj(self.name)\n        self._obj = getattr(self._testcase, self.name)\n        if hasattr(self, \"_request\"):\n            self._request._fillfixtures()\n\n    def teardown(self):\n        if self._explicit_tearDown is not None:\n            self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None\n\n    def startTest(self, testcase):\n        pass\n\n    def _addexcinfo(self, rawexcinfo):\n        # unwrap potential exception info (see twisted trial support below)\n        rawexcinfo = getattr(rawexcinfo, \"_rawexcinfo\", rawexcinfo)\n        try:\n            excinfo = _pytest._code.ExceptionInfo(rawexcinfo)\n            # invoke the attributes to trigger storing the traceback\n            # trial causes some issue there\n            excinfo.value\n            excinfo.traceback\n        except TypeError:\n            try:\n                try:\n                    values = traceback.format_exception(*rawexcinfo)\n                    values.insert(\n                        0,\n                        \"NOTE: Incompatible Exception Representation, \"\n                        \"displaying natively:\\n\\n\",\n                    )\n                    fail(\"\".join(values), pytrace=False)\n                except (fail.Exception, KeyboardInterrupt):\n                    raise\n                except:  # noqa\n                    fail(\n                        \"ERROR: Unknown Incompatible Exception \"\n                        \"representation:\\n%r\" % (rawexcinfo,),\n                        pytrace=False,\n                    )\n            except KeyboardInterrupt:\n                raise\n            except fail.Exception:\n                excinfo = _pytest._code.ExceptionInfo.from_current()\n        self.__dict__.setdefault(\"_excinfo\", []).append(excinfo)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_os_TestGeneralUsage.test_config_preparse_plugin_option": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_os_TestGeneralUsage.test_config_preparse_plugin_option", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 106, "span_ids": ["TestGeneralUsage", "TestGeneralUsage.test_config_error", "TestGeneralUsage.test_config_preparse_plugin_option", "TestGeneralUsage.test_early_hook_configure_error_issue38", "TestGeneralUsage.test_early_hook_error_issue38_1", "TestGeneralUsage.test_file_not_found", "TestGeneralUsage.test_file_not_found_unconfigure_issue143", "TestGeneralUsage.test_root_conftest_syntax_error", "imports", "prepend_pythonpath"], "tokens": 777}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport sys\nimport textwrap\nimport types\n\nimport attr\nimport py\n\nimport _pytest.runner\nimport pytest\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.config import ExitCode\nfrom _pytest.monkeypatch import MonkeyPatch\nfrom _pytest.pytester import Testdir\n\n\ndef prepend_pythonpath(*dirs):\n    cur = os.getenv(\"PYTHONPATH\")\n    if cur:\n        dirs += (cur,)\n    return os.pathsep.join(str(p) for p in dirs)\n\n\nclass TestGeneralUsage:\n    def test_config_error(self, testdir):\n        testdir.copy_example(\"conftest_usageerror/conftest.py\")\n        result = testdir.runpytest(testdir.tmpdir)\n        assert result.ret == ExitCode.USAGE_ERROR\n        result.stderr.fnmatch_lines([\"*ERROR: hello\"])\n        result.stdout.fnmatch_lines([\"*pytest_unconfigure_called\"])\n\n    def test_root_conftest_syntax_error(self, testdir):\n        testdir.makepyfile(conftest=\"raise SyntaxError\\n\")\n        result = testdir.runpytest()\n        result.stderr.fnmatch_lines([\"*raise SyntaxError*\"])\n        assert result.ret != 0\n\n    def test_early_hook_error_issue38_1(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_sessionstart():\n                0 / 0\n        \"\"\"\n        )\n        result = testdir.runpytest(testdir.tmpdir)\n        assert result.ret != 0\n        # tracestyle is native by default for hook failures\n        result.stdout.fnmatch_lines(\n            [\"*INTERNALERROR*File*conftest.py*line 2*\", \"*0 / 0*\"]\n        )\n        result = testdir.runpytest(testdir.tmpdir, \"--fulltrace\")\n        assert result.ret != 0\n        # tracestyle is native by default for hook failures\n        result.stdout.fnmatch_lines(\n            [\"*INTERNALERROR*def pytest_sessionstart():*\", \"*INTERNALERROR*0 / 0*\"]\n        )\n\n    def test_early_hook_configure_error_issue38(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_configure():\n                0 / 0\n        \"\"\"\n        )\n        result = testdir.runpytest(testdir.tmpdir)\n        assert result.ret != 0\n        # here we get it on stderr\n        result.stderr.fnmatch_lines(\n            [\"*INTERNALERROR*File*conftest.py*line 2*\", \"*0 / 0*\"]\n        )\n\n    def test_file_not_found(self, testdir):\n        result = testdir.runpytest(\"asd\")\n        assert result.ret != 0\n        result.stderr.fnmatch_lines([\"ERROR: file not found*asd\"])\n\n    def test_file_not_found_unconfigure_issue143(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_configure():\n                print(\"---configure\")\n            def pytest_unconfigure():\n                print(\"---unconfigure\")\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-s\", \"asd\")\n        assert result.ret == ExitCode.USAGE_ERROR\n        result.stderr.fnmatch_lines([\"ERROR: file not found*asd\"])\n        result.stdout.fnmatch_lines([\"*---configure\", \"*---unconfigure\"])\n\n    def test_config_preparse_plugin_option(self, testdir):\n        testdir.makepyfile(\n            pytest_xyz=\"\"\"\n            def pytest_addoption(parser):\n                parser.addoption(\"--xyz\", dest=\"xyz\", action=\"store\")\n        \"\"\"\n        )\n        testdir.makepyfile(\n            test_one=\"\"\"\n            def test_option(pytestconfig):\n                assert pytestconfig.option.xyz == \"123\"\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-p\", \"pytest_xyz\", \"--xyz=123\", syspathinsert=True)\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_pyargs_importerror_TestInvocationVariants.test_pyargs_filename_looks_like_module": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_pyargs_importerror_TestInvocationVariants.test_pyargs_filename_looks_like_module", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 631, "end_line": 658, "span_ids": ["TestInvocationVariants.test_pyargs_filename_looks_like_module", "TestInvocationVariants.test_pyargs_importerror", "TestInvocationVariants.test_pyargs_only_imported_once"], "tokens": 315}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestInvocationVariants:\n\n    def test_pyargs_importerror(self, testdir, monkeypatch):\n        monkeypatch.delenv(\"PYTHONDONTWRITEBYTECODE\", False)\n        path = testdir.mkpydir(\"tpkg\")\n        path.join(\"test_hello.py\").write(\"raise ImportError\")\n\n        result = testdir.runpytest(\"--pyargs\", \"tpkg.test_hello\", syspathinsert=True)\n        assert result.ret != 0\n\n        result.stdout.fnmatch_lines([\"collected*0*items*/*1*error\"])\n\n    def test_pyargs_only_imported_once(self, testdir):\n        pkg = testdir.mkpydir(\"foo\")\n        pkg.join(\"test_foo.py\").write(\"print('hello from test_foo')\\ndef test(): pass\")\n        pkg.join(\"conftest.py\").write(\n            \"def pytest_configure(config): print('configuring')\"\n        )\n\n        result = testdir.runpytest(\"--pyargs\", \"foo.test_foo\", \"-s\", syspathinsert=True)\n        # should only import once\n        assert result.outlines.count(\"hello from test_foo\") == 1\n        # should only configure once\n        assert result.outlines.count(\"configuring\") == 1\n\n    def test_pyargs_filename_looks_like_module(self, testdir):\n        testdir.tmpdir.join(\"conftest.py\").ensure()\n        testdir.tmpdir.join(\"t.py\").write(\"def test(): pass\")\n        result = testdir.runpytest(\"--pyargs\", \"t.py\")\n        assert result.ret == ExitCode.OK", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_TestInvocationVariants.test_cmdline_python_package.result_stderr_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_TestInvocationVariants.test_cmdline_python_package.result_stderr_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 652, "end_line": 679, "span_ids": ["TestInvocationVariants.test_cmdline_python_package"], "tokens": 304}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestInvocationVariants:\n\n    def test_cmdline_python_package(self, testdir, monkeypatch):\n        import warnings\n\n        monkeypatch.delenv(\"PYTHONDONTWRITEBYTECODE\", False)\n        path = testdir.mkpydir(\"tpkg\")\n        path.join(\"test_hello.py\").write(\"def test_hello(): pass\")\n        path.join(\"test_world.py\").write(\"def test_world(): pass\")\n        result = testdir.runpytest(\"--pyargs\", \"tpkg\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n        result = testdir.runpytest(\"--pyargs\", \"tpkg.test_hello\", syspathinsert=True)\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n        empty_package = testdir.mkpydir(\"empty_package\")\n        monkeypatch.setenv(\"PYTHONPATH\", str(empty_package), prepend=os.pathsep)\n        # the path which is not a package raises a warning on pypy;\n        # no idea why only pypy and not normal python warn about it here\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", ImportWarning)\n            result = testdir.runpytest(\"--pyargs\", \".\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n        monkeypatch.setenv(\"PYTHONPATH\", str(testdir), prepend=os.pathsep)\n        result = testdir.runpytest(\"--pyargs\", \"tpkg.test_missing\", syspathinsert=True)\n        assert result.ret != 0\n        result.stderr.fnmatch_lines([\"*not*found*test_missing*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_sys_test_code_getargs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_sys_test_code_getargs", "embedding": null, "metadata": {"file_path": "testing/code/test_code.py", "file_name": "test_code.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 112, "span_ids": ["imports", "test_code_from_func", "test_code_fullsource", "test_code_getargs", "test_code_gives_back_name_for_not_existing_file", "test_code_source", "test_code_with_class", "test_frame_getsourcelineno_myself", "test_getstatement_empty_fullsource", "test_ne", "test_unicode_handling", "x"], "tokens": 662}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\nfrom types import FrameType\nfrom unittest import mock\n\nimport pytest\nfrom _pytest._code import Code\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import Frame\nfrom _pytest._code.code import ExceptionChainRepr\nfrom _pytest._code.code import ReprFuncArgs\n\n\ndef test_ne() -> None:\n    code1 = Code(compile('foo = \"bar\"', \"\", \"exec\"))\n    assert code1 == code1\n    code2 = Code(compile('foo = \"baz\"', \"\", \"exec\"))\n    assert code2 != code1\n\n\ndef test_code_gives_back_name_for_not_existing_file() -> None:\n    name = \"abc-123\"\n    co_code = compile(\"pass\\n\", name, \"exec\")\n    assert co_code.co_filename == name\n    code = Code(co_code)\n    assert str(code.path) == name\n    assert code.fullsource is None\n\n\ndef test_code_with_class() -> None:\n    class A:\n        pass\n\n    pytest.raises(TypeError, Code, A)\n\n\ndef x() -> None:\n    raise NotImplementedError()\n\n\ndef test_code_fullsource() -> None:\n    code = Code(x)\n    full = code.fullsource\n    assert \"test_code_fullsource()\" in str(full)\n\n\ndef test_code_source() -> None:\n    code = Code(x)\n    src = code.source()\n    expected = \"\"\"def x() -> None:\n    raise NotImplementedError()\"\"\"\n    assert str(src) == expected\n\n\ndef test_frame_getsourcelineno_myself() -> None:\n    def func() -> FrameType:\n        return sys._getframe(0)\n\n    f = Frame(func())\n    source, lineno = f.code.fullsource, f.lineno\n    assert source is not None\n    assert source[lineno].startswith(\"        return sys._getframe(0)\")\n\n\ndef test_getstatement_empty_fullsource() -> None:\n    def func() -> FrameType:\n        return sys._getframe(0)\n\n    f = Frame(func())\n    with mock.patch.object(f.code.__class__, \"fullsource\", None):\n        assert f.statement == \"\"\n\n\ndef test_code_from_func() -> None:\n    co = Code(test_frame_getsourcelineno_myself)\n    assert co.firstlineno\n    assert co.path\n\n\ndef test_unicode_handling() -> None:\n    value = \"\u0105\u0107\".encode()\n\n    def f() -> None:\n        raise Exception(value)\n\n    excinfo = pytest.raises(Exception, f)\n    str(excinfo)\n\n\ndef test_code_getargs() -> None:\n    def f1(x):\n        raise NotImplementedError()\n\n    c1 = Code(f1)\n    assert c1.getargs(var=True) == (\"x\",)\n\n    def f2(x, *y):\n        raise NotImplementedError()\n\n    c2 = Code(f2)\n    assert c2.getargs(var=True) == (\"x\", \"y\")\n\n    def f3(x, **z):\n        raise NotImplementedError()\n\n    c3 = Code(f3)\n    assert c3.getargs(var=True) == (\"x\", \"z\")\n\n    def f4(x, *y, **z):\n        raise NotImplementedError()\n\n    c4 = Code(f4)\n    assert c4.getargs(var=True) == (\"x\", \"y\", \"z\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_test_frame_getargs_test_frame_getargs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_code.py_test_frame_getargs_test_frame_getargs", "embedding": null, "metadata": {"file_path": "testing/code/test_code.py", "file_name": "test_code.py", "file_type": "text/x-python", "category": "test", "start_line": 115, "end_line": 138, "span_ids": ["test_frame_getargs"], "tokens": 255}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_frame_getargs() -> None:\n    def f1(x) -> FrameType:\n        return sys._getframe(0)\n\n    fr1 = Frame(f1(\"a\"))\n    assert fr1.getargs(var=True) == [(\"x\", \"a\")]\n\n    def f2(x, *y) -> FrameType:\n        return sys._getframe(0)\n\n    fr2 = Frame(f2(\"a\", \"b\", \"c\"))\n    assert fr2.getargs(var=True) == [(\"x\", \"a\"), (\"y\", (\"b\", \"c\"))]\n\n    def f3(x, **z) -> FrameType:\n        return sys._getframe(0)\n\n    fr3 = Frame(f3(\"a\", b=\"c\"))\n    assert fr3.getargs(var=True) == [(\"x\", \"a\"), (\"z\", {\"b\": \"c\"})]\n\n    def f4(x, *y, **z) -> FrameType:\n        return sys._getframe(0)\n\n    fr4 = Frame(f4(\"a\", \"b\", c=\"d\"))\n    assert fr4.getargs(var=True) == [(\"x\", \"a\"), (\"y\", (\"b\",)), (\"z\", {\"c\": \"d\"})]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_TestFormattedExcinfo.test_toterminal_long.assert_tw_mock_lines_12_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_TestFormattedExcinfo.test_toterminal_long.assert_tw_mock_lines_12_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 893, "end_line": 922, "span_ids": ["TestFormattedExcinfo.test_toterminal_long"], "tokens": 272}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_toterminal_long(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def g(x):\n                raise ValueError(x)\n            def f():\n                g(3)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.f)\n        excinfo.traceback = excinfo.traceback.filter()\n        repr = excinfo.getrepr()\n        repr.toterminal(tw_mock)\n        assert tw_mock.lines[0] == \"\"\n        tw_mock.lines.pop(0)\n        assert tw_mock.lines[0] == \"    def f():\"\n        assert tw_mock.lines[1] == \">       g(3)\"\n        assert tw_mock.lines[2] == \"\"\n        line = tw_mock.get_write_msg(3)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[4] == (\":5: \")\n        assert tw_mock.lines[5] == (\"_ \", None)\n        assert tw_mock.lines[6] == \"\"\n        assert tw_mock.lines[7] == \"    def g(x):\"\n        assert tw_mock.lines[8] == \">       raise ValueError(x)\"\n        assert tw_mock.lines[9] == \"E       ValueError: 3\"\n        assert tw_mock.lines[10] == \"\"\n        line = tw_mock.get_write_msg(11)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[12] == \":3: ValueError\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_missing_source_TestFormattedExcinfo.test_toterminal_long_missing_source.assert_tw_mock_lines_10_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_missing_source_TestFormattedExcinfo.test_toterminal_long_missing_source.assert_tw_mock_lines_10_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 924, "end_line": 952, "span_ids": ["TestFormattedExcinfo.test_toterminal_long_missing_source"], "tokens": 252}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_toterminal_long_missing_source(self, importasmod, tmpdir, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def g(x):\n                raise ValueError(x)\n            def f():\n                g(3)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.f)\n        tmpdir.join(\"mod.py\").remove()\n        excinfo.traceback = excinfo.traceback.filter()\n        repr = excinfo.getrepr()\n        repr.toterminal(tw_mock)\n        assert tw_mock.lines[0] == \"\"\n        tw_mock.lines.pop(0)\n        assert tw_mock.lines[0] == \">   ???\"\n        assert tw_mock.lines[1] == \"\"\n        line = tw_mock.get_write_msg(2)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[3] == \":5: \"\n        assert tw_mock.lines[4] == (\"_ \", None)\n        assert tw_mock.lines[5] == \"\"\n        assert tw_mock.lines[6] == \">   ???\"\n        assert tw_mock.lines[7] == \"E   ValueError: 3\"\n        assert tw_mock.lines[8] == \"\"\n        line = tw_mock.get_write_msg(9)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[10] == \":3: ValueError\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_incomplete_source_TestFormattedExcinfo.test_toterminal_long_incomplete_source.assert_tw_mock_lines_10_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_incomplete_source_TestFormattedExcinfo.test_toterminal_long_incomplete_source.assert_tw_mock_lines_10_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 954, "end_line": 982, "span_ids": ["TestFormattedExcinfo.test_toterminal_long_incomplete_source"], "tokens": 255}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_toterminal_long_incomplete_source(self, importasmod, tmpdir, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def g(x):\n                raise ValueError(x)\n            def f():\n                g(3)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.f)\n        tmpdir.join(\"mod.py\").write(\"asdf\")\n        excinfo.traceback = excinfo.traceback.filter()\n        repr = excinfo.getrepr()\n        repr.toterminal(tw_mock)\n        assert tw_mock.lines[0] == \"\"\n        tw_mock.lines.pop(0)\n        assert tw_mock.lines[0] == \">   ???\"\n        assert tw_mock.lines[1] == \"\"\n        line = tw_mock.get_write_msg(2)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[3] == \":5: \"\n        assert tw_mock.lines[4] == (\"_ \", None)\n        assert tw_mock.lines[5] == \"\"\n        assert tw_mock.lines[6] == \">   ???\"\n        assert tw_mock.lines[7] == \"E   ValueError: 3\"\n        assert tw_mock.lines[8] == \"\"\n        line = tw_mock.get_write_msg(9)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[10] == \":3: ValueError\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_traceback_repr_style_TestFormattedExcinfo.test_traceback_repr_style.assert_tw_mock_lines_20_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_traceback_repr_style_TestFormattedExcinfo.test_traceback_repr_style.assert_tw_mock_lines_20_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 1042, "end_line": 1085, "span_ids": ["TestFormattedExcinfo.test_traceback_repr_style"], "tokens": 385}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_traceback_repr_style(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def f():\n                g()\n            def g():\n                h()\n            def h():\n                i()\n            def i():\n                raise ValueError()\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.f)\n        excinfo.traceback = excinfo.traceback.filter()\n        excinfo.traceback[1].set_repr_style(\"short\")\n        excinfo.traceback[2].set_repr_style(\"short\")\n        r = excinfo.getrepr(style=\"long\")\n        r.toterminal(tw_mock)\n        for line in tw_mock.lines:\n            print(line)\n        assert tw_mock.lines[0] == \"\"\n        assert tw_mock.lines[1] == \"    def f():\"\n        assert tw_mock.lines[2] == \">       g()\"\n        assert tw_mock.lines[3] == \"\"\n        msg = tw_mock.get_write_msg(4)\n        assert msg.endswith(\"mod.py\")\n        assert tw_mock.lines[5] == \":3: \"\n        assert tw_mock.lines[6] == (\"_ \", None)\n        tw_mock.get_write_msg(7)\n        assert tw_mock.lines[8].endswith(\"in g\")\n        assert tw_mock.lines[9] == \"    h()\"\n        tw_mock.get_write_msg(10)\n        assert tw_mock.lines[11].endswith(\"in h\")\n        assert tw_mock.lines[12] == \"    i()\"\n        assert tw_mock.lines[13] == (\"_ \", None)\n        assert tw_mock.lines[14] == \"\"\n        assert tw_mock.lines[15] == \"    def i():\"\n        assert tw_mock.lines[16] == \">       raise ValueError()\"\n        assert tw_mock.lines[17] == \"E       ValueError\"\n        assert tw_mock.lines[18] == \"\"\n        msg = tw_mock.get_write_msg(19)\n        msg.endswith(\"mod.py\")\n        assert tw_mock.lines[20] == \":9: ValueError\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_TestFormattedExcinfo.test_exc_chain_repr.assert_tw_mock_lines_47_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_chain_repr_TestFormattedExcinfo.test_exc_chain_repr.assert_tw_mock_lines_47_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 1087, "end_line": 1169, "span_ids": ["TestFormattedExcinfo.test_exc_chain_repr"], "tokens": 752}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_exc_chain_repr(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            class Err(Exception):\n                pass\n            def f():\n                try:\n                    g()\n                except Exception as e:\n                    raise Err() from e\n                finally:\n                    h()\n            def g():\n                raise ValueError()\n\n            def h():\n                raise AttributeError()\n        \"\"\"\n        )\n        excinfo = pytest.raises(AttributeError, mod.f)\n        r = excinfo.getrepr(style=\"long\")\n        r.toterminal(tw_mock)\n        for line in tw_mock.lines:\n            print(line)\n        assert tw_mock.lines[0] == \"\"\n        assert tw_mock.lines[1] == \"    def f():\"\n        assert tw_mock.lines[2] == \"        try:\"\n        assert tw_mock.lines[3] == \">           g()\"\n        assert tw_mock.lines[4] == \"\"\n        line = tw_mock.get_write_msg(5)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[6] == \":6: \"\n        assert tw_mock.lines[7] == (\"_ \", None)\n        assert tw_mock.lines[8] == \"\"\n        assert tw_mock.lines[9] == \"    def g():\"\n        assert tw_mock.lines[10] == \">       raise ValueError()\"\n        assert tw_mock.lines[11] == \"E       ValueError\"\n        assert tw_mock.lines[12] == \"\"\n        line = tw_mock.get_write_msg(13)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[14] == \":12: ValueError\"\n        assert tw_mock.lines[15] == \"\"\n        assert (\n            tw_mock.lines[16]\n            == \"The above exception was the direct cause of the following exception:\"\n        )\n        assert tw_mock.lines[17] == \"\"\n        assert tw_mock.lines[18] == \"    def f():\"\n        assert tw_mock.lines[19] == \"        try:\"\n        assert tw_mock.lines[20] == \"            g()\"\n        assert tw_mock.lines[21] == \"        except Exception as e:\"\n        assert tw_mock.lines[22] == \">           raise Err() from e\"\n        assert tw_mock.lines[23] == \"E           test_exc_chain_repr0.mod.Err\"\n        assert tw_mock.lines[24] == \"\"\n        line = tw_mock.get_write_msg(25)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[26] == \":8: Err\"\n        assert tw_mock.lines[27] == \"\"\n        assert (\n            tw_mock.lines[28]\n            == \"During handling of the above exception, another exception occurred:\"\n        )\n        assert tw_mock.lines[29] == \"\"\n        assert tw_mock.lines[30] == \"    def f():\"\n        assert tw_mock.lines[31] == \"        try:\"\n        assert tw_mock.lines[32] == \"            g()\"\n        assert tw_mock.lines[33] == \"        except Exception as e:\"\n        assert tw_mock.lines[34] == \"            raise Err() from e\"\n        assert tw_mock.lines[35] == \"        finally:\"\n        assert tw_mock.lines[36] == \">           h()\"\n        assert tw_mock.lines[37] == \"\"\n        line = tw_mock.get_write_msg(38)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[39] == \":10: \"\n        assert tw_mock.lines[40] == (\"_ \", None)\n        assert tw_mock.lines[41] == \"\"\n        assert tw_mock.lines[42] == \"    def h():\"\n        assert tw_mock.lines[43] == \">       raise AttributeError()\"\n        assert tw_mock.lines[44] == \"E       AttributeError\"\n        assert tw_mock.lines[45] == \"\"\n        line = tw_mock.get_write_msg(46)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[47] == \":15: AttributeError\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_repr_chain_suppression_TestFormattedExcinfo.test_exc_repr_chain_suppression.assert_len_tw_mock_lines_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_exc_repr_chain_suppression_TestFormattedExcinfo.test_exc_repr_chain_suppression.assert_len_tw_mock_lines_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 1171, "end_line": 1209, "span_ids": ["TestFormattedExcinfo.test_exc_repr_chain_suppression"], "tokens": 341}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    @pytest.mark.parametrize(\"mode\", [\"from_none\", \"explicit_suppress\"])\n    def test_exc_repr_chain_suppression(self, importasmod, mode, tw_mock):\n        \"\"\"Check that exc repr does not show chained exceptions in Python 3.\n        - When the exception is raised with \"from None\"\n        - Explicitly suppressed with \"chain=False\" to ExceptionInfo.getrepr().\n        \"\"\"\n        raise_suffix = \" from None\" if mode == \"from_none\" else \"\"\n        mod = importasmod(\n            \"\"\"\n            def f():\n                try:\n                    g()\n                except Exception:\n                    raise AttributeError(){raise_suffix}\n            def g():\n                raise ValueError()\n        \"\"\".format(\n                raise_suffix=raise_suffix\n            )\n        )\n        excinfo = pytest.raises(AttributeError, mod.f)\n        r = excinfo.getrepr(style=\"long\", chain=mode != \"explicit_suppress\")\n        r.toterminal(tw_mock)\n        for line in tw_mock.lines:\n            print(line)\n        assert tw_mock.lines[0] == \"\"\n        assert tw_mock.lines[1] == \"    def f():\"\n        assert tw_mock.lines[2] == \"        try:\"\n        assert tw_mock.lines[3] == \"            g()\"\n        assert tw_mock.lines[4] == \"        except Exception:\"\n        assert tw_mock.lines[5] == \">           raise AttributeError(){}\".format(\n            raise_suffix\n        )\n        assert tw_mock.lines[6] == \"E           AttributeError\"\n        assert tw_mock.lines[7] == \"\"\n        line = tw_mock.get_write_msg(8)\n        assert line.endswith(\"mod.py\")\n        assert tw_mock.lines[9] == \":6: AttributeError\"\n        assert len(tw_mock.lines) == 10", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/test_fixture_named_request.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/fixtures/test_fixture_named_request.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/fixtures/test_fixture_named_request.py", "file_name": "test_fixture_named_request.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 11, "span_ids": ["imports", "request", "test"], "tokens": 15}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef request():\n    pass\n\n\ndef test():\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue_519.py_pprint_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/issue_519.py_pprint_", "embedding": null, "metadata": {"file_path": "testing/example_scripts/issue_519.py", "file_name": "issue_519.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 52, "span_ids": ["checked_order", "fix1", "fix2", "imports", "pytest_generate_tests", "test_one", "test_two"], "tokens": 460}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pprint\n\nimport pytest\n\n\ndef pytest_generate_tests(metafunc):\n    if \"arg1\" in metafunc.fixturenames:\n        metafunc.parametrize(\"arg1\", [\"arg1v1\", \"arg1v2\"], scope=\"module\")\n\n    if \"arg2\" in metafunc.fixturenames:\n        metafunc.parametrize(\"arg2\", [\"arg2v1\", \"arg2v2\"], scope=\"function\")\n\n\n@pytest.fixture(scope=\"session\")\ndef checked_order():\n    order = []\n\n    yield order\n    pprint.pprint(order)\n    assert order == [\n        (\"testing/example_scripts/issue_519.py\", \"fix1\", \"arg1v1\"),\n        (\"test_one[arg1v1-arg2v1]\", \"fix2\", \"arg2v1\"),\n        (\"test_two[arg1v1-arg2v1]\", \"fix2\", \"arg2v1\"),\n        (\"test_one[arg1v1-arg2v2]\", \"fix2\", \"arg2v2\"),\n        (\"test_two[arg1v1-arg2v2]\", \"fix2\", \"arg2v2\"),\n        (\"testing/example_scripts/issue_519.py\", \"fix1\", \"arg1v2\"),\n        (\"test_one[arg1v2-arg2v1]\", \"fix2\", \"arg2v1\"),\n        (\"test_two[arg1v2-arg2v1]\", \"fix2\", \"arg2v1\"),\n        (\"test_one[arg1v2-arg2v2]\", \"fix2\", \"arg2v2\"),\n        (\"test_two[arg1v2-arg2v2]\", \"fix2\", \"arg2v2\"),\n    ]\n\n\n@pytest.yield_fixture(scope=\"module\")\ndef fix1(request, arg1, checked_order):\n    checked_order.append((request.node.name, \"fix1\", arg1))\n    yield \"fix1-\" + arg1\n\n\n@pytest.yield_fixture(scope=\"function\")\ndef fix2(request, fix1, arg2, checked_order):\n    checked_order.append((request.node.name, \"fix2\", arg2))\n    yield \"fix2-\" + arg2 + fix1\n\n\ndef test_one(fix2):\n    pass\n\n\ndef test_two(fix2):\n    pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/perf_examples/collect_stats/generate_folders.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/perf_examples/collect_stats/generate_folders.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/perf_examples/collect_stats/generate_folders.py", "file_name": "generate_folders.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 28, "span_ids": ["generate_folders", "impl:5", "imports"], "tokens": 194}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import argparse\nimport pathlib\n\nHERE = pathlib.Path(__file__).parent\nTEST_CONTENT = (HERE / \"template_test.py\").read_bytes()\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"numbers\", nargs=\"*\", type=int)\n\n\ndef generate_folders(root, elements, *more_numbers):\n    fill_len = len(str(elements))\n    if more_numbers:\n        for i in range(elements):\n            new_folder = root.joinpath(f\"foo_{i:0>{fill_len}}\")\n            new_folder.mkdir()\n            new_folder.joinpath(\"__init__.py\").write_bytes(TEST_CONTENT)\n            generate_folders(new_folder, *more_numbers)\n    else:\n        for i in range(elements):\n            new_test = root.joinpath(f\"test_{i:0<{fill_len}}.py\")\n            new_test.write_bytes(TEST_CONTENT)\n\n\nif __name__ == \"__main__\":\n    args = parser.parse_args()\n    generate_folders(HERE, *(args.numbers or (10, 100)))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_fixture.py_logging_test_record_tuples": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_fixture.py_logging_test_record_tuples", "embedding": null, "metadata": {"file_path": "testing/logging/test_fixture.py", "file_name": "test_fixture.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 100, "span_ids": ["imports", "test_change_level", "test_change_level_undo", "test_fixture_help", "test_log_access", "test_messages", "test_record_tuples", "test_with_statement"], "tokens": 741}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import logging\n\nimport pytest\n\nlogger = logging.getLogger(__name__)\nsublogger = logging.getLogger(__name__ + \".baz\")\n\n\ndef test_fixture_help(testdir):\n    result = testdir.runpytest(\"--fixtures\")\n    result.stdout.fnmatch_lines([\"*caplog*\"])\n\n\ndef test_change_level(caplog):\n    caplog.set_level(logging.INFO)\n    logger.debug(\"handler DEBUG level\")\n    logger.info(\"handler INFO level\")\n\n    caplog.set_level(logging.CRITICAL, logger=sublogger.name)\n    sublogger.warning(\"logger WARNING level\")\n    sublogger.critical(\"logger CRITICAL level\")\n\n    assert \"DEBUG\" not in caplog.text\n    assert \"INFO\" in caplog.text\n    assert \"WARNING\" not in caplog.text\n    assert \"CRITICAL\" in caplog.text\n\n\ndef test_change_level_undo(testdir):\n    \"\"\"Ensure that 'set_level' is undone after the end of the test\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import logging\n\n        def test1(caplog):\n            caplog.set_level(logging.INFO)\n            # using + operator here so fnmatch_lines doesn't match the code in the traceback\n            logging.info('log from ' + 'test1')\n            assert 0\n\n        def test2(caplog):\n            # using + operator here so fnmatch_lines doesn't match the code in the traceback\n            logging.info('log from ' + 'test2')\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*log from test1*\", \"*2 failed in *\"])\n    result.stdout.no_fnmatch_line(\"*log from test2*\")\n\n\ndef test_with_statement(caplog):\n    with caplog.at_level(logging.INFO):\n        logger.debug(\"handler DEBUG level\")\n        logger.info(\"handler INFO level\")\n\n        with caplog.at_level(logging.CRITICAL, logger=sublogger.name):\n            sublogger.warning(\"logger WARNING level\")\n            sublogger.critical(\"logger CRITICAL level\")\n\n    assert \"DEBUG\" not in caplog.text\n    assert \"INFO\" in caplog.text\n    assert \"WARNING\" not in caplog.text\n    assert \"CRITICAL\" in caplog.text\n\n\ndef test_log_access(caplog):\n    caplog.set_level(logging.INFO)\n    logger.info(\"boo %s\", \"arg\")\n    assert caplog.records[0].levelname == \"INFO\"\n    assert caplog.records[0].msg == \"boo %s\"\n    assert \"boo arg\" in caplog.text\n\n\ndef test_messages(caplog):\n    caplog.set_level(logging.INFO)\n    logger.info(\"boo %s\", \"arg\")\n    logger.info(\"bar %s\\nbaz %s\", \"arg1\", \"arg2\")\n    assert \"boo arg\" == caplog.messages[0]\n    assert \"bar arg1\\nbaz arg2\" == caplog.messages[1]\n    assert caplog.text.count(\"\\n\") > len(caplog.messages)\n    assert len(caplog.text.splitlines()) > len(caplog.messages)\n\n    try:\n        raise Exception(\"test\")\n    except Exception:\n        logger.exception(\"oops\")\n\n    assert \"oops\" in caplog.text\n    assert \"oops\" in caplog.messages[-1]\n    # Tracebacks are stored in the record and not added until the formatter or handler.\n    assert \"Exception\" in caplog.text\n    assert \"Exception\" not in caplog.messages[-1]\n\n\ndef test_record_tuples(caplog):\n    caplog.set_level(logging.INFO)\n    logger.info(\"boo %s\", \"arg\")\n\n    assert caplog.record_tuples == [(__name__, logging.INFO, \"boo arg\")]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_io_test_messages_logged": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_io_test_messages_logged", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 46, "span_ids": ["imports", "test_messages_logged", "test_nothing_logged"], "tokens": 301}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import io\nimport os\nimport re\n\nimport pytest\n\n\ndef test_nothing_logged(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            sys.stderr.write('text going to stderr')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])\n    with pytest.raises(pytest.fail.Exception):\n        result.stdout.fnmatch_lines([\"*- Captured *log call -*\"])\n\n\ndef test_messages_logged(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        import logging\n\n        logger = logging.getLogger(__name__)\n\n        def test_foo():\n            sys.stdout.write('text going to stdout')\n            sys.stderr.write('text going to stderr')\n            logger.info('text going to logger')\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--log-level=INFO\")\n    assert result.ret == 1\n    result.stdout.fnmatch_lines([\"*- Captured *log call -*\", \"*text going to logger*\"])\n    result.stdout.fnmatch_lines([\"*- Captured stdout call -*\", \"text going to stdout\"])\n    result.stdout.fnmatch_lines([\"*- Captured stderr call -*\", \"text going to stderr\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_os_TestModule.test_invalid_test_module_name": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_os_TestModule.test_invalid_test_module_name", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 77, "span_ids": ["TestModule", "TestModule.test_failing_import", "TestModule.test_import_duplicate", "TestModule.test_import_prepend_append", "TestModule.test_invalid_test_module_name", "TestModule.test_module_considers_pluginmanager_at_import", "TestModule.test_syntax_error_in_module", "imports"], "tokens": 578}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport sys\nimport textwrap\n\nimport _pytest._code\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.nodes import Collector\n\n\nclass TestModule:\n    def test_failing_import(self, testdir):\n        modcol = testdir.getmodulecol(\"import alksdjalskdjalkjals\")\n        pytest.raises(Collector.CollectError, modcol.collect)\n\n    def test_import_duplicate(self, testdir):\n        a = testdir.mkdir(\"a\")\n        b = testdir.mkdir(\"b\")\n        p = a.ensure(\"test_whatever.py\")\n        p.pyimport()\n        del sys.modules[\"test_whatever\"]\n        b.ensure(\"test_whatever.py\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*import*mismatch*\",\n                \"*imported*test_whatever*\",\n                \"*%s*\" % a.join(\"test_whatever.py\"),\n                \"*not the same*\",\n                \"*%s*\" % b.join(\"test_whatever.py\"),\n                \"*HINT*\",\n            ]\n        )\n\n    def test_import_prepend_append(self, testdir, monkeypatch):\n        root1 = testdir.mkdir(\"root1\")\n        root2 = testdir.mkdir(\"root2\")\n        root1.ensure(\"x456.py\")\n        root2.ensure(\"x456.py\")\n        p = root2.join(\"test_x456.py\")\n        monkeypatch.syspath_prepend(str(root1))\n        p.write(\n            textwrap.dedent(\n                \"\"\"\\\n                import x456\n                def test():\n                    assert x456.__file__.startswith({!r})\n                \"\"\".format(\n                    str(root2)\n                )\n            )\n        )\n        with root2.as_cwd():\n            reprec = testdir.inline_run(\"--import-mode=append\")\n            reprec.assertoutcome(passed=0, failed=1)\n            reprec = testdir.inline_run()\n            reprec.assertoutcome(passed=1)\n\n    def test_syntax_error_in_module(self, testdir):\n        modcol = testdir.getmodulecol(\"this is a syntax error\")\n        pytest.raises(modcol.CollectError, modcol.collect)\n        pytest.raises(modcol.CollectError, modcol.collect)\n\n    def test_module_considers_pluginmanager_at_import(self, testdir):\n        modcol = testdir.getmodulecol(\"pytest_plugins='xasdlkj',\")\n        pytest.raises(ImportError, lambda: modcol.obj)\n\n    def test_invalid_test_module_name(self, testdir):\n        a = testdir.mkdir(\"a\")\n        a.ensure(\"test_one.part1.py\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"ImportError while importing test module*test_one.part1*\",\n                \"Hint: make sure your test modules/packages have valid Python names.\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_customized_python_discovery_test_class_injection_does_not_break_collection.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_customized_python_discovery_test_class_injection_does_not_break_collection.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1091, "end_line": 1217, "span_ids": ["test_class_injection_does_not_break_collection", "test_customized_python_discovery", "test_customized_python_discovery_functions", "test_dont_collect_non_function_callable", "test_unorderable_types"], "tokens": 733}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_customized_python_discovery(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        python_files=check_*.py\n        python_classes=Check\n        python_functions=check\n    \"\"\"\n    )\n    p = testdir.makepyfile(\n        \"\"\"\n        def check_simple():\n            pass\n        class CheckMyApp(object):\n            def check_meth(self):\n                pass\n    \"\"\"\n    )\n    p2 = p.new(basename=p.basename.replace(\"test\", \"check\"))\n    p.move(p2)\n    result = testdir.runpytest(\"--collect-only\", \"-s\")\n    result.stdout.fnmatch_lines(\n        [\"*check_customized*\", \"*check_simple*\", \"*CheckMyApp*\", \"*check_meth*\"]\n    )\n\n    result = testdir.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n\ndef test_customized_python_discovery_functions(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        python_functions=_test\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        def _test_underscore():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--collect-only\", \"-s\")\n    result.stdout.fnmatch_lines([\"*_test_underscore*\"])\n\n    result = testdir.runpytest()\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_unorderable_types(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        class TestJoinEmpty(object):\n            pass\n\n        def make_test():\n            class Test(object):\n                pass\n            Test.__name__ = \"TestFoo\"\n            return Test\n        TestFoo = make_test()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.no_fnmatch_line(\"*TypeError*\")\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_dont_collect_non_function_callable(testdir):\n    \"\"\"Test for issue https://github.com/pytest-dev/pytest/issues/331\n\n    In this case an INTERNALERROR occurred trying to report the failure of\n    a test like this one because pytest failed to get the source lines.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        class Oh(object):\n            def __call__(self):\n                pass\n\n        test_a = Oh()\n\n        def test_real():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*collected 1 item*\",\n            \"*test_dont_collect_non_function_callable.py:2: *cannot collect 'test_a' because it is not a function*\",\n            \"*1 passed, 1 warning in *\",\n        ]\n    )\n\n\ndef test_class_injection_does_not_break_collection(testdir):\n    \"\"\"Tests whether injection during collection time will terminate testing.\n\n    In this case the error should not occur if the TestClass itself\n    is modified during collection time, and the original method list\n    is still used for collection.\n    \"\"\"\n    testdir.makeconftest(\n        \"\"\"\n        from test_inject import TestClass\n        def pytest_generate_tests(metafunc):\n            TestClass.changed_var = {}\n    \"\"\"\n    )\n    testdir.makepyfile(\n        test_inject='''\n         class TestClass(object):\n            def test_injection(self):\n                \"\"\"Test being parametrized.\"\"\"\n                pass\n    '''\n    )\n    result = testdir.runpytest()\n    assert (\n        \"RuntimeError: dictionary changed size during iteration\"\n        not in result.stdout.str()\n    )\n    result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_syntax_error_with_non_ascii_chars_test_package_collection_init_given_as_argument": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_syntax_error_with_non_ascii_chars_test_package_collection_init_given_as_argument", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1220, "end_line": 1300, "span_ids": ["test_collecterror_with_fulltrace", "test_keep_duplicates", "test_package_collection_infinite_recursion", "test_package_collection_init_given_as_argument", "test_skip_duplicates_by_default", "test_syntax_error_with_non_ascii_chars"], "tokens": 576}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_syntax_error_with_non_ascii_chars(testdir):\n    \"\"\"Fix decoding issue while formatting SyntaxErrors during collection (#578)\n    \"\"\"\n    testdir.makepyfile(\"\u2603\")\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*ERROR collecting*\", \"*SyntaxError*\", \"*1 error in*\"])\n\n\ndef test_collecterror_with_fulltrace(testdir):\n    testdir.makepyfile(\"assert 0\")\n    result = testdir.runpytest(\"--fulltrace\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 0 items / 1 error\",\n            \"\",\n            \"*= ERRORS =*\",\n            \"*_ ERROR collecting test_collecterror_with_fulltrace.py _*\",\n            \"\",\n            \"*/_pytest/python.py:*: \",\n            \"_ _ _ _ _ _ _ _ *\",\n            \"\",\n            \">   assert 0\",\n            \"E   assert 0\",\n            \"\",\n            \"test_collecterror_with_fulltrace.py:1: AssertionError\",\n            \"*! Interrupted: 1 error during collection !*\",\n        ]\n    )\n\n\ndef test_skip_duplicates_by_default(testdir):\n    \"\"\"Test for issue https://github.com/pytest-dev/pytest/issues/1609 (#1609)\n\n    Ignore duplicate directories.\n    \"\"\"\n    a = testdir.mkdir(\"a\")\n    fh = a.join(\"test_a.py\")\n    fh.write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n            def test_real():\n                pass\n            \"\"\"\n        )\n    )\n    result = testdir.runpytest(a.strpath, a.strpath)\n    result.stdout.fnmatch_lines([\"*collected 1 item*\"])\n\n\ndef test_keep_duplicates(testdir):\n    \"\"\"Test for issue https://github.com/pytest-dev/pytest/issues/1609 (#1609)\n\n    Use --keep-duplicates to collect tests from duplicate directories.\n    \"\"\"\n    a = testdir.mkdir(\"a\")\n    fh = a.join(\"test_a.py\")\n    fh.write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n            def test_real():\n                pass\n            \"\"\"\n        )\n    )\n    result = testdir.runpytest(\"--keep-duplicates\", a.strpath, a.strpath)\n    result.stdout.fnmatch_lines([\"*collected 2 item*\"])\n\n\ndef test_package_collection_infinite_recursion(testdir):\n    testdir.copy_example(\"collect/package_infinite_recursion\")\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_package_collection_init_given_as_argument(testdir):\n    \"\"\"Regression test for #3749\"\"\"\n    p = testdir.copy_example(\"collect/package_init_given_as_arg\")\n    result = testdir.runpytest(p / \"pkg\" / \"__init__.py\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_package_with_modules_test_package_with_modules.None_7": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_test_package_with_modules_test_package_with_modules.None_7", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1266, "end_line": 1303, "span_ids": ["test_package_with_modules"], "tokens": 299}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_package_with_modules(testdir):\n    \"\"\"\n    .\n    \u2514\u2500\u2500 root\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 sub1\n        \u2502   \u251c\u2500\u2500 __init__.py\n        \u2502   \u2514\u2500\u2500 sub1_1\n        \u2502       \u251c\u2500\u2500 __init__.py\n        \u2502       \u2514\u2500\u2500 test_in_sub1.py\n        \u2514\u2500\u2500 sub2\n            \u2514\u2500\u2500 test\n                \u2514\u2500\u2500 test_in_sub2.py\n\n    \"\"\"\n    root = testdir.mkpydir(\"root\")\n    sub1 = root.mkdir(\"sub1\")\n    sub1.ensure(\"__init__.py\")\n    sub1_test = sub1.mkdir(\"sub1_1\")\n    sub1_test.ensure(\"__init__.py\")\n    sub2 = root.mkdir(\"sub2\")\n    sub2_test = sub2.mkdir(\"sub2\")\n\n    sub1_test.join(\"test_in_sub1.py\").write(\"def test_1(): pass\")\n    sub2_test.join(\"test_in_sub2.py\").write(\"def test_2(): pass\")\n\n    # Execute from .\n    result = testdir.runpytest(\"-v\", \"-s\")\n    result.assert_outcomes(passed=2)\n\n    # Execute from . with one argument \"root\"\n    result = testdir.runpytest(\"-v\", \"-s\", \"root\")\n    result.assert_outcomes(passed=2)\n\n    # Chdir into package's root and execute with no args\n    root.chdir()\n    result = testdir.runpytest(\"-v\", \"-s\")\n    result.assert_outcomes(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_sys_test_getfuncargnames_staticmethod_partial": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_sys_test_getfuncargnames_staticmethod_partial", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 82, "span_ids": ["imports", "test_getfuncargnames_functions", "test_getfuncargnames_methods", "test_getfuncargnames_partial", "test_getfuncargnames_staticmethod", "test_getfuncargnames_staticmethod_partial"], "tokens": 482}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\nimport textwrap\n\nimport pytest\nfrom _pytest import fixtures\nfrom _pytest.config import ExitCode\nfrom _pytest.fixtures import FixtureRequest\nfrom _pytest.pathlib import Path\nfrom _pytest.pytester import get_public_names\n\n\ndef test_getfuncargnames_functions():\n    \"\"\"Test getfuncargnames for normal functions\"\"\"\n\n    def f():\n        raise NotImplementedError()\n\n    assert not fixtures.getfuncargnames(f)\n\n    def g(arg):\n        raise NotImplementedError()\n\n    assert fixtures.getfuncargnames(g) == (\"arg\",)\n\n    def h(arg1, arg2=\"hello\"):\n        raise NotImplementedError()\n\n    assert fixtures.getfuncargnames(h) == (\"arg1\",)\n\n    def j(arg1, arg2, arg3=\"hello\"):\n        raise NotImplementedError()\n\n    assert fixtures.getfuncargnames(j) == (\"arg1\", \"arg2\")\n\n\ndef test_getfuncargnames_methods():\n    \"\"\"Test getfuncargnames for normal methods\"\"\"\n\n    class A:\n        def f(self, arg1, arg2=\"hello\"):\n            raise NotImplementedError()\n\n    assert fixtures.getfuncargnames(A().f) == (\"arg1\",)\n\n\ndef test_getfuncargnames_staticmethod():\n    \"\"\"Test getfuncargnames for staticmethods\"\"\"\n\n    class A:\n        @staticmethod\n        def static(arg1, arg2, x=1):\n            raise NotImplementedError()\n\n    assert fixtures.getfuncargnames(A.static, cls=A) == (\"arg1\", \"arg2\")\n\n\ndef test_getfuncargnames_partial():\n    \"\"\"Check getfuncargnames for methods defined with functools.partial (#5701)\"\"\"\n    import functools\n\n    def check(arg1, arg2, i):\n        raise NotImplementedError()\n\n    class T:\n        test_ok = functools.partial(check, i=2)\n\n    values = fixtures.getfuncargnames(T().test_ok, name=\"test_ok\")\n    assert values == (\"arg1\", \"arg2\")\n\n\ndef test_getfuncargnames_staticmethod_partial():\n    \"\"\"Check getfuncargnames for staticmethods defined with functools.partial (#5701)\"\"\"\n    import functools\n\n    def check(arg1, arg2, i):\n        raise NotImplementedError()\n\n    class T:\n        test_ok = staticmethod(functools.partial(check, i=2))\n\n    values = fixtures.getfuncargnames(T().test_ok, name=\"test_ok\")\n    assert values == (\"arg1\", \"arg2\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_getfixturevalue_TestRequestBasic.test_request_addfinalizer_partial_setup_failure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_getfixturevalue_TestRequestBasic.test_request_addfinalizer_partial_setup_failure", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 642, "end_line": 746, "span_ids": ["TestRequestBasic.test_getfixturevalue", "TestRequestBasic.test_request_addfinalizer", "TestRequestBasic.test_request_addfinalizer_failing_setup", "TestRequestBasic.test_request_addfinalizer_failing_setup_module", "TestRequestBasic.test_request_addfinalizer_partial_setup_failure"], "tokens": 689}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestBasic:\n\n    def test_getfixturevalue(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            values = [2]\n            @pytest.fixture\n            def something(request): return 1\n            @pytest.fixture\n            def other(request):\n                return values.pop()\n            def test_func(something): pass\n        \"\"\"\n        )\n        req = item._request\n\n        with pytest.raises(pytest.FixtureLookupError):\n            req.getfixturevalue(\"notexists\")\n        val = req.getfixturevalue(\"something\")\n        assert val == 1\n        val = req.getfixturevalue(\"something\")\n        assert val == 1\n        val2 = req.getfixturevalue(\"other\")\n        assert val2 == 2\n        val2 = req.getfixturevalue(\"other\")  # see about caching\n        assert val2 == 2\n        item._request._fillfixtures()\n        assert item.funcargs[\"something\"] == 1\n        assert len(get_public_names(item.funcargs)) == 2\n        assert \"request\" in item.funcargs\n\n    def test_request_addfinalizer(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            teardownlist = []\n            @pytest.fixture\n            def something(request):\n                request.addfinalizer(lambda: teardownlist.append(1))\n            def test_func(something): pass\n        \"\"\"\n        )\n        item.session._setupstate.prepare(item)\n        item._request._fillfixtures()\n        # successively check finalization calls\n        teardownlist = item.getparent(pytest.Module).obj.teardownlist\n        ss = item.session._setupstate\n        assert not teardownlist\n        ss.teardown_exact(item, None)\n        print(ss.stack)\n        assert teardownlist == [1]\n\n    def test_request_addfinalizer_failing_setup(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = [1]\n            @pytest.fixture\n            def myfix(request):\n                request.addfinalizer(values.pop)\n                assert 0\n            def test_fix(myfix):\n                pass\n            def test_finalizer_ran():\n                assert not values\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        reprec.assertoutcome(failed=1, passed=1)\n\n    def test_request_addfinalizer_failing_setup_module(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = [1, 2]\n            @pytest.fixture(scope=\"module\")\n            def myfix(request):\n                request.addfinalizer(values.pop)\n                request.addfinalizer(values.pop)\n                assert 0\n            def test_fix(myfix):\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-s\")\n        mod = reprec.getcalls(\"pytest_runtest_setup\")[0].item.module\n        assert not mod.values\n\n    def test_request_addfinalizer_partial_setup_failure(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture\n            def something(request):\n                request.addfinalizer(lambda: values.append(None))\n            def test_func(something, missingarg):\n                pass\n            def test_second():\n                assert len(values) == 1\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\"*1 error*\"]  # XXX the whole module collection fails\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_getmodulepath_TestRequestBasic.test_setupdecorator_and_xunit.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_request_getmodulepath_TestRequestBasic.test_setupdecorator_and_xunit.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 782, "end_line": 869, "span_ids": ["TestRequestBasic.test_funcargnames_compatattr", "TestRequestBasic.test_request_fixturenames", "TestRequestBasic.test_request_fixturenames_dynamic_fixture", "TestRequestBasic.test_request_getmodulepath", "TestRequestBasic.test_setupdecorator_and_xunit"], "tokens": 635}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestBasic:\n\n    def test_request_getmodulepath(self, testdir):\n        modcol = testdir.getmodulecol(\"def test_somefunc(): pass\")\n        (item,) = testdir.genitems([modcol])\n        req = fixtures.FixtureRequest(item)\n        assert req.fspath == modcol.fspath\n\n    def test_request_fixturenames(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            from _pytest.pytester import get_public_names\n            @pytest.fixture()\n            def arg1():\n                pass\n            @pytest.fixture()\n            def farg(arg1):\n                pass\n            @pytest.fixture(autouse=True)\n            def sarg(tmpdir):\n                pass\n            def test_function(request, farg):\n                assert set(get_public_names(request.fixturenames)) == \\\n                       set([\"tmpdir\", \"sarg\", \"arg1\", \"request\", \"farg\",\n                            \"tmp_path\", \"tmp_path_factory\"])\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_request_fixturenames_dynamic_fixture(self, testdir):\n        \"\"\"Regression test for #3057\"\"\"\n        testdir.copy_example(\"fixtures/test_getfixturevalue_dynamic.py\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_funcargnames_compatattr(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                with pytest.warns(pytest.PytestDeprecationWarning):\n                    assert metafunc.funcargnames == metafunc.fixturenames\n            @pytest.fixture\n            def fn(request):\n                with pytest.warns(pytest.PytestDeprecationWarning):\n                    assert request._pyfuncitem.funcargnames == \\\n                           request._pyfuncitem.fixturenames\n                with pytest.warns(pytest.PytestDeprecationWarning):\n                    return request.funcargnames, request.fixturenames\n\n            def test_hello(fn):\n                assert fn[0] == fn[1]\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_setupdecorator_and_xunit(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(scope='module', autouse=True)\n            def setup_module():\n                values.append(\"module\")\n            @pytest.fixture(autouse=True)\n            def setup_function():\n                values.append(\"function\")\n\n            def test_func():\n                pass\n\n            class TestClass(object):\n                @pytest.fixture(scope=\"class\", autouse=True)\n                def setup_class(self):\n                    values.append(\"class\")\n                @pytest.fixture(autouse=True)\n                def setup_method(self):\n                    values.append(\"method\")\n                def test_method(self):\n                    pass\n            def test_all():\n                assert values == [\"module\", \"function\", \"class\",\n                             \"function\", \"method\", \"function\"]\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\")\n        reprec.assertoutcome(passed=3)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_fixtures_sub_subdir_normalize_sep_TestRequestBasic.test_setupcontext_no_param": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestRequestBasic.test_fixtures_sub_subdir_normalize_sep_TestRequestBasic.test_setupcontext_no_param", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 871, "end_line": 930, "span_ids": ["TestRequestBasic.test_fixtures_sub_subdir_normalize_sep", "TestRequestBasic.test_newstyle_with_request", "TestRequestBasic.test_setupcontext_no_param", "TestRequestBasic.test_show_fixtures_color_yes"], "tokens": 389}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRequestBasic:\n\n    def test_fixtures_sub_subdir_normalize_sep(self, testdir):\n        # this tests that normalization of nodeids takes place\n        b = testdir.mkdir(\"tests\").mkdir(\"unit\")\n        b.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n                @pytest.fixture\n                def arg1():\n                    pass\n                \"\"\"\n            )\n        )\n        p = b.join(\"test_module.py\")\n        p.write(\"def test_func(arg1): pass\")\n        result = testdir.runpytest(p, \"--fixtures\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *fixtures defined*conftest*\n            *arg1*\n        \"\"\"\n        )\n\n    def test_show_fixtures_color_yes(self, testdir):\n        testdir.makepyfile(\"def test_this(): assert 1\")\n        result = testdir.runpytest(\"--color=yes\", \"--fixtures\")\n        assert \"\\x1b[32mtmpdir\" in result.stdout.str()\n\n    def test_newstyle_with_request(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture()\n            def arg(request):\n                pass\n            def test_1(arg):\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_setupcontext_no_param(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(params=[1,2])\n            def arg(request):\n                return request.param\n\n            @pytest.fixture(autouse=True)\n            def mysetup(request, arg):\n                assert not hasattr(request, \"param\")\n            def test_1(arg):\n                assert arg in (1,2)\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_multiple_packages_TestScopeOrdering.test_class_fixture_self_instance.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestScopeOrdering.test_multiple_packages_TestScopeOrdering.test_class_fixture_self_instance.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3881, "end_line": 3979, "span_ids": ["TestScopeOrdering.test_class_fixture_self_instance", "TestScopeOrdering.test_multiple_packages"], "tokens": 590}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestScopeOrdering:\n\n    def test_multiple_packages(self, testdir):\n        \"\"\"Complex test involving multiple package fixtures. Make sure teardowns\n        are executed in order.\n        .\n        \u2514\u2500\u2500 root\n            \u251c\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 sub1\n            \u2502   \u251c\u2500\u2500 __init__.py\n            \u2502   \u251c\u2500\u2500 conftest.py\n            \u2502   \u2514\u2500\u2500 test_1.py\n            \u2514\u2500\u2500 sub2\n                \u251c\u2500\u2500 __init__.py\n                \u251c\u2500\u2500 conftest.py\n                \u2514\u2500\u2500 test_2.py\n        \"\"\"\n        root = testdir.mkdir(\"root\")\n        root.join(\"__init__.py\").write(\"values = []\")\n        sub1 = root.mkdir(\"sub1\")\n        sub1.ensure(\"__init__.py\")\n        sub1.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n            import pytest\n            from .. import values\n            @pytest.fixture(scope=\"package\")\n            def fix():\n                values.append(\"pre-sub1\")\n                yield values\n                assert values.pop() == \"pre-sub1\"\n        \"\"\"\n            )\n        )\n        sub1.join(\"test_1.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n            from .. import values\n            def test_1(fix):\n                assert values == [\"pre-sub1\"]\n        \"\"\"\n            )\n        )\n        sub2 = root.mkdir(\"sub2\")\n        sub2.ensure(\"__init__.py\")\n        sub2.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n            import pytest\n            from .. import values\n            @pytest.fixture(scope=\"package\")\n            def fix():\n                values.append(\"pre-sub2\")\n                yield values\n                assert values.pop() == \"pre-sub2\"\n        \"\"\"\n            )\n        )\n        sub2.join(\"test_2.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n            from .. import values\n            def test_2(fix):\n                assert values == [\"pre-sub2\"]\n        \"\"\"\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_class_fixture_self_instance(self, testdir):\n        \"\"\"Check that plugin classes which implement fixtures receive the plugin instance\n        as self (see #2270).\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            def pytest_configure(config):\n                config.pluginmanager.register(MyPlugin())\n\n            class MyPlugin():\n                def __init__(self):\n                    self.arg = 1\n\n                @pytest.fixture(scope='function')\n                def myfix(self):\n                    assert isinstance(self, MyPlugin)\n                    return self.arg\n        \"\"\"\n        )\n\n        testdir.makepyfile(\n            \"\"\"\n            class TestClass(object):\n                def test_1(self, myfix):\n                    assert myfix == 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_call_fixture_function_error_test_fixture_param_shadowing.None_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_call_fixture_function_error_test_fixture_param_shadowing.None_5", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3982, "end_line": 4033, "span_ids": ["test_call_fixture_function_error", "test_fixture_param_shadowing"], "tokens": 354}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_call_fixture_function_error():\n    \"\"\"Check if an error is raised if a fixture function is called directly (#4545)\"\"\"\n\n    @pytest.fixture\n    def fix():\n        raise NotImplementedError()\n\n    with pytest.raises(pytest.fail.Exception):\n        assert fix() == 1\n\n\ndef test_fixture_param_shadowing(testdir):\n    \"\"\"Parametrized arguments would be shadowed if a fixture with the same name also exists (#5036)\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture(params=['a', 'b'])\n        def argroot(request):\n            return request.param\n\n        @pytest.fixture\n        def arg(argroot):\n            return argroot\n\n        # This should only be parametrized directly\n        @pytest.mark.parametrize(\"arg\", [1])\n        def test_direct(arg):\n            assert arg == 1\n\n        # This should be parametrized based on the fixtures\n        def test_normal_fixture(arg):\n            assert isinstance(arg, str)\n\n        # Indirect should still work:\n\n        @pytest.fixture\n        def arg2(request):\n            return 2*request.param\n\n        @pytest.mark.parametrize(\"arg2\", [1], indirect=True)\n        def test_indirect(arg2):\n            assert arg2 == 2\n    \"\"\"\n    )\n    # Only one test should have run\n    result = testdir.runpytest(\"-v\")\n    result.assert_outcomes(passed=4)\n    result.stdout.fnmatch_lines([\"*::test_direct[[]1[]]*\"])\n    result.stdout.fnmatch_lines([\"*::test_normal_fixture[[]a[]]*\"])\n    result.stdout.fnmatch_lines([\"*::test_normal_fixture[[]b[]]*\"])\n    result.stdout.fnmatch_lines([\"*::test_indirect[[]1[]]*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_pytest_TestOEJSKITSpecials.test_funcarg_non_pycollectobj.assert_clscol_funcargs_a": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_pytest_TestOEJSKITSpecials.test_funcarg_non_pycollectobj.assert_clscol_funcargs_a", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 35, "span_ids": ["TestOEJSKITSpecials", "TestOEJSKITSpecials.test_funcarg_non_pycollectobj", "imports"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\nfrom _pytest import python\nfrom _pytest import runner\n\n\nclass TestOEJSKITSpecials:\n    def test_funcarg_non_pycollectobj(self, testdir, recwarn):  # rough jstests usage\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_pycollect_makeitem(collector, name, obj):\n                if name == \"MyClass\":\n                    return MyCollector.from_parent(collector, name=name)\n            class MyCollector(pytest.Collector):\n                def reportinfo(self):\n                    return self.fspath, 3, \"xyz\"\n        \"\"\"\n        )\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def arg1(request):\n                return 42\n            class MyClass(object):\n                pass\n        \"\"\"\n        )\n        # this hook finds funcarg factories\n        rep = runner.collect_one_node(collector=modcol)\n        clscol = rep.result[0]\n        clscol.obj = lambda arg1: None\n        clscol.funcargs = {}\n        pytest._fillfuncargs(clscol)\n        assert clscol.funcargs[\"arg1\"] == 42", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_sentinel_check_against_numpy_like_TestMockDecoration.test_mock_sentinel_check_against_numpy_like.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/integration.py_TestMockDecoration.test_mock_sentinel_check_against_numpy_like_TestMockDecoration.test_mock_sentinel_check_against_numpy_like.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/integration.py", "file_name": "integration.py", "file_type": "text/x-python", "category": "implementation", "start_line": 181, "end_line": 207, "span_ids": ["TestMockDecoration.test_mock_sentinel_check_against_numpy_like"], "tokens": 208}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMockDecoration:\n\n    def test_mock_sentinel_check_against_numpy_like(self, testdir):\n        \"\"\"Ensure our function that detects mock arguments compares against sentinels using\n        identity to circumvent objects which can't be compared with equality against others\n        in a truth context, like with numpy arrays (#5606).\n        \"\"\"\n        testdir.makepyfile(\n            dummy=\"\"\"\n            class NumpyLike:\n                def __init__(self, value):\n                    self.value = value\n                def __eq__(self, other):\n                    raise ValueError(\"like numpy, cannot compare against others for truth\")\n            FOO = NumpyLike(10)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            from unittest.mock import patch\n            import dummy\n            class Test(object):\n                @patch(\"dummy.FOO\", new=dummy.NumpyLike(50))\n                def test_hello(self):\n                    assert dummy.FOO.value == 50\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_noclass_TestRaises.test_raises_cyclic_reference.assert_refcount_len_gc": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_noclass_TestRaises.test_raises_cyclic_reference.assert_refcount_len_gc", "embedding": null, "metadata": {"file_path": "testing/python/raises.py", "file_name": "raises.py", "file_type": "text/x-python", "category": "implementation", "start_line": 129, "end_line": 188, "span_ids": ["TestRaises.test_invalid_arguments_to_raises", "TestRaises.test_no_raise_message", "TestRaises.test_noclass", "TestRaises.test_raises_cyclic_reference", "TestRaises.test_tuple"], "tokens": 406}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRaises:\n\n    def test_noclass(self):\n        with pytest.raises(TypeError):\n            pytest.raises(\"wrong\", lambda: None)\n\n    def test_invalid_arguments_to_raises(self):\n        with pytest.raises(TypeError, match=\"unknown\"):\n            with pytest.raises(TypeError, unknown=\"bogus\"):\n                raise ValueError()\n\n    def test_tuple(self):\n        with pytest.raises((KeyError, ValueError)):\n            raise KeyError(\"oops\")\n\n    def test_no_raise_message(self):\n        try:\n            pytest.raises(ValueError, int, \"0\")\n        except pytest.raises.Exception as e:\n            assert e.msg == \"DID NOT RAISE {}\".format(repr(ValueError))\n        else:\n            assert False, \"Expected pytest.raises.Exception\"\n\n        try:\n            with pytest.raises(ValueError):\n                pass\n        except pytest.raises.Exception as e:\n            assert e.msg == \"DID NOT RAISE {}\".format(repr(ValueError))\n        else:\n            assert False, \"Expected pytest.raises.Exception\"\n\n    @pytest.mark.parametrize(\"method\", [\"function\", \"function_match\", \"with\"])\n    def test_raises_cyclic_reference(self, method):\n        \"\"\"\n        Ensure pytest.raises does not leave a reference cycle (#1965).\n        \"\"\"\n        import gc\n\n        class T:\n            def __call__(self):\n                # Early versions of Python 3.5 have some bug causing the\n                # __call__ frame to still refer to t even after everything\n                # is done. This makes the test pass for them.\n                if sys.version_info < (3, 5, 2):\n                    del self\n                raise ValueError\n\n        t = T()\n        refcount = len(gc.get_referrers(t))\n\n        if method == \"function\":\n            pytest.raises(ValueError, t)\n        elif method == \"function_match\":\n            pytest.raises(ValueError, t).match(\"^$\")\n        else:\n            with pytest.raises(ValueError):\n                t()\n\n        # ensure both forms of pytest.raises don't leave exceptions in sys.exc_info()\n        assert sys.exc_info() == (None, None, None)\n\n        assert refcount == len(gc.get_referrers(t))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_no_items_should_not_show_output_test_fixtures_in_conftest.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/show_fixtures_per_test.py_test_no_items_should_not_show_output_test_fixtures_in_conftest.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/show_fixtures_per_test.py", "file_name": "show_fixtures_per_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 80, "span_ids": ["test_fixtures_in_conftest", "test_fixtures_in_module", "test_no_items_should_not_show_output"], "tokens": 456}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_no_items_should_not_show_output(testdir):\n    result = testdir.runpytest(\"--fixtures-per-test\")\n    result.stdout.no_fnmatch_line(\"*fixtures used by*\")\n    assert result.ret == 0\n\n\ndef test_fixtures_in_module(testdir):\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture\n        def _arg0():\n            \"\"\"hidden arg0 fixture\"\"\"\n        @pytest.fixture\n        def arg1():\n            \"\"\"arg1 docstring\"\"\"\n        def test_arg1(arg1):\n            pass\n    '''\n    )\n\n    result = testdir.runpytest(\"--fixtures-per-test\", p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*fixtures used by test_arg1*\",\n            \"*(test_fixtures_in_module.py:9)*\",\n            \"arg1\",\n            \"    arg1 docstring\",\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*_arg0*\")\n\n\ndef test_fixtures_in_conftest(testdir):\n    testdir.makeconftest(\n        '''\n        import pytest\n        @pytest.fixture\n        def arg1():\n            \"\"\"arg1 docstring\"\"\"\n        @pytest.fixture\n        def arg2():\n            \"\"\"arg2 docstring\"\"\"\n        @pytest.fixture\n        def arg3(arg1, arg2):\n            \"\"\"arg3\n            docstring\n            \"\"\"\n    '''\n    )\n    p = testdir.makepyfile(\n        \"\"\"\n        def test_arg2(arg2):\n            pass\n        def test_arg3(arg3):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--fixtures-per-test\", p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*fixtures used by test_arg2*\",\n            \"*(test_fixtures_in_conftest.py:2)*\",\n            \"arg2\",\n            \"    arg2 docstring\",\n            \"*fixtures used by test_arg3*\",\n            \"*(test_fixtures_in_conftest.py:4)*\",\n            \"arg1\",\n            \"    arg1 docstring\",\n            \"arg2\",\n            \"    arg2 docstring\",\n            \"arg3\",\n            \"    arg3\",\n            \"    docstring\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_subprocess__wrapcall": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_argcomplete.py_subprocess__wrapcall", "embedding": null, "metadata": {"file_path": "testing/test_argcomplete.py", "file_name": "test_argcomplete.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 30, "span_ids": ["_wrapcall", "equal_with_bash", "impl", "imports"], "tokens": 216}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import subprocess\nimport sys\n\nimport pytest\n\n# test for _argcomplete but not specific for any application\n\n\ndef equal_with_bash(prefix, ffc, fc, out=None):\n    res = ffc(prefix)\n    res_bash = set(fc(prefix))\n    retval = set(res) == res_bash\n    if out:\n        out.write(\"equal_with_bash({}) {} {}\\n\".format(prefix, retval, res))\n        if not retval:\n            out.write(\" python - bash: %s\\n\" % (set(res) - res_bash))\n            out.write(\" bash - python: %s\\n\" % (res_bash - set(res)))\n    return retval\n\n\n# copied from argcomplete.completers as import from there\n# also pulls in argcomplete.__init__ which opens filedescriptor 9\n# this gives an OSError at the end of testrun\n\n\ndef _wrapcall(*args, **kargs):\n    try:\n        return subprocess.check_output(*args, **kargs).decode().splitlines()\n    except subprocess.CalledProcessError:\n        return []", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_TestAssert_reprcompare.test_list": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare_TestAssert_reprcompare.test_list", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 325, "end_line": 381, "span_ids": ["TestAssert_reprcompare", "TestAssert_reprcompare.test_bytes_diff_normal", "TestAssert_reprcompare.test_bytes_diff_verbose", "TestAssert_reprcompare.test_different_types", "TestAssert_reprcompare.test_list", "TestAssert_reprcompare.test_multiline_text_diff", "TestAssert_reprcompare.test_summary", "TestAssert_reprcompare.test_text_diff", "TestAssert_reprcompare.test_text_skipping", "TestAssert_reprcompare.test_text_skipping_verbose"], "tokens": 487}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n    def test_different_types(self):\n        assert callequal([0, 1], \"foo\") is None\n\n    def test_summary(self):\n        summary = callequal([0, 1], [0, 2])[0]\n        assert len(summary) < 65\n\n    def test_text_diff(self):\n        assert callequal(\"spam\", \"eggs\") == [\n            \"'spam' == 'eggs'\",\n            \"- eggs\",\n            \"+ spam\",\n        ]\n\n    def test_text_skipping(self):\n        lines = callequal(\"a\" * 50 + \"spam\", \"a\" * 50 + \"eggs\")\n        assert \"Skipping\" in lines[1]\n        for line in lines:\n            assert \"a\" * 50 not in line\n\n    def test_text_skipping_verbose(self):\n        lines = callequal(\"a\" * 50 + \"spam\", \"a\" * 50 + \"eggs\", verbose=1)\n        assert \"- \" + \"a\" * 50 + \"eggs\" in lines\n        assert \"+ \" + \"a\" * 50 + \"spam\" in lines\n\n    def test_multiline_text_diff(self):\n        left = \"foo\\nspam\\nbar\"\n        right = \"foo\\neggs\\nbar\"\n        diff = callequal(left, right)\n        assert \"- eggs\" in diff\n        assert \"+ spam\" in diff\n\n    def test_bytes_diff_normal(self):\n        \"\"\"Check special handling for bytes diff (#5260)\"\"\"\n        diff = callequal(b\"spam\", b\"eggs\")\n\n        assert diff == [\n            \"b'spam' == b'eggs'\",\n            \"At index 0 diff: b's' != b'e'\",\n            \"Use -v to get the full diff\",\n        ]\n\n    def test_bytes_diff_verbose(self):\n        \"\"\"Check special handling for bytes diff (#5260)\"\"\"\n        diff = callequal(b\"spam\", b\"eggs\", verbose=1)\n        assert diff == [\n            \"b'spam' == b'eggs'\",\n            \"At index 0 diff: b's' != b'e'\",\n            \"Full diff:\",\n            \"- b'eggs'\",\n            \"+ b'spam'\",\n        ]\n\n    def test_list(self):\n        expl = callequal([0, 1], [0, 2])\n        assert len(expl) > 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_exception_handling_no_traceback_test_assert_tuple_warning": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_exception_handling_no_traceback_test_assert_tuple_warning", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 1244, "end_line": 1365, "span_ids": ["test_AssertionError_message", "test_assert_tuple_warning", "test_diff_newline_at_end", "test_exception_handling_no_traceback", "test_recursion_source_decode", "test_warn_missing"], "tokens": 711}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_exception_handling_no_traceback(testdir):\n    \"\"\"\n    Handle chain exceptions in tasks submitted by the multiprocess module (#1984).\n    \"\"\"\n    p1 = testdir.makepyfile(\n        \"\"\"\n        from multiprocessing import Pool\n\n        def process_task(n):\n            assert n == 10\n\n        def multitask_job():\n            tasks = [1]\n            with Pool(processes=1) as pool:\n                pool.map(process_task, tasks)\n\n        def test_multitask_job():\n            multitask_job()\n    \"\"\"\n    )\n    testdir.syspathinsert()\n    result = testdir.runpytest(p1, \"--tb=long\")\n    result.stdout.fnmatch_lines(\n        [\n            \"====* FAILURES *====\",\n            \"*multiprocessing.pool.RemoteTraceback:*\",\n            \"Traceback (most recent call last):\",\n            \"*assert n == 10\",\n            \"The above exception was the direct cause of the following exception:\",\n            \"> * multitask_job()\",\n        ]\n    )\n\n\n@pytest.mark.skipif(\"'__pypy__' in sys.builtin_module_names\")\ndef test_warn_missing(testdir):\n    testdir.makepyfile(\"\")\n    result = testdir.run(sys.executable, \"-OO\", \"-m\", \"pytest\", \"-h\")\n    result.stderr.fnmatch_lines([\"*WARNING*assert statements are not executed*\"])\n    result = testdir.run(sys.executable, \"-OO\", \"-m\", \"pytest\")\n    result.stderr.fnmatch_lines([\"*WARNING*assert statements are not executed*\"])\n\n\ndef test_recursion_source_decode(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_something():\n            pass\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        python_files = *.py\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--collect-only\")\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        <Module*>\n    \"\"\"\n    )\n\n\ndef test_AssertionError_message(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_hello():\n            x,y = 1,2\n            assert 0, (x,y)\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *def test_hello*\n        *assert 0, (x,y)*\n        *AssertionError: (1, 2)*\n    \"\"\"\n    )\n\n\ndef test_diff_newline_at_end(testdir):\n    testdir.makepyfile(\n        r\"\"\"\n        def test_diff():\n            assert 'asdf' == 'asdf\\n'\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        r\"\"\"\n        *assert 'asdf' == 'asdf\\n'\n        *  - asdf\n        *  ?     -\n        *  + asdf\n    \"\"\"\n    )\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_assert_tuple_warning(testdir):\n    msg = \"assertion is always true\"\n    testdir.makepyfile(\n        \"\"\"\n        def test_tuple():\n            assert(False, 'you shall not pass')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*test_assert_tuple_warning.py:2:*{}*\".format(msg)])\n\n    # tuples with size != 2 should not trigger the warning\n    testdir.makepyfile(\n        \"\"\"\n        def test_tuple():\n            assert ()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert msg not in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_assert_indirect_tuple_no_warning_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_test_assert_indirect_tuple_no_warning_", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 1368, "end_line": 1466, "span_ids": ["test_assert_indirect_tuple_no_warning", "test_assert_with_unicode", "test_assertion_location_with_coverage", "test_exit_from_assertrepr_compare", "test_issue_1944", "test_raise_assertion_error_raisin_repr", "test_raise_unprintable_assertion_error"], "tokens": 560}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_assert_indirect_tuple_no_warning(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_tuple():\n            tpl = ('foo', 'bar')\n            assert tpl\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    output = \"\\n\".join(result.stdout.lines)\n    assert \"WR1\" not in output\n\n\ndef test_assert_with_unicode(testdir):\n    testdir.makepyfile(\n        \"\"\"\\\n        def test_unicode():\n            assert '\uc720\ub2c8\ucf54\ub4dc' == 'Unicode'\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*AssertionError*\"])\n\n\ndef test_raise_unprintable_assertion_error(testdir):\n    testdir.makepyfile(\n        r\"\"\"\n        def test_raise_assertion_error():\n            raise AssertionError('\\xff')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [r\">       raise AssertionError('\\xff')\", \"E       AssertionError: *\"]\n    )\n\n\ndef test_raise_assertion_error_raisin_repr(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        class RaisingRepr(object):\n            def __repr__(self):\n                raise Exception()\n        def test_raising_repr():\n            raise AssertionError(RaisingRepr())\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\"E       AssertionError: <unprintable AssertionError object>\"]\n    )\n\n\ndef test_issue_1944(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def f():\n            return\n\n        assert f() == 10\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 error*\"])\n    assert (\n        \"AttributeError: 'Module' object has no attribute '_obj'\"\n        not in result.stdout.str()\n    )\n\n\ndef test_exit_from_assertrepr_compare(monkeypatch):\n    def raise_exit(obj):\n        outcomes.exit(\"Quitting debugger\")\n\n    monkeypatch.setattr(util, \"istext\", raise_exit)\n\n    with pytest.raises(outcomes.Exit, match=\"Quitting debugger\"):\n        callequal(1, 1)\n\n\ndef test_assertion_location_with_coverage(testdir):\n    \"\"\"This used to report the wrong location when run with coverage (#5754).\"\"\"\n    p = testdir.makepyfile(\n        \"\"\"\n        def test():\n            assert False, 1\n            assert False, 2\n        \"\"\"\n    )\n    result = testdir.runpytest(str(p))\n    result.stdout.fnmatch_lines(\n        [\n            \">       assert False, 1\",\n            \"E       AssertionError: 1\",\n            \"E       assert False\",\n            \"*= 1 failed in*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_ast_getmsg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_ast_getmsg", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 55, "span_ids": ["getmsg", "imports", "rewrite"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import ast\nimport errno\nimport glob\nimport importlib\nimport os\nimport py_compile\nimport stat\nimport sys\nimport textwrap\nimport zipfile\nfrom functools import partial\n\nimport _pytest._code\nimport pytest\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import _get_assertion_exprs\nfrom _pytest.assertion.rewrite import AssertionRewritingHook\nfrom _pytest.assertion.rewrite import get_cache_dir\nfrom _pytest.assertion.rewrite import PYC_TAIL\nfrom _pytest.assertion.rewrite import PYTEST_TAG\nfrom _pytest.assertion.rewrite import rewrite_asserts\nfrom _pytest.config import ExitCode\nfrom _pytest.pathlib import make_numbered_dir\nfrom _pytest.pathlib import Path\nfrom _pytest.pytester import Testdir\n\n\ndef rewrite(src):\n    tree = ast.parse(src)\n    rewrite_asserts(tree, src.encode())\n    return tree\n\n\ndef getmsg(f, extra_ns=None, must_pass=False):\n    \"\"\"Rewrite the assertions in f, run it, and get the failure message.\"\"\"\n    src = \"\\n\".join(_pytest._code.Code(f).source().lines)\n    mod = rewrite(src)\n    code = compile(mod, \"<test>\", \"exec\")\n    ns = {}\n    if extra_ns is not None:\n        ns.update(extra_ns)\n    exec(code, ns)\n    func = ns[f.__name__]\n    try:\n        func()\n    except AssertionError:\n        if must_pass:\n            pytest.fail(\"shouldn't have raised\")\n        s = str(sys.exc_info()[1])\n        if not s.startswith(\"assert\"):\n            return \"AssertionError: \" + s\n        return s\n    else:\n        if not must_pass:\n            pytest.fail(\"function didn't raise at all\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_dont_rewrite_TestAssertionRewrite.test_honors_pep_235": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_dont_rewrite_TestAssertionRewrite.test_honors_pep_235", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 101, "end_line": 146, "span_ids": ["TestAssertionRewrite.test_dont_rewrite", "TestAssertionRewrite.test_dont_rewrite_plugin", "TestAssertionRewrite.test_honors_pep_235", "TestAssertionRewrite.test_rewrites_plugin_as_a_package"], "tokens": 490}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_dont_rewrite(self):\n        s = \"\"\"'PYTEST_DONT_REWRITE'\\nassert 14\"\"\"\n        m = rewrite(s)\n        assert len(m.body) == 2\n        assert m.body[1].msg is None\n\n    def test_dont_rewrite_plugin(self, testdir):\n        contents = {\n            \"conftest.py\": \"pytest_plugins = 'plugin'; import plugin\",\n            \"plugin.py\": \"'PYTEST_DONT_REWRITE'\",\n            \"test_foo.py\": \"def test_foo(): pass\",\n        }\n        testdir.makepyfile(**contents)\n        result = testdir.runpytest_subprocess()\n        assert \"warning\" not in \"\".join(result.outlines)\n\n    def test_rewrites_plugin_as_a_package(self, testdir):\n        pkgdir = testdir.mkpydir(\"plugin\")\n        pkgdir.join(\"__init__.py\").write(\n            \"import pytest\\n\"\n            \"@pytest.fixture\\n\"\n            \"def special_asserter():\\n\"\n            \"    def special_assert(x, y):\\n\"\n            \"        assert x == y\\n\"\n            \"    return special_assert\\n\"\n        )\n        testdir.makeconftest('pytest_plugins = [\"plugin\"]')\n        testdir.makepyfile(\"def test(special_asserter): special_asserter(1, 2)\\n\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*assert 1 == 2*\"])\n\n    def test_honors_pep_235(self, testdir, monkeypatch):\n        # note: couldn't make it fail on macos with a single `sys.path` entry\n        # note: these modules are named `test_*` to trigger rewriting\n        testdir.tmpdir.join(\"test_y.py\").write(\"x = 1\")\n        xdir = testdir.tmpdir.join(\"x\").ensure_dir()\n        xdir.join(\"test_Y\").ensure_dir().join(\"__init__.py\").write(\"x = 2\")\n        testdir.makepyfile(\n            \"import test_y\\n\"\n            \"import test_Y\\n\"\n            \"def test():\\n\"\n            \"    assert test_y.x == 1\\n\"\n            \"    assert test_Y.x == 2\\n\"\n        )\n        monkeypatch.syspath_prepend(xdir)\n        testdir.runpytest().assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport_TestRewriteOnImport.test_orphaned_pyc_file": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport_TestRewriteOnImport.test_orphaned_pyc_file", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 699, "end_line": 794, "span_ids": ["TestRewriteOnImport", "TestRewriteOnImport.test_dont_write_bytecode", "TestRewriteOnImport.test_orphaned_pyc_file", "TestRewriteOnImport.test_pycache_is_a_file", "TestRewriteOnImport.test_pycache_is_readonly", "TestRewriteOnImport.test_readonly", "TestRewriteOnImport.test_zipfile"], "tokens": 709}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRewriteOnImport:\n    def test_pycache_is_a_file(self, testdir):\n        testdir.tmpdir.join(\"__pycache__\").write(\"Hello\")\n        testdir.makepyfile(\n            \"\"\"\n            def test_rewritten():\n                assert \"@py_builtins\" in globals()\"\"\"\n        )\n        assert testdir.runpytest().ret == 0\n\n    def test_pycache_is_readonly(self, testdir):\n        cache = testdir.tmpdir.mkdir(\"__pycache__\")\n        old_mode = cache.stat().mode\n        cache.chmod(old_mode ^ stat.S_IWRITE)\n        testdir.makepyfile(\n            \"\"\"\n            def test_rewritten():\n                assert \"@py_builtins\" in globals()\"\"\"\n        )\n        try:\n            assert testdir.runpytest().ret == 0\n        finally:\n            cache.chmod(old_mode)\n\n    def test_zipfile(self, testdir):\n        z = testdir.tmpdir.join(\"myzip.zip\")\n        z_fn = str(z)\n        f = zipfile.ZipFile(z_fn, \"w\")\n        try:\n            f.writestr(\"test_gum/__init__.py\", \"\")\n            f.writestr(\"test_gum/test_lizard.py\", \"\")\n        finally:\n            f.close()\n        z.chmod(256)\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            sys.path.append(%r)\n            import test_gum.test_lizard\"\"\"\n            % (z_fn,)\n        )\n        assert testdir.runpytest().ret == ExitCode.NO_TESTS_COLLECTED\n\n    def test_readonly(self, testdir):\n        sub = testdir.mkdir(\"testing\")\n        sub.join(\"test_readonly.py\").write(\n            b\"\"\"\ndef test_rewritten():\n    assert \"@py_builtins\" in globals()\n            \"\"\",\n            \"wb\",\n        )\n        old_mode = sub.stat().mode\n        sub.chmod(320)\n        try:\n            assert testdir.runpytest().ret == 0\n        finally:\n            sub.chmod(old_mode)\n\n    def test_dont_write_bytecode(self, testdir, monkeypatch):\n        testdir.makepyfile(\n            \"\"\"\n            import os\n            def test_no_bytecode():\n                assert \"__pycache__\" in __cached__\n                assert not os.path.exists(__cached__)\n                assert not os.path.exists(os.path.dirname(__cached__))\"\"\"\n        )\n        monkeypatch.setenv(\"PYTHONDONTWRITEBYTECODE\", \"1\")\n        assert testdir.runpytest_subprocess().ret == 0\n\n    def test_orphaned_pyc_file(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import orphan\n            def test_it():\n                assert orphan.value == 17\n            \"\"\"\n        )\n        testdir.makepyfile(\n            orphan=\"\"\"\n            value = 17\n            \"\"\"\n        )\n        py_compile.compile(\"orphan.py\")\n        os.remove(\"orphan.py\")\n\n        # Python 3 puts the .pyc files in a __pycache__ directory, and will\n        # not import from there without source.  It will import a .pyc from\n        # the source location though.\n        if not os.path.exists(\"orphan.pyc\"):\n            pycs = glob.glob(\"__pycache__/orphan.*.pyc\")\n            assert len(pycs) == 1\n            os.rename(pycs[0], \"orphan.pyc\")\n\n        assert testdir.runpytest().ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport.test_cached_pyc_includes_pytest_version_TestRewriteOnImport.test_pyc_vs_pyo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport.test_cached_pyc_includes_pytest_version_TestRewriteOnImport.test_pyc_vs_pyo", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 798, "end_line": 835, "span_ids": ["TestRewriteOnImport.test_cached_pyc_includes_pytest_version", "TestRewriteOnImport.test_pyc_vs_pyo"], "tokens": 380}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRewriteOnImport:\n\n    def test_cached_pyc_includes_pytest_version(self, testdir, monkeypatch):\n        \"\"\"Avoid stale caches (#1671)\"\"\"\n        monkeypatch.delenv(\"PYTHONDONTWRITEBYTECODE\", raising=False)\n        testdir.makepyfile(\n            test_foo=\"\"\"\n            def test_foo():\n                assert True\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess()\n        assert result.ret == 0\n        found_names = glob.glob(\n            \"__pycache__/*-pytest-{}.pyc\".format(pytest.__version__)\n        )\n        assert found_names, \"pyc with expected tag not found in names: {}\".format(\n            glob.glob(\"__pycache__/*.pyc\")\n        )\n\n    @pytest.mark.skipif('\"__pypy__\" in sys.modules')\n    def test_pyc_vs_pyo(self, testdir, monkeypatch):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_optimized():\n                \"hello\"\n                assert test_optimized.__doc__ is None\"\"\"\n        )\n        p = make_numbered_dir(root=Path(testdir.tmpdir), prefix=\"runpytest-\")\n        tmp = \"--basetemp=%s\" % p\n        monkeypatch.setenv(\"PYTHONOPTIMIZE\", \"2\")\n        monkeypatch.delenv(\"PYTHONDONTWRITEBYTECODE\", raising=False)\n        assert testdir.runpytest_subprocess(tmp).ret == 0\n        tagged = \"test_pyc_vs_pyo.\" + PYTEST_TAG\n        assert tagged + \".pyo\" in os.listdir(\"__pycache__\")\n        monkeypatch.undo()\n        monkeypatch.delenv(\"PYTHONDONTWRITEBYTECODE\", raising=False)\n        assert testdir.runpytest_subprocess(tmp).ret == 1\n        assert tagged + \".pyc\" in os.listdir(\"__pycache__\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport.test_package_TestRewriteOnImport.test_rewrite_warning_using_pytest_plugins_env_var": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestRewriteOnImport.test_package_TestRewriteOnImport.test_rewrite_warning_using_pytest_plugins_env_var", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 837, "end_line": 935, "span_ids": ["TestRewriteOnImport.test_package", "TestRewriteOnImport.test_package_without__init__py", "TestRewriteOnImport.test_remember_rewritten_modules", "TestRewriteOnImport.test_rewrite_module_imported_from_conftest", "TestRewriteOnImport.test_rewrite_warning", "TestRewriteOnImport.test_rewrite_warning_using_pytest_plugins", "TestRewriteOnImport.test_rewrite_warning_using_pytest_plugins_env_var", "TestRewriteOnImport.test_translate_newlines"], "tokens": 816}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRewriteOnImport:\n\n    def test_package(self, testdir):\n        pkg = testdir.tmpdir.join(\"pkg\")\n        pkg.mkdir()\n        pkg.join(\"__init__.py\").ensure()\n        pkg.join(\"test_blah.py\").write(\n            \"\"\"\ndef test_rewritten():\n    assert \"@py_builtins\" in globals()\"\"\"\n        )\n        assert testdir.runpytest().ret == 0\n\n    def test_translate_newlines(self, testdir):\n        content = \"def test_rewritten():\\r\\n assert '@py_builtins' in globals()\"\n        b = content.encode(\"utf-8\")\n        testdir.tmpdir.join(\"test_newlines.py\").write(b, \"wb\")\n        assert testdir.runpytest().ret == 0\n\n    def test_package_without__init__py(self, testdir):\n        pkg = testdir.mkdir(\"a_package_without_init_py\")\n        pkg.join(\"module.py\").ensure()\n        testdir.makepyfile(\"import a_package_without_init_py.module\")\n        assert testdir.runpytest().ret == ExitCode.NO_TESTS_COLLECTED\n\n    def test_rewrite_warning(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            pytest.register_assert_rewrite(\"_pytest\")\n        \"\"\"\n        )\n        # needs to be a subprocess because pytester explicitly disables this warning\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*Module already imported*: _pytest\"])\n\n    def test_rewrite_module_imported_from_conftest(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import test_rewrite_module_imported\n        \"\"\"\n        )\n        testdir.makepyfile(\n            test_rewrite_module_imported=\"\"\"\n            def test_rewritten():\n                assert \"@py_builtins\" in globals()\n        \"\"\"\n        )\n        assert testdir.runpytest_subprocess().ret == 0\n\n    def test_remember_rewritten_modules(self, pytestconfig, testdir, monkeypatch):\n        \"\"\"\n        AssertionRewriteHook should remember rewritten modules so it\n        doesn't give false positives (#2005).\n        \"\"\"\n        monkeypatch.syspath_prepend(testdir.tmpdir)\n        testdir.makepyfile(test_remember_rewritten_modules=\"\")\n        warnings = []\n        hook = AssertionRewritingHook(pytestconfig)\n        monkeypatch.setattr(\n            hook, \"_warn_already_imported\", lambda code, msg: warnings.append(msg)\n        )\n        spec = hook.find_spec(\"test_remember_rewritten_modules\")\n        module = importlib.util.module_from_spec(spec)\n        hook.exec_module(module)\n        hook.mark_rewrite(\"test_remember_rewritten_modules\")\n        hook.mark_rewrite(\"test_remember_rewritten_modules\")\n        assert warnings == []\n\n    def test_rewrite_warning_using_pytest_plugins(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"conftest.py\": \"pytest_plugins = ['core', 'gui', 'sci']\",\n                \"core.py\": \"\",\n                \"gui.py\": \"pytest_plugins = ['core', 'sci']\",\n                \"sci.py\": \"pytest_plugins = ['core']\",\n                \"test_rewrite_warning_pytest_plugins.py\": \"def test(): pass\",\n            }\n        )\n        testdir.chdir()\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*= 1 passed in *=*\"])\n        result.stdout.no_fnmatch_line(\"*pytest-warning summary*\")\n\n    def test_rewrite_warning_using_pytest_plugins_env_var(self, testdir, monkeypatch):\n        monkeypatch.setenv(\"PYTEST_PLUGINS\", \"plugin\")\n        testdir.makepyfile(\n            **{\n                \"plugin.py\": \"\",\n                \"test_rewrite_warning_using_pytest_plugins_env_var.py\": \"\"\"\n                import plugin\n                pytest_plugins = ['plugin']\n                def test():\n                    pass\n            \"\"\",\n            }\n        )\n        testdir.chdir()\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*= 1 passed in *=*\"])\n        result.stdout.no_fnmatch_line(\"*pytest-warning summary*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestEarlyRewriteBailout.test_pattern_contains_subdirectories_TestEarlyRewriteBailout.test_cwd_changed.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestEarlyRewriteBailout.test_pattern_contains_subdirectories_TestEarlyRewriteBailout.test_cwd_changed.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1302, "end_line": 1347, "span_ids": ["TestEarlyRewriteBailout.test_cwd_changed", "TestEarlyRewriteBailout.test_pattern_contains_subdirectories"], "tokens": 345}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestEarlyRewriteBailout:\n\n    def test_pattern_contains_subdirectories(self, testdir, hook):\n        \"\"\"If one of the python_files patterns contain subdirectories (\"tests/**.py\") we can't bailout early\n        because we need to match with the full path, which can only be found by calling PathFinder.find_spec\n        \"\"\"\n        p = testdir.makepyfile(\n            **{\n                \"tests/file.py\": \"\"\"\\\n                    def test_simple_failure():\n                        assert 1 + 1 == 3\n                \"\"\"\n            }\n        )\n        testdir.syspathinsert(p.dirpath())\n        hook.fnpats[:] = [\"tests/**.py\"]\n        assert hook.find_spec(\"file\") is not None\n        assert self.find_spec_calls == [\"file\"]\n\n    @pytest.mark.skipif(\n        sys.platform.startswith(\"win32\"), reason=\"cannot remove cwd on Windows\"\n    )\n    def test_cwd_changed(self, testdir, monkeypatch):\n        # Setup conditions for py's fspath trying to import pathlib on py34\n        # always (previously triggered via xdist only).\n        # Ref: https://github.com/pytest-dev/py/pull/207\n        monkeypatch.syspath_prepend(\"\")\n        monkeypatch.delitem(sys.modules, \"pathlib\", raising=False)\n\n        testdir.makepyfile(\n            **{\n                \"test_setup_nonexisting_cwd.py\": \"\"\"\\\n                    import os\n                    import shutil\n                    import tempfile\n\n                    d = tempfile.mkdtemp()\n                    os.chdir(d)\n                    shutil.rmtree(d)\n                \"\"\",\n                \"test_test.py\": \"\"\"\\\n                    def test():\n                        pass\n                \"\"\",\n            }\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 1 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionPass_TestAssertionPass.test_hook_not_called_without_hookimpl": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionPass_TestAssertionPass.test_hook_not_called_without_hookimpl", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1350, "end_line": 1423, "span_ids": ["TestAssertionPass", "TestAssertionPass.flag_on", "TestAssertionPass.hook_on", "TestAssertionPass.test_hook_call", "TestAssertionPass.test_hook_call_with_parens", "TestAssertionPass.test_hook_not_called_without_hookimpl", "TestAssertionPass.test_option_default"], "tokens": 496}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionPass:\n    def test_option_default(self, testdir):\n        config = testdir.parseconfig()\n        assert config.getini(\"enable_assertion_pass_hook\") is False\n\n    @pytest.fixture\n    def flag_on(self, testdir):\n        testdir.makeini(\"[pytest]\\nenable_assertion_pass_hook = True\\n\")\n\n    @pytest.fixture\n    def hook_on(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\\\n            def pytest_assertion_pass(item, lineno, orig, expl):\n                raise Exception(\"Assertion Passed: {} {} at line {}\".format(orig, expl, lineno))\n            \"\"\"\n        )\n\n    def test_hook_call(self, testdir, flag_on, hook_on):\n        testdir.makepyfile(\n            \"\"\"\\\n            def test_simple():\n                a=1\n                b=2\n                c=3\n                d=0\n\n                assert a+b == c+d\n\n            # cover failing assertions with a message\n            def test_fails():\n                assert False, \"assert with message\"\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            \"*Assertion Passed: a+b == c+d (1 + 2) == (3 + 0) at line 7*\"\n        )\n\n    def test_hook_call_with_parens(self, testdir, flag_on, hook_on):\n        testdir.makepyfile(\n            \"\"\"\\\n            def f(): return 1\n            def test():\n                assert f()\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\"*Assertion Passed: f() 1\")\n\n    def test_hook_not_called_without_hookimpl(self, testdir, monkeypatch, flag_on):\n        \"\"\"Assertion pass should not be called (and hence formatting should\n        not occur) if there is no hook declared for pytest_assertion_pass\"\"\"\n\n        def raise_on_assertionpass(*_, **__):\n            raise Exception(\"Assertion passed called when it shouldn't!\")\n\n        monkeypatch.setattr(\n            _pytest.assertion.rewrite, \"_call_assertion_pass\", raise_on_assertionpass\n        )\n\n        testdir.makepyfile(\n            \"\"\"\\\n            def test_simple():\n                a=1\n                b=2\n                c=3\n                d=0\n\n                assert a+b == c+d\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionPass.test_hook_not_called_without_cmd_option_TestAssertionPass.test_hook_not_called_without_cmd_option.result_assert_outcomes_pa": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionPass.test_hook_not_called_without_cmd_option_TestAssertionPass.test_hook_not_called_without_cmd_option.result_assert_outcomes_pa", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1425, "end_line": 1455, "span_ids": ["TestAssertionPass.test_hook_not_called_without_cmd_option"], "tokens": 204}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionPass:\n\n    def test_hook_not_called_without_cmd_option(self, testdir, monkeypatch):\n        \"\"\"Assertion pass should not be called (and hence formatting should\n        not occur) if there is no hook declared for pytest_assertion_pass\"\"\"\n\n        def raise_on_assertionpass(*_, **__):\n            raise Exception(\"Assertion passed called when it shouldn't!\")\n\n        monkeypatch.setattr(\n            _pytest.assertion.rewrite, \"_call_assertion_pass\", raise_on_assertionpass\n        )\n\n        testdir.makeconftest(\n            \"\"\"\\\n            def pytest_assertion_pass(item, lineno, orig, expl):\n                raise Exception(\"Assertion Passed: {} {} at line {}\".format(orig, expl, lineno))\n            \"\"\"\n        )\n\n        testdir.makepyfile(\n            \"\"\"\\\n            def test_simple():\n                a=1\n                b=2\n                c=3\n                d=0\n\n                assert a+b == c+d\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_get_assertion_exprs_test_get_assertion_exprs.assert__get_assertion_exp": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_get_assertion_exprs_test_get_assertion_exprs.assert__get_assertion_exp", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1458, "end_line": 1542, "span_ids": ["test_get_assertion_exprs"], "tokens": 694}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    (\"src\", \"expected\"),\n    (\n        # fmt: off\n        pytest.param(b\"\", {}, id=\"trivial\"),\n        pytest.param(\n            b\"def x(): assert 1\\n\",\n            {1: \"1\"},\n            id=\"assert statement not on own line\",\n        ),\n        pytest.param(\n            b\"def x():\\n\"\n            b\"    assert 1\\n\"\n            b\"    assert 1+2\\n\",\n            {2: \"1\", 3: \"1+2\"},\n            id=\"multiple assertions\",\n        ),\n        pytest.param(\n            # changes in encoding cause the byte offsets to be different\n            \"# -*- coding: latin1\\n\"\n            \"def \u00c0\u00c0\u00c0\u00c0\u00c0(): assert 1\\n\".encode(\"latin1\"),\n            {2: \"1\"},\n            id=\"latin1 encoded on first line\\n\",\n        ),\n        pytest.param(\n            # using the default utf-8 encoding\n            \"def \u00c0\u00c0\u00c0\u00c0\u00c0(): assert 1\\n\".encode(),\n            {1: \"1\"},\n            id=\"utf-8 encoded on first line\",\n        ),\n        pytest.param(\n            b\"def x():\\n\"\n            b\"    assert (\\n\"\n            b\"        1 + 2  # comment\\n\"\n            b\"    )\\n\",\n            {2: \"(\\n        1 + 2  # comment\\n    )\"},\n            id=\"multi-line assertion\",\n        ),\n        pytest.param(\n            b\"def x():\\n\"\n            b\"    assert y == [\\n\"\n            b\"        1, 2, 3\\n\"\n            b\"    ]\\n\",\n            {2: \"y == [\\n        1, 2, 3\\n    ]\"},\n            id=\"multi line assert with list continuation\",\n        ),\n        pytest.param(\n            b\"def x():\\n\"\n            b\"    assert 1 + \\\\\\n\"\n            b\"        2\\n\",\n            {2: \"1 + \\\\\\n        2\"},\n            id=\"backslash continuation\",\n        ),\n        pytest.param(\n            b\"def x():\\n\"\n            b\"    assert x, y\\n\",\n            {2: \"x\"},\n            id=\"assertion with message\",\n        ),\n        pytest.param(\n            b\"def x():\\n\"\n            b\"    assert (\\n\"\n            b\"        f(1, 2, 3)\\n\"\n            b\"    ),  'f did not work!'\\n\",\n            {2: \"(\\n        f(1, 2, 3)\\n    )\"},\n            id=\"assertion with message, test spanning multiple lines\",\n        ),\n        pytest.param(\n            b\"def x():\\n\"\n            b\"    assert \\\\\\n\"\n            b\"        x\\\\\\n\"\n            b\"        , 'failure message'\\n\",\n            {2: \"x\"},\n            id=\"escaped newlines plus message\",\n        ),\n        pytest.param(\n            b\"def x(): assert 5\",\n            {1: \"5\"},\n            id=\"no newline at end of file\",\n        ),\n        # fmt: on\n    ),\n)\ndef test_get_assertion_exprs(src, expected):\n    assert _get_assertion_exprs(src) == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_contextlib_TestCaptureManager.test_init_capturing": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_contextlib_TestCaptureManager.test_init_capturing", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 73, "span_ids": ["StdCapture", "StdCaptureFD", "TeeStdCapture", "TestCaptureManager", "TestCaptureManager.test_capturing_basic_api", "TestCaptureManager.test_init_capturing", "imports"], "tokens": 506}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import contextlib\nimport io\nimport os\nimport subprocess\nimport sys\nimport textwrap\nfrom io import UnsupportedOperation\nfrom typing import BinaryIO\nfrom typing import Generator\n\nimport pytest\nfrom _pytest import capture\nfrom _pytest.capture import _get_multicapture\nfrom _pytest.capture import CaptureManager\nfrom _pytest.capture import MultiCapture\nfrom _pytest.config import ExitCode\n\n# note: py.io capture tests where copied from\n# pylib 1.4.20.dev2 (rev 13d9af95547e)\n\n\ndef StdCaptureFD(out=True, err=True, in_=True):\n    return capture.MultiCapture(out, err, in_, Capture=capture.FDCapture)\n\n\ndef StdCapture(out=True, err=True, in_=True):\n    return capture.MultiCapture(out, err, in_, Capture=capture.SysCapture)\n\n\ndef TeeStdCapture(out=True, err=True, in_=True):\n    return capture.MultiCapture(out, err, in_, Capture=capture.TeeSysCapture)\n\n\nclass TestCaptureManager:\n    @pytest.mark.parametrize(\"method\", [\"no\", \"sys\", \"fd\"])\n    def test_capturing_basic_api(self, method):\n        capouter = StdCaptureFD()\n        old = sys.stdout, sys.stderr, sys.stdin\n        try:\n            capman = CaptureManager(method)\n            capman.start_global_capturing()\n            capman.suspend_global_capture()\n            outerr = capman.read_global_capture()\n            assert outerr == (\"\", \"\")\n            capman.suspend_global_capture()\n            outerr = capman.read_global_capture()\n            assert outerr == (\"\", \"\")\n            print(\"hello\")\n            capman.suspend_global_capture()\n            out, err = capman.read_global_capture()\n            if method == \"no\":\n                assert old == (sys.stdout, sys.stderr, sys.stdin)\n            else:\n                assert not out\n            capman.resume_global_capture()\n            print(\"hello\")\n            capman.suspend_global_capture()\n            out, err = capman.read_global_capture()\n            if method != \"no\":\n                assert out == \"hello\\n\"\n            capman.stop_global_capturing()\n        finally:\n            capouter.stop_capturing()\n\n    def test_init_capturing(self):\n        capouter = StdCaptureFD()\n        try:\n            capman = CaptureManager(\"fd\")\n            capman.start_global_capturing()\n            pytest.raises(AssertionError, capman.start_global_capturing)\n            capman.stop_global_capturing()\n        finally:\n            capouter.stop_capturing()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestStdCapture_TestStdCapture.test_stdin_nulled_by_default": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestStdCapture_TestStdCapture.test_stdin_nulled_by_default", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 971, "end_line": 1086, "span_ids": ["TestStdCapture", "TestStdCapture.getcapture", "TestStdCapture.test_capture_results_accessible_by_attribute", "TestStdCapture.test_capturing_done_simple", "TestStdCapture.test_capturing_error_recursive", "TestStdCapture.test_capturing_modify_sysouterr_in_between", "TestStdCapture.test_capturing_readouterr", "TestStdCapture.test_capturing_readouterr_unicode", "TestStdCapture.test_capturing_reset_simple", "TestStdCapture.test_just_err_capture", "TestStdCapture.test_just_out_capture", "TestStdCapture.test_reset_twice_error", "TestStdCapture.test_stdin_nulled_by_default", "TestStdCapture.test_stdin_restored"], "tokens": 856}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestStdCapture:\n    captureclass = staticmethod(StdCapture)\n\n    @contextlib.contextmanager\n    def getcapture(self, **kw):\n        cap = self.__class__.captureclass(**kw)\n        cap.start_capturing()\n        try:\n            yield cap\n        finally:\n            cap.stop_capturing()\n\n    def test_capturing_done_simple(self):\n        with self.getcapture() as cap:\n            sys.stdout.write(\"hello\")\n            sys.stderr.write(\"world\")\n            out, err = cap.readouterr()\n        assert out == \"hello\"\n        assert err == \"world\"\n\n    def test_capturing_reset_simple(self):\n        with self.getcapture() as cap:\n            print(\"hello world\")\n            sys.stderr.write(\"hello error\\n\")\n            out, err = cap.readouterr()\n        assert out == \"hello world\\n\"\n        assert err == \"hello error\\n\"\n\n    def test_capturing_readouterr(self):\n        with self.getcapture() as cap:\n            print(\"hello world\")\n            sys.stderr.write(\"hello error\\n\")\n            out, err = cap.readouterr()\n            assert out == \"hello world\\n\"\n            assert err == \"hello error\\n\"\n            sys.stderr.write(\"error2\")\n            out, err = cap.readouterr()\n        assert err == \"error2\"\n\n    def test_capture_results_accessible_by_attribute(self):\n        with self.getcapture() as cap:\n            sys.stdout.write(\"hello\")\n            sys.stderr.write(\"world\")\n            capture_result = cap.readouterr()\n        assert capture_result.out == \"hello\"\n        assert capture_result.err == \"world\"\n\n    def test_capturing_readouterr_unicode(self):\n        with self.getcapture() as cap:\n            print(\"hx\u0105\u0107\")\n            out, err = cap.readouterr()\n        assert out == \"hx\u0105\u0107\\n\"\n\n    def test_reset_twice_error(self):\n        with self.getcapture() as cap:\n            print(\"hello\")\n            out, err = cap.readouterr()\n        pytest.raises(ValueError, cap.stop_capturing)\n        assert out == \"hello\\n\"\n        assert not err\n\n    def test_capturing_modify_sysouterr_in_between(self):\n        oldout = sys.stdout\n        olderr = sys.stderr\n        with self.getcapture() as cap:\n            sys.stdout.write(\"hello\")\n            sys.stderr.write(\"world\")\n            sys.stdout = capture.CaptureIO()\n            sys.stderr = capture.CaptureIO()\n            print(\"not seen\")\n            sys.stderr.write(\"not seen\\n\")\n            out, err = cap.readouterr()\n        assert out == \"hello\"\n        assert err == \"world\"\n        assert sys.stdout == oldout\n        assert sys.stderr == olderr\n\n    def test_capturing_error_recursive(self):\n        with self.getcapture() as cap1:\n            print(\"cap1\")\n            with self.getcapture() as cap2:\n                print(\"cap2\")\n                out2, err2 = cap2.readouterr()\n                out1, err1 = cap1.readouterr()\n        assert out1 == \"cap1\\n\"\n        assert out2 == \"cap2\\n\"\n\n    def test_just_out_capture(self):\n        with self.getcapture(out=True, err=False) as cap:\n            sys.stdout.write(\"hello\")\n            sys.stderr.write(\"world\")\n            out, err = cap.readouterr()\n        assert out == \"hello\"\n        assert not err\n\n    def test_just_err_capture(self):\n        with self.getcapture(out=False, err=True) as cap:\n            sys.stdout.write(\"hello\")\n            sys.stderr.write(\"world\")\n            out, err = cap.readouterr()\n        assert err == \"world\"\n        assert not out\n\n    def test_stdin_restored(self):\n        old = sys.stdin\n        with self.getcapture(in_=True):\n            newstdin = sys.stdin\n        assert newstdin != sys.stdin\n        assert sys.stdin is old\n\n    def test_stdin_nulled_by_default(self):\n        print(\"XXX this test may well hang instead of crashing\")\n        print(\"XXX which indicates an error in the underlying capturing\")\n        print(\"XXX mechanisms\")\n        with self.getcapture():\n            pytest.raises(OSError, sys.stdin.read)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_compat.py_sys_test_is_generator_async_syntax": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_compat.py_sys_test_is_generator_async_syntax", "embedding": null, "metadata": {"file_path": "testing/test_compat.py", "file_name": "test_compat.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 122, "span_ids": ["imports", "test_get_real_func", "test_get_real_func_partial", "test_is_generator", "test_is_generator_async_syntax", "test_is_generator_asyncio", "test_real_func_loop_limit"], "tokens": 685}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\nfrom functools import partial\nfrom functools import wraps\n\nimport pytest\nfrom _pytest.compat import _PytestWrapper\nfrom _pytest.compat import cached_property\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import is_generator\nfrom _pytest.compat import safe_getattr\nfrom _pytest.compat import safe_isclass\nfrom _pytest.outcomes import OutcomeException\n\n\ndef test_is_generator():\n    def zap():\n        yield  # pragma: no cover\n\n    def foo():\n        pass  # pragma: no cover\n\n    assert is_generator(zap)\n    assert not is_generator(foo)\n\n\ndef test_real_func_loop_limit():\n    class Evil:\n        def __init__(self):\n            self.left = 1000\n\n        def __repr__(self):\n            return \"<Evil left={left}>\".format(left=self.left)\n\n        def __getattr__(self, attr):\n            if not self.left:\n                raise RuntimeError(\"it's over\")  # pragma: no cover\n            self.left -= 1\n            return self\n\n    evil = Evil()\n\n    with pytest.raises(\n        ValueError,\n        match=(\n            \"could not find real function of <Evil left=800>\\n\"\n            \"stopped at <Evil left=800>\"\n        ),\n    ):\n        get_real_func(evil)\n\n\ndef test_get_real_func():\n    \"\"\"Check that get_real_func correctly unwraps decorators until reaching the real function\"\"\"\n\n    def decorator(f):\n        @wraps(f)\n        def inner():\n            pass  # pragma: no cover\n\n        return inner\n\n    def func():\n        pass  # pragma: no cover\n\n    wrapped_func = decorator(decorator(func))\n    assert get_real_func(wrapped_func) is func\n\n    wrapped_func2 = decorator(decorator(wrapped_func))\n    assert get_real_func(wrapped_func2) is func\n\n    # special case for __pytest_wrapped__ attribute: used to obtain the function up until the point\n    # a function was wrapped by pytest itself\n    wrapped_func2.__pytest_wrapped__ = _PytestWrapper(wrapped_func)\n    assert get_real_func(wrapped_func2) is wrapped_func\n\n\ndef test_get_real_func_partial():\n    \"\"\"Test get_real_func handles partial instances correctly\"\"\"\n\n    def foo(x):\n        return x\n\n    assert get_real_func(foo) is foo\n    assert get_real_func(partial(foo)) is foo\n\n\ndef test_is_generator_asyncio(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        from _pytest.compat import is_generator\n        import asyncio\n        @asyncio.coroutine\n        def baz():\n            yield from [1,2,3]\n\n        def test_is_generator_asyncio():\n            assert not is_generator(baz)\n    \"\"\"\n    )\n    # avoid importing asyncio into pytest's own process,\n    # which in turn imports logging (#8)\n    result = testdir.runpytest_subprocess()\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_is_generator_async_syntax(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        from _pytest.compat import is_generator\n        def test_is_generator_py35():\n            async def foo():\n                await foo()\n\n            async def bar():\n                pass\n\n            assert not is_generator(foo)\n            assert not is_generator(bar)\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_compat.py_test_is_generator_async_gen_syntax_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_compat.py_test_is_generator_async_gen_syntax_", "embedding": null, "metadata": {"file_path": "testing/test_compat.py", "file_name": "test_compat.py", "file_type": "text/x-python", "category": "test", "start_line": 125, "end_line": 208, "span_ids": ["ErrorsHelper", "ErrorsHelper.raise_baseexception", "ErrorsHelper.raise_exception", "ErrorsHelper.raise_fail_outcome", "test_cached_property", "test_helper_failures", "test_is_generator_async_gen_syntax", "test_safe_getattr", "test_safe_isclass"], "tokens": 480}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.skipif(\n    sys.version_info < (3, 6), reason=\"async gen syntax available in Python 3.6+\"\n)\ndef test_is_generator_async_gen_syntax(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        from _pytest.compat import is_generator\n        def test_is_generator_py36():\n            async def foo():\n                yield\n                await foo()\n\n            async def bar():\n                yield\n\n            assert not is_generator(foo)\n            assert not is_generator(bar)\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\nclass ErrorsHelper:\n    @property\n    def raise_baseexception(self):\n        raise BaseException(\"base exception should be raised\")\n\n    @property\n    def raise_exception(self):\n        raise Exception(\"exception should be catched\")\n\n    @property\n    def raise_fail_outcome(self):\n        pytest.fail(\"fail should be catched\")\n\n\ndef test_helper_failures():\n    helper = ErrorsHelper()\n    with pytest.raises(Exception):\n        helper.raise_exception\n    with pytest.raises(OutcomeException):\n        helper.raise_fail_outcome\n\n\ndef test_safe_getattr():\n    helper = ErrorsHelper()\n    assert safe_getattr(helper, \"raise_exception\", \"default\") == \"default\"\n    assert safe_getattr(helper, \"raise_fail_outcome\", \"default\") == \"default\"\n    with pytest.raises(BaseException):\n        assert safe_getattr(helper, \"raise_baseexception\", \"default\")\n\n\ndef test_safe_isclass():\n    assert safe_isclass(type) is True\n\n    class CrappyClass(Exception):\n        # Type ignored because it's bypassed intentionally.\n        @property  # type: ignore\n        def __class__(self):\n            assert False, \"Should be ignored\"\n\n    assert safe_isclass(CrappyClass()) is False\n\n\ndef test_cached_property() -> None:\n    ncalls = 0\n\n    class Class:\n        @cached_property\n        def prop(self) -> int:\n            nonlocal ncalls\n            ncalls += 1\n            return ncalls\n\n    c1 = Class()\n    assert ncalls == 0\n    assert c1.prop == 1\n    assert c1.prop == 1\n    c2 = Class()\n    assert ncalls == 1\n    assert c2.prop == 2\n    assert c1.prop == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_os_TestParseIni.test_confcutdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_os_TestParseIni.test_confcutdir", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 147, "span_ids": ["TestParseIni", "TestParseIni.test_append_parse_args", "TestParseIni.test_confcutdir", "TestParseIni.test_getcfg_and_config", "TestParseIni.test_getcfg_empty_path", "TestParseIni.test_ini_names", "TestParseIni.test_ini_parse_error", "TestParseIni.test_setupcfg_uses_toolpytest_with_pytest", "TestParseIni.test_tox_ini_wrong_version", "TestParseIni.test_toxini_before_lower_pytestini", "imports"], "tokens": 982}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport re\nimport sys\nimport textwrap\n\nimport py.path\n\nimport _pytest._code\nimport pytest\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.config import _iter_rewritable_modules\nfrom _pytest.config import Config\nfrom _pytest.config import ExitCode\nfrom _pytest.config.exceptions import UsageError\nfrom _pytest.config.findpaths import determine_setup\nfrom _pytest.config.findpaths import get_common_ancestor\nfrom _pytest.config.findpaths import getcfg\nfrom _pytest.pathlib import Path\n\n\nclass TestParseIni:\n    @pytest.mark.parametrize(\n        \"section, filename\", [(\"pytest\", \"pytest.ini\"), (\"tool:pytest\", \"setup.cfg\")]\n    )\n    def test_getcfg_and_config(self, testdir, tmpdir, section, filename):\n        sub = tmpdir.mkdir(\"sub\")\n        sub.chdir()\n        tmpdir.join(filename).write(\n            textwrap.dedent(\n                \"\"\"\\\n                [{section}]\n                name = value\n                \"\"\".format(\n                    section=section\n                )\n            )\n        )\n        _, _, cfg = getcfg([sub])\n        assert cfg[\"name\"] == \"value\"\n        config = testdir.parseconfigure(sub)\n        assert config.inicfg[\"name\"] == \"value\"\n\n    def test_getcfg_empty_path(self):\n        \"\"\"correctly handle zero length arguments (a la pytest '')\"\"\"\n        getcfg([\"\"])\n\n    def test_setupcfg_uses_toolpytest_with_pytest(self, testdir):\n        p1 = testdir.makepyfile(\"def test(): pass\")\n        testdir.makefile(\n            \".cfg\",\n            setup=\"\"\"\n                [tool:pytest]\n                testpaths=%s\n                [pytest]\n                testpaths=ignored\n        \"\"\"\n            % p1.basename,\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*, inifile: setup.cfg, *\", \"* 1 passed in *\"])\n        assert result.ret == 0\n\n    def test_append_parse_args(self, testdir, tmpdir, monkeypatch):\n        monkeypatch.setenv(\"PYTEST_ADDOPTS\", '--color no -rs --tb=\"short\"')\n        tmpdir.join(\"pytest.ini\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                [pytest]\n                addopts = --verbose\n                \"\"\"\n            )\n        )\n        config = testdir.parseconfig(tmpdir)\n        assert config.option.color == \"no\"\n        assert config.option.reportchars == \"s\"\n        assert config.option.tbstyle == \"short\"\n        assert config.option.verbose\n\n    def test_tox_ini_wrong_version(self, testdir):\n        testdir.makefile(\n            \".ini\",\n            tox=\"\"\"\n            [pytest]\n            minversion=9.0\n        \"\"\",\n        )\n        result = testdir.runpytest()\n        assert result.ret != 0\n        result.stderr.fnmatch_lines([\"*tox.ini:2*requires*9.0*actual*\"])\n\n    @pytest.mark.parametrize(\n        \"section, name\",\n        [(\"tool:pytest\", \"setup.cfg\"), (\"pytest\", \"tox.ini\"), (\"pytest\", \"pytest.ini\")],\n    )\n    def test_ini_names(self, testdir, name, section):\n        testdir.tmpdir.join(name).write(\n            textwrap.dedent(\n                \"\"\"\n            [{section}]\n            minversion = 1.0\n        \"\"\".format(\n                    section=section\n                )\n            )\n        )\n        config = testdir.parseconfig()\n        assert config.getini(\"minversion\") == \"1.0\"\n\n    def test_toxini_before_lower_pytestini(self, testdir):\n        sub = testdir.tmpdir.mkdir(\"sub\")\n        sub.join(\"tox.ini\").write(\n            textwrap.dedent(\n                \"\"\"\n            [pytest]\n            minversion = 2.0\n        \"\"\"\n            )\n        )\n        testdir.tmpdir.join(\"pytest.ini\").write(\n            textwrap.dedent(\n                \"\"\"\n            [pytest]\n            minversion = 1.5\n        \"\"\"\n            )\n        )\n        config = testdir.parseconfigure(sub)\n        assert config.getini(\"minversion\") == \"2.0\"\n\n    def test_ini_parse_error(self, testdir):\n        testdir.tmpdir.join(\"pytest.ini\").write(\"addopts = -x\")\n        result = testdir.runpytest()\n        assert result.ret != 0\n        result.stderr.fnmatch_lines([\"ERROR: *pytest.ini:1: no section header defined\"])\n\n    @pytest.mark.xfail(reason=\"probably not needed\")\n    def test_confcutdir(self, testdir):\n        sub = testdir.mkdir(\"sub\")\n        sub.chdir()\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            addopts = --qwe\n        \"\"\"\n        )\n        result = testdir.inline_run(\"--confcutdir=.\")\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigFromdictargs_TestConfigFromdictargs.test_invocation_params_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestConfigFromdictargs_TestConfigFromdictargs.test_invocation_params_args", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 446, "end_line": 468, "span_ids": ["TestConfigFromdictargs", "TestConfigFromdictargs.test_basic_behavior", "TestConfigFromdictargs.test_invocation_params_args"], "tokens": 216}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestConfigFromdictargs:\n    def test_basic_behavior(self, _sys_snapshot):\n        option_dict = {\"verbose\": 444, \"foo\": \"bar\", \"capture\": \"no\"}\n        args = [\"a\", \"b\"]\n\n        config = Config.fromdictargs(option_dict, args)\n        with pytest.raises(AssertionError):\n            config.parse([\"should refuse to parse again\"])\n        assert config.option.verbose == 444\n        assert config.option.foo == \"bar\"\n        assert config.option.capture == \"no\"\n        assert config.args == args\n\n    def test_invocation_params_args(self, _sys_snapshot):\n        \"\"\"Show that fromdictargs can handle args in their \"orig\" format\"\"\"\n        option_dict = {}\n        args = [\"-vvvv\", \"-s\", \"a\", \"b\"]\n\n        config = Config.fromdictargs(option_dict, args)\n        assert config.args == [\"a\", \"b\"]\n        assert config.invocation_params.args == tuple(args)\n        assert config.option.verbose == 4\n        assert config.option.capture == \"no\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_help_and_version_after_argument_error_test_help_and_version_after_argument_error.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_help_and_version_after_argument_error_test_help_and_version_after_argument_error.None_2", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1151, "end_line": 1194, "span_ids": ["test_help_and_version_after_argument_error"], "tokens": 286}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_help_and_version_after_argument_error(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        def validate(arg):\n            raise argparse.ArgumentTypeError(\"argerror\")\n\n        def pytest_addoption(parser):\n            group = parser.getgroup('cov')\n            group.addoption(\n                \"--invalid-option-should-allow-for-help\",\n                type=validate,\n            )\n        \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        addopts = --invalid-option-should-allow-for-help\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--help\")\n    result.stdout.fnmatch_lines(\n        [\n            \"usage: *\",\n            \"positional arguments:\",\n            \"NOTE: displaying only minimal help due to UsageError.\",\n        ]\n    )\n    result.stderr.fnmatch_lines(\n        [\n            \"ERROR: usage: *\",\n            \"%s: error: argument --invalid-option-should-allow-for-help: expected one argument\"\n            % (testdir.request.config._parser.optparser.prog,),\n        ]\n    )\n    # Does not display full/default help.\n    assert \"to see available markers type: pytest --markers\" not in result.stdout.lines\n    assert result.ret == ExitCode.USAGE_ERROR\n\n    result = testdir.runpytest(\"--version\")\n    result.stderr.fnmatch_lines(\n        [\"*pytest*{}*imported from*\".format(pytest.__version__)]\n    )\n    assert result.ret == ExitCode.USAGE_ERROR", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_config_blocked_default_plugins_TestSetupCfg.test_pytest_custom_cfg_unsupported": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_config_blocked_default_plugins_TestSetupCfg.test_pytest_custom_cfg_unsupported", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1305, "end_line": 1371, "span_ids": ["TestSetupCfg", "TestSetupCfg.test_pytest_custom_cfg_unsupported", "TestSetupCfg.test_pytest_setup_cfg_unsupported", "test_config_blocked_default_plugins"], "tokens": 448}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"plugin\",\n    [\n        x\n        for x in _pytest.config.default_plugins\n        if x not in _pytest.config.essential_plugins\n    ],\n)\ndef test_config_blocked_default_plugins(testdir, plugin):\n    if plugin == \"debugging\":\n        # Fixed in xdist master (after 1.27.0).\n        # https://github.com/pytest-dev/pytest-xdist/pull/422\n        try:\n            import xdist  # noqa: F401\n        except ImportError:\n            pass\n        else:\n            pytest.skip(\"does not work with xdist currently\")\n\n    p = testdir.makepyfile(\"def test(): pass\")\n    result = testdir.runpytest(str(p), \"-pno:%s\" % plugin)\n\n    if plugin == \"python\":\n        assert result.ret == ExitCode.USAGE_ERROR\n        result.stderr.fnmatch_lines(\n            [\n                \"ERROR: not found: */test_config_blocked_default_plugins.py\",\n                \"(no name '*/test_config_blocked_default_plugins.py' in any of [])\",\n            ]\n        )\n        return\n\n    assert result.ret == ExitCode.OK\n    if plugin != \"terminal\":\n        result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n\n    p = testdir.makepyfile(\"def test(): assert 0\")\n    result = testdir.runpytest(str(p), \"-pno:%s\" % plugin)\n    assert result.ret == ExitCode.TESTS_FAILED\n    if plugin != \"terminal\":\n        result.stdout.fnmatch_lines([\"* 1 failed in *\"])\n    else:\n        assert result.stdout.lines == []\n\n\nclass TestSetupCfg:\n    def test_pytest_setup_cfg_unsupported(self, testdir):\n        testdir.makefile(\n            \".cfg\",\n            setup=\"\"\"\n            [pytest]\n            addopts = --verbose\n        \"\"\",\n        )\n        with pytest.raises(pytest.fail.Exception):\n            testdir.runpytest()\n\n    def test_pytest_custom_cfg_unsupported(self, testdir):\n        testdir.makefile(\n            \".cfg\",\n            custom=\"\"\"\n            [pytest]\n            addopts = --verbose\n        \"\"\",\n        )\n        with pytest.raises(pytest.fail.Exception):\n            testdir.runpytest(\"-c\", \"custom.cfg\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestPytestPluginsVariable_TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs.if_use_pyargs_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestPytestPluginsVariable_TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs.if_use_pyargs_", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1301, "end_line": 1352, "span_ids": ["TestPytestPluginsVariable", "TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported", "TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs"], "tokens": 436}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPytestPluginsVariable:\n    def test_pytest_plugins_in_non_top_level_conftest_unsupported(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"subdirectory/conftest.py\": \"\"\"\n            pytest_plugins=['capture']\n        \"\"\"\n            }\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_func():\n                pass\n        \"\"\"\n        )\n        res = testdir.runpytest()\n        assert res.ret == 2\n        msg = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n        res.stdout.fnmatch_lines(\n            [\n                \"*{msg}*\".format(msg=msg),\n                \"*subdirectory{sep}conftest.py*\".format(sep=os.sep),\n            ]\n        )\n\n    @pytest.mark.parametrize(\"use_pyargs\", [True, False])\n    def test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs(\n        self, testdir, use_pyargs\n    ):\n        \"\"\"When using --pyargs, do not emit the warning about non-top-level conftest warnings (#4039, #4044)\"\"\"\n\n        files = {\n            \"src/pkg/__init__.py\": \"\",\n            \"src/pkg/conftest.py\": \"\",\n            \"src/pkg/test_root.py\": \"def test(): pass\",\n            \"src/pkg/sub/__init__.py\": \"\",\n            \"src/pkg/sub/conftest.py\": \"pytest_plugins=['capture']\",\n            \"src/pkg/sub/test_bar.py\": \"def test(): pass\",\n        }\n        testdir.makepyfile(**files)\n        testdir.syspathinsert(testdir.tmpdir.join(\"src\"))\n\n        args = (\"--pyargs\", \"pkg\") if use_pyargs else ()\n        res = testdir.runpytest(*args)\n        assert res.ret == (0 if use_pyargs else 2)\n        msg = (\n            msg\n        ) = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n        if use_pyargs:\n            assert msg not in res.stdout.str()\n        else:\n            res.stdout.fnmatch_lines([\"*{msg}*\".format(msg=msg)])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest_", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1427, "end_line": 1474, "span_ids": ["TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_no_false_positives", "TestPytestPluginsVariable.test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest"], "tokens": 327}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPytestPluginsVariable:\n\n    def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest(\n        self, testdir\n    ):\n        subdirectory = testdir.tmpdir.join(\"subdirectory\")\n        subdirectory.mkdir()\n        testdir.makeconftest(\n            \"\"\"\n            pytest_plugins=['capture']\n        \"\"\"\n        )\n        testdir.tmpdir.join(\"conftest.py\").move(subdirectory.join(\"conftest.py\"))\n\n        testdir.makepyfile(\n            \"\"\"\n            def test_func():\n                pass\n        \"\"\"\n        )\n\n        res = testdir.runpytest_subprocess()\n        assert res.ret == 2\n        msg = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n        res.stdout.fnmatch_lines(\n            [\n                \"*{msg}*\".format(msg=msg),\n                \"*subdirectory{sep}conftest.py*\".format(sep=os.sep),\n            ]\n        )\n\n    def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_false_positives(\n        self, testdir\n    ):\n        testdir.makepyfile(\n            \"def test_func(): pass\",\n            **{\n                \"subdirectory/conftest\": \"pass\",\n                \"conftest\": \"\"\"\n                    import warnings\n                    warnings.filterwarnings('always', category=DeprecationWarning)\n                    pytest_plugins=['capture']\n                    \"\"\",\n            },\n        )\n        res = testdir.runpytest_subprocess()\n        assert res.ret == 0\n        msg = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n        assert msg not in res.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_symlink_files_test_conftest_symlink_files.assert_result_ret_Exit": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_symlink_files_test_conftest_symlink_files.assert_result_ret_Exit", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 244, "end_line": 277, "span_ids": ["test_conftest_symlink_files"], "tokens": 267}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.skipif(\n    not hasattr(py.path.local, \"mksymlinkto\"),\n    reason=\"symlink not available on this platform\",\n)\ndef test_conftest_symlink_files(testdir):\n    \"\"\"Check conftest.py loading when running in directory with symlinks.\"\"\"\n    real = testdir.tmpdir.mkdir(\"real\")\n    source = {\n        \"app/test_foo.py\": \"def test1(fixture): pass\",\n        \"app/__init__.py\": \"\",\n        \"app/conftest.py\": textwrap.dedent(\n            \"\"\"\n            import pytest\n\n            print(\"conftest_loaded\")\n\n            @pytest.fixture\n            def fixture():\n                print(\"fixture_used\")\n            \"\"\"\n        ),\n    }\n    testdir.makepyfile(**{\"real/%s\" % k: v for k, v in source.items()})\n\n    # Create a build directory that contains symlinks to actual files\n    # but doesn't symlink actual directories.\n    build = testdir.tmpdir.mkdir(\"build\")\n    build.mkdir(\"app\")\n    for f in source:\n        build.join(f).mksymlinkto(real.join(f))\n    build.chdir()\n    result = testdir.runpytest(\"-vs\", \"app/test_foo.py\")\n    result.stdout.fnmatch_lines([\"*conftest_loaded*\", \"PASSED\"])\n    assert result.ret == ExitCode.OK", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_badcase_test_conftest_import_order": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_test_conftest_badcase_test_conftest_import_order", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 281, "end_line": 357, "span_ids": ["test_conftest_badcase", "test_conftest_existing_junitxml", "test_conftest_existing_resultlog", "test_conftest_import_order", "test_conftest_uppercase", "test_no_conftest"], "tokens": 672}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.skipif(\n    os.path.normcase(\"x\") != os.path.normcase(\"X\"),\n    reason=\"only relevant for case insensitive file systems\",\n)\ndef test_conftest_badcase(testdir):\n    \"\"\"Check conftest.py loading when directory casing is wrong (#5792).\"\"\"\n    testdir.tmpdir.mkdir(\"JenkinsRoot\").mkdir(\"test\")\n    source = {\"setup.py\": \"\", \"test/__init__.py\": \"\", \"test/conftest.py\": \"\"}\n    testdir.makepyfile(**{\"JenkinsRoot/%s\" % k: v for k, v in source.items()})\n\n    testdir.tmpdir.join(\"jenkinsroot/test\").chdir()\n    result = testdir.runpytest()\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_conftest_uppercase(testdir):\n    \"\"\"Check conftest.py whose qualified name contains uppercase characters (#5819)\"\"\"\n    source = {\"__init__.py\": \"\", \"Foo/conftest.py\": \"\", \"Foo/__init__.py\": \"\"}\n    testdir.makepyfile(**source)\n\n    testdir.tmpdir.chdir()\n    result = testdir.runpytest()\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_no_conftest(testdir):\n    testdir.makeconftest(\"assert 0\")\n    result = testdir.runpytest(\"--noconftest\")\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n    result = testdir.runpytest()\n    assert result.ret == ExitCode.USAGE_ERROR\n\n\ndef test_conftest_existing_resultlog(testdir):\n    x = testdir.mkdir(\"tests\")\n    x.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            def pytest_addoption(parser):\n                parser.addoption(\"--xyz\", action=\"store_true\")\n            \"\"\"\n        )\n    )\n    testdir.makefile(ext=\".log\", result=\"\")  # Writes result.log\n    result = testdir.runpytest(\"-h\", \"--resultlog\", \"result.log\")\n    result.stdout.fnmatch_lines([\"*--xyz*\"])\n\n\ndef test_conftest_existing_junitxml(testdir):\n    x = testdir.mkdir(\"tests\")\n    x.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            def pytest_addoption(parser):\n                parser.addoption(\"--xyz\", action=\"store_true\")\n            \"\"\"\n        )\n    )\n    testdir.makefile(ext=\".xml\", junit=\"\")  # Writes junit.xml\n    result = testdir.runpytest(\"-h\", \"--junitxml\", \"junit.xml\")\n    result.stdout.fnmatch_lines([\"*--xyz*\"])\n\n\ndef test_conftest_import_order(testdir, monkeypatch):\n    ct1 = testdir.makeconftest(\"\")\n    sub = testdir.mkdir(\"sub\")\n    ct2 = sub.join(\"conftest.py\")\n    ct2.write(\"\")\n\n    def impct(p):\n        return p\n\n    conftest = PytestPluginManager()\n    conftest._confcutdir = testdir.tmpdir\n    monkeypatch.setattr(conftest, \"_importconftest\", impct)\n    assert conftest._getconftestmodules(sub) == [ct1, ct2]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_inspect_TestDoctests.test_simple_doctestfile": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_inspect_TestDoctests.test_simple_doctestfile", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 102, "span_ids": ["TestDoctests", "TestDoctests.test_collect_module_empty", "TestDoctests.test_collect_module_single_modulelevel_doctest", "TestDoctests.test_collect_module_two_doctest_no_modulelevel", "TestDoctests.test_collect_module_two_doctest_one_modulelevel", "TestDoctests.test_collect_testtextfile", "TestDoctests.test_simple_doctestfile", "imports"], "tokens": 818}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import inspect\nimport textwrap\n\nimport pytest\nfrom _pytest.compat import MODULE_NOT_FOUND_ERROR\nfrom _pytest.doctest import _get_checker\nfrom _pytest.doctest import _is_mocked\nfrom _pytest.doctest import _is_setup_py\nfrom _pytest.doctest import _patch_unwrap_mock_aware\nfrom _pytest.doctest import DoctestItem\nfrom _pytest.doctest import DoctestModule\nfrom _pytest.doctest import DoctestTextfile\n\n\nclass TestDoctests:\n    def test_collect_testtextfile(self, testdir):\n        w = testdir.maketxtfile(whatever=\"\")\n        checkfile = testdir.maketxtfile(\n            test_something=\"\"\"\n            alskdjalsdk\n            >>> i = 5\n            >>> i-1\n            4\n        \"\"\"\n        )\n\n        for x in (testdir.tmpdir, checkfile):\n            # print \"checking that %s returns custom items\" % (x,)\n            items, reprec = testdir.inline_genitems(x)\n            assert len(items) == 1\n            assert isinstance(items[0], DoctestItem)\n            assert isinstance(items[0].parent, DoctestTextfile)\n        # Empty file has no items.\n        items, reprec = testdir.inline_genitems(w)\n        assert len(items) == 0\n\n    def test_collect_module_empty(self, testdir):\n        path = testdir.makepyfile(whatever=\"#\")\n        for p in (path, testdir.tmpdir):\n            items, reprec = testdir.inline_genitems(p, \"--doctest-modules\")\n            assert len(items) == 0\n\n    def test_collect_module_single_modulelevel_doctest(self, testdir):\n        path = testdir.makepyfile(whatever='\"\"\">>> pass\"\"\"')\n        for p in (path, testdir.tmpdir):\n            items, reprec = testdir.inline_genitems(p, \"--doctest-modules\")\n            assert len(items) == 1\n            assert isinstance(items[0], DoctestItem)\n            assert isinstance(items[0].parent, DoctestModule)\n\n    def test_collect_module_two_doctest_one_modulelevel(self, testdir):\n        path = testdir.makepyfile(\n            whatever=\"\"\"\n            '>>> x = None'\n            def my_func():\n                \">>> magic = 42 \"\n        \"\"\"\n        )\n        for p in (path, testdir.tmpdir):\n            items, reprec = testdir.inline_genitems(p, \"--doctest-modules\")\n            assert len(items) == 2\n            assert isinstance(items[0], DoctestItem)\n            assert isinstance(items[1], DoctestItem)\n            assert isinstance(items[0].parent, DoctestModule)\n            assert items[0].parent is items[1].parent\n\n    def test_collect_module_two_doctest_no_modulelevel(self, testdir):\n        path = testdir.makepyfile(\n            whatever=\"\"\"\n            '# Empty'\n            def my_func():\n                \">>> magic = 42 \"\n            def unuseful():\n                '''\n                # This is a function\n                # >>> # it doesn't have any doctest\n                '''\n            def another():\n                '''\n                # This is another function\n                >>> import os # this one does have a doctest\n                '''\n        \"\"\"\n        )\n        for p in (path, testdir.tmpdir):\n            items, reprec = testdir.inline_genitems(p, \"--doctest-modules\")\n            assert len(items) == 2\n            assert isinstance(items[0], DoctestItem)\n            assert isinstance(items[1], DoctestItem)\n            assert isinstance(items[0].parent, DoctestModule)\n            assert items[0].parent is items[1].parent\n\n    def test_simple_doctestfile(self, testdir):\n        p = testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> x = 1\n            >>> x == 1\n            False\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p)\n        reprec.assertoutcome(failed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_unicode_string_TestLiterals.test_number_re.for_s_in_1_abc_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_unicode_string_TestLiterals.test_number_re.for_s_in_1_abc_", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 905, "end_line": 960, "span_ids": ["TestLiterals.test_bytes_literal", "TestLiterals.test_number_re", "TestLiterals.test_unicode_string"], "tokens": 379}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLiterals:\n\n    def test_unicode_string(self, testdir):\n        \"\"\"Test that doctests which output unicode fail in Python 2 when\n        the ALLOW_UNICODE option is not used. The same test should pass\n        in Python 3.\n        \"\"\"\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> b'12'.decode('ascii')\n            '12'\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_bytes_literal(self, testdir):\n        \"\"\"Test that doctests which output bytes fail in Python 3 when\n        the ALLOW_BYTES option is not used. (#1287).\n        \"\"\"\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> b'foo'\n            'foo'\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(failed=1)\n\n    def test_number_re(self) -> None:\n        _number_re = _get_checker()._number_re  # type: ignore\n        for s in [\n            \"1.\",\n            \"+1.\",\n            \"-1.\",\n            \".1\",\n            \"+.1\",\n            \"-.1\",\n            \"0.1\",\n            \"+0.1\",\n            \"-0.1\",\n            \"1e5\",\n            \"+1e5\",\n            \"1e+5\",\n            \"+1e+5\",\n            \"1e-5\",\n            \"+1e-5\",\n            \"-1e-5\",\n            \"1.2e3\",\n            \"-1.2e-3\",\n        ]:\n            print(s)\n            m = _number_re.match(s)\n            assert m is not None\n            assert float(m.group()) == pytest.approx(float(s))\n        for s in [\"1\", \"abc\"]:\n            print(s)\n            assert _number_re.match(s) is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_number_precision_TestLiterals.test_number_precision.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_number_precision_TestLiterals.test_number_precision.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 871, "end_line": 943, "span_ids": ["TestLiterals.test_number_precision"], "tokens": 515}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLiterals:\n\n    @pytest.mark.parametrize(\"config_mode\", [\"ini\", \"comment\"])\n    def test_number_precision(self, testdir, config_mode):\n        \"\"\"Test the NUMBER option.\"\"\"\n        if config_mode == \"ini\":\n            testdir.makeini(\n                \"\"\"\n                [pytest]\n                doctest_optionflags = NUMBER\n                \"\"\"\n            )\n            comment = \"\"\n        else:\n            comment = \"#doctest: +NUMBER\"\n\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n\n            Scalars:\n\n            >>> import math\n            >>> math.pi {comment}\n            3.141592653589793\n            >>> math.pi {comment}\n            3.1416\n            >>> math.pi {comment}\n            3.14\n            >>> -math.pi {comment}\n            -3.14\n            >>> math.pi {comment}\n            3.\n            >>> 3. {comment}\n            3.0\n            >>> 3. {comment}\n            3.\n            >>> 3. {comment}\n            3.01\n            >>> 3. {comment}\n            2.99\n            >>> .299 {comment}\n            .3\n            >>> .301 {comment}\n            .3\n            >>> 951. {comment}\n            1e3\n            >>> 1049. {comment}\n            1e3\n            >>> -1049. {comment}\n            -1e3\n            >>> 1e3 {comment}\n            1e3\n            >>> 1e3 {comment}\n            1000.\n\n            Lists:\n\n            >>> [3.1415, 0.097, 13.1, 7, 8.22222e5, 0.598e-2] {comment}\n            [3.14, 0.1, 13., 7, 8.22e5, 6.0e-3]\n            >>> [[0.333, 0.667], [0.999, 1.333]] {comment}\n            [[0.33, 0.667], [0.999, 1.333]]\n            >>> [[[0.101]]] {comment}\n            [[[0.1]]]\n\n            Doesn't barf on non-numbers:\n\n            >>> 'abc' {comment}\n            'abc'\n            >>> None {comment}\n            \"\"\".format(\n                comment=comment\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_number_non_matches_TestLiterals.test_number_and_allow_unicode": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestLiterals.test_number_non_matches_TestLiterals.test_number_and_allow_unicode", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 945, "end_line": 988, "span_ids": ["TestLiterals.test_number_and_allow_unicode", "TestLiterals.test_number_non_matches"], "tokens": 391}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLiterals:\n\n    @pytest.mark.parametrize(\n        \"expression,output\",\n        [\n            # ints shouldn't match floats:\n            (\"3.0\", \"3\"),\n            (\"3e0\", \"3\"),\n            (\"1e3\", \"1000\"),\n            (\"3\", \"3.0\"),\n            # Rounding:\n            (\"3.1\", \"3.0\"),\n            (\"3.1\", \"3.2\"),\n            (\"3.1\", \"4.0\"),\n            (\"8.22e5\", \"810000.0\"),\n            # Only the actual output is rounded up, not the expected output:\n            (\"3.0\", \"2.98\"),\n            (\"1e3\", \"999\"),\n            # The current implementation doesn't understand that numbers inside\n            # strings shouldn't be treated as numbers:\n            pytest.param(\"'3.1416'\", \"'3.14'\", marks=pytest.mark.xfail),\n        ],\n    )\n    def test_number_non_matches(self, testdir, expression, output):\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> {expression} #doctest: +NUMBER\n            {output}\n            \"\"\".format(\n                expression=expression, output=output\n            )\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=0, failed=1)\n\n    def test_number_and_allow_unicode(self, testdir):\n        testdir.maketxtfile(\n            test_doc=\"\"\"\n            >>> from collections import namedtuple\n            >>> T = namedtuple('T', 'a b c')\n            >>> T(a=0.2330000001, b=u'str', c=b'bytes') # doctest: +ALLOW_UNICODE, +ALLOW_BYTES, +NUMBER\n            T(a=0.233, b=u'str', c='bytes')\n            \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_sys_test_disabled": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_sys_test_disabled", "embedding": null, "metadata": {"file_path": "testing/test_faulthandler.py", "file_name": "test_faulthandler.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 49, "span_ids": ["imports", "test_crash_near_exit", "test_disabled", "test_enabled"], "tokens": 293}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\n\nimport pytest\n\n\ndef test_enabled(testdir):\n    \"\"\"Test single crashing test displays a traceback.\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n    import faulthandler\n    def test_crash():\n        faulthandler._sigabrt()\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess()\n    result.stderr.fnmatch_lines([\"*Fatal Python error*\"])\n    assert result.ret != 0\n\n\ndef test_crash_near_exit(testdir):\n    \"\"\"Test that fault handler displays crashes that happen even after\n    pytest is exiting (for example, when the interpreter is shutting down).\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n    import faulthandler\n    import atexit\n    def test_ok():\n        atexit.register(faulthandler._sigabrt)\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess()\n    result.stderr.fnmatch_lines([\"*Fatal Python error*\"])\n    assert result.ret != 0\n\n\ndef test_disabled(testdir):\n    \"\"\"Test option to disable fault handler in the command line.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n    import faulthandler\n    def test_disabled():\n        assert not faulthandler.is_enabled()\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess(\"-p\", \"no:faulthandler\")\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_helpconfig.py_pytest_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_helpconfig.py_pytest_", "embedding": null, "metadata": {"file_path": "testing/test_helpconfig.py", "file_name": "test_helpconfig.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 75, "span_ids": ["imports", "test_PYTEST_DEBUG", "test_debug", "test_help", "test_hookvalidation_optional", "test_hookvalidation_unknown", "test_traceconfig", "test_version"], "tokens": 489}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\nfrom _pytest.config import ExitCode\n\n\ndef test_version(testdir, pytestconfig):\n    testdir.monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n    result = testdir.runpytest(\"--version\")\n    assert result.ret == 0\n    # p = py.path.local(py.__file__).dirpath()\n    result.stderr.fnmatch_lines(\n        [\"*pytest*{}*imported from*\".format(pytest.__version__)]\n    )\n    if pytestconfig.pluginmanager.list_plugin_distinfo():\n        result.stderr.fnmatch_lines([\"*setuptools registered plugins:\", \"*at*\"])\n\n\ndef test_help(testdir):\n    result = testdir.runpytest(\"--help\")\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *-v*verbose*\n        *setup.cfg*\n        *minversion*\n        *to see*markers*pytest --markers*\n        *to see*fixtures*pytest --fixtures*\n    \"\"\"\n    )\n\n\ndef test_hookvalidation_unknown(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_hello(xyz):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret != 0\n    result.stdout.fnmatch_lines([\"*unknown hook*pytest_hello*\"])\n\n\ndef test_hookvalidation_optional(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        @pytest.hookimpl(optionalhook=True)\n        def pytest_hello(xyz):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_traceconfig(testdir):\n    result = testdir.runpytest(\"--traceconfig\")\n    result.stdout.fnmatch_lines([\"*using*pytest*py*\", \"*active plugins*\"])\n\n\ndef test_debug(testdir):\n    result = testdir.runpytest_subprocess(\"--debug\")\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n    p = testdir.tmpdir.join(\"pytestdebug.log\")\n    assert \"pytest_sessionstart\" in p.read()\n\n\ndef test_PYTEST_DEBUG(testdir, monkeypatch):\n    monkeypatch.setenv(\"PYTEST_DEBUG\", \"1\")\n    result = testdir.runpytest_subprocess()\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n    result.stderr.fnmatch_lines(\n        [\"*pytest_plugin_registered*\", \"*manager*PluginManager*\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_os_assert_attr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_os_assert_attr", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 59, "span_ids": ["assert_attr", "imports", "run_and_parse", "schema"], "tokens": 409}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport platform\nfrom datetime import datetime\nfrom xml.dom import minidom\n\nimport py\nimport xmlschema\n\nimport pytest\nfrom _pytest.junitxml import bin_xml_escape\nfrom _pytest.junitxml import LogXML\nfrom _pytest.pathlib import Path\nfrom _pytest.reports import BaseReport\nfrom _pytest.store import Store\n\n\n@pytest.fixture(scope=\"session\")\ndef schema():\n    \"\"\"Returns a xmlschema.XMLSchema object for the junit-10.xsd file\"\"\"\n    fn = Path(__file__).parent / \"example_scripts/junit-10.xsd\"\n    with fn.open() as f:\n        return xmlschema.XMLSchema(f)\n\n\n@pytest.fixture\ndef run_and_parse(testdir, schema):\n    \"\"\"\n    Fixture that returns a function that can be used to execute pytest and return\n    the parsed ``DomNode`` of the root xml node.\n\n    The ``family`` parameter is used to configure the ``junit_family`` of the written report.\n    \"xunit2\" is also automatically validated against the schema.\n    \"\"\"\n\n    def run(*args, family=\"xunit1\"):\n        if family:\n            args = (\"-o\", \"junit_family=\" + family) + args\n        xml_path = testdir.tmpdir.join(\"junit.xml\")\n        result = testdir.runpytest(\"--junitxml=%s\" % xml_path, *args)\n        if family == \"xunit2\":\n            with xml_path.open() as f:\n                schema.validate(f)\n        xmldoc = minidom.parse(str(xml_path))\n        return result, DomNode(xmldoc)\n\n    return run\n\n\ndef assert_attr(node, **kwargs):\n    __tracebackhide__ = True\n\n    def nodeval(node, name):\n        anode = node.getAttributeNode(name)\n        if anode is not None:\n            return anode.value\n\n    expected = {name: str(value) for name, value in kwargs.items()}\n    on_node = {name: nodeval(node, name) for name in expected}\n    assert on_node == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_DomNode_parametrize_families": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_DomNode_parametrize_families", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 60, "end_line": 121, "span_ids": ["DomNode", "DomNode.__getitem__", "DomNode.__init__", "DomNode.__repr__", "DomNode._by_tag", "DomNode.assert_attr", "DomNode.children", "DomNode.find_by_tag", "DomNode.find_first_by_tag", "DomNode.find_nth_by_tag", "DomNode.get_unique_child", "DomNode.next_sibling", "DomNode.tag", "DomNode.text", "DomNode.toxml", "impl"], "tokens": 339}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class DomNode:\n    def __init__(self, dom):\n        self.__node = dom\n\n    def __repr__(self):\n        return self.__node.toxml()\n\n    def find_first_by_tag(self, tag):\n        return self.find_nth_by_tag(tag, 0)\n\n    def _by_tag(self, tag):\n        return self.__node.getElementsByTagName(tag)\n\n    @property\n    def children(self):\n        return [type(self)(x) for x in self.__node.childNodes]\n\n    @property\n    def get_unique_child(self):\n        children = self.children\n        assert len(children) == 1\n        return children[0]\n\n    def find_nth_by_tag(self, tag, n):\n        items = self._by_tag(tag)\n        try:\n            nth = items[n]\n        except IndexError:\n            pass\n        else:\n            return type(self)(nth)\n\n    def find_by_tag(self, tag):\n        t = type(self)\n        return [t(x) for x in self.__node.getElementsByTagName(tag)]\n\n    def __getitem__(self, key):\n        node = self.__node.getAttributeNode(key)\n        if node is not None:\n            return node.value\n\n    def assert_attr(self, **kwargs):\n        __tracebackhide__ = True\n        return assert_attr(self.__node, **kwargs)\n\n    def toxml(self):\n        return self.__node.toxml()\n\n    @property\n    def text(self):\n        return self.__node.childNodes[0].wholeText\n\n    @property\n    def tag(self):\n        return self.__node.tagName\n\n    @property\n    def next_sibling(self):\n        return type(self)(self.__node.nextSibling)\n\n\nparametrize_families = pytest.mark.parametrize(\"xunit_family\", [\"xunit1\", \"xunit2\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_xfailure_xpass_TestPython.test_assertion_binchars": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_xfailure_xpass_TestPython.test_assertion_binchars", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 616, "end_line": 694, "span_ids": ["TestPython.test_assertion_binchars", "TestPython.test_collect_error", "TestPython.test_unicode", "TestPython.test_xfailure_xpass", "TestPython.test_xfailure_xpass_strict"], "tokens": 657}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @parametrize_families\n    def test_xfailure_xpass(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test_xpass():\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        # assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(skipped=0, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_xfailure_xpass\", name=\"test_xpass\")\n\n    @parametrize_families\n    def test_xfailure_xpass_strict(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(strict=True, reason=\"This needs to fail!\")\n            def test_xpass():\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        # assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(skipped=0, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_xfailure_xpass_strict\", name=\"test_xpass\")\n        fnode = tnode.find_first_by_tag(\"failure\")\n        fnode.assert_attr(message=\"[XPASS(strict)] This needs to fail!\")\n\n    @parametrize_families\n    def test_collect_error(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\"syntax error\")\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(errors=1, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        fnode = tnode.find_first_by_tag(\"error\")\n        fnode.assert_attr(message=\"collection failure\")\n        assert \"SyntaxError\" in fnode.toxml()\n\n    def test_unicode(self, testdir, run_and_parse):\n        value = \"hx\\xc4\\x85\\xc4\\x87\\n\"\n        testdir.makepyfile(\n            \"\"\"\\\n            # coding: latin1\n            def test_hello():\n                print(%r)\n                assert 0\n            \"\"\"\n            % value\n        )\n        result, dom = run_and_parse()\n        assert result.ret == 1\n        tnode = dom.find_first_by_tag(\"testcase\")\n        fnode = tnode.find_first_by_tag(\"failure\")\n        assert \"hx\" in fnode.toxml()\n\n    def test_assertion_binchars(self, testdir, run_and_parse):\n        \"\"\"this test did fail when the escaping wasnt strict\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n\n            M1 = '\\x01\\x02\\x03\\x04'\n            M2 = '\\x01\\x02\\x03\\x05'\n\n            def test_str_compare():\n                assert M1 == M2\n            \"\"\"\n        )\n        result, dom = run_and_parse()\n        print(dom.toxml())", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_root_testsuites_tag_test_runs_twice_xdist": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_root_testsuites_tag_test_runs_twice_xdist", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1268, "end_line": 1310, "span_ids": ["test_root_testsuites_tag", "test_runs_twice", "test_runs_twice_xdist"], "tokens": 303}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@parametrize_families\ndef test_root_testsuites_tag(testdir, run_and_parse, xunit_family):\n    testdir.makepyfile(\n        \"\"\"\n        def test_x():\n            pass\n    \"\"\"\n    )\n    _, dom = run_and_parse(family=xunit_family)\n    root = dom.get_unique_child\n    assert root.tag == \"testsuites\"\n    suite_node = root.get_unique_child\n    assert suite_node.tag == \"testsuite\"\n\n\ndef test_runs_twice(testdir, run_and_parse):\n    f = testdir.makepyfile(\n        \"\"\"\n        def test_pass():\n            pass\n    \"\"\"\n    )\n\n    result, dom = run_and_parse(f, f)\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR*\")\n    first, second = [x[\"classname\"] for x in dom.find_by_tag(\"testcase\")]\n    assert first == second\n\n\ndef test_runs_twice_xdist(testdir, run_and_parse):\n    pytest.importorskip(\"xdist\")\n    testdir.monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n    f = testdir.makepyfile(\n        \"\"\"\n        def test_pass():\n            pass\n    \"\"\"\n    )\n\n    result, dom = run_and_parse(f, \"--dist\", \"each\", \"--tx\", \"2*popen\")\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR*\")\n    first, second = [x[\"classname\"] for x in dom.find_by_tag(\"testcase\")]\n    assert first == second", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_global_properties_test_global_properties.assert_actual_expected": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_global_properties_test_global_properties.assert_actual_expected", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1291, "end_line": 1323, "span_ids": ["test_global_properties"], "tokens": 201}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@parametrize_families\ndef test_global_properties(testdir, xunit_family):\n    path = testdir.tmpdir.join(\"test_global_properties.xml\")\n    log = LogXML(str(path), None, family=xunit_family)\n\n    class Report(BaseReport):\n        sections = []\n        nodeid = \"test_node_id\"\n\n    log.pytest_sessionstart()\n    log.add_global_property(\"foo\", 1)\n    log.add_global_property(\"bar\", 2)\n    log.pytest_sessionfinish()\n\n    dom = minidom.parse(str(path))\n\n    properties = dom.getElementsByTagName(\"properties\")\n\n    assert properties.length == 1, \"There must be one <properties> node\"\n\n    property_list = dom.getElementsByTagName(\"property\")\n\n    assert property_list.length == 2, \"There most be only 2 property nodes\"\n\n    expected = {\"foo\": \"1\", \"bar\": \"2\"}\n    actual = {}\n\n    for p in property_list:\n        k = str(p.getAttribute(\"name\"))\n        v = str(p.getAttribute(\"value\"))\n        actual[k] = v\n\n    assert actual == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_url_property_test_set_suite_name.node_assert_attr_name_exp": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_url_property_test_set_suite_name.node_assert_attr_name_exp", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1326, "end_line": 1427, "span_ids": ["test_record_testsuite_property", "test_record_testsuite_property_junit_disabled", "test_record_testsuite_property_type_checking", "test_set_suite_name", "test_url_property"], "tokens": 715}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_url_property(testdir):\n    test_url = \"http://www.github.com/pytest-dev\"\n    path = testdir.tmpdir.join(\"test_url_property.xml\")\n    log = LogXML(str(path), None)\n\n    class Report(BaseReport):\n        longrepr = \"FooBarBaz\"\n        sections = []\n        nodeid = \"something\"\n        location = \"tests/filename.py\", 42, \"TestClass.method\"\n        url = test_url\n\n    test_report = Report()\n\n    log.pytest_sessionstart()\n    node_reporter = log._opentestcase(test_report)\n    node_reporter.append_failure(test_report)\n    log.pytest_sessionfinish()\n\n    test_case = minidom.parse(str(path)).getElementsByTagName(\"testcase\")[0]\n\n    assert (\n        test_case.getAttribute(\"url\") == test_url\n    ), \"The URL did not get written to the xml\"\n\n\n@parametrize_families\ndef test_record_testsuite_property(testdir, run_and_parse, xunit_family):\n    testdir.makepyfile(\n        \"\"\"\n        def test_func1(record_testsuite_property):\n            record_testsuite_property(\"stats\", \"all good\")\n\n        def test_func2(record_testsuite_property):\n            record_testsuite_property(\"stats\", 10)\n    \"\"\"\n    )\n    result, dom = run_and_parse(family=xunit_family)\n    assert result.ret == 0\n    node = dom.find_first_by_tag(\"testsuite\")\n    properties_node = node.find_first_by_tag(\"properties\")\n    p1_node = properties_node.find_nth_by_tag(\"property\", 0)\n    p2_node = properties_node.find_nth_by_tag(\"property\", 1)\n    p1_node.assert_attr(name=\"stats\", value=\"all good\")\n    p2_node.assert_attr(name=\"stats\", value=\"10\")\n\n\ndef test_record_testsuite_property_junit_disabled(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_func1(record_testsuite_property):\n            record_testsuite_property(\"stats\", \"all good\")\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 0\n\n\n@pytest.mark.parametrize(\"junit\", [True, False])\ndef test_record_testsuite_property_type_checking(testdir, junit):\n    testdir.makepyfile(\n        \"\"\"\n        def test_func1(record_testsuite_property):\n            record_testsuite_property(1, 2)\n    \"\"\"\n    )\n    args = (\"--junitxml=tests.xml\",) if junit else ()\n    result = testdir.runpytest(*args)\n    assert result.ret == 1\n    result.stdout.fnmatch_lines(\n        [\"*TypeError: name parameter needs to be a string, but int given\"]\n    )\n\n\n@pytest.mark.parametrize(\"suite_name\", [\"my_suite\", \"\"])\n@parametrize_families\ndef test_set_suite_name(testdir, suite_name, run_and_parse, xunit_family):\n    if suite_name:\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            junit_suite_name={suite_name}\n            junit_family={family}\n        \"\"\".format(\n                suite_name=suite_name, family=xunit_family\n            )\n        )\n        expected = suite_name\n    else:\n        expected = \"pytest\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        def test_func():\n            pass\n    \"\"\"\n    )\n    result, dom = run_and_parse(family=xunit_family)\n    assert result.ret == 0\n    node = dom.find_first_by_tag(\"testsuite\")\n    node.assert_attr(name=expected)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_os_test_ini_markers_whitespace": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_os_test_ini_markers_whitespace", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 119, "span_ids": ["TestMark", "TestMark.test_mark_with_param", "TestMark.test_pytest_exists_in_namespace_all", "TestMark.test_pytest_mark_name_starts_with_underscore", "TestMark.test_pytest_mark_notcallable", "imports", "test_ini_markers", "test_ini_markers_whitespace", "test_marked_class_run_twice", "test_markers_option"], "tokens": 700}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport sys\nfrom unittest import mock\n\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.mark import EMPTY_PARAMETERSET_OPTION\nfrom _pytest.mark import MarkGenerator as Mark\nfrom _pytest.nodes import Collector\nfrom _pytest.nodes import Node\n\n\nclass TestMark:\n    @pytest.mark.parametrize(\"attr\", [\"mark\", \"param\"])\n    @pytest.mark.parametrize(\"modulename\", [\"py.test\", \"pytest\"])\n    def test_pytest_exists_in_namespace_all(self, attr, modulename):\n        module = sys.modules[modulename]\n        assert attr in module.__all__\n\n    def test_pytest_mark_notcallable(self):\n        mark = Mark()\n        with pytest.raises(TypeError):\n            mark()\n\n    def test_mark_with_param(self):\n        def some_function(abc):\n            pass\n\n        class SomeClass:\n            pass\n\n        assert pytest.mark.foo(some_function) is some_function\n        assert pytest.mark.foo.with_args(some_function) is not some_function\n\n        assert pytest.mark.foo(SomeClass) is SomeClass\n        assert pytest.mark.foo.with_args(SomeClass) is not SomeClass\n\n    def test_pytest_mark_name_starts_with_underscore(self):\n        mark = Mark()\n        with pytest.raises(AttributeError):\n            mark._some_name\n\n\ndef test_marked_class_run_twice(testdir):\n    \"\"\"Test fails file is run twice that contains marked class.\n    See issue#683.\n    \"\"\"\n    py_file = testdir.makepyfile(\n        \"\"\"\n    import pytest\n    @pytest.mark.parametrize('abc', [1, 2, 3])\n    class Test1(object):\n        def test_1(self, abc):\n            assert abc in [1, 2, 3]\n    \"\"\"\n    )\n    file_name = os.path.basename(py_file.strpath)\n    rec = testdir.inline_run(file_name, file_name)\n    rec.assertoutcome(passed=6)\n\n\ndef test_ini_markers(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        markers =\n            a1: this is a webtest marker\n            a2: this is a smoke marker\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        def test_markers(pytestconfig):\n            markers = pytestconfig.getini(\"markers\")\n            print(markers)\n            assert len(markers) >= 2\n            assert markers[0].startswith(\"a1:\")\n            assert markers[1].startswith(\"a2:\")\n    \"\"\"\n    )\n    rec = testdir.inline_run()\n    rec.assertoutcome(passed=1)\n\n\ndef test_markers_option(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        markers =\n            a1: this is a webtest marker\n            a1some: another marker\n            nodescription\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--markers\")\n    result.stdout.fnmatch_lines(\n        [\"*a1*this is a webtest*\", \"*a1some*another marker\", \"*nodescription*\"]\n    )\n\n\ndef test_ini_markers_whitespace(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        markers =\n            a1 : this is a whitespace marker\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.mark.a1\n        def test_markers():\n            assert True\n    \"\"\"\n    )\n    rec = testdir.inline_run(\"--strict-markers\", \"-m\", \"a1\")\n    rec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parametrized_collected_from_command_line_test_parametrize_iterator": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parametrized_collected_from_command_line_test_parametrize_iterator", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 340, "end_line": 419, "span_ids": ["test_parametrize_iterator", "test_parametrized_collect_with_wrong_args", "test_parametrized_collected_from_command_line", "test_parametrized_with_kwargs"], "tokens": 518}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_parametrized_collected_from_command_line(testdir):\n    \"\"\"Parametrized test not collected if test named specified\n       in command line issue#649.\n    \"\"\"\n    py_file = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.parametrize(\"arg\", [None, 1.3, \"2-3\"])\n        def test_func(arg):\n            pass\n    \"\"\"\n    )\n    file_name = os.path.basename(py_file.strpath)\n    rec = testdir.inline_run(file_name + \"::\" + \"test_func\")\n    rec.assertoutcome(passed=3)\n\n\ndef test_parametrized_collect_with_wrong_args(testdir):\n    \"\"\"Test collect parametrized func with wrong number of args.\"\"\"\n    py_file = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.mark.parametrize('foo, bar', [(1, 2, 3)])\n        def test_func(foo, bar):\n            pass\n    \"\"\"\n    )\n\n    result = testdir.runpytest(py_file)\n    result.stdout.fnmatch_lines(\n        [\n            'test_parametrized_collect_with_wrong_args.py::test_func: in \"parametrize\" the number of names (2):',\n            \"  ['foo', 'bar']\",\n            \"must be equal to the number of values (3):\",\n            \"  (1, 2, 3)\",\n        ]\n    )\n\n\ndef test_parametrized_with_kwargs(testdir):\n    \"\"\"Test collect parametrized func with wrong number of args.\"\"\"\n    py_file = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture(params=[1,2])\n        def a(request):\n            return request.param\n\n        @pytest.mark.parametrize(argnames='b', argvalues=[1, 2])\n        def test_func(a, b):\n            pass\n    \"\"\"\n    )\n\n    result = testdir.runpytest(py_file)\n    assert result.ret == 0\n\n\ndef test_parametrize_iterator(testdir):\n    \"\"\"parametrize should work with generators (#5354).\"\"\"\n    py_file = testdir.makepyfile(\n        \"\"\"\\\n        import pytest\n\n        def gen():\n            yield 1\n            yield 2\n            yield 3\n\n        @pytest.mark.parametrize('a', gen())\n        def test(a):\n            assert a >= 1\n        \"\"\"\n    )\n    result = testdir.runpytest(py_file)\n    assert result.ret == 0\n    # should not skip any tests\n    result.stdout.fnmatch_lines([\"*3 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parameterset_for_fail_at_collect_test_parameterset_for_fail_at_collect.assert_result_ret_Exit": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parameterset_for_fail_at_collect_test_parameterset_for_fail_at_collect.assert_result_ret_Exit", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 884, "end_line": 923, "span_ids": ["test_parameterset_for_fail_at_collect"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_parameterset_for_fail_at_collect(testdir):\n    testdir.makeini(\n        \"\"\"\n    [pytest]\n    {}=fail_at_collect\n    \"\"\".format(\n            EMPTY_PARAMETERSET_OPTION\n        )\n    )\n\n    config = testdir.parseconfig()\n    from _pytest.mark import pytest_configure, get_empty_parameterset_mark\n\n    pytest_configure(config)\n\n    with pytest.raises(\n        Collector.CollectError,\n        match=r\"Empty parameter set in 'pytest_configure' at line \\d\\d+\",\n    ):\n        get_empty_parameterset_mark(config, [\"a\"], pytest_configure)\n\n    p1 = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.mark.parametrize(\"empty\", [])\n        def test():\n            pass\n        \"\"\"\n    )\n    result = testdir.runpytest(str(p1))\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 0 items / 1 error\",\n            \"* ERROR collecting test_parameterset_for_fail_at_collect.py *\",\n            \"Empty parameter set in 'test' at line 3\",\n            \"*= 1 error in *\",\n        ]\n    )\n    assert result.ret == ExitCode.INTERRUPTED", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_os_test_setattr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_os_test_setattr", "embedding": null, "metadata": {"file_path": "testing/test_monkeypatch.py", "file_name": "test_monkeypatch.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 44, "span_ids": ["imports", "mp", "test_setattr"], "tokens": 247}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport re\nimport sys\nimport textwrap\n\nimport pytest\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.monkeypatch import MonkeyPatch\n\nif TYPE_CHECKING:\n    from typing import Type\n\n\n@pytest.fixture\ndef mp():\n    cwd = os.getcwd()\n    sys_path = list(sys.path)\n    yield MonkeyPatch()\n    sys.path[:] = sys_path\n    os.chdir(cwd)\n\n\ndef test_setattr():\n    class A:\n        x = 1\n\n    monkeypatch = MonkeyPatch()\n    pytest.raises(AttributeError, monkeypatch.setattr, A, \"notexists\", 2)\n    monkeypatch.setattr(A, \"y\", 2, raising=False)\n    assert A.y == 2\n    monkeypatch.undo()\n    assert not hasattr(A, \"y\")\n\n    monkeypatch = MonkeyPatch()\n    monkeypatch.setattr(A, \"x\", 2)\n    assert A.x == 2\n    monkeypatch.setattr(A, \"x\", 3)\n    assert A.x == 3\n    monkeypatch.undo()\n    assert A.x == 1\n\n    A.x = 5\n    monkeypatch.undo()  # double-undo makes no modification\n    assert A.x == 5", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_delenv_test_chdir_undo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_delenv_test_chdir_undo", "embedding": null, "metadata": {"file_path": "testing/test_monkeypatch.py", "file_name": "test_monkeypatch.py", "file_type": "text/x-python", "category": "test", "start_line": 175, "end_line": 278, "span_ids": ["TestEnvironWarnings", "TestEnvironWarnings.test_setenv_non_str_warning", "test_chdir_undo", "test_chdir_with_path_local", "test_chdir_with_str", "test_delenv", "test_monkeypatch_plugin", "test_setenv_prepend", "test_syspath_prepend", "test_syspath_prepend_double_undo"], "tokens": 725}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_delenv():\n    name = \"xyz1234\"\n    assert name not in os.environ\n    monkeypatch = MonkeyPatch()\n    pytest.raises(KeyError, monkeypatch.delenv, name, raising=True)\n    monkeypatch.delenv(name, raising=False)\n    monkeypatch.undo()\n    os.environ[name] = \"1\"\n    try:\n        monkeypatch = MonkeyPatch()\n        monkeypatch.delenv(name)\n        assert name not in os.environ\n        monkeypatch.setenv(name, \"3\")\n        assert os.environ[name] == \"3\"\n        monkeypatch.undo()\n        assert os.environ[name] == \"1\"\n    finally:\n        if name in os.environ:\n            del os.environ[name]\n\n\nclass TestEnvironWarnings:\n    \"\"\"\n    os.environ keys and values should be native strings, otherwise it will cause problems with other modules (notably\n    subprocess). On Python 2 os.environ accepts anything without complaining, while Python 3 does the right thing\n    and raises an error.\n    \"\"\"\n\n    VAR_NAME = \"PYTEST_INTERNAL_MY_VAR\"\n\n    def test_setenv_non_str_warning(self, monkeypatch):\n        value = 2\n        msg = (\n            \"Value of environment variable PYTEST_INTERNAL_MY_VAR type should be str, \"\n            \"but got 2 (type: int); converted to str implicitly\"\n        )\n        with pytest.warns(pytest.PytestWarning, match=re.escape(msg)):\n            monkeypatch.setenv(str(self.VAR_NAME), value)\n\n\ndef test_setenv_prepend():\n    import os\n\n    monkeypatch = MonkeyPatch()\n    with pytest.warns(pytest.PytestWarning):\n        monkeypatch.setenv(\"XYZ123\", 2, prepend=\"-\")\n    assert os.environ[\"XYZ123\"] == \"2\"\n    with pytest.warns(pytest.PytestWarning):\n        monkeypatch.setenv(\"XYZ123\", 3, prepend=\"-\")\n    assert os.environ[\"XYZ123\"] == \"3-2\"\n    monkeypatch.undo()\n    assert \"XYZ123\" not in os.environ\n\n\ndef test_monkeypatch_plugin(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        def test_method(monkeypatch):\n            assert monkeypatch.__class__.__name__ == \"MonkeyPatch\"\n    \"\"\"\n    )\n    res = reprec.countoutcomes()\n    assert tuple(res) == (1, 0, 0), res\n\n\ndef test_syspath_prepend(mp):\n    old = list(sys.path)\n    mp.syspath_prepend(\"world\")\n    mp.syspath_prepend(\"hello\")\n    assert sys.path[0] == \"hello\"\n    assert sys.path[1] == \"world\"\n    mp.undo()\n    assert sys.path == old\n    mp.undo()\n    assert sys.path == old\n\n\ndef test_syspath_prepend_double_undo(mp):\n    old_syspath = sys.path[:]\n    try:\n        mp.syspath_prepend(\"hello world\")\n        mp.undo()\n        sys.path.append(\"more hello world\")\n        mp.undo()\n        assert sys.path[-1] == \"more hello world\"\n    finally:\n        sys.path[:] = old_syspath\n\n\ndef test_chdir_with_path_local(mp, tmpdir):\n    mp.chdir(tmpdir)\n    assert os.getcwd() == tmpdir.strpath\n\n\ndef test_chdir_with_str(mp, tmpdir):\n    mp.chdir(tmpdir.strpath)\n    assert os.getcwd() == tmpdir.strpath\n\n\ndef test_chdir_undo(mp, tmpdir):\n    cwd = os.getcwd()\n    mp.chdir(tmpdir)\n    mp.undo()\n    assert os.getcwd() == cwd", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_chdir_double_undo_test_context": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_monkeypatch.py_test_chdir_double_undo_test_context", "embedding": null, "metadata": {"file_path": "testing/test_monkeypatch.py", "file_name": "test_monkeypatch.py", "file_type": "text/x-python", "category": "test", "start_line": 285, "end_line": 406, "span_ids": ["Sample", "Sample.hello", "SampleInherit", "test_chdir_double_undo", "test_context", "test_importerror", "test_issue1338_name_resolving", "test_issue156_undo_staticmethod", "test_issue185_time_breaks", "test_undo_class_descriptors_delattr"], "tokens": 633}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_chdir_double_undo(mp, tmpdir):\n    mp.chdir(tmpdir.strpath)\n    mp.undo()\n    tmpdir.chdir()\n    mp.undo()\n    assert os.getcwd() == tmpdir.strpath\n\n\ndef test_issue185_time_breaks(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import time\n        def test_m(monkeypatch):\n            def f():\n                raise Exception\n            monkeypatch.setattr(time, \"time\", f)\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *1 passed*\n    \"\"\"\n    )\n\n\ndef test_importerror(testdir):\n    p = testdir.mkpydir(\"package\")\n    p.join(\"a.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n        import doesnotexist\n\n        x = 1\n    \"\"\"\n        )\n    )\n    testdir.tmpdir.join(\"test_importerror.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n        def test_importerror(monkeypatch):\n            monkeypatch.setattr('package.a.x', 2)\n    \"\"\"\n        )\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *import error in package.a: No module named 'doesnotexist'*\n    \"\"\"\n    )\n\n\nclass Sample:\n    @staticmethod\n    def hello() -> bool:\n        return True\n\n\nclass SampleInherit(Sample):\n    pass\n\n\n@pytest.mark.parametrize(\n    \"Sample\", [Sample, SampleInherit], ids=[\"new\", \"new-inherit\"],\n)\ndef test_issue156_undo_staticmethod(Sample: \"Type[Sample]\") -> None:\n    monkeypatch = MonkeyPatch()\n\n    monkeypatch.setattr(Sample, \"hello\", None)\n    assert Sample.hello is None\n\n    monkeypatch.undo()\n    assert Sample.hello()\n\n\ndef test_undo_class_descriptors_delattr():\n    class SampleParent:\n        @classmethod\n        def hello(_cls):\n            pass\n\n        @staticmethod\n        def world():\n            pass\n\n    class SampleChild(SampleParent):\n        pass\n\n    monkeypatch = MonkeyPatch()\n\n    original_hello = SampleChild.hello\n    original_world = SampleChild.world\n    monkeypatch.delattr(SampleParent, \"hello\")\n    monkeypatch.delattr(SampleParent, \"world\")\n    assert getattr(SampleParent, \"hello\", None) is None\n    assert getattr(SampleParent, \"world\", None) is None\n\n    monkeypatch.undo()\n    assert original_hello == SampleChild.hello\n    assert original_world == SampleChild.world\n\n\ndef test_issue1338_name_resolving():\n    pytest.importorskip(\"requests\")\n    monkeypatch = MonkeyPatch()\n    try:\n        monkeypatch.delattr(\"requests.sessions.Session.request\")\n    finally:\n        monkeypatch.undo()\n\n\ndef test_context():\n    monkeypatch = MonkeyPatch()\n\n    import functools\n    import inspect\n\n    with monkeypatch.context() as m:\n        m.setattr(functools, \"partial\", 3)\n        assert not inspect.isclass(functools.partial)\n    assert inspect.isclass(functools.partial)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nodes.py_py_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nodes.py_py_", "embedding": null, "metadata": {"file_path": "testing/test_nodes.py", "file_name": "test_nodes.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 61, "span_ids": ["imports", "test__check_initialpaths_for_relpath", "test_ischildnode", "test_node_from_parent_disallowed_arguments", "test_std_warn_not_pytestwarning"], "tokens": 395}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import py\n\nimport pytest\nfrom _pytest import nodes\n\n\n@pytest.mark.parametrize(\n    \"baseid, nodeid, expected\",\n    (\n        (\"\", \"\", True),\n        (\"\", \"foo\", True),\n        (\"\", \"foo/bar\", True),\n        (\"\", \"foo/bar::TestBaz\", True),\n        (\"foo\", \"food\", False),\n        (\"foo/bar::TestBaz\", \"foo/bar\", False),\n        (\"foo/bar::TestBaz\", \"foo/bar::TestBop\", False),\n        (\"foo/bar\", \"foo/bar::TestBop\", True),\n    ),\n)\ndef test_ischildnode(baseid, nodeid, expected):\n    result = nodes.ischildnode(baseid, nodeid)\n    assert result is expected\n\n\ndef test_node_from_parent_disallowed_arguments():\n    with pytest.raises(TypeError, match=\"session is\"):\n        nodes.Node.from_parent(None, session=None)\n    with pytest.raises(TypeError, match=\"config is\"):\n        nodes.Node.from_parent(None, config=None)\n\n\ndef test_std_warn_not_pytestwarning(testdir):\n    items = testdir.getitems(\n        \"\"\"\n        def test():\n            pass\n    \"\"\"\n    )\n    with pytest.raises(ValueError, match=\".*instance of PytestWarning.*\"):\n        items[0].warn(UserWarning(\"some warning\"))\n\n\ndef test__check_initialpaths_for_relpath():\n    \"\"\"Ensure that it handles dirs, and does not always use dirname.\"\"\"\n    cwd = py.path.local()\n\n    class FakeSession:\n        _initialpaths = [cwd]\n\n    assert nodes._check_initialpaths_for_relpath(FakeSession, cwd) == \"\"\n\n    sub = cwd.join(\"file\")\n\n    class FakeSession:\n        _initialpaths = [cwd]\n\n    assert nodes._check_initialpaths_for_relpath(FakeSession, sub) == \"file\"\n\n    outside = py.path.local(\"/outside\")\n    assert nodes._check_initialpaths_for_relpath(FakeSession, outside) is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_pytest_test_nose_setup_func_failure_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_pytest_test_nose_setup_func_failure_2", "embedding": null, "metadata": {"file_path": "testing/test_nose.py", "file_name": "test_nose.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 122, "span_ids": ["imports", "setup_module", "test_nose_setup", "test_nose_setup_func", "test_nose_setup_func_failure", "test_nose_setup_func_failure_2", "test_setup_func_not_callable", "test_setup_func_with_setup_decorator"], "tokens": 605}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\ndef setup_module(mod):\n    mod.nose = pytest.importorskip(\"nose\")\n\n\ndef test_nose_setup(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        values = []\n        from nose.tools import with_setup\n\n        @with_setup(lambda: values.append(1), lambda: values.append(2))\n        def test_hello():\n            assert values == [1]\n\n        def test_world():\n            assert values == [1,2]\n\n        test_hello.setup = lambda: values.append(1)\n        test_hello.teardown = lambda: values.append(2)\n    \"\"\"\n    )\n    result = testdir.runpytest(p, \"-p\", \"nose\")\n    result.assert_outcomes(passed=2)\n\n\ndef test_setup_func_with_setup_decorator():\n    from _pytest.nose import call_optional\n\n    values = []\n\n    class A:\n        @pytest.fixture(autouse=True)\n        def f(self):\n            values.append(1)\n\n    call_optional(A(), \"f\")\n    assert not values\n\n\ndef test_setup_func_not_callable():\n    from _pytest.nose import call_optional\n\n    class A:\n        f = 1\n\n    call_optional(A(), \"f\")\n\n\ndef test_nose_setup_func(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        from nose.tools import with_setup\n\n        values = []\n\n        def my_setup():\n            a = 1\n            values.append(a)\n\n        def my_teardown():\n            b = 2\n            values.append(b)\n\n        @with_setup(my_setup, my_teardown)\n        def test_hello():\n            print(values)\n            assert values == [1]\n\n        def test_world():\n            print(values)\n            assert values == [1,2]\n\n    \"\"\"\n    )\n    result = testdir.runpytest(p, \"-p\", \"nose\")\n    result.assert_outcomes(passed=2)\n\n\ndef test_nose_setup_func_failure(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        from nose.tools import with_setup\n\n        values = []\n        my_setup = lambda x: 1\n        my_teardown = lambda x: 2\n\n        @with_setup(my_setup, my_teardown)\n        def test_hello():\n            print(values)\n            assert values == [1]\n\n        def test_world():\n            print(values)\n            assert values == [1,2]\n\n    \"\"\"\n    )\n    result = testdir.runpytest(p, \"-p\", \"nose\")\n    result.stdout.fnmatch_lines([\"*TypeError: <lambda>()*\"])\n\n\ndef test_nose_setup_func_failure_2(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        values = []\n\n        my_setup = 1\n        my_teardown = 2\n\n        def test_hello():\n            assert values == []\n\n        test_hello.setup = my_setup\n        test_hello.teardown = my_teardown\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_argparse_TestParser.test_group_addoption": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_parseopt.py_argparse_TestParser.test_group_addoption", "embedding": null, "metadata": {"file_path": "testing/test_parseopt.py", "file_name": "test_parseopt.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 95, "span_ids": ["TestParser", "TestParser.test_argument", "TestParser.test_argument_processopt", "TestParser.test_argument_type", "TestParser.test_custom_prog", "TestParser.test_getgroup_simple", "TestParser.test_group_add_and_get", "TestParser.test_group_addoption", "TestParser.test_group_ordering", "TestParser.test_no_help_by_default", "imports", "parser"], "tokens": 768}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import argparse\nimport os\nimport shlex\nimport shutil\nimport sys\n\nimport py\n\nimport pytest\nfrom _pytest.config import argparsing as parseopt\nfrom _pytest.config.exceptions import UsageError\n\n\n@pytest.fixture\ndef parser() -> parseopt.Parser:\n    return parseopt.Parser()\n\n\nclass TestParser:\n    def test_no_help_by_default(self) -> None:\n        parser = parseopt.Parser(usage=\"xyz\")\n        pytest.raises(UsageError, lambda: parser.parse([\"-h\"]))\n\n    def test_custom_prog(self, parser: parseopt.Parser) -> None:\n        \"\"\"Custom prog can be set for `argparse.ArgumentParser`.\"\"\"\n        assert parser._getparser().prog == os.path.basename(sys.argv[0])\n        parser.prog = \"custom-prog\"\n        assert parser._getparser().prog == \"custom-prog\"\n\n    def test_argument(self) -> None:\n        with pytest.raises(parseopt.ArgumentError):\n            # need a short or long option\n            argument = parseopt.Argument()\n        argument = parseopt.Argument(\"-t\")\n        assert argument._short_opts == [\"-t\"]\n        assert argument._long_opts == []\n        assert argument.dest == \"t\"\n        argument = parseopt.Argument(\"-t\", \"--test\")\n        assert argument._short_opts == [\"-t\"]\n        assert argument._long_opts == [\"--test\"]\n        assert argument.dest == \"test\"\n        argument = parseopt.Argument(\"-t\", \"--test\", dest=\"abc\")\n        assert argument.dest == \"abc\"\n        assert str(argument) == (\n            \"Argument(_short_opts: ['-t'], _long_opts: ['--test'], dest: 'abc')\"\n        )\n\n    def test_argument_type(self) -> None:\n        argument = parseopt.Argument(\"-t\", dest=\"abc\", type=int)\n        assert argument.type is int\n        argument = parseopt.Argument(\"-t\", dest=\"abc\", type=str)\n        assert argument.type is str\n        argument = parseopt.Argument(\"-t\", dest=\"abc\", type=float)\n        assert argument.type is float\n        with pytest.warns(DeprecationWarning):\n            with pytest.raises(KeyError):\n                argument = parseopt.Argument(\"-t\", dest=\"abc\", type=\"choice\")\n        argument = parseopt.Argument(\n            \"-t\", dest=\"abc\", type=str, choices=[\"red\", \"blue\"]\n        )\n        assert argument.type is str\n\n    def test_argument_processopt(self) -> None:\n        argument = parseopt.Argument(\"-t\", type=int)\n        argument.default = 42\n        argument.dest = \"abc\"\n        res = argument.attrs()\n        assert res[\"default\"] == 42\n        assert res[\"dest\"] == \"abc\"\n\n    def test_group_add_and_get(self, parser: parseopt.Parser) -> None:\n        group = parser.getgroup(\"hello\", description=\"desc\")\n        assert group.name == \"hello\"\n        assert group.description == \"desc\"\n\n    def test_getgroup_simple(self, parser: parseopt.Parser) -> None:\n        group = parser.getgroup(\"hello\", description=\"desc\")\n        assert group.name == \"hello\"\n        assert group.description == \"desc\"\n        group2 = parser.getgroup(\"hello\")\n        assert group2 is group\n\n    def test_group_ordering(self, parser: parseopt.Parser) -> None:\n        parser.getgroup(\"1\")\n        parser.getgroup(\"2\")\n        parser.getgroup(\"3\", after=\"1\")\n        groups = parser._groups\n        groups_names = [x.name for x in groups]\n        assert groups_names == list(\"132\")\n\n    def test_group_addoption(self) -> None:\n        group = parseopt.OptionGroup(\"hello\")\n        group.addoption(\"--option1\", action=\"store_true\")\n        assert len(group.options) == 1\n        assert isinstance(group.options[0], parseopt.Argument)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pastebin.py_pytest_TestPasteCapture.test_non_ascii_paste_text": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pastebin.py_pytest_TestPasteCapture.test_non_ascii_paste_text", "embedding": null, "metadata": {"file_path": "testing/test_pastebin.py", "file_name": "test_pastebin.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 77, "span_ids": ["TestPasteCapture", "TestPasteCapture.pastebinlist", "TestPasteCapture.test_all", "TestPasteCapture.test_failed", "TestPasteCapture.test_non_ascii_paste_text", "imports"], "tokens": 522}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\nclass TestPasteCapture:\n    @pytest.fixture\n    def pastebinlist(self, monkeypatch, request):\n        pastebinlist = []\n        plugin = request.config.pluginmanager.getplugin(\"pastebin\")\n        monkeypatch.setattr(plugin, \"create_new_paste\", pastebinlist.append)\n        return pastebinlist\n\n    def test_failed(self, testdir, pastebinlist):\n        testpath = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_pass():\n                pass\n            def test_fail():\n                assert 0\n            def test_skip():\n                pytest.skip(\"\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run(testpath, \"--pastebin=failed\")\n        assert len(pastebinlist) == 1\n        s = pastebinlist[0]\n        assert s.find(\"def test_fail\") != -1\n        assert reprec.countoutcomes() == [1, 1, 1]\n\n    def test_all(self, testdir, pastebinlist):\n        from _pytest.pytester import LineMatcher\n\n        testpath = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_pass():\n                pass\n            def test_fail():\n                assert 0\n            def test_skip():\n                pytest.skip(\"\")\n        \"\"\"\n        )\n        reprec = testdir.inline_run(testpath, \"--pastebin=all\", \"-v\")\n        assert reprec.countoutcomes() == [1, 1, 1]\n        assert len(pastebinlist) == 1\n        contents = pastebinlist[0].decode(\"utf-8\")\n        matcher = LineMatcher(contents.splitlines())\n        matcher.fnmatch_lines(\n            [\n                \"*test_pass PASSED*\",\n                \"*test_fail FAILED*\",\n                \"*test_skip SKIPPED*\",\n                \"*== 1 failed, 1 passed, 1 skipped in *\",\n            ]\n        )\n\n    def test_non_ascii_paste_text(self, testdir, pastebinlist):\n        \"\"\"Make sure that text which contains non-ascii characters is pasted\n        correctly. See #1219.\n        \"\"\"\n        testdir.makepyfile(\n            test_unicode=\"\"\"\\\n            def test():\n                assert '\u263a' == 1\n            \"\"\"\n        )\n        result = testdir.runpytest(\"--pastebin=all\")\n        expected_msg = \"*assert '\u263a' == 1*\"\n        result.stdout.fnmatch_lines(\n            [\n                expected_msg,\n                \"*== 1 failed in *\",\n                \"*Sending information to Paste Service*\",\n            ]\n        )\n        assert len(pastebinlist) == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pathlib.py_os.path_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pathlib.py_os.path_", "embedding": null, "metadata": {"file_path": "testing/test_pathlib.py", "file_name": "test_pathlib.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 92, "span_ids": ["TestPort", "TestPort.match", "TestPort.test_matching", "TestPort.test_matching_abspath", "TestPort.test_not_matching", "TestPort:3", "imports", "test_access_denied_during_cleanup"], "tokens": 683}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os.path\nimport sys\n\nimport py\n\nimport pytest\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import get_lock_path\nfrom _pytest.pathlib import maybe_delete_a_numbered_dir\nfrom _pytest.pathlib import Path\n\n\nclass TestPort:\n    \"\"\"Test that our port of py.common.FNMatcher (fnmatch_ex) produces the same results as the\n    original py.path.local.fnmatch method.\n    \"\"\"\n\n    @pytest.fixture(params=[\"pathlib\", \"py.path\"])\n    def match(self, request):\n        if request.param == \"py.path\":\n\n            def match_(pattern, path):\n                return py.path.local(path).fnmatch(pattern)\n\n        else:\n            assert request.param == \"pathlib\"\n\n            def match_(pattern, path):\n                return fnmatch_ex(pattern, path)\n\n        return match_\n\n    if sys.platform == \"win32\":\n        drv1 = \"c:\"\n        drv2 = \"d:\"\n    else:\n        drv1 = \"/c\"\n        drv2 = \"/d\"\n\n    @pytest.mark.parametrize(\n        \"pattern, path\",\n        [\n            (\"*.py\", \"foo.py\"),\n            (\"*.py\", \"bar/foo.py\"),\n            (\"test_*.py\", \"foo/test_foo.py\"),\n            (\"tests/*.py\", \"tests/foo.py\"),\n            (drv1 + \"/*.py\", drv1 + \"/foo.py\"),\n            (drv1 + \"/foo/*.py\", drv1 + \"/foo/foo.py\"),\n            (\"tests/**/test*.py\", \"tests/foo/test_foo.py\"),\n            (\"tests/**/doc/test*.py\", \"tests/foo/bar/doc/test_foo.py\"),\n            (\"tests/**/doc/**/test*.py\", \"tests/foo/doc/bar/test_foo.py\"),\n        ],\n    )\n    def test_matching(self, match, pattern, path):\n        assert match(pattern, path)\n\n    def test_matching_abspath(self, match):\n        abspath = os.path.abspath(os.path.join(\"tests/foo.py\"))\n        assert match(\"tests/foo.py\", abspath)\n\n    @pytest.mark.parametrize(\n        \"pattern, path\",\n        [\n            (\"*.py\", \"foo.pyc\"),\n            (\"*.py\", \"foo/foo.pyc\"),\n            (\"tests/*.py\", \"foo/foo.py\"),\n            (drv1 + \"/*.py\", drv2 + \"/foo.py\"),\n            (drv1 + \"/foo/*.py\", drv2 + \"/foo/foo.py\"),\n            (\"tests/**/test*.py\", \"tests/foo.py\"),\n            (\"tests/**/test*.py\", \"foo/test_foo.py\"),\n            (\"tests/**/doc/test*.py\", \"tests/foo/bar/doc/foo.py\"),\n            (\"tests/**/doc/test*.py\", \"tests/foo/bar/test_foo.py\"),\n        ],\n    )\n    def test_not_matching(self, match, pattern, path):\n        assert not match(pattern, path)\n\n\ndef test_access_denied_during_cleanup(tmp_path, monkeypatch):\n    \"\"\"Ensure that deleting a numbered dir does not fail because of OSErrors (#4262).\"\"\"\n    path = tmp_path / \"temp-1\"\n    path.mkdir()\n\n    def renamed_failed(*args):\n        raise OSError(\"access denied\")\n\n    monkeypatch.setattr(Path, \"rename\", renamed_failed)\n\n    lock_path = get_lock_path(path)\n    maybe_delete_a_numbered_dir(path)\n    assert not lock_path.is_file()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_os_TestPytestPluginInteractions.test_configure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_os_TestPytestPluginInteractions.test_configure", "embedding": null, "metadata": {"file_path": "testing/test_pluginmanager.py", "file_name": "test_pluginmanager.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 87, "span_ids": ["TestPytestPluginInteractions", "TestPytestPluginInteractions.test_addhooks_conftestplugin", "TestPytestPluginInteractions.test_addhooks_nohooks", "TestPytestPluginInteractions.test_configure", "TestPytestPluginInteractions.test_do_option_postinitialize", "imports", "pytestpm"], "tokens": 528}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport sys\nimport types\n\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.config.exceptions import UsageError\nfrom _pytest.main import Session\n\n\n@pytest.fixture\ndef pytestpm():\n    return PytestPluginManager()\n\n\nclass TestPytestPluginInteractions:\n    def test_addhooks_conftestplugin(self, testdir, _config_for_test):\n        testdir.makepyfile(\n            newhooks=\"\"\"\n            def pytest_myhook(xyz):\n                \"new hook\"\n        \"\"\"\n        )\n        conf = testdir.makeconftest(\n            \"\"\"\n            import newhooks\n            def pytest_addhooks(pluginmanager):\n                pluginmanager.add_hookspecs(newhooks)\n            def pytest_myhook(xyz):\n                return xyz + 1\n        \"\"\"\n        )\n        config = _config_for_test\n        pm = config.pluginmanager\n        pm.hook.pytest_addhooks.call_historic(\n            kwargs=dict(pluginmanager=config.pluginmanager)\n        )\n        config.pluginmanager._importconftest(conf)\n        # print(config.pluginmanager.get_plugins())\n        res = config.hook.pytest_myhook(xyz=10)\n        assert res == [11]\n\n    def test_addhooks_nohooks(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import sys\n            def pytest_addhooks(pluginmanager):\n                pluginmanager.add_hookspecs(sys)\n        \"\"\"\n        )\n        res = testdir.runpytest()\n        assert res.ret != 0\n        res.stderr.fnmatch_lines([\"*did not find*sys*\"])\n\n    def test_do_option_postinitialize(self, testdir):\n        config = testdir.parseconfigure()\n        assert not hasattr(config.option, \"test123\")\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_addoption(parser):\n                parser.addoption('--test123', action=\"store_true\",\n                    default=True)\n        \"\"\"\n        )\n        config.pluginmanager._importconftest(p)\n        assert config.option.test123\n\n    def test_configure(self, testdir):\n        config = testdir.parseconfig()\n        values = []\n\n        class A:\n            def pytest_configure(self):\n                values.append(self)\n\n        config.pluginmanager.register(A())\n        assert len(values) == 0\n        config._do_configure()\n        assert len(values) == 1\n        config.pluginmanager.register(A())  # leads to a configured() plugin\n        assert len(values) == 2\n        assert values[0] != values[1]\n\n        config._ensure_unconfigure()\n        config.pluginmanager.register(A())\n        assert len(values) == 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_os_test_make_hook_recorder.pytest_raises_ValueError_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_os_test_make_hook_recorder.pytest_raises_ValueError_", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 71, "span_ids": ["imports", "test_make_hook_recorder"], "tokens": 420}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport subprocess\nimport sys\nimport time\nfrom typing import List\n\nimport py.path\n\nimport _pytest.pytester as pytester\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.pytester import CwdSnapshot\nfrom _pytest.pytester import HookRecorder\nfrom _pytest.pytester import LineMatcher\nfrom _pytest.pytester import SysModulesSnapshot\nfrom _pytest.pytester import SysPathsSnapshot\nfrom _pytest.pytester import Testdir\n\n\ndef test_make_hook_recorder(testdir) -> None:\n    item = testdir.getitem(\"def test_func(): pass\")\n    recorder = testdir.make_hook_recorder(item.config.pluginmanager)\n    assert not recorder.getfailures()\n\n    pytest.xfail(\"internal reportrecorder tests need refactoring\")\n\n    class rep:\n        excinfo = None\n        passed = False\n        failed = True\n        skipped = False\n        when = \"call\"\n\n    recorder.hook.pytest_runtest_logreport(report=rep)\n    failures = recorder.getfailures()\n    assert failures == [rep]\n    failures = recorder.getfailures()\n    assert failures == [rep]\n\n    class rep2:\n        excinfo = None\n        passed = False\n        failed = False\n        skipped = True\n        when = \"call\"\n\n    rep2.passed = False\n    rep2.skipped = True\n    recorder.hook.pytest_runtest_logreport(report=rep2)\n\n    modcol = testdir.getmodulecol(\"\")\n    rep3 = modcol.config.hook.pytest_make_collect_report(collector=modcol)\n    rep3.passed = False\n    rep3.failed = True\n    rep3.skipped = False\n    recorder.hook.pytest_collectreport(report=rep3)\n\n    passed, skipped, failed = recorder.listoutcomes()\n    assert not passed and skipped and failed\n\n    numpassed, numskipped, numfailed = recorder.countoutcomes()\n    assert numpassed == 0\n    assert numskipped == 1\n    assert numfailed == 1\n    assert len(recorder.getfailedcollections()) == 1\n\n    recorder.unregister()\n    recorder.clear()\n    recorder.hook.pytest_runtest_logreport(report=rep3)\n    pytest.raises(ValueError, recorder.getfailures)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_TestInlineRunModulesCleanup_TestInlineRunModulesCleanup.test_external_test_module_imports_not_cleaned_up": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_TestInlineRunModulesCleanup_TestInlineRunModulesCleanup.test_external_test_module_imports_not_cleaned_up", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 216, "end_line": 288, "span_ids": ["TestInlineRunModulesCleanup", "TestInlineRunModulesCleanup.spy_factory", "TestInlineRunModulesCleanup.test_external_test_module_imports_not_cleaned_up", "TestInlineRunModulesCleanup.test_inline_run_sys_modules_snapshot_restore_preserving_modules", "TestInlineRunModulesCleanup.test_inline_run_taking_and_restoring_a_sys_modules_snapshot", "TestInlineRunModulesCleanup.test_inline_run_test_module_not_cleaned_up"], "tokens": 648}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestInlineRunModulesCleanup:\n    def test_inline_run_test_module_not_cleaned_up(self, testdir) -> None:\n        test_mod = testdir.makepyfile(\"def test_foo(): assert True\")\n        result = testdir.inline_run(str(test_mod))\n        assert result.ret == ExitCode.OK\n        # rewrite module, now test should fail if module was re-imported\n        test_mod.write(\"def test_foo(): assert False\")\n        result2 = testdir.inline_run(str(test_mod))\n        assert result2.ret == ExitCode.TESTS_FAILED\n\n    def spy_factory(self):\n        class SysModulesSnapshotSpy:\n            instances = []  # type: List[SysModulesSnapshotSpy]\n\n            def __init__(self, preserve=None) -> None:\n                SysModulesSnapshotSpy.instances.append(self)\n                self._spy_restore_count = 0\n                self._spy_preserve = preserve\n                self.__snapshot = SysModulesSnapshot(preserve=preserve)\n\n            def restore(self):\n                self._spy_restore_count += 1\n                return self.__snapshot.restore()\n\n        return SysModulesSnapshotSpy\n\n    def test_inline_run_taking_and_restoring_a_sys_modules_snapshot(\n        self, testdir, monkeypatch\n    ) -> None:\n        spy_factory = self.spy_factory()\n        monkeypatch.setattr(pytester, \"SysModulesSnapshot\", spy_factory)\n        testdir.syspathinsert()\n        original = dict(sys.modules)\n        testdir.makepyfile(import1=\"# you son of a silly person\")\n        testdir.makepyfile(import2=\"# my hovercraft is full of eels\")\n        test_mod = testdir.makepyfile(\n            \"\"\"\n            import import1\n            def test_foo(): import import2\"\"\"\n        )\n        testdir.inline_run(str(test_mod))\n        assert len(spy_factory.instances) == 1\n        spy = spy_factory.instances[0]\n        assert spy._spy_restore_count == 1\n        assert sys.modules == original\n        assert all(sys.modules[x] is original[x] for x in sys.modules)\n\n    def test_inline_run_sys_modules_snapshot_restore_preserving_modules(\n        self, testdir, monkeypatch\n    ) -> None:\n        spy_factory = self.spy_factory()\n        monkeypatch.setattr(pytester, \"SysModulesSnapshot\", spy_factory)\n        test_mod = testdir.makepyfile(\"def test_foo(): pass\")\n        testdir.inline_run(str(test_mod))\n        spy = spy_factory.instances[0]\n        assert not spy._spy_preserve(\"black_knight\")\n        assert spy._spy_preserve(\"zope\")\n        assert spy._spy_preserve(\"zope.interface\")\n        assert spy._spy_preserve(\"zopelicious\")\n\n    def test_external_test_module_imports_not_cleaned_up(self, testdir) -> None:\n        testdir.syspathinsert()\n        testdir.makepyfile(imported=\"data = 'you son of a silly person'\")\n        import imported\n\n        test_mod = testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                import imported\n                imported.data = 42\"\"\"\n        )\n        testdir.inline_run(str(test_mod))\n        assert imported.data == 42", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_re_TestWarningsRecorderChecker.test_invalid_enter_exit": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_recwarn.py_re_TestWarningsRecorderChecker.test_invalid_enter_exit", "embedding": null, "metadata": {"file_path": "testing/test_recwarn.py", "file_name": "test_recwarn.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 73, "span_ids": ["TestWarningsRecorderChecker", "TestWarningsRecorderChecker.test_invalid_enter_exit", "TestWarningsRecorderChecker.test_recording", "TestWarningsRecorderChecker.test_typechecking", "TestWarningsRecorderChecker.test_warn_stacklevel", "imports", "test_recwarn_functional", "test_recwarn_stacklevel"], "tokens": 491}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import re\nimport warnings\nfrom typing import Optional\n\nimport pytest\nfrom _pytest.recwarn import WarningsRecorder\n\n\ndef test_recwarn_stacklevel(recwarn: WarningsRecorder) -> None:\n    warnings.warn(\"hello\")\n    warn = recwarn.pop()\n    assert warn.filename == __file__\n\n\ndef test_recwarn_functional(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        import warnings\n        def test_method(recwarn):\n            warnings.warn(\"hello\")\n            warn = recwarn.pop()\n            assert isinstance(warn.message, UserWarning)\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\nclass TestWarningsRecorderChecker:\n    def test_recording(self) -> None:\n        rec = WarningsRecorder()\n        with rec:\n            assert not rec.list\n            warnings.warn_explicit(\"hello\", UserWarning, \"xyz\", 13)\n            assert len(rec.list) == 1\n            warnings.warn(DeprecationWarning(\"hello\"))\n            assert len(rec.list) == 2\n            warn = rec.pop()\n            assert str(warn.message) == \"hello\"\n            values = rec.list\n            rec.clear()\n            assert len(rec.list) == 0\n            assert values is rec.list\n            pytest.raises(AssertionError, rec.pop)\n\n    def test_warn_stacklevel(self) -> None:\n        \"\"\"#4243\"\"\"\n        rec = WarningsRecorder()\n        with rec:\n            warnings.warn(\"test\", DeprecationWarning, 2)\n\n    def test_typechecking(self) -> None:\n        from _pytest.recwarn import WarningsChecker\n\n        with pytest.raises(TypeError):\n            WarningsChecker(5)  # type: ignore\n        with pytest.raises(TypeError):\n            WarningsChecker((\"hi\", RuntimeWarning))  # type: ignore\n        with pytest.raises(TypeError):\n            WarningsChecker([DeprecationWarning, RuntimeWarning])  # type: ignore\n\n    def test_invalid_enter_exit(self) -> None:\n        # wrap this test in WarningsRecorder to ensure warning state gets reset\n        with WarningsRecorder():\n            with pytest.raises(RuntimeError):\n                rec = WarningsRecorder()\n                rec.__exit__(None, None, None)  # can't exit before entering\n\n            with pytest.raises(RuntimeError):\n                rec = WarningsRecorder()\n                with rec:\n                    with rec:\n                        pass  # can't enter twice", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_collectreport_passed_TestReportSerialization.test_deserialization_failure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_collectreport_passed_TestReportSerialization.test_deserialization_failure", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 165, "end_line": 244, "span_ids": ["TestReportSerialization.test_collectreport_fail", "TestReportSerialization.test_collectreport_passed", "TestReportSerialization.test_deserialization_failure", "TestReportSerialization.test_extended_report_deserialization", "TestReportSerialization.test_paths_support"], "tokens": 706}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportSerialization:\n\n    def test_collectreport_passed(self, testdir):\n        \"\"\"This test came originally from test_remote.py in xdist (ca03269).\"\"\"\n        reprec = testdir.inline_runsource(\"def test_func(): pass\")\n        reports = reprec.getreports(\"pytest_collectreport\")\n        for rep in reports:\n            d = rep._to_json()\n            newrep = CollectReport._from_json(d)\n            assert newrep.passed == rep.passed\n            assert newrep.failed == rep.failed\n            assert newrep.skipped == rep.skipped\n\n    def test_collectreport_fail(self, testdir):\n        \"\"\"This test came originally from test_remote.py in xdist (ca03269).\"\"\"\n        reprec = testdir.inline_runsource(\"qwe abc\")\n        reports = reprec.getreports(\"pytest_collectreport\")\n        assert reports\n        for rep in reports:\n            d = rep._to_json()\n            newrep = CollectReport._from_json(d)\n            assert newrep.passed == rep.passed\n            assert newrep.failed == rep.failed\n            assert newrep.skipped == rep.skipped\n            if rep.failed:\n                assert newrep.longrepr == str(rep.longrepr)\n\n    def test_extended_report_deserialization(self, testdir):\n        \"\"\"This test came originally from test_remote.py in xdist (ca03269).\"\"\"\n        reprec = testdir.inline_runsource(\"qwe abc\")\n        reports = reprec.getreports(\"pytest_collectreport\")\n        assert reports\n        for rep in reports:\n            rep.extra = True\n            d = rep._to_json()\n            newrep = CollectReport._from_json(d)\n            assert newrep.extra\n            assert newrep.passed == rep.passed\n            assert newrep.failed == rep.failed\n            assert newrep.skipped == rep.skipped\n            if rep.failed:\n                assert newrep.longrepr == str(rep.longrepr)\n\n    def test_paths_support(self, testdir):\n        \"\"\"Report attributes which are py.path or pathlib objects should become strings.\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def test_a():\n                assert False\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 3\n        test_a_call = reports[1]\n        test_a_call.path1 = testdir.tmpdir\n        test_a_call.path2 = Path(testdir.tmpdir)\n        data = test_a_call._to_json()\n        assert data[\"path1\"] == str(testdir.tmpdir)\n        assert data[\"path2\"] == str(testdir.tmpdir)\n\n    def test_deserialization_failure(self, testdir):\n        \"\"\"Check handling of failure during deserialization of report types.\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def test_a():\n                assert False\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 3\n        test_a_call = reports[1]\n        data = test_a_call._to_json()\n        entry = data[\"longrepr\"][\"reprtraceback\"][\"reprentries\"][0]\n        assert entry[\"type\"] == \"ReprEntry\"\n\n        entry[\"type\"] = \"Unknown\"\n        with pytest.raises(\n            RuntimeError, match=\"INTERNALERROR: Unknown entry type returned: Unknown\"\n        ):\n            TestReport._from_json(data)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_chained_exceptions_TestReportSerialization.test_chained_exceptions.loaded_report_longrepr_to": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_chained_exceptions_TestReportSerialization.test_chained_exceptions.loaded_report_longrepr_to", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 248, "end_line": 317, "span_ids": ["TestReportSerialization.test_chained_exceptions"], "tokens": 572}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportSerialization:\n\n    @pytest.mark.parametrize(\"report_class\", [TestReport, CollectReport])\n    def test_chained_exceptions(self, testdir, tw_mock, report_class):\n        \"\"\"Check serialization/deserialization of report objects containing chained exceptions (#5786)\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def foo():\n                raise ValueError('value error')\n            def test_a():\n                try:\n                    foo()\n                except ValueError as e:\n                    raise RuntimeError('runtime error') from e\n            if {error_during_import}:\n                test_a()\n        \"\"\".format(\n                error_during_import=report_class is CollectReport\n            )\n        )\n\n        reprec = testdir.inline_run()\n        if report_class is TestReport:\n            reports = reprec.getreports(\"pytest_runtest_logreport\")\n            # we have 3 reports: setup/call/teardown\n            assert len(reports) == 3\n            # get the call report\n            report = reports[1]\n        else:\n            assert report_class is CollectReport\n            # two collection reports: session and test file\n            reports = reprec.getreports(\"pytest_collectreport\")\n            assert len(reports) == 2\n            report = reports[1]\n\n        def check_longrepr(longrepr):\n            \"\"\"Check the attributes of the given longrepr object according to the test file.\n\n            We can get away with testing both CollectReport and TestReport with this function because\n            the longrepr objects are very similar.\n            \"\"\"\n            assert isinstance(longrepr, ExceptionChainRepr)\n            assert longrepr.sections == [(\"title\", \"contents\", \"=\")]\n            assert len(longrepr.chain) == 2\n            entry1, entry2 = longrepr.chain\n            tb1, fileloc1, desc1 = entry1\n            tb2, fileloc2, desc2 = entry2\n\n            assert \"ValueError('value error')\" in str(tb1)\n            assert \"RuntimeError('runtime error')\" in str(tb2)\n\n            assert (\n                desc1\n                == \"The above exception was the direct cause of the following exception:\"\n            )\n            assert desc2 is None\n\n        assert report.failed\n        assert len(report.sections) == 0\n        report.longrepr.addsection(\"title\", \"contents\", \"=\")\n        check_longrepr(report.longrepr)\n\n        data = report._to_json()\n        loaded_report = report_class._from_json(data)\n\n        assert loaded_report.failed\n        check_longrepr(loaded_report.longrepr)\n\n        # make sure we don't blow up on ``toterminal`` call; we don't test the actual output because it is very\n        # brittle and hard to maintain, but we can assume it is correct because ``toterminal`` is already tested\n        # elsewhere and we do check the contents of the longrepr object after loading it.\n        loaded_report.longrepr.toterminal(tw_mock)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_os_test_write_log_entry.None_14": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_os_test_write_log_entry.None_14", "embedding": null, "metadata": {"file_path": "testing/test_resultlog.py", "file_name": "test_resultlog.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 50, "span_ids": ["imports", "test_write_log_entry"], "tokens": 391}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nfrom io import StringIO\n\nimport _pytest._code\nimport pytest\nfrom _pytest.resultlog import pytest_configure\nfrom _pytest.resultlog import pytest_unconfigure\nfrom _pytest.resultlog import ResultLog\nfrom _pytest.resultlog import resultlog_key\n\npytestmark = pytest.mark.filterwarnings(\"ignore:--result-log is deprecated\")\n\n\ndef test_write_log_entry():\n    reslog = ResultLog(None, None)\n    reslog.logfile = StringIO()\n    reslog.write_log_entry(\"name\", \".\", \"\")\n    entry = reslog.logfile.getvalue()\n    assert entry[-1] == \"\\n\"\n    entry_lines = entry.splitlines()\n    assert len(entry_lines) == 1\n    assert entry_lines[0] == \". name\"\n\n    reslog.logfile = StringIO()\n    reslog.write_log_entry(\"name\", \"s\", \"Skipped\")\n    entry = reslog.logfile.getvalue()\n    assert entry[-1] == \"\\n\"\n    entry_lines = entry.splitlines()\n    assert len(entry_lines) == 2\n    assert entry_lines[0] == \"s name\"\n    assert entry_lines[1] == \" Skipped\"\n\n    reslog.logfile = StringIO()\n    reslog.write_log_entry(\"name\", \"s\", \"Skipped\\n\")\n    entry = reslog.logfile.getvalue()\n    assert entry[-1] == \"\\n\"\n    entry_lines = entry.splitlines()\n    assert len(entry_lines) == 2\n    assert entry_lines[0] == \"s name\"\n    assert entry_lines[1] == \" Skipped\"\n\n    reslog.logfile = StringIO()\n    longrepr = \" tb1\\n tb 2\\nE tb3\\nSome Error\"\n    reslog.write_log_entry(\"name\", \"F\", longrepr)\n    entry = reslog.logfile.getvalue()\n    assert entry[-1] == \"\\n\"\n    entry_lines = entry.splitlines()\n    assert len(entry_lines) == 5\n    assert entry_lines[0] == \"F name\"\n    assert entry_lines[1:] == [\" \" + line for line in longrepr.splitlines()]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_inspect_TestSetupState.test_teardown_multiple_scopes_one_fails": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_inspect_TestSetupState.test_teardown_multiple_scopes_one_fails", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 109, "span_ids": ["TestSetupState", "TestSetupState.test_setup", "TestSetupState.test_setup_fails_and_failure_is_cached", "TestSetupState.test_teardown_exact_stack_empty", "TestSetupState.test_teardown_multiple_fail", "TestSetupState.test_teardown_multiple_one_fails", "TestSetupState.test_teardown_multiple_scopes_one_fails", "imports"], "tokens": 697}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import inspect\nimport os\nimport sys\nimport types\nfrom typing import Dict\nfrom typing import List\nfrom typing import Tuple\n\nimport py\n\nimport _pytest._code\nimport pytest\nfrom _pytest import outcomes\nfrom _pytest import reports\nfrom _pytest import runner\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import ExitCode\nfrom _pytest.outcomes import OutcomeException\n\nif TYPE_CHECKING:\n    from typing import Type\n\n\nclass TestSetupState:\n    def test_setup(self, testdir) -> None:\n        ss = runner.SetupState()\n        item = testdir.getitem(\"def test_func(): pass\")\n        values = [1]\n        ss.prepare(item)\n        ss.addfinalizer(values.pop, colitem=item)\n        assert values\n        ss._pop_and_teardown()\n        assert not values\n\n    def test_teardown_exact_stack_empty(self, testdir) -> None:\n        item = testdir.getitem(\"def test_func(): pass\")\n        ss = runner.SetupState()\n        ss.teardown_exact(item, None)\n        ss.teardown_exact(item, None)\n        ss.teardown_exact(item, None)\n\n    def test_setup_fails_and_failure_is_cached(self, testdir) -> None:\n        item = testdir.getitem(\n            \"\"\"\n            def setup_module(mod):\n                raise ValueError(42)\n            def test_func(): pass\n        \"\"\"\n        )\n        ss = runner.SetupState()\n        pytest.raises(ValueError, lambda: ss.prepare(item))\n        pytest.raises(ValueError, lambda: ss.prepare(item))\n\n    def test_teardown_multiple_one_fails(self, testdir) -> None:\n        r = []\n\n        def fin1():\n            r.append(\"fin1\")\n\n        def fin2():\n            raise Exception(\"oops\")\n\n        def fin3():\n            r.append(\"fin3\")\n\n        item = testdir.getitem(\"def test_func(): pass\")\n        ss = runner.SetupState()\n        ss.addfinalizer(fin1, item)\n        ss.addfinalizer(fin2, item)\n        ss.addfinalizer(fin3, item)\n        with pytest.raises(Exception) as err:\n            ss._callfinalizers(item)\n        assert err.value.args == (\"oops\",)\n        assert r == [\"fin3\", \"fin1\"]\n\n    def test_teardown_multiple_fail(self, testdir) -> None:\n        # Ensure the first exception is the one which is re-raised.\n        # Ideally both would be reported however.\n        def fin1():\n            raise Exception(\"oops1\")\n\n        def fin2():\n            raise Exception(\"oops2\")\n\n        item = testdir.getitem(\"def test_func(): pass\")\n        ss = runner.SetupState()\n        ss.addfinalizer(fin1, item)\n        ss.addfinalizer(fin2, item)\n        with pytest.raises(Exception) as err:\n            ss._callfinalizers(item)\n        assert err.value.args == (\"oops2\",)\n\n    def test_teardown_multiple_scopes_one_fails(self, testdir) -> None:\n        module_teardown = []\n\n        def fin_func():\n            raise Exception(\"oops1\")\n\n        def fin_module():\n            module_teardown.append(\"fin_module\")\n\n        item = testdir.getitem(\"def test_func(): pass\")\n        ss = runner.SetupState()\n        ss.addfinalizer(fin_module, item.listchain()[-2])\n        ss.addfinalizer(fin_func, item)\n        ss.prepare(item)\n        with pytest.raises(Exception, match=\"oops1\"):\n            ss.teardown_exact(item, None)\n        assert module_teardown", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py___test_class_setup_failure_no_teardown": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py___test_class_setup_failure_no_teardown", "embedding": null, "metadata": {"file_path": "testing/test_runner_xunit.py", "file_name": "test_runner_xunit.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 124, "span_ids": ["docstring", "test_class_setup", "test_class_setup_failure_no_teardown", "test_module_and_function_setup", "test_module_setup_failure_no_teardown", "test_setup_function_failure_no_teardown"], "tokens": 664}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\n test correct setup/teardowns at\n module, class, and instance level\n\"\"\"\nimport pytest\n\n\ndef test_module_and_function_setup(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        modlevel = []\n        def setup_module(module):\n            assert not modlevel\n            module.modlevel.append(42)\n\n        def teardown_module(module):\n            modlevel.pop()\n\n        def setup_function(function):\n            function.answer = 17\n\n        def teardown_function(function):\n            del function.answer\n\n        def test_modlevel():\n            assert modlevel[0] == 42\n            assert test_modlevel.answer == 17\n\n        class TestFromClass(object):\n            def test_module(self):\n                assert modlevel[0] == 42\n                assert not hasattr(test_modlevel, 'answer')\n    \"\"\"\n    )\n    rep = reprec.matchreport(\"test_modlevel\")\n    assert rep.passed\n    rep = reprec.matchreport(\"test_module\")\n    assert rep.passed\n\n\ndef test_module_setup_failure_no_teardown(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        values = []\n        def setup_module(module):\n            values.append(1)\n            0/0\n\n        def test_nothing():\n            pass\n\n        def teardown_module(module):\n            values.append(2)\n    \"\"\"\n    )\n    reprec.assertoutcome(failed=1)\n    calls = reprec.getcalls(\"pytest_runtest_setup\")\n    assert calls[0].item.module.values == [1]\n\n\ndef test_setup_function_failure_no_teardown(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        modlevel = []\n        def setup_function(function):\n            modlevel.append(1)\n            0/0\n\n        def teardown_function(module):\n            modlevel.append(2)\n\n        def test_func():\n            pass\n    \"\"\"\n    )\n    calls = reprec.getcalls(\"pytest_runtest_setup\")\n    assert calls[0].item.module.modlevel == [1]\n\n\ndef test_class_setup(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        class TestSimpleClassSetup(object):\n            clslevel = []\n            def setup_class(cls):\n                cls.clslevel.append(23)\n\n            def teardown_class(cls):\n                cls.clslevel.pop()\n\n            def test_classlevel(self):\n                assert self.clslevel[0] == 23\n\n        class TestInheritedClassSetupStillWorks(TestSimpleClassSetup):\n            def test_classlevel_anothertime(self):\n                assert self.clslevel == [23]\n\n        def test_cleanup():\n            assert not TestSimpleClassSetup.clslevel\n            assert not TestInheritedClassSetupStillWorks.clslevel\n    \"\"\"\n    )\n    reprec.assertoutcome(passed=1 + 2 + 1)\n\n\ndef test_class_setup_failure_no_teardown(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        class TestSimpleClassSetup(object):\n            clslevel = []\n            def setup_class(cls):\n                0/0\n\n            def teardown_class(cls):\n                cls.clslevel.append(1)\n\n            def test_classlevel(self):\n                pass\n\n        def test_cleanup():\n            assert not TestSimpleClassSetup.clslevel\n    \"\"\"\n    )\n    reprec.assertoutcome(failed=1, passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_pytest_SessionTests.test_basic_testitem_events._assert_colreports_1_re": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_pytest_SessionTests.test_basic_testitem_events._assert_colreports_1_re", "embedding": null, "metadata": {"file_path": "testing/test_session.py", "file_name": "test_session.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 36, "span_ids": ["SessionTests", "SessionTests.test_basic_testitem_events", "imports"], "tokens": 234}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\nfrom _pytest.config import ExitCode\n\n\nclass SessionTests:\n    def test_basic_testitem_events(self, testdir):\n        tfile = testdir.makepyfile(\n            \"\"\"\n            def test_one():\n                pass\n            def test_one_one():\n                assert 0\n            def test_other():\n                raise ValueError(23)\n            class TestClass(object):\n                def test_two(self, someargs):\n                    pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(tfile)\n        passed, skipped, failed = reprec.listoutcomes()\n        assert len(skipped) == 0\n        assert len(passed) == 1\n        assert len(failed) == 3\n\n        def end(x):\n            return x.nodeid.split(\"::\")[-1]\n\n        assert end(failed[0]) == \"test_one_one\"\n        assert end(failed[1]) == \"test_other\"\n        itemstarted = reprec.getcalls(\"pytest_itemcollected\")\n        assert len(itemstarted) == 4\n        # XXX check for failing funcarg setup\n        # colreports = reprec.getcalls(\"pytest_collectreport\")\n        # assert len(colreports) == 4\n        # assert colreports[1].report.failed", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_sys_TestEvaluator.test_skipif_class": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_skipping.py_sys_TestEvaluator.test_skipif_class", "embedding": null, "metadata": {"file_path": "testing/test_skipping.py", "file_name": "test_skipping.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 131, "span_ids": ["TestEvaluator", "TestEvaluator.test_marked_no_args", "TestEvaluator.test_marked_one_arg", "TestEvaluator.test_marked_one_arg_twice", "TestEvaluator.test_marked_one_arg_twice2", "TestEvaluator.test_marked_one_arg_with_reason", "TestEvaluator.test_marked_skip_with_not_string", "TestEvaluator.test_no_marker", "TestEvaluator.test_skipif_class", "imports"], "tokens": 861}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\n\nimport pytest\nfrom _pytest.runner import runtestprotocol\nfrom _pytest.skipping import MarkEvaluator\nfrom _pytest.skipping import pytest_runtest_setup\n\n\nclass TestEvaluator:\n    def test_no_marker(self, testdir):\n        item = testdir.getitem(\"def test_func(): pass\")\n        evalskipif = MarkEvaluator(item, \"skipif\")\n        assert not evalskipif\n        assert not evalskipif.istrue()\n\n    def test_marked_no_args(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xyz\n            def test_func():\n                pass\n        \"\"\"\n        )\n        ev = MarkEvaluator(item, \"xyz\")\n        assert ev\n        assert ev.istrue()\n        expl = ev.getexplanation()\n        assert expl == \"\"\n        assert not ev.get(\"run\", False)\n\n    def test_marked_one_arg(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xyz(\"hasattr(os, 'sep')\")\n            def test_func():\n                pass\n        \"\"\"\n        )\n        ev = MarkEvaluator(item, \"xyz\")\n        assert ev\n        assert ev.istrue()\n        expl = ev.getexplanation()\n        assert expl == \"condition: hasattr(os, 'sep')\"\n\n    def test_marked_one_arg_with_reason(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.xyz(\"hasattr(os, 'sep')\", attr=2, reason=\"hello world\")\n            def test_func():\n                pass\n        \"\"\"\n        )\n        ev = MarkEvaluator(item, \"xyz\")\n        assert ev\n        assert ev.istrue()\n        expl = ev.getexplanation()\n        assert expl == \"hello world\"\n        assert ev.get(\"attr\") == 2\n\n    def test_marked_one_arg_twice(self, testdir):\n        lines = [\n            \"\"\"@pytest.mark.skipif(\"not hasattr(os, 'murks')\")\"\"\",\n            \"\"\"@pytest.mark.skipif(\"hasattr(os, 'murks')\")\"\"\",\n        ]\n        for i in range(0, 2):\n            item = testdir.getitem(\n                \"\"\"\n                import pytest\n                %s\n                %s\n                def test_func():\n                    pass\n            \"\"\"\n                % (lines[i], lines[(i + 1) % 2])\n            )\n            ev = MarkEvaluator(item, \"skipif\")\n            assert ev\n            assert ev.istrue()\n            expl = ev.getexplanation()\n            assert expl == \"condition: not hasattr(os, 'murks')\"\n\n    def test_marked_one_arg_twice2(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.skipif(\"hasattr(os, 'murks')\")\n            @pytest.mark.skipif(\"not hasattr(os, 'murks')\")\n            def test_func():\n                pass\n        \"\"\"\n        )\n        ev = MarkEvaluator(item, \"skipif\")\n        assert ev\n        assert ev.istrue()\n        expl = ev.getexplanation()\n        assert expl == \"condition: not hasattr(os, 'murks')\"\n\n    def test_marked_skip_with_not_string(self, testdir):\n        item = testdir.getitem(\n            \"\"\"\n            import pytest\n            @pytest.mark.skipif(False)\n            def test_func():\n                pass\n        \"\"\"\n        )\n        ev = MarkEvaluator(item, \"skipif\")\n        exc = pytest.raises(pytest.fail.Exception, ev.istrue)\n        assert (\n            \"\"\"Failed: you need to specify reason=STRING when using booleans as conditions.\"\"\"\n            in exc.value.msg\n        )\n\n    def test_skipif_class(self, testdir):\n        (item,) = testdir.getitems(\n            \"\"\"\n            import pytest\n            class TestClass(object):\n                pytestmark = pytest.mark.skipif(\"config._hackxyz\")\n                def test_func(self):\n                    pass\n        \"\"\"\n        )\n        item.config._hackxyz = 3\n        ev = MarkEvaluator(item, \"skipif\")\n        assert ev.istrue()\n        expl = ev.getexplanation()\n        assert expl == \"condition: config._hackxyz\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_pytest_stepwise_testdir.return_testdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_stepwise.py_pytest_stepwise_testdir.return_testdir", "embedding": null, "metadata": {"file_path": "testing/test_stepwise.py", "file_name": "test_stepwise.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 52, "span_ids": ["imports", "stepwise_testdir"], "tokens": 261}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\n@pytest.fixture\ndef stepwise_testdir(testdir):\n    # Rather than having to modify our testfile between tests, we introduce\n    # a flag for whether or not the second test should fail.\n    testdir.makeconftest(\n        \"\"\"\ndef pytest_addoption(parser):\n    group = parser.getgroup('general')\n    group.addoption('--fail', action='store_true', dest='fail')\n    group.addoption('--fail-last', action='store_true', dest='fail_last')\n\"\"\"\n    )\n\n    # Create a simple test suite.\n    testdir.makepyfile(\n        test_a=\"\"\"\ndef test_success_before_fail():\n    assert 1\n\ndef test_fail_on_flag(request):\n    assert not request.config.getvalue('fail')\n\ndef test_success_after_fail():\n    assert 1\n\ndef test_fail_last_on_flag(request):\n    assert not request.config.getvalue('fail_last')\n\ndef test_success_after_last_fail():\n    assert 1\n\"\"\"\n    )\n\n    testdir.makepyfile(\n        test_b=\"\"\"\ndef test_success():\n    assert 1\n\"\"\"\n    )\n\n    # customize cache directory so we don't use the tox's cache directory, which makes tests in this module flaky\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        cache_dir = .cache\n    \"\"\"\n    )\n\n    return testdir", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py___test_plugin_nameversion": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py___test_plugin_nameversion", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 70, "span_ids": ["Option", "Option.__init__", "Option.args", "docstring", "option", "test_plugin_nameversion"], "tokens": 391}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nterminal reporting of the full testing process.\n\"\"\"\nimport collections\nimport os\nimport sys\nimport textwrap\nfrom io import StringIO\nfrom typing import Dict\nfrom typing import List\nfrom typing import Tuple\n\nimport pluggy\nimport py\n\nimport _pytest.config\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.pytester import Testdir\nfrom _pytest.reports import BaseReport\nfrom _pytest.terminal import _folded_skips\nfrom _pytest.terminal import _get_line_with_reprcrash_message\nfrom _pytest.terminal import _plugin_nameversions\nfrom _pytest.terminal import getreportopt\nfrom _pytest.terminal import TerminalReporter\n\nDistInfo = collections.namedtuple(\"DistInfo\", [\"project_name\", \"version\"])\n\n\nTRANS_FNMATCH = str.maketrans({\"[\": \"[[]\", \"]\": \"[]]\"})\n\n\nclass Option:\n    def __init__(self, verbosity=0):\n        self.verbosity = verbosity\n\n    @property\n    def args(self):\n        values = []\n        values.append(\"--verbosity=%d\" % self.verbosity)\n        return values\n\n\n@pytest.fixture(\n    params=[Option(verbosity=0), Option(verbosity=1), Option(verbosity=-1)],\n    ids=[\"default\", \"verbose\", \"quiet\"],\n)\ndef option(request):\n    return request.param\n\n\n@pytest.mark.parametrize(\n    \"input,expected\",\n    [\n        ([DistInfo(project_name=\"test\", version=1)], [\"test-1\"]),\n        ([DistInfo(project_name=\"pytest-test\", version=1)], [\"test-1\"]),\n        (\n            [\n                DistInfo(project_name=\"test\", version=1),\n                DistInfo(project_name=\"test\", version=1),\n            ],\n            [\"test-1\"],\n        ),\n    ],\n    ids=[\"normal\", \"prefix-strip\", \"deduplicate\"],\n)\ndef test_plugin_nameversion(input, expected):\n    pluginlist = [(None, x) for x in input]\n    result = _plugin_nameversions(pluginlist)\n    assert result == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestRmRf_TestRmRf.test_rm_rf_with_read_only_directory": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestRmRf_TestRmRf.test_rm_rf_with_read_only_directory", "embedding": null, "metadata": {"file_path": "testing/test_tmpdir.py", "file_name": "test_tmpdir.py", "file_type": "text/x-python", "category": "test", "start_line": 326, "end_line": 368, "span_ids": ["TestRmRf", "TestRmRf.chmod_r", "TestRmRf.test_rm_rf", "TestRmRf.test_rm_rf_with_read_only_directory", "TestRmRf.test_rm_rf_with_read_only_file"], "tokens": 263}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRmRf:\n    def test_rm_rf(self, tmp_path):\n        adir = tmp_path / \"adir\"\n        adir.mkdir()\n        rm_rf(adir)\n\n        assert not adir.exists()\n\n        adir.mkdir()\n        afile = adir / \"afile\"\n        afile.write_bytes(b\"aa\")\n\n        rm_rf(adir)\n        assert not adir.exists()\n\n    def test_rm_rf_with_read_only_file(self, tmp_path):\n        \"\"\"Ensure rm_rf can remove directories with read-only files in them (#5524)\"\"\"\n        fn = tmp_path / \"dir/foo.txt\"\n        fn.parent.mkdir()\n\n        fn.touch()\n\n        self.chmod_r(fn)\n\n        rm_rf(fn.parent)\n\n        assert not fn.parent.is_dir()\n\n    def chmod_r(self, path):\n        mode = os.stat(str(path)).st_mode\n        os.chmod(str(path), mode & ~stat.S_IWRITE)\n\n    def test_rm_rf_with_read_only_directory(self, tmp_path):\n        \"\"\"Ensure rm_rf can remove read-only directories (#5524)\"\"\"\n        adir = tmp_path / \"dir\"\n        adir.mkdir()\n\n        (adir / \"foo.txt\").touch()\n        self.chmod_r(adir)\n\n        rm_rf(adir)\n\n        assert not adir.is_dir()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_gc_test_setUpModule_failing_no_teardown": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_gc_test_setUpModule_failing_no_teardown", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 124, "span_ids": ["imports", "test_isclasscheck_issue53", "test_runTest_method", "test_setUpModule", "test_setUpModule_failing_no_teardown", "test_setup", "test_simple_unittest"], "tokens": 693}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import gc\n\nimport pytest\nfrom _pytest.config import ExitCode\n\n\ndef test_simple_unittest(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCase(unittest.TestCase):\n            def testpassing(self):\n                self.assertEqual('foo', 'foo')\n            def test_failing(self):\n                self.assertEqual('foo', 'bar')\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    assert reprec.matchreport(\"testpassing\").passed\n    assert reprec.matchreport(\"test_failing\").failed\n\n\ndef test_runTest_method(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCaseWithRunTest(unittest.TestCase):\n            def runTest(self):\n                self.assertEqual('foo', 'foo')\n        class MyTestCaseWithoutRunTest(unittest.TestCase):\n            def runTest(self):\n                self.assertEqual('foo', 'foo')\n            def test_something(self):\n                pass\n        \"\"\"\n    )\n    result = testdir.runpytest(\"-v\")\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *MyTestCaseWithRunTest::runTest*\n        *MyTestCaseWithoutRunTest::test_something*\n        *2 passed*\n    \"\"\"\n    )\n\n\ndef test_isclasscheck_issue53(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class _E(object):\n            def __getattr__(self, tag):\n                pass\n        E = _E()\n    \"\"\"\n    )\n    result = testdir.runpytest(testpath)\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_setup(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCase(unittest.TestCase):\n            def setUp(self):\n                self.foo = 1\n            def setup_method(self, method):\n                self.foo2 = 1\n            def test_both(self):\n                self.assertEqual(1, self.foo)\n                assert self.foo2 == 1\n            def teardown_method(self, method):\n                assert 0, \"42\"\n\n    \"\"\"\n    )\n    reprec = testdir.inline_run(\"-s\", testpath)\n    assert reprec.matchreport(\"test_both\", when=\"call\").passed\n    rep = reprec.matchreport(\"test_both\", when=\"teardown\")\n    assert rep.failed and \"42\" in str(rep.longrepr)\n\n\ndef test_setUpModule(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        values = []\n\n        def setUpModule():\n            values.append(1)\n\n        def tearDownModule():\n            del values[0]\n\n        def test_hello():\n            assert values == [1]\n\n        def test_world():\n            assert values == [1]\n        \"\"\"\n    )\n    result = testdir.runpytest(testpath)\n    result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n\ndef test_setUpModule_failing_no_teardown(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        values = []\n\n        def setUpModule():\n            0/0\n\n        def tearDownModule():\n            values.append(1)\n\n        def test_hello():\n            pass\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    reprec.assertoutcome(passed=0, failed=1)\n    call = reprec.getcalls(\"pytest_runtest_setup\")[0]\n    assert not call.item.module.values", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_exceptions_with_skips_TestTrialUnittest.test_trial_exceptions_with_skips.assert_result_ret_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_TestTrialUnittest.test_trial_exceptions_with_skips_TestTrialUnittest.test_trial_exceptions_with_skips.assert_result_ret_1", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 445, "end_line": 493, "span_ids": ["TestTrialUnittest.test_trial_exceptions_with_skips"], "tokens": 319}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTrialUnittest:\n\n    def test_trial_exceptions_with_skips(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            from twisted.trial import unittest\n            import pytest\n            class TC(unittest.TestCase):\n                def test_hello(self):\n                    pytest.skip(\"skip_in_method\")\n                @pytest.mark.skipif(\"sys.version_info != 1\")\n                def test_hello2(self):\n                    pass\n                @pytest.mark.xfail(reason=\"iwanto\")\n                def test_hello3(self):\n                    assert 0\n                def test_hello4(self):\n                    pytest.xfail(\"i2wanto\")\n                def test_trial_skip(self):\n                    pass\n                test_trial_skip.skip = \"trialselfskip\"\n\n                def test_trial_todo(self):\n                    assert 0\n                test_trial_todo.todo = \"mytodo\"\n\n                def test_trial_todo_success(self):\n                    pass\n                test_trial_todo_success.todo = \"mytodo\"\n\n            class TC2(unittest.TestCase):\n                def setup_class(cls):\n                    pytest.skip(\"skip_in_setup_class\")\n                def test_method(self):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-rxs\", *self.ignore_unclosed_socket_warning)\n        result.stdout.fnmatch_lines_random(\n            [\n                \"*XFAIL*test_trial_todo*\",\n                \"*trialselfskip*\",\n                \"*skip_in_setup_class*\",\n                \"*iwanto*\",\n                \"*i2wanto*\",\n                \"*sys.version_info*\",\n                \"*skip_in_method*\",\n                \"*1 failed*4 skipped*3 xfailed*\",\n            ]\n        )\n        assert result.ret == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_not_shown_in_traceback_test_unittest_expected_failure_for_passing_test_is_fail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_not_shown_in_traceback_test_unittest_expected_failure_for_passing_test_is_fail", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 688, "end_line": 783, "span_ids": ["test_unittest_expected_failure_for_failing_test_is_xfail", "test_unittest_expected_failure_for_passing_test_is_fail", "test_unittest_not_shown_in_traceback", "test_unittest_typerror_traceback", "test_unorderable_types"], "tokens": 605}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_unittest_not_shown_in_traceback(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class t(unittest.TestCase):\n            def test_hello(self):\n                x = 3\n                self.assertEqual(x, 4)\n    \"\"\"\n    )\n    res = testdir.runpytest()\n    res.stdout.no_fnmatch_line(\"*failUnlessEqual*\")\n\n\ndef test_unorderable_types(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class TestJoinEmpty(unittest.TestCase):\n            pass\n\n        def make_test():\n            class Test(unittest.TestCase):\n                pass\n            Test.__name__ = \"TestFoo\"\n            return Test\n        TestFoo = make_test()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.no_fnmatch_line(\"*TypeError*\")\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_unittest_typerror_traceback(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class TestJoinEmpty(unittest.TestCase):\n            def test_hello(self, arg1):\n                pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert \"TypeError\" in result.stdout.str()\n    assert result.ret == 1\n\n\n@pytest.mark.parametrize(\"runner\", [\"pytest\", \"unittest\"])\ndef test_unittest_expected_failure_for_failing_test_is_xfail(testdir, runner):\n    script = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCase(unittest.TestCase):\n            @unittest.expectedFailure\n            def test_failing_test_is_xfail(self):\n                assert False\n        if __name__ == '__main__':\n            unittest.main()\n    \"\"\"\n    )\n    if runner == \"pytest\":\n        result = testdir.runpytest(\"-rxX\")\n        result.stdout.fnmatch_lines(\n            [\"*XFAIL*MyTestCase*test_failing_test_is_xfail*\", \"*1 xfailed*\"]\n        )\n    else:\n        result = testdir.runpython(script)\n        result.stderr.fnmatch_lines([\"*1 test in*\", \"*OK*(expected failures=1)*\"])\n    assert result.ret == 0\n\n\n@pytest.mark.parametrize(\"runner\", [\"pytest\", \"unittest\"])\ndef test_unittest_expected_failure_for_passing_test_is_fail(testdir, runner):\n    script = testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class MyTestCase(unittest.TestCase):\n            @unittest.expectedFailure\n            def test_passing_test_is_fail(self):\n                assert True\n        if __name__ == '__main__':\n            unittest.main()\n    \"\"\"\n    )\n\n    if runner == \"pytest\":\n        result = testdir.runpytest(\"-rxX\")\n        result.stdout.fnmatch_lines(\n            [\"*MyTestCase*test_passing_test_is_fail*\", \"*1 failed*\"]\n        )\n    else:\n        result = testdir.runpython(script)\n        result.stderr.fnmatch_lines([\"*1 test in*\", \"*(unexpected successes=1)*\"])\n\n    assert result.ret == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warning_types.py_inspect_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warning_types.py_inspect_", "embedding": null, "metadata": {"file_path": "testing/test_warning_types.py", "file_name": "test_warning_types.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 38, "span_ids": ["imports", "test_pytest_warnings_repr_integration_test", "test_warning_types"], "tokens": 224}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import inspect\n\nimport _pytest.warning_types\nimport pytest\n\n\n@pytest.mark.parametrize(\n    \"warning_class\",\n    [\n        w\n        for n, w in vars(_pytest.warning_types).items()\n        if inspect.isclass(w) and issubclass(w, Warning)\n    ],\n)\ndef test_warning_types(warning_class):\n    \"\"\"Make sure all warnings declared in _pytest.warning_types are displayed as coming\n    from 'pytest' instead of the internal module (#5452).\n    \"\"\"\n    assert warning_class.__module__ == \"pytest\"\n\n\n@pytest.mark.filterwarnings(\"error::pytest.PytestWarning\")\ndef test_pytest_warnings_repr_integration_test(testdir):\n    \"\"\"Small integration test to ensure our small hack of setting the __module__ attribute\n    of our warnings actually works (#5452).\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import warnings\n\n        def test():\n            warnings.warn(pytest.PytestWarning(\"some warning\"))\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"E       pytest.PytestWarning: some warning\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_ignore_test_filterwarnings_mark_registration": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_ignore_test_filterwarnings_mark_registration", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 111, "end_line": 238, "span_ids": ["test_filterwarnings_mark", "test_filterwarnings_mark_registration", "test_ignore", "test_non_string_warning_argument", "test_unicode", "test_works_with_filterwarnings"], "tokens": 732}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"method\", [\"cmdline\", \"ini\"])\ndef test_ignore(testdir, pyfile_with_warnings, method):\n    args = (\"-W\", \"ignore\") if method == \"cmdline\" else ()\n    if method == \"ini\":\n        testdir.makeini(\n            \"\"\"\n        [pytest]\n        filterwarnings= ignore\n        \"\"\"\n        )\n\n    result = testdir.runpytest(*args, pyfile_with_warnings)\n    result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n    assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()\n\n\n@pytest.mark.filterwarnings(\"always\")\ndef test_unicode(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import warnings\n        import pytest\n\n\n        @pytest.fixture\n        def fix():\n            warnings.warn(\"\u6d4b\u8bd5\")\n            yield\n\n        def test_func(fix):\n            pass\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n            \"*test_unicode.py:7: UserWarning: \\u6d4b\\u8bd5*\",\n            \"* 1 passed, 1 warning*\",\n        ]\n    )\n\n\ndef test_works_with_filterwarnings(testdir):\n    \"\"\"Ensure our warnings capture does not mess with pre-installed filters (#2430).\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import warnings\n\n        class MyWarning(Warning):\n            pass\n\n        warnings.filterwarnings(\"error\", category=MyWarning)\n\n        class TestWarnings(object):\n            def test_my_warning(self):\n                try:\n                    warnings.warn(MyWarning(\"warn!\"))\n                    assert False\n                except MyWarning:\n                    assert True\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*== 1 passed in *\"])\n\n\n@pytest.mark.parametrize(\"default_config\", [\"ini\", \"cmdline\"])\ndef test_filterwarnings_mark(testdir, default_config):\n    \"\"\"\n    Test ``filterwarnings`` mark works and takes precedence over command line and ini options.\n    \"\"\"\n    if default_config == \"ini\":\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            filterwarnings = always\n        \"\"\"\n        )\n    testdir.makepyfile(\n        \"\"\"\n        import warnings\n        import pytest\n\n        @pytest.mark.filterwarnings('ignore::RuntimeWarning')\n        def test_ignore_runtime_warning():\n            warnings.warn(RuntimeWarning())\n\n        @pytest.mark.filterwarnings('error')\n        def test_warning_error():\n            warnings.warn(RuntimeWarning())\n\n        def test_show_warning():\n            warnings.warn(RuntimeWarning())\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-W always\" if default_config == \"cmdline\" else \"\")\n    result.stdout.fnmatch_lines([\"*= 1 failed, 2 passed, 1 warning in *\"])\n\n\ndef test_non_string_warning_argument(testdir):\n    \"\"\"Non-str argument passed to warning breaks pytest (#2956)\"\"\"\n    testdir.makepyfile(\n        \"\"\"\\\n        import warnings\n        import pytest\n\n        def test():\n            warnings.warn(UserWarning(1, 'foo'))\n        \"\"\"\n    )\n    result = testdir.runpytest(\"-W\", \"always\")\n    result.stdout.fnmatch_lines([\"*= 1 passed, 1 warning in *\"])\n\n\ndef test_filterwarnings_mark_registration(testdir):\n    \"\"\"Ensure filterwarnings mark is registered\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.mark.filterwarnings('error')\n        def test_func():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--strict-markers\")\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_DummyRewriteHook_pytest_collection": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_DummyRewriteHook_pytest_collection", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 71, "end_line": 110, "span_ids": ["AssertionState", "AssertionState.__init__", "DummyRewriteHook", "DummyRewriteHook.mark_rewrite", "install_importhook", "pytest_collection"], "tokens": 309}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names):\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config, mode):\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config):\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo():\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__Rewrite_assertion_AST__PYC_TAIL": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__Rewrite_assertion_AST__PYC_TAIL", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 45, "span_ids": ["docstring"], "tokens": 260}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Rewrite assertion AST to produce nice error messages\"\"\"\nimport ast\nimport errno\nimport functools\nimport importlib.abc\nimport importlib.machinery\nimport importlib.util\nimport io\nimport itertools\nimport marshal\nimport os\nimport struct\nimport sys\nimport tokenize\nimport types\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Set\nfrom typing import Tuple\n\nfrom _pytest._io.saferepr import saferepr\nfrom _pytest._version import version\nfrom _pytest.assertion import util\nfrom _pytest.assertion.util import (  # noqa: F401\n    format_explanation as _format_explanation,\n)\nfrom _pytest.compat import fspath\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.pathlib import fnmatch_ex\nfrom _pytest.pathlib import Path\nfrom _pytest.pathlib import PurePath\nfrom _pytest.store import StoreKey\n\nif TYPE_CHECKING:\n    from _pytest.assertion import AssertionState  # noqa: F401\n\n\nassertstate_key = StoreKey[\"AssertionState\"]()\n\n\n# pytest caches rewritten pycs in pycache dirs\nPYTEST_TAG = \"{}-pytest-{}\".format(sys.implementation.cache_tag, version)\nPYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\nPYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook_AssertionRewritingHook._find_spec": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewritingHook_AssertionRewritingHook._find_spec", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 48, "end_line": 72, "span_ids": ["AssertionRewritingHook", "AssertionRewritingHook.__init__", "AssertionRewritingHook.set_session", "AssertionRewritingHook:3"], "tokens": 255}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n\n    def __init__(self, config):\n        self.config = config\n        try:\n            self.fnpats = config.getini(\"python_files\")\n        except ValueError:\n            self.fnpats = [\"test_*.py\", \"*_test.py\"]\n        self.session = None\n        self._rewritten_names = set()  # type: Set[str]\n        self._must_rewrite = set()  # type: Set[str]\n        # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n        # which might result in infinite recursion (#3506)\n        self._writing_pyc = False\n        self._basenames_to_check_rewrite = {\"conftest\"}\n        self._marked_for_rewrite_cache = {}  # type: Dict[str, bool]\n        self._session_paths_checked = False\n\n    def set_session(self, session):\n        self.session = session\n        self._session_paths_checked = False\n\n    # Indirection so we can mock calls to find_spec originated from the hook during testing\n    _find_spec = importlib.machinery.PathFinder.find_spec", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fail_fixturefunc__eval_scope_callable": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fail_fixturefunc__eval_scope_callable", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 783, "end_line": 836, "span_ids": ["_eval_scope_callable", "_teardown_yield_fixture", "call_fixture_func", "fail_fixturefunc"], "tokens": 409}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"{}:{}\".format(fs, lineno + 1)\n    source = _pytest._code.Source(fixturefunc)\n    fail(msg + \":\\n\\n\" + str(source.indent()) + \"\\n\" + location, pytrace=False)\n\n\ndef call_fixture_func(fixturefunc, request, kwargs):\n    yieldctx = is_generator(fixturefunc)\n    if yieldctx:\n        generator = fixturefunc(**kwargs)\n        try:\n            fixture_result = next(generator)\n        except StopIteration:\n            raise ValueError(\n                \"{} did not yield a value\".format(request.fixturename)\n            ) from None\n        finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)\n        request.addfinalizer(finalizer)\n    else:\n        fixture_result = fixturefunc(**kwargs)\n    return fixture_result\n\n\ndef _teardown_yield_fixture(fixturefunc, it):\n    \"\"\"Executes the teardown of a fixture function by advancing the iterator after the\n    yield and ensure the iteration ends (if not it means there is more than one yield in the function)\"\"\"\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        fail_fixturefunc(\n            fixturefunc, \"yield_fixture function has more than one 'yield'\"\n        )\n\n\ndef _eval_scope_callable(scope_callable, fixture_name, config):\n    try:\n        result = scope_callable(fixture_name=fixture_name, config=config)\n    except Exception:\n        raise TypeError(\n            \"Error evaluating {} while defining fixture '{}'.\\n\"\n            \"Expected a function with the signature (*, fixture_name, config)\".format(\n                scope_callable, fixture_name\n            )\n        )\n    if not isinstance(result, str):\n        fail(\n            \"Expected {} to return a 'str' while defining fixture '{}', but it returned:\\n\"\n            \"{!r}\".format(scope_callable, fixture_name, result),\n            pytrace=False,\n        )\n    return result", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_yield_fixture_pytest_addoption": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_yield_fixture_pytest_addoption", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1163, "end_line": 1208, "span_ids": ["pytest_addoption", "pytestconfig", "yield_fixture"], "tokens": 219}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def yield_fixture(\n    fixture_function=None,\n    *args,\n    scope=\"function\",\n    params=None,\n    autouse=False,\n    ids=None,\n    name=None\n):\n    \"\"\" (return a) decorator to mark a yield-fixture factory function.\n\n    .. deprecated:: 3.0\n        Use :py:func:`pytest.fixture` directly instead.\n    \"\"\"\n    return fixture(\n        fixture_function,\n        *args,\n        scope=scope,\n        params=params,\n        autouse=autouse,\n        ids=ids,\n        name=name,\n    )\n\n\n@fixture(scope=\"session\")\ndef pytestconfig(request):\n    \"\"\"Session-scoped fixture that returns the :class:`_pytest.config.Config` object.\n\n    Example::\n\n        def test_foo(pytestconfig):\n            if pytestconfig.getoption(\"verbose\") > 0:\n                ...\n\n    \"\"\"\n    return request.config\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"usefixtures\",\n        type=\"args\",\n        default=[],\n        help=\"list of default fixtures to be used with this project\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pastebin.py__submit_failure_or_tes_pytest_unconfigure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pastebin.py__submit_failure_or_tes_pytest_unconfigure", "embedding": null, "metadata": {"file_path": "src/_pytest/pastebin.py", "file_name": "pastebin.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 61, "span_ids": ["docstring", "pytest_addoption", "pytest_configure", "pytest_unconfigure"], "tokens": 459}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" submit failure or test session information to a pastebin service. \"\"\"\nimport tempfile\nfrom io import StringIO\nfrom typing import IO\n\nimport pytest\nfrom _pytest.store import StoreKey\n\n\npastebinfile_key = StoreKey[IO[bytes]]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"terminal reporting\")\n    group._addoption(\n        \"--pastebin\",\n        metavar=\"mode\",\n        action=\"store\",\n        dest=\"pastebin\",\n        default=None,\n        choices=[\"failed\", \"all\"],\n        help=\"send failed|all info to bpaste.net pastebin service.\",\n    )\n\n\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    if config.option.pastebin == \"all\":\n        tr = config.pluginmanager.getplugin(\"terminalreporter\")\n        # if no terminal reporter plugin is present, nothing we can do here;\n        # this can happen when this function executes in a slave node\n        # when using pytest-xdist, for example\n        if tr is not None:\n            # pastebin file will be utf-8 encoded binary file\n            config._store[pastebinfile_key] = tempfile.TemporaryFile(\"w+b\")\n            oldwrite = tr._tw.write\n\n            def tee_write(s, **kwargs):\n                oldwrite(s, **kwargs)\n                if isinstance(s, str):\n                    s = s.encode(\"utf-8\")\n                config._store[pastebinfile_key].write(s)\n\n            tr._tw.write = tee_write\n\n\ndef pytest_unconfigure(config):\n    if pastebinfile_key in config._store:\n        pastebinfile = config._store[pastebinfile_key]\n        # get terminal contents and delete file\n        pastebinfile.seek(0)\n        sessionlog = pastebinfile.read()\n        pastebinfile.close()\n        del config._store[pastebinfile_key]\n        # undo our patching in the terminal reporter\n        tr = config.pluginmanager.getplugin(\"terminalreporter\")\n        del tr._tw.__dict__[\"write\"]\n        # write summary\n        tr.write_sep(\"=\", \"Sending information to Paste Service\")\n        pastebinurl = create_new_paste(sessionlog)\n        tr.write_line(\"pastebin session-log: %s\\n\" % pastebinurl)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pastebin.py_create_new_paste_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pastebin.py_create_new_paste_", "embedding": null, "metadata": {"file_path": "src/_pytest/pastebin.py", "file_name": "pastebin.py", "file_type": "text/x-python", "category": "implementation", "start_line": 64, "end_line": 110, "span_ids": ["create_new_paste", "pytest_terminal_summary"], "tokens": 389}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def create_new_paste(contents):\n    \"\"\"\n    Creates a new paste using bpaste.net service.\n\n    :contents: paste contents as utf-8 encoded bytes\n    :returns: url to the pasted contents or error message\n    \"\"\"\n    import re\n    from urllib.request import urlopen\n    from urllib.parse import urlencode\n\n    params = {\"code\": contents, \"lexer\": \"text\", \"expiry\": \"1week\"}\n    url = \"https://bpaste.net\"\n    try:\n        response = (\n            urlopen(url, data=urlencode(params).encode(\"ascii\")).read().decode(\"utf-8\")\n        )\n    except OSError as exc_info:  # urllib errors\n        return \"bad response: %s\" % exc_info\n    m = re.search(r'href=\"/raw/(\\w+)\"', response)\n    if m:\n        return \"{}/show/{}\".format(url, m.group(1))\n    else:\n        return \"bad response: invalid format ('\" + response + \"')\"\n\n\ndef pytest_terminal_summary(terminalreporter):\n    import _pytest.config\n\n    if terminalreporter.config.option.pastebin != \"failed\":\n        return\n    tr = terminalreporter\n    if \"failed\" in tr.stats:\n        terminalreporter.write_sep(\"=\", \"Sending information to Paste Service\")\n        for rep in terminalreporter.stats.get(\"failed\"):\n            try:\n                msg = rep.longrepr.reprtraceback.reprentries[-1].reprfileloc\n            except AttributeError:\n                msg = tr._getfailureheadline(rep)\n            file = StringIO()\n            tw = _pytest.config.create_terminal_writer(terminalreporter.config, file)\n            rep.toterminal(tw)\n            s = file.getvalue()\n            assert len(s)\n            pastebinurl = create_new_paste(s)\n            tr.write_line(\"{} --> {}\".format(msg, pastebinurl))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_from_io_import_StringIO_getslaveinfoline": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/reports.py_from_io_import_StringIO_getslaveinfoline", "embedding": null, "metadata": {"file_path": "src/_pytest/reports.py", "file_name": "reports.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 38, "span_ids": ["getslaveinfoline", "imports"], "tokens": 263}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from io import StringIO\nfrom pprint import pprint\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n\nimport attr\nimport py\n\nfrom _pytest._code.code import ExceptionChainRepr\nfrom _pytest._code.code import ExceptionInfo\nfrom _pytest._code.code import ReprEntry\nfrom _pytest._code.code import ReprEntryNative\nfrom _pytest._code.code import ReprExceptionInfo\nfrom _pytest._code.code import ReprFileLocation\nfrom _pytest._code.code import ReprFuncArgs\nfrom _pytest._code.code import ReprLocals\nfrom _pytest._code.code import ReprTraceback\nfrom _pytest._code.code import TerminalRepr\nfrom _pytest._io import TerminalWriter\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.nodes import Node\nfrom _pytest.outcomes import skip\nfrom _pytest.pathlib import Path\n\n\ndef getslaveinfoline(node):\n    try:\n        return node._slaveinfocache\n    except AttributeError:\n        d = node.slaveinfo\n        ver = \"%s.%s.%s\" % d[\"version_info\"][:3]\n        node._slaveinfocache = s = \"[{}] {} -- Python {} {}\".format(\n            d[\"id\"], d[\"sysplatform\"], ver, d[\"executable\"]\n        )\n        return s", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_runtest_makereport_pytest_make_collect_report.return_rep": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_runtest_makereport_pytest_make_collect_report.return_rep", "embedding": null, "metadata": {"file_path": "src/_pytest/runner.py", "file_name": "runner.py", "file_type": "text/x-python", "category": "implementation", "start_line": 285, "end_line": 317, "span_ids": ["pytest_make_collect_report", "pytest_runtest_makereport"], "tokens": 288}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_runtest_makereport(item, call):\n    return TestReport.from_item_and_call(item, call)\n\n\ndef pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr = None\n    if not call.excinfo:\n        outcome = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"unittest\")\n        if unittest is not None:\n            # Type ignored because unittest is loaded dynamically.\n            skip_exceptions.append(unittest.SkipTest)  # type: ignore\n        if call.excinfo.errisinstance(tuple(skip_exceptions)):\n            outcome = \"skipped\"\n            r_ = collector._repr_failure_py(call.excinfo, \"line\")\n            assert isinstance(r_, ExceptionChainRepr), repr(r_)\n            r = r_.reprcrash\n            assert r\n            longrepr = (str(r.path), r.lineno, r.message)\n        else:\n            outcome = \"failed\"\n            errorinfo = collector.repr_failure(call.excinfo)\n            if not hasattr(errorinfo, \"toterminal\"):\n                errorinfo = CollectErrorRepr(errorinfo)\n            longrepr = errorinfo\n    rep = CollectReport(\n        collector.nodeid, outcome, longrepr, getattr(call, \"result\", None)\n    )\n    rep.call = call  # type: ignore # see collect_one_node\n    return rep", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setuponly.py_pytest_pytest_fixture_post_finalizer": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/setuponly.py_pytest_pytest_fixture_post_finalizer", "embedding": null, "metadata": {"file_path": "src/_pytest/setuponly.py", "file_name": "setuponly.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 43, "span_ids": ["imports", "pytest_addoption", "pytest_fixture_post_finalizer", "pytest_fixture_setup"], "tokens": 292}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--setuponly\",\n        \"--setup-only\",\n        action=\"store_true\",\n        help=\"only setup fixtures, do not execute tests.\",\n    )\n    group.addoption(\n        \"--setupshow\",\n        \"--setup-show\",\n        action=\"store_true\",\n        help=\"show setup of fixtures while executing tests.\",\n    )\n\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_fixture_setup(fixturedef, request):\n    yield\n    if request.config.option.setupshow:\n        if hasattr(request, \"param\"):\n            # Save the fixture parameter so ._show_fixture_action() can\n            # display it now and during the teardown (in .finish()).\n            if fixturedef.ids:\n                if callable(fixturedef.ids):\n                    fixturedef.cached_param = fixturedef.ids(request.param)\n                else:\n                    fixturedef.cached_param = fixturedef.ids[request.param_index]\n            else:\n                fixturedef.cached_param = request.param\n        _show_fixture_action(fixturedef, \"SETUP\")\n\n\ndef pytest_fixture_post_finalizer(fixturedef) -> None:\n    if fixturedef.cached_result is not None:\n        config = fixturedef._fixturemanager.config\n        if config.option.setupshow:\n            _show_fixture_action(fixturedef, \"TEARDOWN\")\n            if hasattr(fixturedef, \"cached_param\"):\n                del fixturedef.cached_param", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_mismatch_various_TestFixtureMarker.test_parametrize_and_scope": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_mismatch_various_TestFixtureMarker.test_parametrize_and_scope", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2193, "end_line": 2322, "span_ids": ["TestFixtureMarker.test_dynamic_scope", "TestFixtureMarker.test_dynamic_scope_bad_return", "TestFixtureMarker.test_parametrize_and_scope", "TestFixtureMarker.test_register_only_with_mark", "TestFixtureMarker.test_scope_mismatch_various"], "tokens": 691}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_scope_mismatch_various(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            finalized = []\n            created = []\n            @pytest.fixture(scope=\"function\")\n            def arg(request):\n                pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            test_mod1=\"\"\"\n                import pytest\n                @pytest.fixture(scope=\"session\")\n                def arg(request):\n                    request.getfixturevalue(\"arg\")\n                def test_1(arg):\n                    pass\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret != 0\n        result.stdout.fnmatch_lines(\n            [\"*ScopeMismatch*You tried*function*session*request*\"]\n        )\n\n    def test_dynamic_scope(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n\n            def pytest_addoption(parser):\n                parser.addoption(\"--extend-scope\", action=\"store_true\", default=False)\n\n\n            def dynamic_scope(fixture_name, config):\n                if config.getoption(\"--extend-scope\"):\n                    return \"session\"\n                return \"function\"\n\n\n            @pytest.fixture(scope=dynamic_scope)\n            def dynamic_fixture(calls=[]):\n                calls.append(\"call\")\n                return len(calls)\n\n        \"\"\"\n        )\n\n        testdir.makepyfile(\n            \"\"\"\n            def test_first(dynamic_fixture):\n                assert dynamic_fixture == 1\n\n\n            def test_second(dynamic_fixture):\n                assert dynamic_fixture == 2\n\n        \"\"\"\n        )\n\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n        reprec = testdir.inline_run(\"--extend-scope\")\n        reprec.assertoutcome(passed=1, failed=1)\n\n    def test_dynamic_scope_bad_return(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def dynamic_scope(**_):\n                return \"wrong-scope\"\n\n            @pytest.fixture(scope=dynamic_scope)\n            def fixture():\n                pass\n\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            \"Fixture 'fixture' from test_dynamic_scope_bad_return.py \"\n            \"got an unexpected scope value 'wrong-scope'\"\n        )\n\n    def test_register_only_with_mark(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture()\n            def arg():\n                return 1\n        \"\"\"\n        )\n        testdir.makepyfile(\n            test_mod1=\"\"\"\n                import pytest\n                @pytest.fixture()\n                def arg(arg):\n                    return arg + 1\n                def test_1(arg):\n                    assert arg == 2\n            \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_parametrize_and_scope(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=\"module\", params=[\"a\", \"b\", \"c\"])\n            def arg(request):\n                return request.param\n            values = []\n            def test_param(arg):\n                values.append(arg)\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\")\n        reprec.assertoutcome(passed=3)\n        values = reprec.getcalls(\"pytest_runtest_call\")[0].item.module.values\n        assert len(values) == 3\n        assert \"a\" in values\n        assert \"b\" in values\n        assert \"c\" in values", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_mismatch_TestFixtureMarker.test_parametrize_separated_order": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_scope_mismatch_TestFixtureMarker.test_parametrize_separated_order", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2324, "end_line": 2365, "span_ids": ["TestFixtureMarker.test_parametrize_separated_order", "TestFixtureMarker.test_scope_mismatch"], "tokens": 249}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_scope_mismatch(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=\"function\")\n            def arg(request):\n                pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=\"session\")\n            def arg(arg):\n                pass\n            def test_mismatch(arg):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*ScopeMismatch*\", \"*1 error*\"])\n\n    def test_parametrize_separated_order(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"module\", params=[1, 2])\n            def arg(request):\n                return request.param\n\n            values = []\n            def test_1(arg):\n                values.append(arg)\n            def test_2(arg):\n                values.append(arg)\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\")\n        reprec.assertoutcome(passed=4)\n        values = reprec.getcalls(\"pytest_runtest_call\")[0].item.module.values\n        assert values == [1, 1, 2, 2]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewFirst.test_newfirst_parametrize_TestNewFirst.test_newfirst_parametrize.None_7": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewFirst.test_newfirst_parametrize_TestNewFirst.test_newfirst_parametrize.None_7", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 939, "end_line": 1000, "span_ids": ["TestNewFirst.test_newfirst_parametrize"], "tokens": 566}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNewFirst:\n\n    def test_newfirst_parametrize(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"test_1/test_1.py\": \"\"\"\n                import pytest\n                @pytest.mark.parametrize('num', [1, 2])\n                def test_1(num): assert num\n            \"\"\",\n                \"test_2/test_2.py\": \"\"\"\n                import pytest\n                @pytest.mark.parametrize('num', [1, 2])\n                def test_1(num): assert num\n            \"\"\",\n            }\n        )\n\n        testdir.tmpdir.join(\"test_1/test_1.py\").setmtime(1)\n\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_1/test_1.py::test_1[1*\",\n                \"*test_1/test_1.py::test_1[2*\",\n                \"*test_2/test_2.py::test_1[1*\",\n                \"*test_2/test_2.py::test_1[2*\",\n            ]\n        )\n\n        result = testdir.runpytest(\"-v\", \"--nf\")\n\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_2/test_2.py::test_1[1*\",\n                \"*test_2/test_2.py::test_1[2*\",\n                \"*test_1/test_1.py::test_1[1*\",\n                \"*test_1/test_1.py::test_1[2*\",\n            ]\n        )\n\n        testdir.tmpdir.join(\"test_1/test_1.py\").write(\n            \"import pytest\\n\"\n            \"@pytest.mark.parametrize('num', [1, 2, 3])\\n\"\n            \"def test_1(num): assert num\\n\"\n        )\n        testdir.tmpdir.join(\"test_1/test_1.py\").setmtime(1)\n\n        # Running only a subset does not forget about existing ones.\n        result = testdir.runpytest(\"-v\", \"--nf\", \"test_2/test_2.py\")\n        result.stdout.fnmatch_lines(\n            [\"*test_2/test_2.py::test_1[1*\", \"*test_2/test_2.py::test_1[2*\"]\n        )\n\n        result = testdir.runpytest(\"-v\", \"--nf\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_1/test_1.py::test_1[3*\",\n                \"*test_2/test_2.py::test_1[1*\",\n                \"*test_2/test_2.py::test_1[2*\",\n                \"*test_1/test_1.py::test_1[1*\",\n                \"*test_1/test_1.py::test_1[2*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_os_TestConftestValueAccessGlobal.test_value_access_with_confmod": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_conftest.py_os_TestConftestValueAccessGlobal.test_value_access_with_confmod", "embedding": null, "metadata": {"file_path": "testing/test_conftest.py", "file_name": "test_conftest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 77, "span_ids": ["ConftestWithSetinitial", "TestConftestValueAccessGlobal", "TestConftestValueAccessGlobal.basedir", "TestConftestValueAccessGlobal.test_basic_init", "TestConftestValueAccessGlobal.test_immediate_initialiation_and_incremental_are_the_same", "TestConftestValueAccessGlobal.test_value_access_by_path", "TestConftestValueAccessGlobal.test_value_access_not_existing", "TestConftestValueAccessGlobal.test_value_access_with_confmod", "conftest_setinitial", "imports"], "tokens": 740}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport textwrap\n\nimport py\n\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.pathlib import Path\n\n\ndef ConftestWithSetinitial(path):\n    conftest = PytestPluginManager()\n    conftest_setinitial(conftest, [path])\n    return conftest\n\n\ndef conftest_setinitial(conftest, args, confcutdir=None):\n    class Namespace:\n        def __init__(self):\n            self.file_or_dir = args\n            self.confcutdir = str(confcutdir)\n            self.noconftest = False\n            self.pyargs = False\n\n    conftest._set_initial_conftests(Namespace())\n\n\n@pytest.mark.usefixtures(\"_sys_snapshot\")\nclass TestConftestValueAccessGlobal:\n    @pytest.fixture(scope=\"module\", params=[\"global\", \"inpackage\"])\n    def basedir(self, request, tmpdir_factory):\n        tmpdir = tmpdir_factory.mktemp(\"basedir\", numbered=True)\n        tmpdir.ensure(\"adir/conftest.py\").write(\"a=1 ; Directory = 3\")\n        tmpdir.ensure(\"adir/b/conftest.py\").write(\"b=2 ; a = 1.5\")\n        if request.param == \"inpackage\":\n            tmpdir.ensure(\"adir/__init__.py\")\n            tmpdir.ensure(\"adir/b/__init__.py\")\n\n        yield tmpdir\n\n    def test_basic_init(self, basedir):\n        conftest = PytestPluginManager()\n        p = basedir.join(\"adir\")\n        assert conftest._rget_with_confmod(\"a\", p)[1] == 1\n\n    def test_immediate_initialiation_and_incremental_are_the_same(self, basedir):\n        conftest = PytestPluginManager()\n        assert not len(conftest._dirpath2confmods)\n        conftest._getconftestmodules(basedir)\n        snap1 = len(conftest._dirpath2confmods)\n        assert snap1 == 1\n        conftest._getconftestmodules(basedir.join(\"adir\"))\n        assert len(conftest._dirpath2confmods) == snap1 + 1\n        conftest._getconftestmodules(basedir.join(\"b\"))\n        assert len(conftest._dirpath2confmods) == snap1 + 2\n\n    def test_value_access_not_existing(self, basedir):\n        conftest = ConftestWithSetinitial(basedir)\n        with pytest.raises(KeyError):\n            conftest._rget_with_confmod(\"a\", basedir)\n\n    def test_value_access_by_path(self, basedir):\n        conftest = ConftestWithSetinitial(basedir)\n        adir = basedir.join(\"adir\")\n        assert conftest._rget_with_confmod(\"a\", adir)[1] == 1\n        assert conftest._rget_with_confmod(\"a\", adir.join(\"b\"))[1] == 1.5\n\n    def test_value_access_with_confmod(self, basedir):\n        startdir = basedir.join(\"adir\", \"b\")\n        startdir.ensure(\"xx\", dir=True)\n        conftest = ConftestWithSetinitial(startdir)\n        mod, value = conftest._rget_with_confmod(\"a\", startdir)\n        assert value == 1.5\n        path = py.path.local(mod.__file__)\n        assert path.dirpath() == basedir.join(\"adir\", \"b\")\n        assert path.purebasename.startswith(\"conftest\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_outcomeexception_exceptionattributes_test_pytest_fail_notrace_collection": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_outcomeexception_exceptionattributes_test_pytest_fail_notrace_collection", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 527, "end_line": 635, "span_ids": ["_strip_resource_warnings", "test_outcomeexception_exceptionattributes", "test_outcomeexception_passes_except_Exception", "test_pytest_exit", "test_pytest_exit_msg", "test_pytest_exit_returncode", "test_pytest_fail", "test_pytest_fail_notrace_collection", "test_pytest_fail_notrace_runtest"], "tokens": 700}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_outcomeexception_exceptionattributes() -> None:\n    outcome = outcomes.OutcomeException(\"test\")\n    assert outcome.args[0] == outcome.msg\n\n\ndef test_outcomeexception_passes_except_Exception() -> None:\n    with pytest.raises(outcomes.OutcomeException):\n        try:\n            raise outcomes.OutcomeException(\"test\")\n        except Exception:\n            raise NotImplementedError()\n\n\ndef test_pytest_exit() -> None:\n    with pytest.raises(pytest.exit.Exception) as excinfo:\n        pytest.exit(\"hello\")\n    assert excinfo.errisinstance(pytest.exit.Exception)\n\n\ndef test_pytest_fail() -> None:\n    with pytest.raises(pytest.fail.Exception) as excinfo:\n        pytest.fail(\"hello\")\n    s = excinfo.exconly(tryshort=True)\n    assert s.startswith(\"Failed\")\n\n\ndef test_pytest_exit_msg(testdir) -> None:\n    testdir.makeconftest(\n        \"\"\"\n    import pytest\n\n    def pytest_configure(config):\n        pytest.exit('oh noes')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stderr.fnmatch_lines([\"Exit: oh noes\"])\n\n\ndef _strip_resource_warnings(lines):\n    # Assert no output on stderr, except for unreliable ResourceWarnings.\n    # (https://github.com/pytest-dev/pytest/issues/5088)\n    return [\n        x\n        for x in lines\n        if not x.startswith((\"Exception ignored in:\", \"ResourceWarning\"))\n    ]\n\n\ndef test_pytest_exit_returncode(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\\\n        import pytest\n        def test_foo():\n            pytest.exit(\"some exit msg\", 99)\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*! *Exit: some exit msg !*\"])\n\n    assert _strip_resource_warnings(result.stderr.lines) == []\n    assert result.ret == 99\n\n    # It prints to stderr also in case of exit during pytest_sessionstart.\n    testdir.makeconftest(\n        \"\"\"\\\n        import pytest\n\n        def pytest_sessionstart():\n            pytest.exit(\"during_sessionstart\", 98)\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*! *Exit: during_sessionstart !*\"])\n    assert _strip_resource_warnings(result.stderr.lines) == [\n        \"Exit: during_sessionstart\"\n    ]\n    assert result.ret == 98\n\n\ndef test_pytest_fail_notrace_runtest(testdir) -> None:\n    \"\"\"Test pytest.fail(..., pytrace=False) does not show tracebacks during test run.\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_hello():\n            pytest.fail(\"hello\", pytrace=False)\n        def teardown_function(function):\n            pytest.fail(\"world\", pytrace=False)\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"world\", \"hello\"])\n    result.stdout.no_fnmatch_line(\"*def teardown_function*\")\n\n\ndef test_pytest_fail_notrace_collection(testdir) -> None:\n    \"\"\"Test pytest.fail(..., pytrace=False) does not show tracebacks during collection.\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def some_internal_function():\n            pytest.fail(\"hello\", pytrace=False)\n        some_internal_function()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"hello\"])\n    result.stdout.no_fnmatch_line(\"*def some_internal_function()*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_pytest_fail_notrace_non_ascii_test_exception_printing_skip": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_pytest_fail_notrace_non_ascii_test_exception_printing_skip", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 638, "end_line": 685, "span_ids": ["test_exception_printing_skip", "test_pytest_fail_notrace_non_ascii", "test_pytest_no_tests_collected_exit_status"], "tokens": 370}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_pytest_fail_notrace_non_ascii(testdir) -> None:\n    \"\"\"Fix pytest.fail with pytrace=False with non-ascii characters (#1178).\n\n    This tests with native and unicode strings containing non-ascii chars.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\\\n        import pytest\n\n        def test_hello():\n            pytest.fail('oh oh: \u263a', pytrace=False)\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*test_hello*\", \"oh oh: \u263a\"])\n    result.stdout.no_fnmatch_line(\"*def test_hello*\")\n\n\ndef test_pytest_no_tests_collected_exit_status(testdir) -> None:\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*collected 0 items*\"])\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n    testdir.makepyfile(\n        test_foo=\"\"\"\n        def test_foo():\n            assert 1\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*collected 1 item*\"])\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n    assert result.ret == ExitCode.OK\n\n    result = testdir.runpytest(\"-k nonmatch\")\n    result.stdout.fnmatch_lines([\"*collected 1 item*\"])\n    result.stdout.fnmatch_lines([\"*1 deselected*\"])\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_exception_printing_skip() -> None:\n    assert pytest.skip.Exception == pytest.skip.Exception\n    try:\n        pytest.skip(\"hello\")\n    except pytest.skip.Exception:\n        excinfo = _pytest._code.ExceptionInfo.from_current()\n        s = excinfo.exconly(tryshort=True)\n        assert s.startswith(\"Skipped\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestRmRf.test_on_rm_rf_error_TestRmRf.test_on_rm_rf_error.assert_not_fn_is_file_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_TestRmRf.test_on_rm_rf_error_TestRmRf.test_on_rm_rf_error.assert_not_fn_is_file_", "embedding": null, "metadata": {"file_path": "testing/test_tmpdir.py", "file_name": "test_tmpdir.py", "file_type": "text/x-python", "category": "test", "start_line": 370, "end_line": 406, "span_ids": ["TestRmRf.test_on_rm_rf_error"], "tokens": 294}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRmRf:\n\n    def test_on_rm_rf_error(self, tmp_path):\n        adir = tmp_path / \"dir\"\n        adir.mkdir()\n\n        fn = adir / \"foo.txt\"\n        fn.touch()\n        self.chmod_r(fn)\n\n        # unknown exception\n        with pytest.warns(pytest.PytestWarning):\n            exc_info = (None, RuntimeError(), None)\n            on_rm_rf_error(os.unlink, str(fn), exc_info, start_path=tmp_path)\n            assert fn.is_file()\n\n        # we ignore FileNotFoundError\n        exc_info = (None, FileNotFoundError(), None)\n        assert not on_rm_rf_error(None, str(fn), exc_info, start_path=tmp_path)\n\n        # unknown function\n        with pytest.warns(\n            pytest.PytestWarning,\n            match=r\"^\\(rm_rf\\) unknown function None when removing .*foo.txt:\\nNone: \",\n        ):\n            exc_info = (None, PermissionError(), None)\n            on_rm_rf_error(None, str(fn), exc_info, start_path=tmp_path)\n            assert fn.is_file()\n\n        # ignored function\n        with pytest.warns(None) as warninfo:\n            exc_info = (None, PermissionError(), None)\n            on_rm_rf_error(os.open, str(fn), exc_info, start_path=tmp_path)\n            assert fn.is_file()\n        assert not [x.message for x in warninfo]\n\n        exc_info = (None, PermissionError(), None)\n        on_rm_rf_error(os.unlink, str(fn), exc_info, start_path=tmp_path)\n        assert not fn.is_file()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pkg_init_and_file_in_args_test_collect_pkg_init_and_file_in_args.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pkg_init_and_file_in_args_test_collect_pkg_init_and_file_in_args.None_3", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1177, "end_line": 1203, "span_ids": ["test_collect_pkg_init_and_file_in_args"], "tokens": 239}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collect_pkg_init_and_file_in_args(testdir):\n    subdir = testdir.mkdir(\"sub\")\n    init = subdir.ensure(\"__init__.py\")\n    init.write(\"def test_init(): pass\")\n    p = subdir.ensure(\"test_file.py\")\n    p.write(\"def test_file(): pass\")\n\n    # NOTE: without \"-o python_files=*.py\" this collects test_file.py twice.\n    # This changed/broke with \"Add package scoped fixtures #2283\" (2b1410895)\n    # initially (causing a RecursionError).\n    result = testdir.runpytest(\"-v\", str(init), str(p))\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/test_file.py::test_file PASSED*\",\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*2 passed in*\",\n        ]\n    )\n\n    result = testdir.runpytest(\"-v\", \"-o\", \"python_files=*.py\", str(init), str(p))\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/__init__.py::test_init PASSED*\",\n            \"sub/test_file.py::test_file PASSED*\",\n            \"*2 passed in*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pkg_init_only_test_collect_sub_with_symlinks": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_pkg_init_only_test_collect_sub_with_symlinks", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1206, "end_line": 1242, "span_ids": ["test_collect_pkg_init_only", "test_collect_sub_with_symlinks"], "tokens": 319}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collect_pkg_init_only(testdir):\n    subdir = testdir.mkdir(\"sub\")\n    init = subdir.ensure(\"__init__.py\")\n    init.write(\"def test_init(): pass\")\n\n    result = testdir.runpytest(str(init))\n    result.stdout.fnmatch_lines([\"*no tests ran in*\"])\n\n    result = testdir.runpytest(\"-v\", \"-o\", \"python_files=*.py\", str(init))\n    result.stdout.fnmatch_lines([\"sub/__init__.py::test_init PASSED*\", \"*1 passed in*\"])\n\n\n@pytest.mark.skipif(\n    not hasattr(py.path.local, \"mksymlinkto\"),\n    reason=\"symlink not available on this platform\",\n)\n@pytest.mark.parametrize(\"use_pkg\", (True, False))\ndef test_collect_sub_with_symlinks(use_pkg, testdir):\n    sub = testdir.mkdir(\"sub\")\n    if use_pkg:\n        sub.ensure(\"__init__.py\")\n    sub.ensure(\"test_file.py\").write(\"def test_file(): pass\")\n\n    # Create a broken symlink.\n    sub.join(\"test_broken.py\").mksymlinkto(\"test_doesnotexist.py\")\n\n    # Symlink that gets collected.\n    sub.join(\"test_symlink.py\").mksymlinkto(\"test_file.py\")\n\n    result = testdir.runpytest(\"-v\", str(sub))\n    result.stdout.fnmatch_lines(\n        [\n            \"sub/test_file.py::test_file PASSED*\",\n            \"sub/test_symlink.py::test_file PASSED*\",\n            \"*2 passed in*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collector_respects_tbstyle_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collector_respects_tbstyle_", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1299, "end_line": 1356, "span_ids": ["test_collector_respects_tbstyle", "test_does_not_eagerly_collect_packages", "test_does_not_put_src_on_path", "test_fscollector_from_parent"], "tokens": 480}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collector_respects_tbstyle(testdir):\n    p1 = testdir.makepyfile(\"assert 0\")\n    result = testdir.runpytest(p1, \"--tb=native\")\n    assert result.ret == ExitCode.INTERRUPTED\n    result.stdout.fnmatch_lines(\n        [\n            \"*_ ERROR collecting test_collector_respects_tbstyle.py _*\",\n            \"Traceback (most recent call last):\",\n            '  File \"*/test_collector_respects_tbstyle.py\", line 1, in <module>',\n            \"    assert 0\",\n            \"AssertionError: assert 0\",\n            \"*! Interrupted: 1 error during collection !*\",\n            \"*= 1 error in *\",\n        ]\n    )\n\n\ndef test_does_not_eagerly_collect_packages(testdir):\n    testdir.makepyfile(\"def test(): pass\")\n    pydir = testdir.mkpydir(\"foopkg\")\n    pydir.join(\"__init__.py\").write(\"assert False\")\n    result = testdir.runpytest()\n    assert result.ret == ExitCode.OK\n\n\ndef test_does_not_put_src_on_path(testdir):\n    # `src` is not on sys.path so it should not be importable\n    testdir.tmpdir.join(\"src/nope/__init__.py\").ensure()\n    testdir.makepyfile(\n        \"import pytest\\n\"\n        \"def test():\\n\"\n        \"    with pytest.raises(ImportError):\\n\"\n        \"        import nope\\n\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == ExitCode.OK\n\n\ndef test_fscollector_from_parent(tmpdir, request):\n    \"\"\"Ensure File.from_parent can forward custom arguments to the constructor.\n\n    Context: https://github.com/pytest-dev/pytest-cpp/pull/47\n    \"\"\"\n\n    class MyCollector(pytest.File):\n        def __init__(self, fspath, parent, x):\n            super().__init__(fspath, parent)\n            self.x = x\n\n        @classmethod\n        def from_parent(cls, parent, *, fspath, x):\n            return super().from_parent(parent=parent, fspath=fspath, x=x)\n\n    collector = MyCollector.from_parent(\n        parent=request.session, fspath=tmpdir / \"foo\", x=10\n    )\n    assert collector.x == 10", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py___add_module_names": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py___add_module_names", "embedding": null, "metadata": {"file_path": "doc/en/conf.py", "file_name": "conf.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 106, "span_ids": ["docstring", "docstring:33"], "tokens": 750}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "#\n# pytest documentation build configuration file, created by\n# sphinx-quickstart on Fri Oct  8 17:54:28 2010.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The full version, including alpha/beta/rc tags.\n# The short X.Y version.\nimport os\nimport sys\n\nfrom _pytest import __version__ as version\nfrom _pytest.compat import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import sphinx.application\n\n\nrelease = \".\".join(version.split(\".\")[:2])\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('.'))\n\nautodoc_member_order = \"bysource\"\ntodo_include_todos = 1\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    \"pygments_pytest\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.todo\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx_removed_in\",\n    \"sphinxcontrib_trio\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"contents\"\n\n# General information about the project.\nproject = \"pytest\"\ncopyright = \"2015\u20132020, holger krekel and pytest-dev team\"\n\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\n    \"_build\",\n    \"naming20.rst\",\n    \"test/*\",\n    \"old_*\",\n    \"*attic*\",\n    \"*/attic*\",\n    \"funcargs.rst\",\n    \"setup.rst\",\n    \"example/remoteinterp.rst\",\n]\n\n\n# The reST default role (used for this markup: `text`) to use for all documents.\ndefault_role = \"literal\"\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\nadd_module_names = False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_pygments_style__If_false_no_index_is_g": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_pygments_style__If_false_no_index_is_g", "embedding": null, "metadata": {"file_path": "doc/en/conf.py", "file_name": "conf.py", "file_type": "text/x-python", "category": "implementation", "start_line": 113, "end_line": 209, "span_ids": ["docstring:33", "impl:18", "impl:27"], "tokens": 759}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "pygments_style = \"sphinx\"\n\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# A list of regular expressions that match URIs that should not be checked when\n# doing a linkcheck.\nlinkcheck_ignore = [\n    \"https://github.com/numpy/numpy/blob/master/doc/release/1.16.0-notes.rst#new-deprecations\",\n    \"https://blogs.msdn.microsoft.com/bharry/2017/06/28/testing-in-a-cloud-delivery-cadence/\",\n    \"http://pythontesting.net/framework/pytest-introduction/\",\n    r\"https://github.com/pytest-dev/pytest/issues/\\d+\",\n    r\"https://github.com/pytest-dev/pytest/pull/\\d+\",\n]\n\n# The number of worker threads to use when checking links (default=5).\nlinkcheck_workers = 5\n\n\n# -- Options for HTML output ---------------------------------------------------\n\nsys.path.append(os.path.abspath(\"_themes\"))\nhtml_theme_path = [\"_themes\"]\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"flask\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\"index_logo\": None}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\nhtml_title = \"pytest documentation\"\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\nhtml_short_title = \"pytest-%s\" % release\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\nhtml_logo = \"img/pytest1.png\"\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\nhtml_favicon = \"img/favicon.png\"\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n# html_sidebars = {'index': 'indexsidebar.html'}\n\nhtml_sidebars = {\n    \"index\": [\n        \"slim_searchbox.html\",\n        \"sidebarintro.html\",\n        \"globaltoc.html\",\n        \"links.html\",\n        \"sourcelink.html\",\n    ],\n    \"**\": [\n        \"slim_searchbox.html\",\n        \"globaltoc.html\",\n        \"relations.html\",\n        \"links.html\",\n        \"sourcelink.html\",\n    ],\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n# html_additional_pages = {'index': 'index.html'}\n\n\n# If false, no module index is generated.\nhtml_domain_indices = True\n\n# If false, no index is generated.", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_html_use_index__Example_configuration_f": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_html_use_index__Example_configuration_f", "embedding": null, "metadata": {"file_path": "doc/en/conf.py", "file_name": "conf.py", "file_type": "text/x-python", "category": "implementation", "start_line": 210, "end_line": 345, "span_ids": ["impl:27", "impl:35"], "tokens": 772}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = False\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\nhtmlhelp_basename = \"pytestdoc\"\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# The paper size ('letter' or 'a4').\n# latex_paper_size = 'letter'\n\n# The font size ('10pt', '11pt' or '12pt').\n# latex_font_size = '10pt'\n\n# Grouping the document tree into LaTeX files. List of tuples\nlatex_documents = [\n    (\n        \"contents\",\n        \"pytest.tex\",\n        \"pytest Documentation\",\n        \"holger krekel, trainer and consultant, http://merlinux.eu\",\n        \"manual\",\n    )\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\nlatex_logo = \"img/pytest1.png\"\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Additional stuff for the LaTeX preamble.\n# latex_preamble = ''\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\nlatex_domain_indices = False\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\nman_pages = [(\"usage\", \"pytest\", \"pytest usage\", [\"holger krekel at merlinux eu\"], 1)]\n\n\n# -- Options for Epub output ---------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = \"pytest\"\nepub_author = \"holger krekel at merlinux eu\"\nepub_publisher = \"holger krekel at merlinux eu\"\nepub_copyright = \"2013-2020, holger krekel et alii\"\n\n# The language of the text. It defaults to the language option\n# or en if the language is not set.\n# epub_language = ''\n\n# The scheme of the identifier. Typical schemes are ISBN or URL.\n# epub_scheme = ''\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n# epub_identifier = ''\n\n# A unique identification for the text.\n# epub_uid = ''\n\n# HTML files that should be inserted before the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n# epub_pre_files = []\n\n# HTML files shat should be inserted after the pages created by sphinx.\n# The format is a list of tuples containing the path and title.\n# epub_post_files = []\n\n# A list of files that should not be packed into the epub file.\n# epub_exclude_files = []\n\n# The depth of the table of contents in toc.ncx.\n# epub_tocdepth = 3\n\n# Allow duplicate toc entries.\n# epub_tocdup = True\n\n\n# -- Options for texinfo output ------------------------------------------------\n\ntexinfo_documents = [\n    (\n        master_doc,\n        \"pytest\",\n        \"pytest Documentation\",\n        (\n            \"Holger Krekel@*Benjamin Peterson@*Ronny Pfannschmidt@*\"\n            \"Floris Bruynooghe@*others\"\n        ),\n        \"pytest\",\n        \"simple powerful testing with Python\",\n        \"Programming\",\n        1,\n    )\n]\n\n\n# Example configuration for intersphinx: refer to the Python standard library.", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_intersphinx_mapping_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/doc/en/conf.py_intersphinx_mapping_", "embedding": null, "metadata": {"file_path": "doc/en/conf.py", "file_name": "conf.py", "file_type": "text/x-python", "category": "implementation", "start_line": 346, "end_line": 393, "span_ids": ["configure_logging", "impl:35", "setup"], "tokens": 364}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "intersphinx_mapping = {\n    \"pluggy\": (\"https://pluggy.readthedocs.io/en/latest\", None),\n    \"python\": (\"https://docs.python.org/3\", None),\n}\n\n\ndef configure_logging(app: \"sphinx.application.Sphinx\") -> None:\n    \"\"\"Configure Sphinx's WarningHandler to handle (expected) missing include.\"\"\"\n    import sphinx.util.logging\n    import logging\n\n    class WarnLogFilter(logging.Filter):\n        def filter(self, record: logging.LogRecord) -> bool:\n            \"\"\"Ignore warnings about missing include with \"only\" directive.\n\n            Ref: https://github.com/sphinx-doc/sphinx/issues/2150.\"\"\"\n            if (\n                record.msg.startswith('Problems with \"include\" directive path:')\n                and \"_changelog_towncrier_draft.rst\" in record.msg\n            ):\n                return False\n            return True\n\n    logger = logging.getLogger(sphinx.util.logging.NAMESPACE)\n    warn_handler = [x for x in logger.handlers if x.level == logging.WARNING]\n    assert len(warn_handler) == 1, warn_handler\n    warn_handler[0].filters.insert(0, WarnLogFilter())\n\n\ndef setup(app: \"sphinx.application.Sphinx\") -> None:\n    # from sphinx.ext.autodoc import cut_lines\n    # app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n    app.add_crossref_type(\n        \"fixture\",\n        \"fixture\",\n        objname=\"built-in fixture\",\n        indextemplate=\"pair: %s; fixture\",\n    )\n\n    app.add_object_type(\n        \"confval\",\n        \"confval\",\n        objname=\"configuration value\",\n        indextemplate=\"pair: %s; configuration value\",\n    )\n\n    configure_logging(app)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/append_codecov_token.py___": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/append_codecov_token.py___", "embedding": null, "metadata": {"file_path": "scripts/append_codecov_token.py", "file_name": "append_codecov_token.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 37, "span_ids": ["docstring", "impl", "main"], "tokens": 268}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nAppends the codecov token to the 'codecov.yml' file at the root of the repository.\n\nThis is done by CI during PRs and builds on the pytest-dev repository so we can upload coverage, at least\nuntil codecov grows some native integration like it has with Travis and AppVeyor.\n\nSee discussion in https://github.com/pytest-dev/pytest/pull/6441 for more information.\n\"\"\"\nimport os.path\nfrom textwrap import dedent\n\n\ndef main():\n    this_dir = os.path.dirname(__file__)\n    cov_file = os.path.join(this_dir, \"..\", \"codecov.yml\")\n\n    assert os.path.isfile(cov_file), \"{cov_file} does not exist\".format(\n        cov_file=cov_file\n    )\n\n    with open(cov_file, \"a\") as f:\n        # token from: https://codecov.io/gh/pytest-dev/pytest/settings\n        # use same URL to regenerate it if needed\n        text = dedent(\n            \"\"\"\n            codecov:\n              token: \"1eca3b1f-31a2-4fb8-a8c3-138b441b50a7\"\n        \"\"\"\n        )\n        f.write(text)\n\n    print(\"Token updated:\", cov_file)\n\n\nif __name__ == \"__main__\":\n    main()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/publish-gh-release-notes.py___convert_rst_to_md": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/publish-gh-release-notes.py___convert_rst_to_md", "embedding": null, "metadata": {"file_path": "scripts/publish-gh-release-notes.py", "file_name": "publish-gh-release-notes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 66, "span_ids": ["convert_rst_to_md", "docstring", "parse_changelog", "publish_github_release"], "tokens": 457}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nScript used to publish GitHub release notes extracted from CHANGELOG.rst.\n\nThis script is meant to be executed after a successful deployment in Travis.\n\nUses the following environment variables:\n\n* GIT_TAG: the name of the tag of the current commit.\n* GH_RELEASE_NOTES_TOKEN: a personal access token with 'repo' permissions.\n\n  Create one at:\n\n    https://github.com/settings/tokens\n\n  It should be encrypted using:\n\n    $travis encrypt GH_RELEASE_NOTES_TOKEN=<token> -r pytest-dev/pytest\n\n  And the contents pasted in the ``deploy.env.secure`` section in the ``travis.yml`` file.\n\nThe script also requires ``pandoc`` to be previously installed in the system.\n\nRequires Python3.6+.\n\"\"\"\nimport os\nimport re\nimport sys\nfrom pathlib import Path\n\nimport github3\nimport pypandoc\n\n\ndef publish_github_release(slug, token, tag_name, body):\n    github = github3.login(token=token)\n    owner, repo = slug.split(\"/\")\n    repo = github.repository(owner, repo)\n    return repo.create_release(tag_name=tag_name, body=body)\n\n\ndef parse_changelog(tag_name):\n    p = Path(__file__).parent.parent / \"doc/en/changelog.rst\"\n    changelog_lines = p.read_text(encoding=\"UTF-8\").splitlines()\n\n    title_regex = re.compile(r\"pytest (\\d\\.\\d+\\.\\d+) \\(\\d{4}-\\d{2}-\\d{2}\\)\")\n    consuming_version = False\n    version_lines = []\n    for line in changelog_lines:\n        m = title_regex.match(line)\n        if m:\n            # found the version we want: start to consume lines until we find the next version title\n            if m.group(1) == tag_name:\n                consuming_version = True\n            # found a new version title while parsing the version we want: break out\n            elif consuming_version:\n                break\n        if consuming_version:\n            version_lines.append(line)\n\n    return \"\\n\".join(version_lines)\n\n\ndef convert_rst_to_md(text):\n    return pypandoc.convert_text(\n        text, \"md\", format=\"rst\", extra_args=[\"--wrap=preserve\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/publish-gh-release-notes.py_main_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/publish-gh-release-notes.py_main_", "embedding": null, "metadata": {"file_path": "scripts/publish-gh-release-notes.py", "file_name": "publish-gh-release-notes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 69, "end_line": 106, "span_ids": ["impl", "main"], "tokens": 269}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def main(argv):\n    if len(argv) > 1:\n        tag_name = argv[1]\n    else:\n        tag_name = os.environ.get(\"GITHUB_REF\")\n        if not tag_name:\n            print(\"tag_name not given and $GITHUB_REF not set\", file=sys.stderr)\n            return 1\n        if tag_name.startswith(\"refs/tags/\"):\n            tag_name = tag_name[len(\"refs/tags/\") :]\n\n    token = os.environ.get(\"GH_RELEASE_NOTES_TOKEN\")\n    if not token:\n        print(\"GH_RELEASE_NOTES_TOKEN not set\", file=sys.stderr)\n        return 1\n\n    slug = os.environ.get(\"GITHUB_REPOSITORY\")\n    if not slug:\n        print(\"GITHUB_REPOSITORY not set\", file=sys.stderr)\n        return 1\n\n    rst_body = parse_changelog(tag_name)\n    md_body = convert_rst_to_md(rst_body)\n    if not publish_github_release(slug, token, tag_name, md_body):\n        print(\"Could not publish release notes:\", file=sys.stderr)\n        print(md_body, file=sys.stderr)\n        return 5\n\n    print()\n    print(f\"Release notes for {tag_name} published successfully:\")\n    print(f\"https://github.com/{slug}/releases/tag/{tag_name}\")\n    print()\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py___print_and_exit": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py___print_and_exit", "embedding": null, "metadata": {"file_path": "scripts/release-on-comment.py", "file_name": "release-on-comment.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 90, "span_ids": ["InvalidFeatureRelease", "docstring", "get_comment_data", "impl", "login", "print_and_exit", "validate_and_get_issue_comment_payload"], "tokens": 555}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nThis script is part of the pytest release process which is triggered by comments\nin issues.\n\nThis script is started by the `prepare_release.yml` workflow, which is triggered by two comment\nrelated events:\n\n* https://help.github.com/en/actions/reference/events-that-trigger-workflows#issue-comment-event-issue_comment\n* https://help.github.com/en/actions/reference/events-that-trigger-workflows#issues-event-issues\n\nThis script receives the payload and a secrets on the command line.\n\nThe payload must contain a comment with a phrase matching this regular expression:\n\n    @pytestbot please prepare release from <branch name>\n\nThen the appropriate version will be obtained based on the given branch name:\n\n* a feature or bug fix release from master (based if there are features in the current changelog\n  folder)\n* a bug fix from a maintenance branch\n\nAfter that, it will create a release using the `release` tox environment, and push a new PR.\n\n**Secret**: currently the secret is defined in the @pytestbot account, which the core maintainers\nhave access to. There we created a new secret named `chatops` with write access to the repository.\n\"\"\"\nimport argparse\nimport json\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom subprocess import check_call\nfrom subprocess import check_output\nfrom textwrap import dedent\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import Tuple\n\nfrom colorama import Fore\nfrom colorama import init\nfrom github3.repos import Repository\n\n\nclass InvalidFeatureRelease(Exception):\n    pass\n\n\nSLUG = \"pytest-dev/pytest\"\n\nPR_BODY = \"\"\"\\\nCreated automatically from {comment_url}.\n\nOnce all builds pass and it has been **approved** by one or more maintainers, the build\ncan be released by pushing a tag `{version}` to this repository.\n\"\"\"\n\n\ndef login(token: str) -> Repository:\n    import github3\n\n    github = github3.login(token=token)\n    owner, repo = SLUG.split(\"/\")\n    return github.repository(owner, repo)\n\n\ndef get_comment_data(payload: Dict) -> str:\n    if \"comment\" in payload:\n        return payload[\"comment\"]\n    else:\n        return payload[\"issue\"]\n\n\ndef validate_and_get_issue_comment_payload(\n    issue_payload_path: Optional[Path],\n) -> Tuple[str, str]:\n    payload = json.loads(issue_payload_path.read_text(encoding=\"UTF-8\"))\n    body = get_comment_data(payload)[\"body\"]\n    m = re.match(r\"@pytestbot please prepare release from ([\\w\\-_\\.]+)\", body)\n    if m:\n        base_branch = m.group(1)\n    else:\n        base_branch = None\n    return payload, base_branch\n\n\ndef print_and_exit(msg) -> None:\n    print(msg)\n    raise SystemExit(1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py_trigger_release_trigger_release.None_1.except_Exception_as_e_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py_trigger_release_trigger_release.None_1.except_Exception_as_e_", "embedding": null, "metadata": {"file_path": "scripts/release-on-comment.py", "file_name": "release-on-comment.py", "file_type": "text/x-python", "category": "implementation", "start_line": 93, "end_line": 169, "span_ids": ["trigger_release"], "tokens": 589}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def trigger_release(payload_path: Path, token: str) -> None:\n    payload, base_branch = validate_and_get_issue_comment_payload(payload_path)\n    if base_branch is None:\n        url = get_comment_data(payload)[\"html_url\"]\n        print_and_exit(\n            f\"Comment {Fore.CYAN}{url}{Fore.RESET} did not match the trigger command.\"\n        )\n    print()\n    print(f\"Precessing release for branch {Fore.CYAN}{base_branch}\")\n\n    repo = login(token)\n\n    issue_number = payload[\"issue\"][\"number\"]\n    issue = repo.issue(issue_number)\n\n    check_call([\"git\", \"checkout\", f\"origin/{base_branch}\"])\n    print(\"DEBUG:\", check_output([\"git\", \"rev-parse\", \"HEAD\"]))\n\n    try:\n        version = find_next_version(base_branch)\n    except InvalidFeatureRelease as e:\n        issue.create_comment(str(e))\n        print_and_exit(f\"{Fore.RED}{e}\")\n\n    try:\n        print(f\"Version: {Fore.CYAN}{version}\")\n\n        release_branch = f\"release-{version}\"\n\n        check_call([\"git\", \"config\", \"user.name\", \"pytest bot\"])\n        check_call([\"git\", \"config\", \"user.email\", \"pytestbot@gmail.com\"])\n\n        check_call([\"git\", \"checkout\", \"-b\", release_branch, f\"origin/{base_branch}\"])\n\n        print(f\"Branch {Fore.CYAN}{release_branch}{Fore.RESET} created.\")\n\n        check_call(\n            [sys.executable, \"scripts/release.py\", version, \"--skip-check-links\"]\n        )\n\n        oauth_url = f\"https://{token}:x-oauth-basic@github.com/{SLUG}.git\"\n        check_call([\"git\", \"push\", oauth_url, f\"HEAD:{release_branch}\", \"--force\"])\n        print(f\"Branch {Fore.CYAN}{release_branch}{Fore.RESET} pushed.\")\n\n        body = PR_BODY.format(\n            comment_url=get_comment_data(payload)[\"html_url\"], version=version\n        )\n        pr = repo.create_pull(\n            f\"Prepare release {version}\",\n            base=base_branch,\n            head=release_branch,\n            body=body,\n        )\n        print(f\"Pull request {Fore.CYAN}{pr.url}{Fore.RESET} created.\")\n\n        comment = issue.create_comment(\n            f\"As requested, opened a PR for release `{version}`: #{pr.number}.\"\n        )\n        print(f\"Notified in original comment {Fore.CYAN}{comment.url}{Fore.RESET}.\")\n\n        print(f\"{Fore.GREEN}Success.\")\n    except Exception as e:\n        link = f\"https://github.com/{SLUG}/actions/runs/{os.environ['GITHUB_RUN_ID']}\"\n        issue.create_comment(\n            dedent(\n                f\"\"\"\n            Sorry, the request to prepare release `{version}` from {base_branch} failed with:\n\n            ```\n            {e}\n            ```\n\n            See: {link}.\n            \"\"\"\n            )\n        )\n        print_and_exit(f\"{Fore.RED}{e}\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py_find_next_version_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/scripts/release-on-comment.py_find_next_version_", "embedding": null, "metadata": {"file_path": "scripts/release-on-comment.py", "file_name": "release-on-comment.py", "file_type": "text/x-python", "category": "implementation", "start_line": 172, "end_line": 216, "span_ids": ["find_next_version", "impl:3", "main"], "tokens": 319}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def find_next_version(base_branch: str) -> str:\n    output = check_output([\"git\", \"tag\"], encoding=\"UTF-8\")\n    valid_versions = []\n    for v in output.splitlines():\n        m = re.match(r\"\\d.\\d.\\d+$\", v.strip())\n        if m:\n            valid_versions.append(tuple(int(x) for x in v.split(\".\")))\n\n    valid_versions.sort()\n    last_version = valid_versions[-1]\n\n    changelog = Path(\"changelog\")\n\n    features = list(changelog.glob(\"*.feature.rst\"))\n    breaking = list(changelog.glob(\"*.breaking.rst\"))\n    is_feature_release = features or breaking\n\n    if is_feature_release and base_branch != \"master\":\n        msg = dedent(\n            f\"\"\"\n            Found features or breaking changes in `{base_branch}`, and feature releases can only be\n            created from `master`.\":\n        \"\"\"\n        )\n        msg += \"\\n\".join(f\"* `{x.name}`\" for x in sorted(features + breaking))\n        raise InvalidFeatureRelease(msg)\n\n    if is_feature_release:\n        return f\"{last_version[0]}.{last_version[1] + 1}.0\"\n    else:\n        return f\"{last_version[0]}.{last_version[1]}.{last_version[2] + 1}\"\n\n\ndef main() -> None:\n    init(autoreset=True)\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"payload\")\n    parser.add_argument(\"token\")\n    options = parser.parse_args()\n    trigger_release(Path(options.payload), options.token)\n\n\nif __name__ == \"__main__\":\n    main()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_argcomplete.py__allow_bash_completion__from_typing_import_Option": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_argcomplete.py__allow_bash_completion__from_typing_import_Option", "embedding": null, "metadata": {"file_path": "src/_pytest/_argcomplete.py", "file_name": "_argcomplete.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 62, "span_ids": ["docstring", "imports"], "tokens": 548}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"allow bash-completion for argparse with argcomplete if installed\nneeds argcomplete>=0.5.6 for python 3.2/3.3 (older versions fail\nto find the magic string, so _ARGCOMPLETE env. var is never set, and\nthis does not need special code.\n\nFunction try_argcomplete(parser) should be called directly before\nthe call to ArgumentParser.parse_args().\n\nThe filescompleter is what you normally would use on the positional\narguments specification, in order to get \"dirname/\" after \"dirn<TAB>\"\ninstead of the default \"dirname \":\n\n   optparser.add_argument(Config._file_or_dir, nargs='*'\n                               ).completer=filescompleter\n\nOther, application specific, completers should go in the file\ndoing the add_argument calls as they need to be specified as .completer\nattributes as well. (If argcomplete is not installed, the function the\nattribute points to will not be used).\n\nSPEEDUP\n=======\nThe generic argcomplete script for bash-completion\n(/etc/bash_completion.d/python-argcomplete.sh )\nuses a python program to determine startup script generated by pip.\nYou can speed up completion somewhat by changing this script to include\n  # PYTHON_ARGCOMPLETE_OK\nso the the python-argcomplete-check-easy-install-script does not\nneed to be called to find the entry point of the code and see if that is\nmarked  with PYTHON_ARGCOMPLETE_OK\n\nINSTALL/DEBUGGING\n=================\nTo include this support in another application that has setup.py generated\nscripts:\n- add the line:\n    # PYTHON_ARGCOMPLETE_OK\n  near the top of the main python entry point\n- include in the file calling parse_args():\n    from _argcomplete import try_argcomplete, filescompleter\n   , call try_argcomplete just before parse_args(), and optionally add\n   filescompleter to the positional arguments' add_argument()\nIf things do not work right away:\n- switch on argcomplete debugging with (also helpful when doing custom\n  completers):\n    export _ARC_DEBUG=1\n- run:\n    python-argcomplete-check-easy-install-script $(which appname)\n    echo $?\n  will echo 0 if the magic line has been found, 1 if not\n- sometimes it helps to find early on errors using:\n    _ARGCOMPLETE=1 _ARC_DEBUG=1 appname\n  which should throw a KeyError: 'COMPLINE' (which is properly set by the\n  global argcomplete script).\n\"\"\"\nimport argparse\nimport os\nimport sys\nfrom glob import glob\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_argcomplete.py_FastFilesCompleter_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_argcomplete.py_FastFilesCompleter_", "embedding": null, "metadata": {"file_path": "src/_pytest/_argcomplete.py", "file_name": "_argcomplete.py", "file_type": "text/x-python", "category": "implementation", "start_line": 65, "end_line": 110, "span_ids": ["FastFilesCompleter", "FastFilesCompleter.__call__", "FastFilesCompleter.__init__", "impl"], "tokens": 315}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FastFilesCompleter:\n    \"Fast file completer class\"\n\n    def __init__(self, directories: bool = True) -> None:\n        self.directories = directories\n\n    def __call__(self, prefix: str, **kwargs: Any) -> List[str]:\n        \"\"\"only called on non option completions\"\"\"\n        if os.path.sep in prefix[1:]:\n            prefix_dir = len(os.path.dirname(prefix) + os.path.sep)\n        else:\n            prefix_dir = 0\n        completion = []\n        globbed = []\n        if \"*\" not in prefix and \"?\" not in prefix:\n            # we are on unix, otherwise no bash\n            if not prefix or prefix[-1] == os.path.sep:\n                globbed.extend(glob(prefix + \".*\"))\n            prefix += \"*\"\n        globbed.extend(glob(prefix))\n        for x in sorted(globbed):\n            if os.path.isdir(x):\n                x += \"/\"\n            # append stripping the prefix (like bash, not like compgen)\n            completion.append(x[prefix_dir:])\n        return completion\n\n\nif os.environ.get(\"_ARGCOMPLETE\"):\n    try:\n        import argcomplete.completers\n    except ImportError:\n        sys.exit(-1)\n    filescompleter = FastFilesCompleter()  # type: Optional[FastFilesCompleter]\n\n    def try_argcomplete(parser: argparse.ArgumentParser) -> None:\n        argcomplete.autocomplete(parser, always_complete_options=False)\n\n\nelse:\n\n    def try_argcomplete(parser: argparse.ArgumentParser) -> None:\n        pass\n\n    filescompleter = None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_inspect_if_TYPE_CHECKING_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_inspect_if_TYPE_CHECKING_", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 49, "span_ids": ["imports"], "tokens": 271}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import inspect\nimport re\nimport sys\nimport traceback\nfrom inspect import CO_VARARGS\nfrom inspect import CO_VARKEYWORDS\nfrom io import StringIO\nfrom traceback import format_exception_only\nfrom types import CodeType\nfrom types import FrameType\nfrom types import TracebackType\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Pattern\nfrom typing import Sequence\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import TypeVar\nfrom typing import Union\nfrom weakref import ref\n\nimport attr\nimport pluggy\nimport py\n\nimport _pytest\nfrom _pytest._code.source import findsource\nfrom _pytest._code.source import getrawcode\nfrom _pytest._code.source import getstatementrange_ast\nfrom _pytest._code.source import Source\nfrom _pytest._io import TerminalWriter\nfrom _pytest._io.saferepr import safeformat\nfrom _pytest._io.saferepr import saferepr\nfrom _pytest.compat import ATTRS_EQ_FIELD\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import overload\nfrom _pytest.compat import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Type\n    from typing_extensions import Literal\n    from weakref import ReferenceType  # noqa: F401\n\n    _TracebackStyle = Literal[\"long\", \"short\", \"line\", \"no\", \"native\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Code_Code.getargs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Code_Code.getargs", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 52, "end_line": 117, "span_ids": ["Code", "Code.__eq__", "Code.__init__", "Code.__ne__", "Code.fullsource", "Code.getargs", "Code.path", "Code.source", "Code:3"], "tokens": 504}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Code:\n    \"\"\" wrapper around Python code objects \"\"\"\n\n    def __init__(self, rawcode) -> None:\n        if not hasattr(rawcode, \"co_filename\"):\n            rawcode = getrawcode(rawcode)\n        if not isinstance(rawcode, CodeType):\n            raise TypeError(\"not a code object: {!r}\".format(rawcode))\n        self.filename = rawcode.co_filename\n        self.firstlineno = rawcode.co_firstlineno - 1\n        self.name = rawcode.co_name\n        self.raw = rawcode\n\n    def __eq__(self, other):\n        return self.raw == other.raw\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    def __ne__(self, other):\n        return not self == other\n\n    @property\n    def path(self) -> Union[py.path.local, str]:\n        \"\"\" return a path object pointing to source code (or a str in case\n        of OSError / non-existing file).\n        \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n            return self.raw.co_filename\n\n    @property\n    def fullsource(self) -> Optional[\"Source\"]:\n        \"\"\" return a _pytest._code.Source object for the full source file of the code\n        \"\"\"\n        full, _ = findsource(self.raw)\n        return full\n\n    def source(self) -> \"Source\":\n        \"\"\" return a _pytest._code.Source object for the code object's source only\n        \"\"\"\n        # return source only for that part of code\n        return Source(self.raw)\n\n    def getargs(self, var: bool = False) -> Tuple[str, ...]:\n        \"\"\" return a tuple with the argument names for the code object\n\n            if 'var' is set True also return the names of the variable and\n            keyword arguments when present\n        \"\"\"\n        # handfull shortcut for getting args\n        raw = self.raw\n        argcount = raw.co_argcount\n        if var:\n            argcount += raw.co_flags & CO_VARARGS\n            argcount += raw.co_flags & CO_VARKEYWORDS\n        return raw.co_varnames[:argcount]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback_Traceback.cut.return_self": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_Traceback_Traceback.cut.return_self", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 290, "end_line": 344, "span_ids": ["Traceback", "Traceback.__init__", "Traceback.cut"], "tokens": 419}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Traceback(List[TracebackEntry]):\n    \"\"\" Traceback objects encapsulate and offer higher level\n        access to Traceback entries.\n    \"\"\"\n\n    def __init__(\n        self,\n        tb: Union[TracebackType, Iterable[TracebackEntry]],\n        excinfo: Optional[\"ReferenceType[ExceptionInfo]\"] = None,\n    ) -> None:\n        \"\"\" initialize from given python traceback object and ExceptionInfo \"\"\"\n        self._excinfo = excinfo\n        if isinstance(tb, TracebackType):\n\n            def f(cur: TracebackType) -> Iterable[TracebackEntry]:\n                cur_ = cur  # type: Optional[TracebackType]\n                while cur_ is not None:\n                    yield TracebackEntry(cur_, excinfo=excinfo)\n                    cur_ = cur_.tb_next\n\n            super().__init__(f(tb))\n        else:\n            super().__init__(tb)\n\n    def cut(\n        self,\n        path=None,\n        lineno: Optional[int] = None,\n        firstlineno: Optional[int] = None,\n        excludepath=None,\n    ) -> \"Traceback\":\n        \"\"\" return a Traceback instance wrapping part of this Traceback\n\n            by providing any combination of path, lineno and firstlineno, the\n            first frame to start the to-be-returned traceback is determined\n\n            this allows cutting the first part of a Traceback instance e.g.\n            for formatting reasons (removing some uninteresting bits that deal\n            with handling of the exception/traceback)\n        \"\"\"\n        for x in self:\n            code = x.frame.code\n            codepath = code.path\n            if (\n                (path is None or codepath == path)\n                and (\n                    excludepath is None\n                    or not isinstance(codepath, py.path.local)\n                    or not codepath.relto(excludepath)\n                )\n                and (lineno is None or x.lineno == lineno)\n                and (firstlineno is None or x.frame.code.firstlineno == firstlineno)\n            ):\n                return Traceback(x._rawentry, self._excinfo)\n        return self", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_locals_FormattedExcinfo.repr_locals.return_None": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_locals_FormattedExcinfo.repr_locals.return_None", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 735, "end_line": 760, "span_ids": ["FormattedExcinfo.repr_locals"], "tokens": 239}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass FormattedExcinfo:\n\n    def repr_locals(self, locals: Dict[str, object]) -> Optional[\"ReprLocals\"]:\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)\n        return None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_traceback_entry_FormattedExcinfo.repr_traceback_entry.return_ReprEntry_lines_N": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo.repr_traceback_entry_FormattedExcinfo.repr_traceback_entry.return_ReprEntry_lines_N", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 762, "end_line": 789, "span_ids": ["FormattedExcinfo.repr_traceback_entry"], "tokens": 286}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass FormattedExcinfo:\n\n    def repr_traceback_entry(\n        self, entry: TracebackEntry, excinfo: Optional[ExceptionInfo] = None\n    ) -> \"ReprEntry\":\n        source = self._getentrysource(entry)\n        if source is None:\n            source = Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []  # type: List[str]\n        style = entry._repr_style if entry._repr_style is not None else self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            reprfileloc = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, reprfileloc, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo._makepath_FormattedExcinfo.repr_traceback": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_FormattedExcinfo._makepath_FormattedExcinfo.repr_traceback", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 791, "end_line": 817, "span_ids": ["FormattedExcinfo._makepath", "FormattedExcinfo.repr_traceback"], "tokens": 207}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass FormattedExcinfo:\n\n    def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path\n\n    def repr_traceback(self, excinfo: ExceptionInfo) -> \"ReprTraceback\":\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_TerminalRepr_ReprExceptionInfo.toterminal": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_TerminalRepr_ReprExceptionInfo.toterminal", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 906, "end_line": 968, "span_ids": ["ExceptionChainRepr", "ExceptionChainRepr.__attrs_post_init__", "ExceptionChainRepr.toterminal", "ExceptionRepr", "ExceptionRepr.__attrs_post_init__", "ExceptionRepr.addsection", "ExceptionRepr.toterminal", "ReprExceptionInfo", "ReprExceptionInfo.toterminal", "TerminalRepr", "TerminalRepr.__repr__", "TerminalRepr.__str__", "TerminalRepr.toterminal"], "tokens": 530}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass TerminalRepr:\n    def __str__(self) -> str:\n        # FYI this is called from pytest-xdist's serialization of exception\n        # information.\n        io = StringIO()\n        tw = TerminalWriter(file=io)\n        self.toterminal(tw)\n        return io.getvalue().strip()\n\n    def __repr__(self) -> str:\n        return \"<{} instance at {:0x}>\".format(self.__class__, id(self))\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        raise NotImplementedError()\n\n\n@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ExceptionRepr(TerminalRepr):\n    def __attrs_post_init__(self):\n        self.sections = []  # type: List[Tuple[str, str, str]]\n\n    def addsection(self, name: str, content: str, sep: str = \"-\") -> None:\n        self.sections.append((name, content, sep))\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        for name, content, sep in self.sections:\n            tw.sep(sep, name)\n            tw.line(content)\n\n\n@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ExceptionChainRepr(ExceptionRepr):\n    chain = attr.ib(\n        type=Sequence[\n            Tuple[\"ReprTraceback\", Optional[\"ReprFileLocation\"], Optional[str]]\n        ]\n    )\n\n    def __attrs_post_init__(self):\n        super().__attrs_post_init__()\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = self.chain[-1][0]\n        self.reprcrash = self.chain[-1][1]\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)\n\n\n@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprExceptionInfo(ExceptionRepr):\n    reprtraceback = attr.ib(type=\"ReprTraceback\")\n    reprcrash = attr.ib(type=\"ReprFileLocation\")\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprTraceback_ReprEntryNative.toterminal": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprTraceback_ReprEntryNative.toterminal", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 971, "end_line": 1011, "span_ids": ["ReprEntryNative", "ReprEntryNative.toterminal", "ReprTraceback", "ReprTraceback.toterminal", "ReprTracebackNative", "ReprTracebackNative.__init__"], "tokens": 341}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprTraceback(TerminalRepr):\n    reprentries = attr.ib(type=Sequence[Union[\"ReprEntry\", \"ReprEntryNative\"]])\n    extraline = attr.ib(type=Optional[str])\n    style = attr.ib(type=\"_TracebackStyle\")\n\n    entrysep = \"_ \"\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)\n\n\nclass ReprTracebackNative(ReprTraceback):\n    def __init__(self, tblines: Sequence[str]) -> None:\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None\n\n\n@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprEntryNative(TerminalRepr):\n    lines = attr.ib(type=Sequence[str])\n    style = \"native\"  # type: _TracebackStyle\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        tw.write(\"\".join(self.lines))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprEntry_ReprEntry._write_entry_lines.for_line_in_failure_lines": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprEntry_ReprEntry._write_entry_lines.for_line_in_failure_lines", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1014, "end_line": 1065, "span_ids": ["ReprEntry", "ReprEntry._write_entry_lines"], "tokens": 417}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprEntry(TerminalRepr):\n    lines = attr.ib(type=Sequence[str])\n    reprfuncargs = attr.ib(type=Optional[\"ReprFuncArgs\"])\n    reprlocals = attr.ib(type=Optional[\"ReprLocals\"])\n    reprfileloc = attr.ib(type=Optional[\"ReprFileLocation\"])\n    style = attr.ib(type=\"_TracebackStyle\")\n\n    def _write_entry_lines(self, tw: TerminalWriter) -> None:\n        \"\"\"Writes the source code portions of a list of traceback entries with syntax highlighting.\n\n        Usually entries are lines like these:\n\n            \"     x = 1\"\n            \">    assert x == 2\"\n            \"E    assert 1 == 2\"\n\n        This function takes care of rendering the \"source\" portions of it (the lines without\n        the \"E\" prefix) using syntax highlighting, taking care to not highlighting the \">\"\n        character, as doing so might break line continuations.\n        \"\"\"\n\n        if not self.lines:\n            return\n\n        # separate indents and source lines that are not failures: we want to\n        # highlight the code but not the indentation, which may contain markers\n        # such as \">   assert 0\"\n        fail_marker = \"{}   \".format(FormattedExcinfo.fail_marker)\n        indent_size = len(fail_marker)\n        indents = []\n        source_lines = []\n        failure_lines = []\n        seeing_failures = False\n        for line in self.lines:\n            is_source_line = not line.startswith(fail_marker)\n            if is_source_line:\n                assert not seeing_failures, (\n                    \"Unexpected failure lines between source lines:\\n\"\n                    + \"\\n\".join(self.lines)\n                )\n                indents.append(line[:indent_size])\n                source_lines.append(line[indent_size:])\n            else:\n                seeing_failures = True\n                failure_lines.append(line)\n\n        tw._write_source(source_lines, indents)\n\n        # failure lines are always completely red and bold\n        for line in failure_lines:\n            tw.line(line, bold=True, red=True)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprEntry.toterminal_ReprEntry.__str__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprEntry.toterminal_ReprEntry.__str__", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1067, "end_line": 1092, "span_ids": ["ReprEntry.__str__", "ReprEntry.toterminal"], "tokens": 206}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprEntry(TerminalRepr):\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        if self.style == \"short\":\n            assert self.reprfileloc is not None\n            self.reprfileloc.toterminal(tw)\n            self._write_entry_lines(tw)\n            if self.reprlocals:\n                self.reprlocals.toterminal(tw, indent=\" \" * 8)\n            return\n\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n\n        self._write_entry_lines(tw)\n\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)\n\n    def __str__(self) -> str:\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprFileLocation_ReprFuncArgs.toterminal": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_ReprFileLocation_ReprFuncArgs.toterminal", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1095, "end_line": 1141, "span_ids": ["ReprFileLocation", "ReprFileLocation.toterminal", "ReprFuncArgs", "ReprFuncArgs.toterminal", "ReprLocals", "ReprLocals.toterminal"], "tokens": 380}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprFileLocation(TerminalRepr):\n    path = attr.ib(type=str, converter=str)\n    lineno = attr.ib(type=int)\n    message = attr.ib(type=str)\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        # filename and lineno output for each entry,\n        # using an output format that most editors understand\n        msg = self.message\n        i = msg.find(\"\\n\")\n        if i != -1:\n            msg = msg[:i]\n        tw.write(self.path, bold=True, red=True)\n        tw.line(\":{}: {}\".format(self.lineno, msg))\n\n\n@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprLocals(TerminalRepr):\n    lines = attr.ib(type=Sequence[str])\n\n    def toterminal(self, tw: TerminalWriter, indent=\"\") -> None:\n        for line in self.lines:\n            tw.line(indent + line)\n\n\n@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\nclass ReprFuncArgs(TerminalRepr):\n    args = attr.ib(type=Sequence[Tuple[str, object]])\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        if self.args:\n            linesofar = \"\"\n            for name, value in self.args:\n                ns = \"{} = {}\".format(name, value)\n                if len(ns) + len(linesofar) + 2 > tw.fullwidth:\n                    if linesofar:\n                        tw.line(linesofar)\n                    linesofar = ns\n                else:\n                    if linesofar:\n                        linesofar += \", \" + ns\n                    else:\n                        linesofar = ns\n            if linesofar:\n                tw.line(linesofar)\n            tw.line(\"\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_getfslineno_getfslineno.try_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py_getfslineno_getfslineno.try_", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1144, "end_line": 1174, "span_ids": ["getfslineno"], "tokens": 235}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def getfslineno(obj: Any) -> Tuple[Union[str, py.path.local], int]:\n    \"\"\" Return source location (path, lineno) for the given object.\n    If the source cannot be determined return (\"\", -1).\n\n    The line number is 0-based.\n    \"\"\"\n    # xxx let decorators etc specify a sane ordering\n    # NOTE: this used to be done in _pytest.compat.getfslineno, initially added\n    #       in 6ec13a2b9.  It (\"place_as\") appears to be something very custom.\n    obj = get_real_func(obj)\n    if hasattr(obj, \"place_as\"):\n        obj = obj.place_as\n\n    try:\n        code = Code(obj)\n    except TypeError:\n        try:\n            fn = inspect.getsourcefile(obj) or inspect.getfile(obj)\n        except TypeError:\n            return \"\", -1\n\n        fspath = fn and py.path.local(fn) or \"\"\n        lineno = -1\n        if fspath:\n            try:\n                _, lineno = findsource(obj)\n            except OSError:\n                pass\n        return fspath, lineno\n    else:\n        return code.path, code.firstlineno", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py__relative_paths_that_we__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/code.py__relative_paths_that_we__", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/code.py", "file_name": "code.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1177, "end_line": 1208, "span_ids": ["filter_traceback", "getfslineno", "impl:4"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# relative paths that we use to filter traceback entries from appearing to the user;\n# see filter_traceback\n# note: if we need to add more paths than what we have now we should probably use a list\n# for better maintenance\n\n_PLUGGY_DIR = py.path.local(pluggy.__file__.rstrip(\"oc\"))\n# pluggy is either a package or a single module depending on the version\nif _PLUGGY_DIR.basename == \"__init__.py\":\n    _PLUGGY_DIR = _PLUGGY_DIR.dirpath()\n_PYTEST_DIR = py.path.local(_pytest.__file__).dirpath()\n_PY_DIR = py.path.local(py.__file__).dirpath()\n\n\ndef filter_traceback(entry: TracebackEntry) -> bool:\n    \"\"\"Return True if a TracebackEntry instance should be removed from tracebacks:\n    * dynamically generated code (no code to show up for it);\n    * internal traceback from pytest or its internal libraries, py and pluggy.\n    \"\"\"\n    # entry.path might sometimes return a str object when the entry\n    # points to dynamically generated code\n    # see https://bitbucket.org/pytest-dev/py/issues/71\n    raw_filename = entry.frame.code.raw.co_filename\n    is_generated = \"<\" in raw_filename and \">\" in raw_filename\n    if is_generated:\n        return False\n    # entry.path might point to a non-existing file, in which case it will\n    # also return a str object. see #1133\n    p = py.path.local(entry.path)\n    return (\n        not p.relto(_PLUGGY_DIR) and not p.relto(_PYTEST_DIR) and not p.relto(_PY_DIR)\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_ast_Source.indent": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_ast_Source.indent", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/source.py", "file_name": "source.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 119, "span_ids": ["Source", "Source.__eq__", "Source.__getitem__", "Source.__getitem___2", "Source.__getitem___3", "Source.__init__", "Source.__iter__", "Source.__len__", "Source.indent", "Source.putaround", "Source.strip", "Source:4", "imports"], "tokens": 791}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import ast\nimport inspect\nimport linecache\nimport sys\nimport textwrap\nimport tokenize\nimport warnings\nfrom bisect import bisect_right\nfrom types import CodeType\nfrom types import FrameType\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\n\nimport py\n\nfrom _pytest.compat import overload\nfrom _pytest.compat import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n\nclass Source:\n    \"\"\" an immutable object holding a source code fragment,\n        possibly deindenting it.\n    \"\"\"\n\n    _compilecounter = 0\n\n    def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)\n\n    def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    @overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()\n\n    def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)\n\n    def __len__(self) -> int:\n        return len(self.lines)\n\n    def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source\n\n    def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource\n\n    def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_Source.getstatement_Source.compile_15": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_Source.getstatement_Source.compile_15", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/source.py", "file_name": "source.py", "file_type": "text/x-python", "category": "implementation", "start_line": 121, "end_line": 181, "span_ids": ["Source.__str__", "Source.compile", "Source.compile_15", "Source.deindent", "Source.getstatement", "Source.getstatementrange", "Source.isparseable"], "tokens": 441}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Source:\n\n    def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]\n\n    def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end\n\n    def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource\n\n    def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True\n\n    def __str__(self) -> str:\n        return \"\\n\".join(self.lines)\n\n    @overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_Source.compile_16_Source.compile_16.try_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_Source.compile_16_Source.compile_16.try_", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/source.py", "file_name": "source.py", "file_type": "text/x-python", "category": "implementation", "start_line": 183, "end_line": 227, "span_ids": ["Source.compile_16"], "tokens": 457}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Source:\n\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py___compile__2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py___compile__2", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/source.py", "file_name": "source.py", "file_type": "text/x-python", "category": "implementation", "start_line": 230, "end_line": 277, "span_ids": ["Source.compile_16", "compile_", "compile__1", "compile__2"], "tokens": 369}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "#\n# public API shortcut functions\n#\n\n\n@overload\ndef compile_(\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: \"Literal[0]\" = ...,\n    dont_inherit: int = ...,\n) -> CodeType:\n    raise NotImplementedError()\n\n\n@overload  # noqa: F811\ndef compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: int = ...,\n    dont_inherit: int = ...,\n) -> Union[CodeType, ast.AST]:\n    raise NotImplementedError()\n\n\ndef compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = None,\n    mode: str = \"exec\",\n    flags: int = 0,\n    dont_inherit: int = 0,\n) -> Union[CodeType, ast.AST]:\n    \"\"\" compile the given source to a raw code object,\n        and maintain an internal cache which allows later\n        retrieval of the source code for the code object\n        and any recursively created code objects.\n    \"\"\"\n    if isinstance(source, ast.AST):\n        # XXX should Source support having AST?\n        assert filename is not None\n        co = compile(source, filename, mode, flags, dont_inherit)\n        assert isinstance(co, (CodeType, ast.AST))\n        return co\n    _genframe = sys._getframe(1)  # the caller\n    s = Source(source)\n    return s.compile(filename, mode, flags, _genframe=_genframe)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_None_3_deindent": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_None_3_deindent", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/source.py", "file_name": "source.py", "file_type": "text/x-python", "category": "implementation", "start_line": 280, "end_line": 321, "span_ids": ["deindent", "findsource", "getrawcode", "getsource", "impl:2"], "tokens": 290}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "#\n# helper functions\n#\n\n\ndef findsource(obj) -> Tuple[Optional[Source], int]:\n    try:\n        sourcelines, lineno = inspect.findsource(obj)\n    except Exception:\n        return None, -1\n    source = Source()\n    source.lines = [line.rstrip() for line in sourcelines]\n    return source, lineno\n\n\ndef getrawcode(obj, trycall: bool = True):\n    \"\"\" return code object for given function. \"\"\"\n    try:\n        return obj.__code__\n    except AttributeError:\n        obj = getattr(obj, \"f_code\", obj)\n        obj = getattr(obj, \"__code__\", obj)\n        if trycall and not hasattr(obj, \"co_firstlineno\"):\n            if hasattr(obj, \"__call__\") and not inspect.isclass(obj):\n                x = getrawcode(obj.__call__, trycall=False)\n                if hasattr(x, \"co_firstlineno\"):\n                    return x\n        return obj\n\n\ndef getsource(obj, **kwargs) -> Source:\n    obj = getrawcode(obj)\n    try:\n        strsrc = inspect.getsource(obj)\n    except IndentationError:\n        strsrc = '\"Buggy python version consider upgrading, cannot get source\"'\n    assert isinstance(strsrc, str)\n    return Source(strsrc, **kwargs)\n\n\ndef deindent(lines: Sequence[str]) -> List[str]:\n    return textwrap.dedent(\"\\n\".join(lines)).splitlines()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_get_statement_startend2_get_statement_startend2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_code/source.py_get_statement_startend2_get_statement_startend2", "embedding": null, "metadata": {"file_path": "src/_pytest/_code/source.py", "file_name": "source.py", "file_type": "text/x-python", "category": "implementation", "start_line": 324, "end_line": 343, "span_ids": ["get_statement_startend2"], "tokens": 215}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def get_statement_startend2(lineno: int, node: ast.AST) -> Tuple[int, Optional[int]]:\n    # flatten all statements and except handlers into one lineno-list\n    # AST's line numbers start indexing at 1\n    values = []  # type: List[int]\n    for x in ast.walk(node):\n        if isinstance(x, (ast.stmt, ast.ExceptHandler)):\n            values.append(x.lineno - 1)\n            for name in (\"finalbody\", \"orelse\"):\n                val = getattr(x, name, None)  # type: Optional[List[ast.stmt]]\n                if val:\n                    # treat the finally/orelse part as its own statement\n                    values.append(val[0].lineno - 1 - 1)\n    values.sort()\n    insert_index = bisect_right(values, lineno)\n    start = values[insert_index - 1]\n    if insert_index >= len(values):\n        end = None\n    else:\n        end = values[insert_index]\n    return start, end", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/__init__.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/__init__.py__", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 9, "span_ids": ["imports"], "tokens": 32}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from .terminalwriter import get_terminal_width\nfrom .terminalwriter import TerminalWriter\n\n\n__all__ = [\n    \"TerminalWriter\",\n    \"get_terminal_width\",\n]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_pprint__ellipsize": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_pprint__ellipsize", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/saferepr.py", "file_name": "saferepr.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 32, "span_ids": ["_ellipsize", "_format_repr_exception", "_try_repr_or_str", "imports"], "tokens": 240}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pprint\nimport reprlib\nfrom typing import Any\n\n\ndef _try_repr_or_str(obj):\n    try:\n        return repr(obj)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException:\n        return '{}(\"{}\")'.format(type(obj).__name__, obj)\n\n\ndef _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, type(obj).__name__, id(obj)\n    )\n\n\ndef _ellipsize(s: str, maxsize: int) -> str:\n    if len(s) > maxsize:\n        i = max(0, (maxsize - 3) // 2)\n        j = max(0, maxsize - 3 - i)\n        return s[:i] + \"...\" + s[len(s) - j :]\n    return s", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_SafeRepr_SafeRepr.repr_instance": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_SafeRepr_SafeRepr.repr_instance", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/saferepr.py", "file_name": "saferepr.py", "file_type": "text/x-python", "category": "implementation", "start_line": 35, "end_line": 61, "span_ids": ["SafeRepr", "SafeRepr.__init__", "SafeRepr.repr", "SafeRepr.repr_instance"], "tokens": 202}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class SafeRepr(reprlib.Repr):\n    \"\"\"subclass of repr.Repr that limits the resulting size of repr()\n    and includes information on exceptions raised during the call.\n    \"\"\"\n\n    def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize\n\n    def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)\n\n    def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_safeformat_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/saferepr.py_safeformat_", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/saferepr.py", "file_name": "saferepr.py", "file_type": "text/x-python", "category": "implementation", "start_line": 64, "end_line": 104, "span_ids": ["AlwaysDispatchingPrettyPrinter", "AlwaysDispatchingPrettyPrinter._format", "_pformat_dispatch", "safeformat", "saferepr"], "tokens": 360}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def safeformat(obj: Any) -> str:\n    \"\"\"return a pretty printed string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info.\n    \"\"\"\n    try:\n        return pprint.pformat(obj)\n    except Exception as exc:\n        return _format_repr_exception(exc, obj)\n\n\ndef saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)\n\n\nclass AlwaysDispatchingPrettyPrinter(pprint.PrettyPrinter):\n    \"\"\"PrettyPrinter that always dispatches (regardless of width).\"\"\"\n\n    def _format(self, object, stream, indent, allowance, context, level):\n        p = self._dispatch.get(type(object).__repr__, None)\n\n        objid = id(object)\n        if objid in context or p is None:\n            return super()._format(object, stream, indent, allowance, context, level)\n\n        context[objid] = 1\n        p(self, object, stream, indent, allowance, context, level + 1)\n        del context[objid]\n\n\ndef _pformat_dispatch(object, indent=1, width=80, depth=None, *, compact=False):\n    return AlwaysDispatchingPrettyPrinter(\n        indent=indent, width=width, depth=depth, compact=compact\n    ).pformat(object)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py__Helper_functions_for_w_should_do_markup": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py__Helper_functions_for_w_should_do_markup", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/terminalwriter.py", "file_name": "terminalwriter.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 46, "span_ids": ["char_width", "docstring", "get_line_width", "get_terminal_width", "should_do_markup"], "tokens": 316}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Helper functions for writing to terminals and files.\"\"\"\nimport os\nimport shutil\nimport sys\nimport unicodedata\nfrom functools import lru_cache\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TextIO\n\n\n# This code was initially copied from py 1.8.1, file _io/terminalwriter.py.\n\n\ndef get_terminal_width() -> int:\n    width, _ = shutil.get_terminal_size(fallback=(80, 24))\n\n    # The Windows get_terminal_size may be bogus, let's sanify a bit.\n    if width < 40:\n        width = 80\n\n    return width\n\n\n@lru_cache(100)\ndef char_width(c: str) -> int:\n    # Fullwidth and Wide -> 2, all else (including Ambiguous) -> 1.\n    return 2 if unicodedata.east_asian_width(c) in (\"F\", \"W\") else 1\n\n\ndef get_line_width(text: str) -> int:\n    text = unicodedata.normalize(\"NFC\", text)\n    return sum(char_width(c) for c in text)\n\n\ndef should_do_markup(file: TextIO) -> bool:\n    if os.environ.get(\"PY_COLORS\") == \"1\":\n        return True\n    if os.environ.get(\"PY_COLORS\") == \"0\":\n        return False\n    return (\n        hasattr(file, \"isatty\")\n        and file.isatty()\n        and os.environ.get(\"TERM\") != \"dumb\"\n        and not (sys.platform.startswith(\"java\") and os._name == \"nt\")\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter_TerminalWriter.markup": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter_TerminalWriter.markup", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/terminalwriter.py", "file_name": "terminalwriter.py", "file_type": "text/x-python", "category": "implementation", "start_line": 49, "end_line": 112, "span_ids": ["TerminalWriter", "TerminalWriter.__init__", "TerminalWriter.fullwidth", "TerminalWriter.fullwidth_1", "TerminalWriter.markup", "TerminalWriter.width_of_current_line"], "tokens": 451}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalWriter:\n    _esctable = dict(\n        black=30,\n        red=31,\n        green=32,\n        yellow=33,\n        blue=34,\n        purple=35,\n        cyan=36,\n        white=37,\n        Black=40,\n        Red=41,\n        Green=42,\n        Yellow=43,\n        Blue=44,\n        Purple=45,\n        Cyan=46,\n        White=47,\n        bold=1,\n        light=2,\n        blink=5,\n        invert=7,\n    )\n\n    def __init__(self, file: Optional[TextIO] = None) -> None:\n        if file is None:\n            file = sys.stdout\n        if hasattr(file, \"isatty\") and file.isatty() and sys.platform == \"win32\":\n            try:\n                import colorama\n            except ImportError:\n                pass\n            else:\n                file = colorama.AnsiToWin32(file).stream\n                assert file is not None\n        self._file = file\n        self.hasmarkup = should_do_markup(file)\n        self._current_line = \"\"\n        self._terminal_width = None  # type: Optional[int]\n\n    @property\n    def fullwidth(self) -> int:\n        if self._terminal_width is not None:\n            return self._terminal_width\n        return get_terminal_width()\n\n    @fullwidth.setter\n    def fullwidth(self, value: int) -> None:\n        self._terminal_width = value\n\n    @property\n    def width_of_current_line(self) -> int:\n        \"\"\"Return an estimate of the width so far in the current line.\"\"\"\n        return get_line_width(self._current_line)\n\n    def markup(self, text: str, **markup: bool) -> str:\n        for name in markup:\n            if name not in self._esctable:\n                raise ValueError(\"unknown markup: {!r}\".format(name))\n        if self.hasmarkup:\n            esc = [self._esctable[name] for name, on in markup.items() if on]\n            if esc:\n                text = \"\".join(\"\\x1b[%sm\" % cod for cod in esc) + text + \"\\x1b[0m\"\n        return text", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter.sep_TerminalWriter.sep.self_line_line_markup_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter.sep_TerminalWriter.sep.self_line_line_markup_", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/terminalwriter.py", "file_name": "terminalwriter.py", "file_type": "text/x-python", "category": "implementation", "start_line": 114, "end_line": 149, "span_ids": ["TerminalWriter.sep"], "tokens": 421}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalWriter:\n\n    def sep(\n        self,\n        sepchar: str,\n        title: Optional[str] = None,\n        fullwidth: Optional[int] = None,\n        **markup: bool\n    ) -> None:\n        if fullwidth is None:\n            fullwidth = self.fullwidth\n        # the goal is to have the line be as long as possible\n        # under the condition that len(line) <= fullwidth\n        if sys.platform == \"win32\":\n            # if we print in the last column on windows we are on a\n            # new line but there is no way to verify/neutralize this\n            # (we may not know the exact line width)\n            # so let's be defensive to avoid empty lines in the output\n            fullwidth -= 1\n        if title is not None:\n            # we want 2 + 2*len(fill) + len(title) <= fullwidth\n            # i.e.    2 + 2*len(sepchar)*N + len(title) <= fullwidth\n            #         2*len(sepchar)*N <= fullwidth - len(title) - 2\n            #         N <= (fullwidth - len(title) - 2) // (2*len(sepchar))\n            N = max((fullwidth - len(title) - 2) // (2 * len(sepchar)), 1)\n            fill = sepchar * N\n            line = \"{} {} {}\".format(fill, title, fill)\n        else:\n            # we want len(sepchar)*N <= fullwidth\n            # i.e.    N <= fullwidth // len(sepchar)\n            line = sepchar * (fullwidth // len(sepchar))\n        # in some situations there is room for an extra sepchar at the right,\n        # in particular if we consider that with a sepchar like \"_ \" the\n        # trailing space is not important at the end of the line\n        if len(line) + len(sepchar.rstrip()) <= fullwidth:\n            line += sepchar.rstrip()\n\n        self.line(line, **markup)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter.write_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/_io/terminalwriter.py_TerminalWriter.write_", "embedding": null, "metadata": {"file_path": "src/_pytest/_io/terminalwriter.py", "file_name": "terminalwriter.py", "file_type": "text/x-python", "category": "implementation", "start_line": 151, "end_line": 207, "span_ids": ["TerminalWriter._highlight", "TerminalWriter._write_source", "TerminalWriter.flush", "TerminalWriter.line", "TerminalWriter.write"], "tokens": 447}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalWriter:\n\n    def write(self, msg: str, *, flush: bool = False, **markup: bool) -> None:\n        if msg:\n            current_line = msg.rsplit(\"\\n\", 1)[-1]\n            if \"\\n\" in msg:\n                self._current_line = current_line\n            else:\n                self._current_line += current_line\n\n            msg = self.markup(msg, **markup)\n\n            self._file.write(msg)\n            if flush:\n                self.flush()\n\n    def line(self, s: str = \"\", **markup: bool) -> None:\n        self.write(s, **markup)\n        self.write(\"\\n\")\n\n    def flush(self) -> None:\n        self._file.flush()\n\n    def _write_source(self, lines: Sequence[str], indents: Sequence[str] = ()) -> None:\n        \"\"\"Write lines of source code possibly highlighted.\n\n        Keeping this private for now because the API is clunky. We should discuss how\n        to evolve the terminal writer so we can have more precise color support, for example\n        being able to write part of a line in one color and the rest in another, and so on.\n        \"\"\"\n        if indents and len(indents) != len(lines):\n            raise ValueError(\n                \"indents size ({}) should have same size as lines ({})\".format(\n                    len(indents), len(lines)\n                )\n            )\n        if not indents:\n            indents = [\"\"] * len(lines)\n        source = \"\\n\".join(lines)\n        new_lines = self._highlight(source).splitlines()\n        for indent, new_line in zip(indents, new_lines):\n            self.line(indent + new_line)\n\n    def _highlight(self, source: str) -> str:\n        \"\"\"Highlight the given source code if we have markup support.\"\"\"\n        if not self.hasmarkup:\n            return source\n        try:\n            from pygments.formatters.terminal import TerminalFormatter\n            from pygments.lexers.python import PythonLexer\n            from pygments import highlight\n        except ImportError:\n            return source\n        else:\n            highlighted = highlight(\n                source, PythonLexer(), TerminalFormatter(bg=\"dark\")\n            )  # type: str\n            return highlighted", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py___pytest_addoption": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py___pytest_addoption", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 42, "span_ids": ["docstring", "pytest_addoption"], "tokens": 243}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nsupport for presenting detailed information in failing assertions.\n\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nfrom _pytest.assertion import rewrite\nfrom _pytest.assertion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=\"\"\"Control assertion debugging tools.  'plain'\n                            performs no assertion debugging.  'rewrite'\n                            (the default) rewrites assert statements in\n                            test modules on import to provide assert\n                            expression information.\"\"\",\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_register_assert_rewrite_register_assert_rewrite": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_register_assert_rewrite_register_assert_rewrite", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 45, "end_line": 68, "span_ids": ["register_assert_rewrite"], "tokens": 232}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def register_assert_rewrite(*names) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_pytest_runtest_protocol_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/__init__.py_pytest_runtest_protocol_", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 113, "end_line": 180, "span_ids": ["pytest_assertrepr_compare", "pytest_runtest_protocol", "pytest_sessionfinish"], "tokens": 537}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item):\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left, right):\n        # type: (str, object, object) -> Optional[str]\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == \"rewrite\":\n                    res = res.replace(\"%\", \"%%\")\n                return res\n        return None\n\n    saved_assert_hooks = util._reprcompare, util._assertion_pass\n    util._reprcompare = callbinrepr\n\n    if item.ihook.pytest_assertion_pass.get_hookimpls():\n\n        def call_assertion_pass_hook(lineno, orig, expl):\n            item.ihook.pytest_assertion_pass(\n                item=item, lineno=lineno, orig=orig, expl=expl\n            )\n\n        util._assertion_pass = call_assertion_pass_hook\n\n    yield\n\n    util._reprcompare, util._assertion_pass = saved_assert_hooks\n\n\ndef pytest_sessionfinish(session):\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(None)\n\n\ndef pytest_assertrepr_compare(\n    config: Config, op: str, left: Any, right: Any\n) -> Optional[List[str]]:\n    return util.assertrepr_compare(config=config, op=op, left=left, right=right)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__write_pyc_fp__rewrite_test": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py__write_pyc_fp__rewrite_test", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 267, "end_line": 331, "span_ids": ["_rewrite_test", "_write_pyc_fp", "impl:6"], "tokens": 573}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _write_pyc_fp(fp, source_stat, co):\n    # Technically, we don't have to have the same pyc format as\n    # (C)Python, since these \"pycs\" should never be seen by builtin\n    # import. However, there's little reason deviate.\n    fp.write(importlib.util.MAGIC_NUMBER)\n    # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)\n    mtime = int(source_stat.st_mtime) & 0xFFFFFFFF\n    size = source_stat.st_size & 0xFFFFFFFF\n    # \"<LL\" stands for 2 unsigned longs, little-ending\n    fp.write(struct.pack(\"<LL\", mtime, size))\n    fp.write(marshal.dumps(co))\n\n\nif sys.platform == \"win32\":\n    from atomicwrites import atomic_write\n\n    def _write_pyc(state, co, source_stat, pyc):\n        try:\n            with atomic_write(fspath(pyc), mode=\"wb\", overwrite=True) as fp:\n                _write_pyc_fp(fp, source_stat, co)\n        except OSError as e:\n            state.trace(\"error writing pyc file at {}: {}\".format(pyc, e))\n            # we ignore any failure to write the cache file\n            # there are many reasons, permission-denied, pycache dir being a\n            # file etc.\n            return False\n        return True\n\n\nelse:\n\n    def _write_pyc(state, co, source_stat, pyc):\n        proc_pyc = \"{}.{}\".format(pyc, os.getpid())\n        try:\n            fp = open(proc_pyc, \"wb\")\n        except OSError as e:\n            state.trace(\n                \"error writing pyc file at {}: errno={}\".format(proc_pyc, e.errno)\n            )\n            return False\n\n        try:\n            _write_pyc_fp(fp, source_stat, co)\n            os.rename(proc_pyc, fspath(pyc))\n        except OSError as e:\n            state.trace(\"error writing pyc file at {}: {}\".format(pyc, e))\n            # we ignore any failure to write the cache file\n            # there are many reasons, permission-denied, pycache dir being a\n            # file etc.\n            return False\n        finally:\n            fp.close()\n        return True\n\n\ndef _rewrite_test(fn, config):\n    \"\"\"read and rewrite *fn* and return the code object.\"\"\"\n    fn = fspath(fn)\n    stat = os.stat(fn)\n    with open(fn, \"rb\") as f:\n        source = f.read()\n    tree = ast.parse(source, filename=fn)\n    rewrite_asserts(tree, source, fn, config)\n    co = compile(tree, fn, \"exec\", dont_inherit=True)\n    return stat, co", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Assert_AssertionRewriter.visit_Assert.negation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Assert_AssertionRewriter.visit_Assert.negation", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 779, "end_line": 814, "span_ids": ["AssertionRewriter.visit_Assert"], "tokens": 275}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=fspath(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []  # type: List[ast.stmt]\n        self.variables = []  # type: List[str]\n        self.variable_counter = itertools.count()\n\n        if self.enable_assertion_pass_hook:\n            self.format_variables = []  # type: List[str]\n\n        self.stack = []  # type: List[Dict[str, ast.expr]]\n        self.expl_stmts = []  # type: List[ast.stmt]\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Assert.None_2_AssertionRewriter.visit_Assert.return_self_statements": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Assert.None_2_AssertionRewriter.visit_Assert.return_self_statements", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 816, "end_line": 892, "span_ids": ["AssertionRewriter.visit_Assert"], "tokens": 616}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Assert(self, assert_):\n        # ... other code\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Str(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Str(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Str(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = self._assert_expr_to_lineno()[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Num(assert_.lineno),\n                    ast.Str(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                self.expl_stmts + [hook_call_pass],\n                [],\n            )\n            statements_pass = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.NameConstant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Str(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, ast.NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Name_AssertionRewriter.visit_BoolOp.return_ast_Name_res_var_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Name_AssertionRewriter.visit_BoolOp.return_ast_Name_res_var_", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 894, "end_line": 937, "span_ids": ["AssertionRewriter.visit_BoolOp", "AssertionRewriter.visit_Name"], "tokens": 486}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast.Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)\n\n    def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.expl_stmts\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuiting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []  # type: List[ast.stmt]\n                # cond is set in a prior loop iteration below\n                self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa\n                self.expl_stmts = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast.Call(app, [expl_format], [])\n            self.expl_stmts.append(ast.Expr(call))\n            if i < levels:\n                cond = res  # type: ast.expr\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []  # type: List[ast.stmt]\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.expl_stmts = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Compare_AssertionRewriter.visit_Compare.return_res_self_explanat": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_AssertionRewriter.visit_Compare_AssertionRewriter.visit_Compare.return_res_self_explanat", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 996, "end_line": 1032, "span_ids": ["AssertionRewriter.visit_Compare"], "tokens": 402}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class AssertionRewriter(ast.NodeVisitor):\n\n    def visit_Compare(self, comp: ast.Compare):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = BINOP_MAP[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)  # type: ast.expr\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_try_makedirs_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/rewrite.py_try_makedirs_", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/rewrite.py", "file_name": "rewrite.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1035, "end_line": 1067, "span_ids": ["get_cache_dir", "try_makedirs"], "tokens": 291}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def try_makedirs(cache_dir) -> bool:\n    \"\"\"Attempts to create the given directory and sub-directories exist, returns True if\n    successful or it already exists\"\"\"\n    try:\n        os.makedirs(fspath(cache_dir), exist_ok=True)\n    except (FileNotFoundError, NotADirectoryError, FileExistsError):\n        # One of the path components was not a directory:\n        # - we're in a zip file\n        # - it is a file\n        return False\n    except PermissionError:\n        return False\n    except OSError as e:\n        # as of now, EROFS doesn't have an equivalent OSError-subclass\n        if e.errno == errno.EROFS:\n            return False\n        raise\n    return True\n\n\ndef get_cache_dir(file_path: Path) -> Path:\n    \"\"\"Returns the cache directory to write .pyc files for the given .py file path\"\"\"\n    if sys.version_info >= (3, 8) and sys.pycache_prefix:\n        # given:\n        #   prefix = '/tmp/pycs'\n        #   path = '/home/user/proj/test_app.py'\n        # we want:\n        #   '/tmp/pycs/home/user/proj'\n        return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])\n    else:\n        # classic pycache directory\n        return file_path.parent / \"__pycache__\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_verbose__surrounding_parens_on_own_lines": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_verbose__surrounding_parens_on_own_lines", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 238, "end_line": 259, "span_ids": ["_compare_eq_verbose", "_surrounding_parens_on_own_lines"], "tokens": 210}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _compare_eq_verbose(left: Any, right: Any) -> List[str]:\n    keepends = True\n    left_lines = repr(left).splitlines(keepends)\n    right_lines = repr(right).splitlines(keepends)\n\n    explanation = []  # type: List[str]\n    explanation += [\"+\" + line for line in left_lines]\n    explanation += [\"-\" + line for line in right_lines]\n\n    return explanation\n\n\ndef _surrounding_parens_on_own_lines(lines: List[str]) -> None:\n    \"\"\"Move opening/closing parenthesis/bracket to own lines.\"\"\"\n    opening = lines[0][:1]\n    if opening in [\"(\", \"[\", \"{\"]:\n        lines[0] = \" \" + lines[0][1:]\n        lines[:] = [opening] + lines\n    closing = lines[-1][-1:]\n    if closing in [\")\", \"]\", \"}\"]:\n        lines[-1] = lines[-1][:-1] + \",\"\n        lines[:] = lines + [closing]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_iterable__compare_eq_iterable.return_explanation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_iterable__compare_eq_iterable.return_explanation", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 262, "end_line": 290, "span_ids": ["_compare_eq_iterable"], "tokens": 249}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _compare_eq_iterable(\n    left: Iterable[Any], right: Iterable[Any], verbose: int = 0\n) -> List[str]:\n    if not verbose:\n        return [\"Use -v to get the full diff\"]\n    # dynamic import to speedup pytest\n    import difflib\n\n    left_formatting = pprint.pformat(left).splitlines()\n    right_formatting = pprint.pformat(right).splitlines()\n\n    # Re-format for different output lengths.\n    lines_left = len(left_formatting)\n    lines_right = len(right_formatting)\n    if lines_left != lines_right:\n        left_formatting = _pformat_dispatch(left).splitlines()\n        right_formatting = _pformat_dispatch(right).splitlines()\n\n    if lines_left > 1 or lines_right > 1:\n        _surrounding_parens_on_own_lines(left_formatting)\n        _surrounding_parens_on_own_lines(right_formatting)\n\n    explanation = [\"Full diff:\"]\n    # \"right\" is the expected base against which we compare \"left\",\n    # see https://github.com/pytest-dev/pytest/issues/3333\n    explanation.extend(\n        line.rstrip() for line in difflib.ndiff(right_formatting, left_formatting)\n    )\n    return explanation", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_sequence__compare_eq_sequence.return_explanation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/assertion/util.py__compare_eq_sequence__compare_eq_sequence.return_explanation", "embedding": null, "metadata": {"file_path": "src/_pytest/assertion/util.py", "file_name": "util.py", "file_type": "text/x-python", "category": "implementation", "start_line": 293, "end_line": 347, "span_ids": ["_compare_eq_sequence"], "tokens": 411}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _compare_eq_sequence(\n    left: Sequence[Any], right: Sequence[Any], verbose: int = 0\n) -> List[str]:\n    comparing_bytes = isinstance(left, bytes) and isinstance(right, bytes)\n    explanation = []  # type: List[str]\n    len_left = len(left)\n    len_right = len(right)\n    for i in range(min(len_left, len_right)):\n        if left[i] != right[i]:\n            if comparing_bytes:\n                # when comparing bytes, we want to see their ascii representation\n                # instead of their numeric values (#5260)\n                # using a slice gives us the ascii representation:\n                # >>> s = b'foo'\n                # >>> s[0]\n                # 102\n                # >>> s[0:1]\n                # b'f'\n                left_value = left[i : i + 1]\n                right_value = right[i : i + 1]\n            else:\n                left_value = left[i]\n                right_value = right[i]\n\n            explanation += [\n                \"At index {} diff: {!r} != {!r}\".format(i, left_value, right_value)\n            ]\n            break\n\n    if comparing_bytes:\n        # when comparing bytes, it doesn't help to show the \"sides contain one or more\n        # items\" longer explanation, so skip it\n\n        return explanation\n\n    len_diff = len_left - len_right\n    if len_diff:\n        if len_diff > 0:\n            dir_with_more = \"Left\"\n            extra = saferepr(left[len_right])\n        else:\n            len_diff = 0 - len_diff\n            dir_with_more = \"Right\"\n            extra = saferepr(right[len_left])\n\n        if len_diff == 1:\n            explanation += [\n                \"{} contains one more item: {}\".format(dir_with_more, extra)\n            ]\n        else:\n            explanation += [\n                \"%s contains %d more items, first extra item: %s\"\n                % (dir_with_more, len_diff, extra)\n            ]\n    return explanation", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPluginCollWrapper_LFPluginCollSkipfiles.pytest_make_collect_report": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/cacheprovider.py_LFPluginCollWrapper_LFPluginCollSkipfiles.pytest_make_collect_report", "embedding": null, "metadata": {"file_path": "src/_pytest/cacheprovider.py", "file_name": "cacheprovider.py", "file_type": "text/x-python", "category": "implementation", "start_line": 170, "end_line": 223, "span_ids": ["LFPluginCollSkipfiles", "LFPluginCollSkipfiles.__init__", "LFPluginCollSkipfiles.pytest_make_collect_report", "LFPluginCollWrapper", "LFPluginCollWrapper.__init__", "LFPluginCollWrapper.pytest_make_collect_report"], "tokens": 394}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LFPluginCollWrapper:\n    def __init__(self, lfplugin: \"LFPlugin\"):\n        self.lfplugin = lfplugin\n        self._collected_at_least_one_failure = False\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_make_collect_report(self, collector) -> Generator:\n        if isinstance(collector, Session):\n            out = yield\n            res = out.get_result()  # type: CollectReport\n\n            # Sort any lf-paths to the beginning.\n            lf_paths = self.lfplugin._last_failed_paths\n            res.result = sorted(\n                res.result, key=lambda x: 0 if Path(str(x.fspath)) in lf_paths else 1,\n            )\n            out.force_result(res)\n            return\n\n        elif isinstance(collector, Module):\n            if Path(str(collector.fspath)) in self.lfplugin._last_failed_paths:\n                out = yield\n                res = out.get_result()\n\n                filtered_result = [\n                    x for x in res.result if x.nodeid in self.lfplugin.lastfailed\n                ]\n                if filtered_result:\n                    res.result = filtered_result\n                    out.force_result(res)\n\n                    if not self._collected_at_least_one_failure:\n                        self.lfplugin.config.pluginmanager.register(\n                            LFPluginCollSkipfiles(self.lfplugin), \"lfplugin-collskip\"\n                        )\n                        self._collected_at_least_one_failure = True\n                return res\n        yield\n\n\nclass LFPluginCollSkipfiles:\n    def __init__(self, lfplugin: \"LFPlugin\"):\n        self.lfplugin = lfplugin\n\n    @pytest.hookimpl\n    def pytest_make_collect_report(self, collector) -> Optional[CollectReport]:\n        if isinstance(collector, Module):\n            if Path(str(collector.fspath)) not in self.lfplugin._last_failed_paths:\n                self.lfplugin._skipped_files += 1\n\n                return CollectReport(\n                    collector.nodeid, \"passed\", longrepr=None, result=[]\n                )\n        return None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py____get_multicapture": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py____get_multicapture", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 81, "span_ids": ["_get_multicapture", "docstring", "pytest_addoption", "pytest_load_initial_conftests"], "tokens": 553}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nper-test stdout/stderr capturing mechanism.\n\n\"\"\"\nimport collections\nimport contextlib\nimport io\nimport os\nimport sys\nfrom io import UnsupportedOperation\nfrom tempfile import TemporaryFile\nfrom typing import Generator\nfrom typing import Optional\nfrom typing import TextIO\n\nimport pytest\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.fixtures import FixtureRequest\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal\n\n    _CaptureMethod = Literal[\"fd\", \"sys\", \"no\", \"tee-sys\"]\n\npatchsysdict = {0: \"stdin\", 1: \"stdout\", 2: \"stderr\"}\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--capture\",\n        action=\"store\",\n        default=\"fd\",\n        metavar=\"method\",\n        choices=[\"fd\", \"sys\", \"no\", \"tee-sys\"],\n        help=\"per-test capturing method: one of fd|sys|no|tee-sys.\",\n    )\n    group._addoption(\n        \"-s\",\n        action=\"store_const\",\n        const=\"no\",\n        dest=\"capture\",\n        help=\"shortcut for --capture=no.\",\n    )\n\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_load_initial_conftests(early_config: Config):\n    ns = early_config.known_args_namespace\n    if ns.capture == \"fd\":\n        _py36_windowsconsoleio_workaround(sys.stdout)\n    _colorama_workaround()\n    _readline_workaround()\n    pluginmanager = early_config.pluginmanager\n    capman = CaptureManager(ns.capture)\n    pluginmanager.register(capman, \"capturemanager\")\n\n    # make sure that capturemanager is properly reset at final shutdown\n    early_config.add_cleanup(capman.stop_global_capturing)\n\n    # finally trigger conftest loading but while capturing (issue93)\n    capman.start_global_capturing()\n    outcome = yield\n    capman.suspend_global_capture()\n    if outcome.excinfo is not None:\n        out, err = capman.read_global_capture()\n        sys.stdout.write(out)\n        sys.stderr.write(err)\n\n\ndef _get_multicapture(method: \"_CaptureMethod\") -> \"MultiCapture\":\n    if method == \"fd\":\n        return MultiCapture(out=True, err=True, Capture=FDCapture)\n    elif method == \"sys\":\n        return MultiCapture(out=True, err=True, Capture=SysCapture)\n    elif method == \"no\":\n        return MultiCapture(out=False, err=False, in_=False)\n    elif method == \"tee-sys\":\n        return MultiCapture(out=True, err=True, in_=False, Capture=TeeSysCapture)\n    raise ValueError(\"unknown capturing method: {!r}\".format(method))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager._capturing_for_request_CaptureManager._capturing_for_request.self._capture_fixture_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureManager._capturing_for_request_CaptureManager._capturing_for_request.self._capture_fixture_2", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 155, "end_line": 182, "span_ids": ["CaptureManager._capturing_for_request"], "tokens": 208}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class CaptureManager:\n\n    @contextlib.contextmanager\n    def _capturing_for_request(\n        self, request: FixtureRequest\n    ) -> Generator[\"CaptureFixture\", None, None]:\n        \"\"\"\n        Context manager that creates a ``CaptureFixture`` instance for the\n        given ``request``, ensuring there is only a single one being requested\n        at the same time.\n\n        This is used as a helper with ``capsys``, ``capfd`` etc.\n        \"\"\"\n        if self._capture_fixture:\n            other_name = next(\n                k\n                for k, v in map_fixname_class.items()\n                if v is self._capture_fixture.captureclass\n            )\n            raise request.raiseerror(\n                \"cannot use {} and {} at the same time\".format(\n                    request.fixturename, other_name\n                )\n            )\n        capture_class = map_fixname_class[request.fixturename]\n        self._capture_fixture = CaptureFixture(capture_class, request)\n        self.activate_fixture()\n        yield self._capture_fixture\n        self._capture_fixture.close()\n        self._capture_fixture = None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_capsys_TeeCaptureIO.write": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_capsys_TeeCaptureIO.write", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 270, "end_line": 338, "span_ids": ["CaptureIO", "CaptureIO.__init__", "CaptureIO.getvalue", "TeeCaptureIO", "TeeCaptureIO.__init__", "TeeCaptureIO.write", "capfd", "capfdbinary", "capsys", "capsysbinary"], "tokens": 554}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.fixture\ndef capsys(request):\n    \"\"\"Enable text capturing of writes to ``sys.stdout`` and ``sys.stderr``.\n\n    The captured output is made available via ``capsys.readouterr()`` method\n    calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``text`` objects.\n    \"\"\"\n    capman = request.config.pluginmanager.getplugin(\"capturemanager\")\n    with capman._capturing_for_request(request) as fixture:\n        yield fixture\n\n\n@pytest.fixture\ndef capsysbinary(request):\n    \"\"\"Enable bytes capturing of writes to ``sys.stdout`` and ``sys.stderr``.\n\n    The captured output is made available via ``capsysbinary.readouterr()``\n    method calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``bytes`` objects.\n    \"\"\"\n    capman = request.config.pluginmanager.getplugin(\"capturemanager\")\n    with capman._capturing_for_request(request) as fixture:\n        yield fixture\n\n\n@pytest.fixture\ndef capfd(request):\n    \"\"\"Enable text capturing of writes to file descriptors ``1`` and ``2``.\n\n    The captured output is made available via ``capfd.readouterr()`` method\n    calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``text`` objects.\n    \"\"\"\n    capman = request.config.pluginmanager.getplugin(\"capturemanager\")\n    with capman._capturing_for_request(request) as fixture:\n        yield fixture\n\n\n@pytest.fixture\ndef capfdbinary(request):\n    \"\"\"Enable bytes capturing of writes to file descriptors ``1`` and ``2``.\n\n    The captured output is made available via ``capfd.readouterr()`` method\n    calls, which return a ``(out, err)`` namedtuple.\n    ``out`` and ``err`` will be ``byte`` objects.\n    \"\"\"\n    capman = request.config.pluginmanager.getplugin(\"capturemanager\")\n    with capman._capturing_for_request(request) as fixture:\n        yield fixture\n\n\nclass CaptureIO(io.TextIOWrapper):\n    def __init__(self) -> None:\n        super().__init__(io.BytesIO(), encoding=\"UTF-8\", newline=\"\", write_through=True)\n\n    def getvalue(self) -> str:\n        assert isinstance(self.buffer, io.BytesIO)\n        return self.buffer.getvalue().decode(\"UTF-8\")\n\n\nclass TeeCaptureIO(CaptureIO):\n    def __init__(self, other: TextIO) -> None:\n        self._other = other\n        super().__init__()\n\n    def write(self, s: str) -> int:\n        super().write(s)\n        return self._other.write(s)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureFixture_CaptureResult": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_CaptureFixture_CaptureResult", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 341, "end_line": 417, "span_ids": ["CaptureFixture", "CaptureFixture.__init__", "CaptureFixture._resume", "CaptureFixture._start", "CaptureFixture._suspend", "CaptureFixture.close", "CaptureFixture.disabled", "CaptureFixture.readouterr", "EncodedFile", "EncodedFile.mode", "EncodedFile.name", "impl:3"], "tokens": 597}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class CaptureFixture:\n    \"\"\"\n    Object returned by :py:func:`capsys`, :py:func:`capsysbinary`, :py:func:`capfd` and :py:func:`capfdbinary`\n    fixtures.\n    \"\"\"\n\n    def __init__(self, captureclass, request):\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n\n    def _start(self):\n        if self._capture is None:\n            self._capture = MultiCapture(\n                out=True, err=True, in_=False, Capture=self.captureclass\n            )\n            self._capture.start_capturing()\n\n    def close(self):\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None\n\n    def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)\n\n    def _suspend(self):\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()\n\n    def _resume(self):\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()\n\n    @contextlib.contextmanager\n    def disabled(self):\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield\n\n\nclass EncodedFile(io.TextIOWrapper):\n    __slots__ = ()\n\n    @property\n    def name(self) -> str:\n        # Ensure that file.name is a string. Workaround for a Python bug\n        # fixed in >=3.7.4: https://bugs.python.org/issue36015\n        return repr(self.buffer)\n\n    @property\n    def mode(self) -> str:\n        # TextIOWrapper doesn't expose a mode, but at least some of our\n        # tests check it.\n        return self.buffer.mode.replace(\"b\", \"\")\n\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_FDCapture_SysCaptureBinary.writeorg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_FDCapture_SysCaptureBinary.writeorg", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 594, "end_line": 668, "span_ids": ["FDCapture", "FDCapture.snap", "FDCapture.writeorg", "SysCaptureBinary", "SysCaptureBinary.__init__", "SysCaptureBinary.__repr__", "SysCaptureBinary.done", "SysCaptureBinary.resume", "SysCaptureBinary.snap", "SysCaptureBinary.start", "SysCaptureBinary.suspend", "SysCaptureBinary.writeorg"], "tokens": 459}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        data = data.encode(\"utf-8\")  # XXX use encoding of original stream\n        os.write(self.targetfd_save, data)\n\n\nclass SysCaptureBinary:\n\n    EMPTY_BUFFER = b\"\"\n    _state = None\n\n    def __init__(self, fd, tmpfile=None):\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO()\n        self.tmpfile = tmpfile\n\n    def __repr__(self):\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def start(self):\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def snap(self):\n        res = self.tmpfile.buffer.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self):\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self):\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"\n\n    def resume(self):\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"resumed\"\n\n    def writeorg(self, data):\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_SysCapture__colorama_workaround": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/capture.py_SysCapture__colorama_workaround", "embedding": null, "metadata": {"file_path": "src/_pytest/capture.py", "file_name": "capture.py", "file_type": "text/x-python", "category": "implementation", "start_line": 671, "end_line": 748, "span_ids": ["DontReadFromInput", "DontReadFromInput.__iter__", "DontReadFromInput.buffer", "DontReadFromInput.close", "DontReadFromInput.fileno", "DontReadFromInput.isatty", "DontReadFromInput.read", "DontReadFromInput:3", "SysCapture", "SysCapture.snap", "SysCapture.writeorg", "TeeSysCapture", "TeeSysCapture.__init__", "_colorama_workaround", "impl:4"], "tokens": 419}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class SysCapture(SysCaptureBinary):\n    EMPTY_BUFFER = \"\"  # type: ignore[assignment]  # noqa: F821\n\n    def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        self._old.write(data)\n        self._old.flush()\n\n\nclass TeeSysCapture(SysCapture):\n    def __init__(self, fd, tmpfile=None):\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n\n\nmap_fixname_class = {\n    \"capfd\": FDCapture,\n    \"capfdbinary\": FDCaptureBinary,\n    \"capsys\": SysCapture,\n    \"capsysbinary\": SysCaptureBinary,\n}\n\n\nclass DontReadFromInput:\n    encoding = None\n\n    def read(self, *args):\n        raise OSError(\n            \"pytest: reading from stdin while output is captured!  Consider using `-s`.\"\n        )\n\n    readline = read\n    readlines = read\n    __next__ = read\n\n    def __iter__(self):\n        return self\n\n    def fileno(self):\n        raise UnsupportedOperation(\"redirected stdin is pseudofile, has no fileno()\")\n\n    def isatty(self):\n        return False\n\n    def close(self):\n        pass\n\n    @property\n    def buffer(self):\n        return self\n\n\ndef _colorama_workaround():\n    \"\"\"\n    Ensure colorama is imported so that it attaches to the correct stdio\n    handles on Windows.\n\n    colorama uses the terminal on import time. So if something does the\n    first import of colorama while I/O capture is active, colorama will\n    fail in various ways.\n    \"\"\"\n    if sys.platform.startswith(\"win32\"):\n        try:\n            import colorama  # noqa: F401\n        except ImportError:\n            pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py___getlocation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py___getlocation", "embedding": null, "metadata": {"file_path": "src/_pytest/compat.py", "file_name": "compat.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 109, "span_ids": ["_format_args", "docstring", "getlocation", "impl:8", "is_async_function", "is_generator", "iscoroutinefunction"], "tokens": 652}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\npython version compatibility code\n\"\"\"\nimport functools\nimport inspect\nimport os\nimport re\nimport sys\nfrom contextlib import contextmanager\nfrom inspect import Parameter\nfrom inspect import signature\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import overload\nfrom typing import Tuple\nfrom typing import TypeVar\nfrom typing import Union\n\nimport attr\nimport py\n\nfrom _pytest._io.saferepr import saferepr\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import TEST_OUTCOME\n\nif sys.version_info < (3, 5, 2):\n    TYPE_CHECKING = False  # type: bool\nelse:\n    from typing import TYPE_CHECKING\n\n\nif TYPE_CHECKING:\n    from typing import Type  # noqa: F401 (used in type string)\n\n\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n\n\nNOTSET = object()\n\nMODULE_NOT_FOUND_ERROR = (\n    \"ModuleNotFoundError\" if sys.version_info[:2] >= (3, 6) else \"ImportError\"\n)\n\n\nif sys.version_info >= (3, 8):\n    from importlib import metadata as importlib_metadata\nelse:\n    import importlib_metadata  # noqa: F401\n\n\ndef _format_args(func: Callable[..., Any]) -> str:\n    return str(signature(func))\n\n\n# The type of re.compile objects is not exposed in Python.\nREGEX_TYPE = type(re.compile(\"\"))\n\n\nif sys.version_info < (3, 6):\n\n    def fspath(p):\n        \"\"\"os.fspath replacement, useful to point out when we should replace it by the\n        real function once we drop py35.\n        \"\"\"\n        return str(p)\n\n\nelse:\n    fspath = os.fspath\n\n\ndef is_generator(func: object) -> bool:\n    genfunc = inspect.isgeneratorfunction(func)\n    return genfunc and not iscoroutinefunction(func)\n\n\ndef iscoroutinefunction(func: object) -> bool:\n    \"\"\"\n    Return True if func is a coroutine function (a function defined with async\n    def syntax, and doesn't contain yield), or a function decorated with\n    @asyncio.coroutine.\n\n    Note: copied and modified from Python 3.5's builtin couroutines.py to avoid\n    importing asyncio directly, which in turns also initializes the \"logging\"\n    module as a side-effect (see issue #8).\n    \"\"\"\n    return inspect.iscoroutinefunction(func) or getattr(func, \"_is_coroutine\", False)\n\n\ndef is_async_function(func: object) -> bool:\n    \"\"\"Return True if the given function seems to be an async function or async generator\"\"\"\n    return iscoroutinefunction(func) or (\n        sys.version_info >= (3, 6) and inspect.isasyncgenfunction(func)\n    )\n\n\ndef getlocation(function, curdir=None) -> str:\n    function = get_real_func(function)\n    fn = py.path.local(inspect.getfile(function))\n    lineno = function.__code__.co_firstlineno\n    if curdir is not None:\n        relfn = fn.relto(curdir)\n        if relfn:\n            return \"%s:%d\" % (relfn, lineno + 1)\n    return \"%s:%d\" % (fn, lineno + 1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_num_mock_patch_args_getfuncargnames.return_arg_names": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_num_mock_patch_args_getfuncargnames.return_arg_names", "embedding": null, "metadata": {"file_path": "src/_pytest/compat.py", "file_name": "compat.py", "file_type": "text/x-python", "category": "implementation", "start_line": 112, "end_line": 191, "span_ids": ["getfuncargnames", "num_mock_patch_args"], "tokens": 604}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def num_mock_patch_args(function) -> int:\n    \"\"\" return number of arguments used up by mock arguments (if any) \"\"\"\n    patchings = getattr(function, \"patchings\", None)\n    if not patchings:\n        return 0\n\n    mock_sentinel = getattr(sys.modules.get(\"mock\"), \"DEFAULT\", object())\n    ut_mock_sentinel = getattr(sys.modules.get(\"unittest.mock\"), \"DEFAULT\", object())\n\n    return len(\n        [\n            p\n            for p in patchings\n            if not p.attribute_name\n            and (p.new is mock_sentinel or p.new is ut_mock_sentinel)\n        ]\n    )\n\n\ndef getfuncargnames(\n    function: Callable[..., Any],\n    *,\n    name: str = \"\",\n    is_method: bool = False,\n    cls: Optional[type] = None\n) -> Tuple[str, ...]:\n    \"\"\"Returns the names of a function's mandatory arguments.\n\n    This should return the names of all function arguments that:\n        * Aren't bound to an instance or type as in instance or class methods.\n        * Don't have default values.\n        * Aren't bound with functools.partial.\n        * Aren't replaced with mocks.\n\n    The is_method and cls arguments indicate that the function should\n    be treated as a bound method even though it's not unless, only in\n    the case of cls, the function is a static method.\n\n    The name parameter should be the original name in which the function was collected.\n    \"\"\"\n    # TODO(RonnyPfannschmidt): This function should be refactored when we\n    # revisit fixtures. The fixture mechanism should ask the node for\n    # the fixture names, and not try to obtain directly from the\n    # function object well after collection has occurred.\n\n    # The parameters attribute of a Signature object contains an\n    # ordered mapping of parameter names to Parameter instances.  This\n    # creates a tuple of the names of the parameters that don't have\n    # defaults.\n    try:\n        parameters = signature(function).parameters\n    except (ValueError, TypeError) as e:\n        fail(\n            \"Could not determine arguments of {!r}: {}\".format(function, e),\n            pytrace=False,\n        )\n\n    arg_names = tuple(\n        p.name\n        for p in parameters.values()\n        if (\n            p.kind is Parameter.POSITIONAL_OR_KEYWORD\n            or p.kind is Parameter.KEYWORD_ONLY\n        )\n        and p.default is Parameter.empty\n    )\n    if not name:\n        name = function.__name__\n\n    # If this function should be treated as a bound method even though\n    # it's passed as an unbound method or function, remove the first\n    # parameter name.\n    if is_method or (\n        cls and not isinstance(cls.__dict__.get(name, None), staticmethod)\n    ):\n        arg_names = arg_names[1:]\n    # Remove any names that will be replaced with mocks.\n    if hasattr(function, \"__wrapped__\"):\n        arg_names = arg_names[num_mock_patch_args(function) :]\n    return arg_names", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_None_4__bytes_to_ascii": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/compat.py_None_4__bytes_to_ascii", "embedding": null, "metadata": {"file_path": "src/_pytest/compat.py", "file_name": "compat.py", "file_type": "text/x-python", "category": "implementation", "start_line": 194, "end_line": 232, "span_ids": ["_bytes_to_ascii", "_translate_non_printable", "get_default_arg_names", "impl:11", "impl:12", "impl:14"], "tokens": 262}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "if sys.version_info < (3, 7):\n\n    @contextmanager\n    def nullcontext():\n        yield\n\n\nelse:\n    from contextlib import nullcontext  # noqa\n\n\ndef get_default_arg_names(function: Callable[..., Any]) -> Tuple[str, ...]:\n    # Note: this code intentionally mirrors the code at the beginning of getfuncargnames,\n    # to get the arguments which were excluded from its result because they had default values\n    return tuple(\n        p.name\n        for p in signature(function).parameters.values()\n        if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n        and p.default is not Parameter.empty\n    )\n\n\n_non_printable_ascii_translate_table = {\n    i: \"\\\\x{:02x}\".format(i) for i in range(128) if i not in range(32, 127)\n}\n_non_printable_ascii_translate_table.update(\n    {ord(\"\\t\"): \"\\\\t\", ord(\"\\r\"): \"\\\\r\", ord(\"\\n\"): \"\\\\n\"}\n)\n\n\ndef _translate_non_printable(s: str) -> str:\n    return s.translate(_non_printable_ascii_translate_table)\n\n\nSTRING_TYPES = bytes, str\n\n\ndef _bytes_to_ascii(val: bytes) -> str:\n    return val.decode(\"ascii\", \"backslashreplace\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_console_main_get_plugin_manager": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_console_main_get_plugin_manager", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 140, "end_line": 252, "span_ids": ["cmdline", "console_main", "directory_arg", "filename_arg", "get_config", "get_plugin_manager", "impl:5"], "tokens": 669}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def console_main() -> int:\n    \"\"\"pytest's CLI entry point.\n\n    This function is not meant for programmable use; use `main()` instead.\n    \"\"\"\n    # https://docs.python.org/3/library/signal.html#note-on-sigpipe\n    try:\n        code = main()\n        sys.stdout.flush()\n        return code\n    except BrokenPipeError:\n        # Python flushes standard streams on exit; redirect remaining output\n        # to devnull to avoid another BrokenPipeError at shutdown\n        devnull = os.open(os.devnull, os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())\n        return 1  # Python exits with error code 1 on EPIPE\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (), plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args, exclude_only=True)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__prepareconfig__fail_on_non_top_pytest_plugins": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__prepareconfig__fail_on_non_top_pytest_plugins", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 255, "end_line": 293, "span_ids": ["_fail_on_non_top_pytest_plugins", "_prepareconfig"], "tokens": 342}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _prepareconfig(\n    args: Optional[Union[py.path.local, List[str]]] = None, plugins=None\n):\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, list):\n        msg = \"`args` parameter expected to be a list of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager_PytestPluginManager.__init__.self._configured": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager_PytestPluginManager.__init__.self._configured", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 296, "end_line": 340, "span_ids": ["PytestPluginManager", "PytestPluginManager.__init__"], "tokens": 378}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loading during start-up;\n    \"\"\"\n\n    def __init__(self):\n        import _pytest.assertion\n\n        super().__init__(\"pytest\")\n        # The objects are module objects, only used generically.\n        self._conftest_plugins = set()  # type: Set[object]\n\n        # state related to local conftest plugins\n        # Maps a py.path.local to a list of module objects.\n        self._dirpath2confmods = {}  # type: Dict[Any, List[object]]\n        # Maps a py.path.local to a module object.\n        self._conftestpath2mod = {}  # type: Dict[Any, object]\n        self._confcutdir = None\n        self._noconftest = False\n        # Set of py.path.local's.\n        self._duplicatepaths = set()  # type: Set[Any]\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err = sys.stderr\n            encoding = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = open(\n                    os.dup(err.fileno()), mode=err.mode, buffering=1, encoding=encoding,\n                )\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.None_4_PytestPluginManager.consider_pluginarg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.None_4_PytestPluginManager.consider_pluginarg", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 543, "end_line": 592, "span_ids": ["PytestPluginManager._importconftest", "PytestPluginManager.consider_pluginarg", "PytestPluginManager.consider_preparse"], "tokens": 366}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args, *, exclude_only=False):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                if exclude_only and not parg.startswith(\"no:\"):\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.consider_conftest_PytestPluginManager.import_plugin.try_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_PytestPluginManager.consider_conftest_PytestPluginManager.import_plugin.try_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 594, "end_line": 649, "span_ids": ["PytestPluginManager._import_plugin_specs", "PytestPluginManager.consider_conftest", "PytestPluginManager.consider_env", "PytestPluginManager.consider_module", "PytestPluginManager.import_plugin"], "tokens": 438}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PytestPluginManager(PluginManager):\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            raise ImportError(\n                'Error importing plugin \"{}\": {}'.format(modname, str(e.args[0]))\n            ).with_traceback(e.__traceback__)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=2,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__get_plugin_specs_as_list_notset": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__get_plugin_specs_as_list_notset", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 652, "end_line": 684, "span_ids": ["Notset", "Notset.__repr__", "_ensure_removed_sysmodule", "_get_plugin_specs_as_list", "impl:11"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__iter_rewritable_modules__iter_rewritable_modules.if_not_seen_some_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py__iter_rewritable_modules__iter_rewritable_modules.if_not_seen_some_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 687, "end_line": 747, "span_ids": ["_iter_rewritable_modules"], "tokens": 275}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _iter_rewritable_modules(package_files):\n    package_files = list(package_files)\n    seen_some = False\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            # we ignore \"setup.py\" at the root of the distribution\n            if module_name != \"setup\":\n                seen_some = True\n                yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            seen_some = True\n            yield package_name\n\n    if not seen_some:\n        # at this point we did not find any packages or modules suitable for assertion\n        # rewriting, so we try again by stripping the first path component (to account for\n        # \"src\" based source trees for example)\n        # this approach lets us have the common case continue to be fast, as egg-distributions\n        # are rarer\n        new_package_files = []\n        for fn in package_files:\n            parts = fn.split(\"/\")\n            new_fn = \"/\".join(parts[1:])\n            if new_fn:\n                new_package_files.append(new_fn)\n        if new_package_files:\n            yield from _iter_rewritable_modules(new_package_files)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config_Config._ensure_unconfigure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config_Config._ensure_unconfigure", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 750, "end_line": 858, "span_ids": ["Config", "Config.InvocationParams", "Config.__init__", "Config._do_configure", "Config._ensure_unconfigure", "Config.add_cleanup", "Config.invocation_dir"], "tokens": 741}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :param PytestPluginManager pluginmanager:\n\n    :param InvocationParams invocation_params:\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        The object attributes are read-only.\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(converter=tuple)\n        \"\"\"tuple of command-line arguments as passed to ``pytest.main()``.\"\"\"\n        plugins = attr.ib()\n        \"\"\"list of extra plugins, might be `None`.\"\"\"\n        dir = attr.ib(type=Path)\n        \"\"\"directory where ``pytest.main()`` was invoked from.\"\"\"\n\n    def __init__(\n        self,\n        pluginmanager: PytestPluginManager,\n        *,\n        invocation_params: Optional[InvocationParams] = None\n    ) -> None:\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        \"\"\"access to command line option as attributes.\n\n          :type: argparse.Namespace\"\"\"\n\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        \"\"\"the plugin manager handles plugin registration and hook invocation.\n\n          :type: PytestPluginManager\"\"\"\n\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}  # type: Dict[str, Any]\n        self._override_ini = ()  # type: Sequence[str]\n        self._opt2dest = {}  # type: Dict[str, str]\n        self._cleanup = []  # type: List[Callable[[], None]]\n        # A place where plugins can store information on the config for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n        if TYPE_CHECKING:\n            from _pytest.cacheprovider import Cache\n\n            self.cache = None  # type: Optional[Cache]\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config.get_terminal_writer_Config._initini": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/__init__.py_Config.get_terminal_writer_Config._initini", "embedding": null, "metadata": {"file_path": "src/_pytest/config/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 860, "end_line": 945, "span_ids": ["Config._initini", "Config._processopt", "Config.cwd_relative_nodeid", "Config.fromdictargs", "Config.get_terminal_writer", "Config.notify_exception", "Config.pytest_cmdline_parse", "Config.pytest_load_initial_conftests"], "tokens": 746}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Config:\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_main is not called in case of errors.\n            if getattr(self.option, \"version\", False) or \"--version\" in args:\n                from _pytest.helpconfig import showversion\n\n                showversion(self)\n            elif (\n                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n            ):\n                self._parser._getparser().print_help()\n                sys.stdout.write(\n                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n                )\n\n            raise\n\n        return self\n\n    def notify_exception(self, excinfo, option=None):\n        if option and getattr(option, \"fulltrace\", False):\n            style = \"long\"\n        else:\n            style = \"native\"\n        excrepr = excinfo.getrepr(\n            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n        )\n        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n        if not any(res):\n            for line in str(excrepr).split(\"\\n\"):\n                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n                sys.stderr.flush()\n\n    def cwd_relative_nodeid(self, nodeid):\n        # nodeid's are relative to the rootpath, compute relative to cwd\n        if self.invocation_dir != self.rootdir:\n            fullpath = self.rootdir.join(nodeid)\n            nodeid = self.invocation_dir.bestrelpath(fullpath)\n        return nodeid\n\n    @classmethod\n    def fromdictargs(cls, option_dict, args):\n        \"\"\" constructor usable for subprocesses. \"\"\"\n        config = get_config(args)\n        config.option.__dict__.update(option_dict)\n        config.parse(args, addopts=False)\n        for x in config.option.plugins:\n            config.pluginmanager.consider_pluginarg(x)\n        return config\n\n    def _processopt(self, opt: \"Argument\") -> None:\n        for name in opt._short_opts + opt._long_opts:\n            self._opt2dest[name] = opt.dest\n\n        if hasattr(opt, \"default\"):\n            if not hasattr(self.option, opt.dest):\n                setattr(self.option, opt.dest, opt.default)\n\n    @hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config):\n        self.pluginmanager._set_initial_conftests(early_config.known_args_namespace)\n\n    def _initini(self, args: Sequence[str]) -> None:\n        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n            args, namespace=copy.copy(self.option)\n        )\n        r = determine_setup(\n            ns.inifilename,\n            ns.file_or_dir + unknown_args,\n            rootdir_cmd_arg=ns.rootdir or None,\n            config=self,\n        )\n        self.rootdir, self.inifile, self.inicfg = r\n        self._parser.extra_info[\"rootdir\"] = self.rootdir\n        self._parser.extra_info[\"inifile\"] = self.inifile\n        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n        self._override_ini = ns.override_ini or ()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_argparse_Parser.processoption": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_argparse_Parser.processoption", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 54, "span_ids": ["Parser", "Parser.__init__", "Parser.processoption", "imports"], "tokens": 325}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import argparse\nimport sys\nimport warnings\nfrom gettext import gettext\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Dict\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\n\nimport py\n\nimport _pytest._io\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config.exceptions import UsageError\n\nif TYPE_CHECKING:\n    from typing import NoReturn\n    from typing_extensions import Literal  # noqa: F401\n\nFILE_OR_DIR = \"file_or_dir\"\n\n\nclass Parser:\n    \"\"\" Parser for command line arguments and ini-file values.\n\n    :ivar extra_info: dict of generic param -> value to display in case\n        there's an error processing the command line arguments.\n    \"\"\"\n\n    prog = None  # type: Optional[str]\n\n    def __init__(\n        self,\n        usage: Optional[str] = None,\n        processopt: Optional[Callable[[\"Argument\"], None]] = None,\n    ) -> None:\n        self._anonymous = OptionGroup(\"custom options\", parser=self)\n        self._groups = []  # type: List[OptionGroup]\n        self._processopt = processopt\n        self._usage = usage\n        self._inidict = {}  # type: Dict[str, Tuple[str, Optional[str], Any]]\n        self._ininames = []  # type: List[str]\n        self.extra_info = {}  # type: Dict[str, Any]\n\n    def processoption(self, option: \"Argument\") -> None:\n        if self._processopt:\n            if option.dest:\n                self._processopt(option)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Parser.getgroup_Parser.getgroup": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Parser.getgroup_Parser.getgroup", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 56, "end_line": 79, "span_ids": ["Parser.getgroup"], "tokens": 216}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Parser:\n\n    def getgroup(\n        self, name: str, description: str = \"\", after: Optional[str] = None\n    ) -> \"OptionGroup\":\n        \"\"\" get (or create) a named option Group.\n\n        :name: name of the option group.\n        :description: long description for --help output.\n        :after: name of other group, used for ordering --help output.\n\n        The returned group object has an ``addoption`` method with the same\n        signature as :py:func:`parser.addoption\n        <_pytest.config.argparsing.Parser.addoption>` but will be shown in the\n        respective group in the output of ``pytest. --help``.\n        \"\"\"\n        for group in self._groups:\n            if group.name == name:\n                return group\n        group = OptionGroup(name, description, parser=self)\n        i = 0\n        for i, grp in enumerate(self._groups):\n            if grp.name == after:\n                break\n        self._groups.insert(i + 1, group)\n        return group", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Parser.addoption_Parser.addini": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_Parser.addoption_Parser.addini", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 81, "end_line": 180, "span_ids": ["Parser._getparser", "Parser.addini", "Parser.addoption", "Parser.parse", "Parser.parse_known_and_unknown_args", "Parser.parse_known_args", "Parser.parse_setoption"], "tokens": 908}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Parser:\n\n    def addoption(self, *opts: str, **attrs: Any) -> None:\n        \"\"\" register a command line option.\n\n        :opts: option names, can be short or long options.\n        :attrs: same attributes which the ``add_argument()`` function of the\n           `argparse library\n           <https://docs.python.org/library/argparse.html>`_\n           accepts.\n\n        After command line parsing options are available on the pytest config\n        object via ``config.option.NAME`` where ``NAME`` is usually set\n        by passing a ``dest`` attribute, for example\n        ``addoption(\"--long\", dest=\"NAME\", ...)``.\n        \"\"\"\n        self._anonymous.addoption(*opts, **attrs)\n\n    def parse(\n        self,\n        args: Sequence[Union[str, py.path.local]],\n        namespace: Optional[argparse.Namespace] = None,\n    ) -> argparse.Namespace:\n        from _pytest._argcomplete import try_argcomplete\n\n        self.optparser = self._getparser()\n        try_argcomplete(self.optparser)\n        strargs = [str(x) if isinstance(x, py.path.local) else x for x in args]\n        return self.optparser.parse_args(strargs, namespace=namespace)\n\n    def _getparser(self) -> \"MyOptionParser\":\n        from _pytest._argcomplete import filescompleter\n\n        optparser = MyOptionParser(self, self.extra_info, prog=self.prog)\n        groups = self._groups + [self._anonymous]\n        for group in groups:\n            if group.options:\n                desc = group.description or group.name\n                arggroup = optparser.add_argument_group(desc)\n                for option in group.options:\n                    n = option.names()\n                    a = option.attrs()\n                    arggroup.add_argument(*n, **a)\n        file_or_dir_arg = optparser.add_argument(FILE_OR_DIR, nargs=\"*\")\n        # bash like autocompletion for dirs (appending '/')\n        # Type ignored because typeshed doesn't know about argcomplete.\n        file_or_dir_arg.completer = filescompleter  # type: ignore\n        return optparser\n\n    def parse_setoption(\n        self,\n        args: Sequence[Union[str, py.path.local]],\n        option: argparse.Namespace,\n        namespace: Optional[argparse.Namespace] = None,\n    ) -> List[str]:\n        parsedoption = self.parse(args, namespace=namespace)\n        for name, value in parsedoption.__dict__.items():\n            setattr(option, name, value)\n        return cast(List[str], getattr(parsedoption, FILE_OR_DIR))\n\n    def parse_known_args(\n        self,\n        args: Sequence[Union[str, py.path.local]],\n        namespace: Optional[argparse.Namespace] = None,\n    ) -> argparse.Namespace:\n        \"\"\"parses and returns a namespace object with known arguments at this\n        point.\n        \"\"\"\n        return self.parse_known_and_unknown_args(args, namespace=namespace)[0]\n\n    def parse_known_and_unknown_args(\n        self,\n        args: Sequence[Union[str, py.path.local]],\n        namespace: Optional[argparse.Namespace] = None,\n    ) -> Tuple[argparse.Namespace, List[str]]:\n        \"\"\"parses and returns a namespace object with known arguments, and\n        the remaining arguments unknown at this point.\n        \"\"\"\n        optparser = self._getparser()\n        strargs = [str(x) if isinstance(x, py.path.local) else x for x in args]\n        return optparser.parse_known_args(strargs, namespace=namespace)\n\n    def addini(\n        self,\n        name: str,\n        help: str,\n        type: Optional[\"Literal['pathlist', 'args', 'linelist', 'bool']\"] = None,\n        default=None,\n    ) -> None:\n        \"\"\" register an ini-file option.\n\n        :name: name of the ini-variable\n        :type: type of the variable, can be ``pathlist``, ``args``, ``linelist``\n               or ``bool``.\n        :default: default value if no ini-file option exists but is queried.\n\n        The value of ini-variables can be retrieved via a call to\n        :py:func:`config.getini(name) <_pytest.config.Config.getini>`.\n        \"\"\"\n        assert type in (None, \"pathlist\", \"args\", \"linelist\", \"bool\")\n        self._inidict[name] = (help, type, default)\n        self._ininames.append(name)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_ArgumentError_Argument.attrs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_ArgumentError_Argument.attrs", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 183, "end_line": 289, "span_ids": ["Argument", "Argument.__init__", "Argument.attrs", "Argument.names", "ArgumentError", "ArgumentError.__init__", "ArgumentError.__str__"], "tokens": 827}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ArgumentError(Exception):\n    \"\"\"\n    Raised if an Argument instance is created with invalid or\n    inconsistent arguments.\n    \"\"\"\n\n    def __init__(self, msg: str, option: Union[\"Argument\", str]) -> None:\n        self.msg = msg\n        self.option_id = str(option)\n\n    def __str__(self) -> str:\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg\n\n\nclass Argument:\n    \"\"\"class that mimics the necessary behaviour of optparse.Option\n\n    it's currently a least effort implementation\n    and ignoring choices and integer prefixes\n    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types\n    \"\"\"\n\n    _typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}\n\n    def __init__(self, *names: str, **attrs: Any) -> None:\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        dest = attrs.get(\"dest\")  # type: Optional[str]\n        if dest:\n            self.dest = dest\n        elif self._long_opts:\n            self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n        else:\n            try:\n                self.dest = self._short_opts[0][1:]\n            except IndexError:\n                self.dest = \"???\"  # Needed for the error repr.\n                raise ArgumentError(\"need a long or short option\", self)\n\n    def names(self) -> List[str]:\n        return self._short_opts + self._long_opts\n\n    def attrs(self) -> Mapping[str, Any]:\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_MyOptionParser_MyOptionParser.parse_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_MyOptionParser_MyOptionParser.parse_args", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 372, "end_line": 418, "span_ids": ["MyOptionParser", "MyOptionParser.__init__", "MyOptionParser.error", "MyOptionParser.parse_args", "MyOptionParser:2"], "tokens": 405}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MyOptionParser(argparse.ArgumentParser):\n    def __init__(\n        self,\n        parser: Parser,\n        extra_info: Optional[Dict[str, Any]] = None,\n        prog: Optional[str] = None,\n    ) -> None:\n        self._parser = parser\n        argparse.ArgumentParser.__init__(\n            self,\n            prog=prog,\n            usage=parser._usage,\n            add_help=False,\n            formatter_class=DropShorterLongHelpFormatter,\n            allow_abbrev=False,\n        )\n        # extra_info is a dict of (param -> value) to display if there's\n        # an usage error to provide more contextual information to the user\n        self.extra_info = extra_info if extra_info else {}\n\n    def error(self, message: str) -> \"NoReturn\":\n        \"\"\"Transform argparse error message into UsageError.\"\"\"\n        msg = \"{}: error: {}\".format(self.prog, message)\n\n        if hasattr(self._parser, \"_config_source_hint\"):\n            # Type ignored because the attribute is set dynamically.\n            msg = \"{} ({})\".format(msg, self._parser._config_source_hint)  # type: ignore\n\n        raise UsageError(self.format_usage() + msg)\n\n    # Type ignored because typeshed has a very complex type in the superclass.\n    def parse_args(  # type: ignore\n        self,\n        args: Optional[Sequence[str]] = None,\n        namespace: Optional[argparse.Namespace] = None,\n    ) -> argparse.Namespace:\n        \"\"\"allow splitting of positional arguments\"\"\"\n        parsed, unrecognized = self.parse_known_args(args, namespace)\n        if unrecognized:\n            for arg in unrecognized:\n                if arg and arg[0] == \"-\":\n                    lines = [\"unrecognized arguments: %s\" % (\" \".join(unrecognized))]\n                    for k, v in sorted(self.extra_info.items()):\n                        lines.append(\"  {}: {}\".format(k, v))\n                    self.error(\"\\n\".join(lines))\n            getattr(parsed, FILE_OR_DIR).extend(unrecognized)\n        return parsed", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_MyOptionParser.if_sys_version_info_2__MyOptionParser.if_sys_version_info_2_._parse_optional.return_None_arg_string_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/config/argparsing.py_MyOptionParser.if_sys_version_info_2__MyOptionParser.if_sys_version_info_2_._parse_optional.return_None_arg_string_", "embedding": null, "metadata": {"file_path": "src/_pytest/config/argparsing.py", "file_name": "argparsing.py", "file_type": "text/x-python", "category": "implementation", "start_line": 420, "end_line": 456, "span_ids": ["MyOptionParser:3"], "tokens": 355}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class MyOptionParser(argparse.ArgumentParser):\n\n    if sys.version_info[:2] < (3, 9):  # pragma: no cover\n        # Backport of https://github.com/python/cpython/pull/14316 so we can\n        # disable long --argument abbreviations without breaking short flags.\n        def _parse_optional(\n            self, arg_string: str\n        ) -> Optional[Tuple[Optional[argparse.Action], str, Optional[str]]]:\n            if not arg_string:\n                return None\n            if not arg_string[0] in self.prefix_chars:\n                return None\n            if arg_string in self._option_string_actions:\n                action = self._option_string_actions[arg_string]\n                return action, arg_string, None\n            if len(arg_string) == 1:\n                return None\n            if \"=\" in arg_string:\n                option_string, explicit_arg = arg_string.split(\"=\", 1)\n                if option_string in self._option_string_actions:\n                    action = self._option_string_actions[option_string]\n                    return action, option_string, explicit_arg\n            if self.allow_abbrev or not arg_string.startswith(\"--\"):\n                option_tuples = self._get_option_tuples(arg_string)\n                if len(option_tuples) > 1:\n                    msg = gettext(\n                        \"ambiguous option: %(option)s could match %(matches)s\"\n                    )\n                    options = \", \".join(option for _, option, _ in option_tuples)\n                    self.error(msg % {\"option\": arg_string, \"matches\": options})\n                elif len(option_tuples) == 1:\n                    (option_tuple,) = option_tuples\n                    return option_tuple\n            if self._negative_number_matcher.match(arg_string):\n                if not self._has_negative_number_optionals:\n                    return None\n            if \" \" in arg_string:\n                return None\n            return None, arg_string, None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__discover_and_run_doct_CHECKER_CLASS": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__discover_and_run_doct_CHECKER_CLASS", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 52, "span_ids": ["docstring"], "tokens": 313}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" discover and run doctests in modules and test files.\"\"\"\nimport bdb\nimport inspect\nimport platform\nimport sys\nimport traceback\nimport warnings\nfrom contextlib import contextmanager\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\n\nimport py.path\n\nimport pytest\nfrom _pytest import outcomes\nfrom _pytest._code.code import ExceptionInfo\nfrom _pytest._code.code import ReprFileLocation\nfrom _pytest._code.code import TerminalRepr\nfrom _pytest._io import TerminalWriter\nfrom _pytest.compat import safe_getattr\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.fixtures import FixtureRequest\nfrom _pytest.outcomes import OutcomeException\nfrom _pytest.python_api import approx\nfrom _pytest.warning_types import PytestWarning\n\nif TYPE_CHECKING:\n    import doctest\n    from typing import Type\n\nDOCTEST_REPORT_CHOICE_NONE = \"none\"\nDOCTEST_REPORT_CHOICE_CDIFF = \"cdiff\"\nDOCTEST_REPORT_CHOICE_NDIFF = \"ndiff\"\nDOCTEST_REPORT_CHOICE_UDIFF = \"udiff\"\nDOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE = \"only_first_failure\"\n\nDOCTEST_REPORT_CHOICES = (\n    DOCTEST_REPORT_CHOICE_NONE,\n    DOCTEST_REPORT_CHOICE_CDIFF,\n    DOCTEST_REPORT_CHOICE_NDIFF,\n    DOCTEST_REPORT_CHOICE_UDIFF,\n    DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE,\n)\n\n# Lazy definition of runner class\nRUNNER_CLASS = None\n# Lazy definition of output checker class\nCHECKER_CLASS = None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__type_Optional_Type_doc_pytest_addoption.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__type_Optional_Type_doc_pytest_addoption.None_6", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 52, "end_line": 102, "span_ids": ["docstring", "pytest_addoption"], "tokens": 325}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "  # type: Optional[Type[doctest.OutputChecker]]\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"doctest_optionflags\",\n        \"option flags for doctests\",\n        type=\"args\",\n        default=[\"ELLIPSIS\"],\n    )\n    parser.addini(\n        \"doctest_encoding\", \"encoding used for doctest files\", default=\"utf-8\"\n    )\n    group = parser.getgroup(\"collect\")\n    group.addoption(\n        \"--doctest-modules\",\n        action=\"store_true\",\n        default=False,\n        help=\"run doctests in all .py modules\",\n        dest=\"doctestmodules\",\n    )\n    group.addoption(\n        \"--doctest-report\",\n        type=str.lower,\n        default=\"udiff\",\n        help=\"choose another output format for diffs on doctest failure\",\n        choices=DOCTEST_REPORT_CHOICES,\n        dest=\"doctestreport\",\n    )\n    group.addoption(\n        \"--doctest-glob\",\n        action=\"append\",\n        default=[],\n        metavar=\"pat\",\n        help=\"doctests file matching pattern, default: test*.txt\",\n        dest=\"doctestglob\",\n    )\n    group.addoption(\n        \"--doctest-ignore-import-errors\",\n        action=\"store_true\",\n        default=False,\n        help=\"ignore doctest ImportErrors\",\n        dest=\"doctest_ignore_import_errors\",\n    )\n    group.addoption(\n        \"--doctest-continue-on-failure\",\n        action=\"store_true\",\n        default=False,\n        help=\"for a given doctest, continue to run after the first failure\",\n        dest=\"doctest_continue_on_failure\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_pytest_unconfigure_MultipleDoctestFailures.__init__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_pytest_unconfigure_MultipleDoctestFailures.__init__", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 105, "end_line": 153, "span_ids": ["MultipleDoctestFailures", "MultipleDoctestFailures.__init__", "ReprFailDoctest", "ReprFailDoctest.__init__", "ReprFailDoctest.toterminal", "_is_doctest", "_is_setup_py", "pytest_collect_file", "pytest_unconfigure"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_unconfigure():\n    global RUNNER_CLASS\n\n    RUNNER_CLASS = None\n\n\ndef pytest_collect_file(path: py.path.local, parent):\n    config = parent.config\n    if path.ext == \".py\":\n        if config.option.doctestmodules and not _is_setup_py(path):\n            return DoctestModule.from_parent(parent, fspath=path)\n    elif _is_doctest(config, path, parent):\n        return DoctestTextfile.from_parent(parent, fspath=path)\n\n\ndef _is_setup_py(path: py.path.local) -> bool:\n    if path.basename != \"setup.py\":\n        return False\n    contents = path.read_binary()\n    return b\"setuptools\" in contents or b\"distutils\" in contents\n\n\ndef _is_doctest(config, path, parent):\n    if path.ext in (\".txt\", \".rst\") and parent.session.isinitpath(path):\n        return True\n    globs = config.getoption(\"doctestglob\") or [\"test*.txt\"]\n    for glob in globs:\n        if path.check(fnmatch=glob):\n            return True\n    return False\n\n\nclass ReprFailDoctest(TerminalRepr):\n    def __init__(\n        self, reprlocation_lines: Sequence[Tuple[ReprFileLocation, Sequence[str]]]\n    ):\n        self.reprlocation_lines = reprlocation_lines\n\n    def toterminal(self, tw: TerminalWriter) -> None:\n        for reprlocation, lines in self.reprlocation_lines:\n            for line in lines:\n                tw.line(line)\n            reprlocation.toterminal(tw)\n\n\nclass MultipleDoctestFailures(Exception):\n    def __init__(self, failures):\n        super().__init__()\n        self.failures = failures", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestModule_DoctestModule.collect.for_test_in_finder_find_m": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py_DoctestModule_DoctestModule.collect.for_test_in_finder_find_m", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 445, "end_line": 503, "span_ids": ["DoctestModule", "DoctestModule.collect"], "tokens": 448}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class DoctestModule(pytest.Module):\n    def collect(self):\n        import doctest\n\n        class MockAwareDocTestFinder(doctest.DocTestFinder):\n            \"\"\"\n            a hackish doctest finder that overrides stdlib internals to fix a stdlib bug\n\n            https://github.com/pytest-dev/pytest/issues/3456\n            https://bugs.python.org/issue25532\n            \"\"\"\n\n            def _find_lineno(self, obj, source_lines):\n                \"\"\"\n                Doctest code does not take into account `@property`, this is a hackish way to fix it.\n\n                https://bugs.python.org/issue17446\n                \"\"\"\n                if isinstance(obj, property):\n                    obj = getattr(obj, \"fget\", obj)\n                return doctest.DocTestFinder._find_lineno(self, obj, source_lines)\n\n            def _find(\n                self, tests, obj, name, module, source_lines, globs, seen\n            ) -> None:\n                if _is_mocked(obj):\n                    return\n                with _patch_unwrap_mock_aware():\n\n                    # Type ignored because this is a private function.\n                    doctest.DocTestFinder._find(  # type: ignore\n                        self, tests, obj, name, module, source_lines, globs, seen\n                    )\n\n        if self.fspath.basename == \"conftest.py\":\n            module = self.config.pluginmanager._importconftest(self.fspath)\n        else:\n            try:\n                module = self.fspath.pyimport()\n            except ImportError:\n                if self.config.getvalue(\"doctest_ignore_import_errors\"):\n                    pytest.skip(\"unable to import module %r\" % self.fspath)\n                else:\n                    raise\n        # uses internal doctest module parsing mechanism\n        finder = MockAwareDocTestFinder()\n        optionflags = get_optionflags(self)\n        runner = _get_runner(\n            verbose=False,\n            optionflags=optionflags,\n            checker=_get_checker(),\n            continue_on_failure=_get_continue_on_failure(self.config),\n        )\n\n        for test in finder.find(module, module.__name__):\n            if test.examples:  # skip empty doctests\n                yield DoctestItem.from_parent(\n                    self, name=test.name, runner=runner, dtest=test\n                )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__setup_fixtures__init_checker_class.LiteralsOutputChecker._number_re": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__setup_fixtures__init_checker_class.LiteralsOutputChecker._number_re", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 506, "end_line": 558, "span_ids": ["_init_checker_class", "_setup_fixtures"], "tokens": 399}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _setup_fixtures(doctest_item):\n    \"\"\"\n    Used by DoctestTextfile and DoctestItem to setup fixture information.\n    \"\"\"\n\n    def func():\n        pass\n\n    doctest_item.funcargs = {}\n    fm = doctest_item.session._fixturemanager\n    doctest_item._fixtureinfo = fm.getfixtureinfo(\n        node=doctest_item, func=func, cls=None, funcargs=False\n    )\n    fixture_request = FixtureRequest(doctest_item)\n    fixture_request._fillfixtures()\n    return fixture_request\n\n\ndef _init_checker_class() -> \"Type[doctest.OutputChecker]\":\n    import doctest\n    import re\n\n    class LiteralsOutputChecker(doctest.OutputChecker):\n        \"\"\"\n        Based on doctest_nose_plugin.py from the nltk project\n        (https://github.com/nltk/nltk) and on the \"numtest\" doctest extension\n        by Sebastien Boisgerault (https://github.com/boisgera/numtest).\n        \"\"\"\n\n        _unicode_literal_re = re.compile(r\"(\\W|^)[uU]([rR]?[\\'\\\"])\", re.UNICODE)\n        _bytes_literal_re = re.compile(r\"(\\W|^)[bB]([rR]?[\\'\\\"])\", re.UNICODE)\n        _number_re = re.compile(\n            r\"\"\"\n            (?P<number>\n              (?P<mantissa>\n                (?P<integer1> [+-]?\\d*)\\.(?P<fraction>\\d+)\n                |\n                (?P<integer2> [+-]?\\d+)\\.\n              )\n              (?:\n                [Ee]\n                (?P<exponent1> [+-]?\\d+)\n              )?\n              |\n              (?P<integer3> [+-]?\\d+)\n              (?:\n                [Ee]\n                (?P<exponent2> [+-]?\\d+)\n              )\n            )\n            \"\"\",\n            re.VERBOSE,\n        )\n    # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_checker_class.LiteralsOutputChecker.check_output__init_checker_class.LiteralsOutputChecker.check_output.return_doctest_OutputChec": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_checker_class.LiteralsOutputChecker.check_output__init_checker_class.LiteralsOutputChecker.check_output.return_doctest_OutputChec", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 560, "end_line": 585, "span_ids": ["_init_checker_class"], "tokens": 202}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _init_checker_class() -> \"Type[doctest.OutputChecker]\":\n\n    class LiteralsOutputChecker(doctest.OutputChecker):\n\n        def check_output(self, want, got, optionflags):\n            if doctest.OutputChecker.check_output(self, want, got, optionflags):\n                return True\n\n            allow_unicode = optionflags & _get_allow_unicode_flag()\n            allow_bytes = optionflags & _get_allow_bytes_flag()\n            allow_number = optionflags & _get_number_flag()\n\n            if not allow_unicode and not allow_bytes and not allow_number:\n                return False\n\n            def remove_prefixes(regex, txt):\n                return re.sub(regex, r\"\\1\\2\", txt)\n\n            if allow_unicode:\n                want = remove_prefixes(self._unicode_literal_re, want)\n                got = remove_prefixes(self._unicode_literal_re, got)\n\n            if allow_bytes:\n                want = remove_prefixes(self._bytes_literal_re, want)\n                got = remove_prefixes(self._bytes_literal_re, got)\n\n            if allow_number:\n                got = self._remove_unwanted_precision(want, got)\n\n            return doctest.OutputChecker.check_output(self, want, got, optionflags)\n    # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_checker_class.LiteralsOutputChecker._remove_unwanted_precision__init_checker_class.return_LiteralsOutputChec": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__init_checker_class.LiteralsOutputChecker._remove_unwanted_precision__init_checker_class.return_LiteralsOutputChec", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 587, "end_line": 614, "span_ids": ["_init_checker_class"], "tokens": 246}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _init_checker_class() -> \"Type[doctest.OutputChecker]\":\n\n    class LiteralsOutputChecker(doctest.OutputChecker):\n\n        def _remove_unwanted_precision(self, want, got):\n            wants = list(self._number_re.finditer(want))\n            gots = list(self._number_re.finditer(got))\n            if len(wants) != len(gots):\n                return got\n            offset = 0\n            for w, g in zip(wants, gots):\n                fraction = w.group(\"fraction\")\n                exponent = w.group(\"exponent1\")\n                if exponent is None:\n                    exponent = w.group(\"exponent2\")\n                if fraction is None:\n                    precision = 0\n                else:\n                    precision = len(fraction)\n                if exponent is not None:\n                    precision -= int(exponent)\n                if float(w.group()) == approx(float(g.group()), abs=10 ** -precision):\n                    # They're close enough. Replace the text we actually\n                    # got with the text we want, so that it will match when we\n                    # check the string literally.\n                    got = (\n                        got[: g.start() + offset] + w.group() + got[g.end() + offset :]\n                    )\n                    offset += w.end() - w.start() - (g.end() - g.start())\n            return got\n\n    return LiteralsOutputChecker", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__get_checker_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/doctest.py__get_checker_", "embedding": null, "metadata": {"file_path": "src/_pytest/doctest.py", "file_name": "doctest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 617, "end_line": 687, "span_ids": ["_get_allow_bytes_flag", "_get_allow_unicode_flag", "_get_checker", "_get_number_flag", "_get_report_choice", "doctest_namespace"], "tokens": 464}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _get_checker() -> \"doctest.OutputChecker\":\n    \"\"\"\n    Returns a doctest.OutputChecker subclass that supports some\n    additional options:\n\n    * ALLOW_UNICODE and ALLOW_BYTES options to ignore u'' and b''\n      prefixes (respectively) in string literals. Useful when the same\n      doctest should run in Python 2 and Python 3.\n\n    * NUMBER to ignore floating-point differences smaller than the\n      precision of the literal number in the doctest.\n\n    An inner class is used to avoid importing \"doctest\" at the module\n    level.\n    \"\"\"\n    global CHECKER_CLASS\n    if CHECKER_CLASS is None:\n        CHECKER_CLASS = _init_checker_class()\n    return CHECKER_CLASS()\n\n\ndef _get_allow_unicode_flag() -> int:\n    \"\"\"\n    Registers and returns the ALLOW_UNICODE flag.\n    \"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"ALLOW_UNICODE\")\n\n\ndef _get_allow_bytes_flag() -> int:\n    \"\"\"\n    Registers and returns the ALLOW_BYTES flag.\n    \"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"ALLOW_BYTES\")\n\n\ndef _get_number_flag() -> int:\n    \"\"\"\n    Registers and returns the NUMBER flag.\n    \"\"\"\n    import doctest\n\n    return doctest.register_optionflag(\"NUMBER\")\n\n\ndef _get_report_choice(key: str) -> int:\n    \"\"\"\n    This function returns the actual `doctest` module flag value, we want to do it as late as possible to avoid\n    importing `doctest` and all its dependencies when parsing options, as it adds overhead and breaks tests.\n    \"\"\"\n    import doctest\n\n    return {\n        DOCTEST_REPORT_CHOICE_UDIFF: doctest.REPORT_UDIFF,\n        DOCTEST_REPORT_CHOICE_CDIFF: doctest.REPORT_CDIFF,\n        DOCTEST_REPORT_CHOICE_NDIFF: doctest.REPORT_NDIFF,\n        DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE: doctest.REPORT_ONLY_FIRST_FAILURE,\n        DOCTEST_REPORT_CHOICE_NONE: 0,\n    }[key]\n\n\n@pytest.fixture(scope=\"session\")\ndef doctest_namespace():\n    \"\"\"\n    Fixture that returns a :py:class:`dict` that will be injected into the namespace of doctests.\n    \"\"\"\n    return dict()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/faulthandler.py_io_pytest_configure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/faulthandler.py_io_pytest_configure", "embedding": null, "metadata": {"file_path": "src/_pytest/faulthandler.py", "file_name": "faulthandler.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 42, "span_ids": ["imports", "pytest_addoption", "pytest_configure"], "tokens": 275}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import io\nimport os\nimport sys\nfrom typing import TextIO\n\nimport pytest\nfrom _pytest.store import StoreKey\n\n\nfault_handler_stderr_key = StoreKey[TextIO]()\n\n\ndef pytest_addoption(parser):\n    help = (\n        \"Dump the traceback of all threads if a test takes \"\n        \"more than TIMEOUT seconds to finish.\"\n    )\n    parser.addini(\"faulthandler_timeout\", help, default=0.0)\n\n\ndef pytest_configure(config):\n    import faulthandler\n\n    if not faulthandler.is_enabled():\n        # faulthhandler is not enabled, so install plugin that does the actual work\n        # of enabling faulthandler before each test executes.\n        config.pluginmanager.register(FaultHandlerHooks(), \"faulthandler-hooks\")\n    else:\n        from _pytest.warnings import _issue_warning_captured\n\n        # Do not handle dumping to stderr if faulthandler is already enabled, so warn\n        # users that the option is being ignored.\n        timeout = FaultHandlerHooks.get_timeout_config_value(config)\n        if timeout > 0:\n            _issue_warning_captured(\n                pytest.PytestConfigWarning(\n                    \"faulthandler module enabled before pytest configuration step, \"\n                    \"'faulthandler_timeout' option ignored\"\n                ),\n                config.hook,\n                stacklevel=2,\n            )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/faulthandler.py_FaultHandlerHooks_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/faulthandler.py_FaultHandlerHooks_", "embedding": null, "metadata": {"file_path": "src/_pytest/faulthandler.py", "file_name": "faulthandler.py", "file_type": "text/x-python", "category": "implementation", "start_line": 45, "end_line": 113, "span_ids": ["FaultHandlerHooks", "FaultHandlerHooks._get_stderr_fileno", "FaultHandlerHooks.get_timeout_config_value", "FaultHandlerHooks.pytest_configure", "FaultHandlerHooks.pytest_enter_pdb", "FaultHandlerHooks.pytest_exception_interact", "FaultHandlerHooks.pytest_runtest_protocol", "FaultHandlerHooks.pytest_unconfigure"], "tokens": 542}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FaultHandlerHooks:\n    \"\"\"Implements hooks that will actually install fault handler before tests execute,\n    as well as correctly handle pdb and internal errors.\"\"\"\n\n    def pytest_configure(self, config):\n        import faulthandler\n\n        stderr_fd_copy = os.dup(self._get_stderr_fileno())\n        config._store[fault_handler_stderr_key] = open(stderr_fd_copy, \"w\")\n        faulthandler.enable(file=config._store[fault_handler_stderr_key])\n\n    def pytest_unconfigure(self, config):\n        import faulthandler\n\n        faulthandler.disable()\n        # close our dup file installed during pytest_configure\n        # re-enable the faulthandler, attaching it to the default sys.stderr\n        # so we can see crashes after pytest has finished, usually during\n        # garbage collection during interpreter shutdown\n        config._store[fault_handler_stderr_key].close()\n        del config._store[fault_handler_stderr_key]\n        faulthandler.enable(file=self._get_stderr_fileno())\n\n    @staticmethod\n    def _get_stderr_fileno():\n        try:\n            return sys.stderr.fileno()\n        except (AttributeError, io.UnsupportedOperation):\n            # pytest-xdist monkeypatches sys.stderr with an object that is not an actual file.\n            # https://docs.python.org/3/library/faulthandler.html#issue-with-file-descriptors\n            # This is potentially dangerous, but the best we can do.\n            return sys.__stderr__.fileno()\n\n    @staticmethod\n    def get_timeout_config_value(config):\n        return float(config.getini(\"faulthandler_timeout\") or 0.0)\n\n    @pytest.hookimpl(hookwrapper=True, trylast=True)\n    def pytest_runtest_protocol(self, item):\n        timeout = self.get_timeout_config_value(item.config)\n        stderr = item.config._store[fault_handler_stderr_key]\n        if timeout > 0 and stderr is not None:\n            import faulthandler\n\n            faulthandler.dump_traceback_later(timeout, file=stderr)\n            try:\n                yield\n            finally:\n                faulthandler.cancel_dump_traceback_later()\n        else:\n            yield\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_enter_pdb(self):\n        \"\"\"Cancel any traceback dumping due to timeout before entering pdb.\n        \"\"\"\n        import faulthandler\n\n        faulthandler.cancel_dump_traceback_later()\n\n    @pytest.hookimpl(tryfirst=True)\n    def pytest_exception_interact(self):\n        \"\"\"Cancel any traceback dumping due to an interactive exception being\n        raised.\n        \"\"\"\n        import faulthandler\n\n        faulthandler.cancel_dump_traceback_later()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_reorder_items_atscope_reorder_items_atscope.return_items_done": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_reorder_items_atscope_reorder_items_atscope.return_items_done", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 240, "end_line": 277, "span_ids": ["reorder_items_atscope"], "tokens": 354}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = order_preserving_dict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items_deque:\n        no_argkey_group = order_preserving_dict()\n        slicing_argkey = None\n        while items_deque:\n            item = items_deque.popleft()\n            if item in items_done or item in no_argkey_group:\n                continue\n            argkeys = order_preserving_dict.fromkeys(\n                k for k in scoped_argkeys_cache.get(item, []) if k not in ignore\n            )\n            if not argkeys:\n                no_argkey_group[item] = None\n            else:\n                slicing_argkey, _ = argkeys.popitem()\n                # we don't have to remove relevant items from later in the deque because they'll just be ignored\n                matching_items = [\n                    i for i in scoped_items_by_argkey[slicing_argkey] if i in items\n                ]\n                for i in reversed(matching_items):\n                    fix_cache_order(i, argkeys_cache, items_by_argkey)\n                    items_deque.appendleft(i)\n                break\n        if no_argkey_group:\n            no_argkey_group = reorder_items_atscope(\n                no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1\n            )\n            for item in no_argkey_group:\n                items_done[item] = None\n        ignore.add(slicing_argkey)\n    return items_done", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fillfixtures_get_direct_param_fixture_func": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fillfixtures_get_direct_param_fixture_func", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 280, "end_line": 304, "span_ids": ["fillfixtures", "get_direct_param_fixture_func"], "tokens": 204}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def fillfixtures(function):\n    \"\"\" fill missing funcargs for a test function. \"\"\"\n    warnings.warn(FILLFUNCARGS, stacklevel=2)\n    try:\n        request = function._request\n    except AttributeError:\n        # XXX this special code path is only expected to execute\n        # with the oejskit plugin.  It uses classes with funcargs\n        # and we thus have to work a bit to allow this.\n        fm = function.session._fixturemanager\n        fi = fm.getfixtureinfo(function.parent, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._request = FixtureRequest(function)\n        request._fillfixtures()\n        # prune out funcargs for jstests\n        newfuncargs = {}\n        for name in fi.argnames:\n            newfuncargs[name] = function.funcargs[name]\n        function.funcargs = newfuncargs\n    else:\n        request._fillfixtures()\n\n\ndef get_direct_param_fixture_func(request):\n    return request.param", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest_FixtureRequest.module": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest_FixtureRequest.module", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 346, "end_line": 430, "span_ids": ["FixtureRequest", "FixtureRequest.__init__", "FixtureRequest._getnextfixturedef", "FixtureRequest.cls", "FixtureRequest.config", "FixtureRequest.fixturenames", "FixtureRequest.funcargnames", "FixtureRequest.function", "FixtureRequest.instance", "FixtureRequest.module", "FixtureRequest.node"], "tokens": 720}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureRequest:\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # type: Dict[str, FixtureDef]\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest.fspath_FixtureRequest._get_fixturestack": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureRequest.fspath_FixtureRequest._get_fixturestack", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 432, "end_line": 522, "span_ids": ["FixtureRequest._addfinalizer", "FixtureRequest._fillfixtures", "FixtureRequest._get_active_fixturedef", "FixtureRequest._get_fixturestack", "FixtureRequest.addfinalizer", "FixtureRequest.applymarker", "FixtureRequest.fspath", "FixtureRequest.getfixturevalue", "FixtureRequest.keywords", "FixtureRequest.raiseerror", "FixtureRequest.session"], "tokens": 707}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FixtureRequest:\n\n    @scopeproperty()\n    def fspath(self) -> py.path.local:\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        # TODO: Remove ignore once _pyfuncitem is properly typed.\n        return self._pyfuncitem.fspath  # type: ignore\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n\n        :raise pytest.FixtureLookupError:\n            If the given fixture could not be found.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_pytest_fixture_setup__ensure_immutable_ids": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_pytest_fixture_setup__ensure_immutable_ids", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 962, "end_line": 988, "span_ids": ["_ensure_immutable_ids", "pytest_fixture_setup"], "tokens": 209}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_fixture_setup(fixturedef, request):\n    \"\"\" Execution of fixture setup. \"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        assert fixdef.cached_result is not None\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request.scope, fixdef.scope)\n        kwargs[argname] = result\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = fixturedef.cache_key(request)\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME:\n        fixturedef.cached_result = (None, my_cache_key, sys.exc_info())\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)\n    return result\n\n\ndef _ensure_immutable_ids(ids):\n    if ids is None:\n        return\n    if callable(ids):\n        return ids\n    return tuple(ids)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_wrap_function_to_error_out_if_called_directly_wrap_function_to_error_out_if_called_directly": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_wrap_function_to_error_out_if_called_directly_wrap_function_to_error_out_if_called_directly", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 991, "end_line": 1010, "span_ids": ["wrap_function_to_error_out_if_called_directly"], "tokens": 233}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def wrap_function_to_error_out_if_called_directly(function, fixture_marker):\n    \"\"\"Wrap the given fixture function so we can raise an error about it being called directly,\n    instead of used as an argument in a test function.\n    \"\"\"\n    message = (\n        'Fixture \"{name}\" called directly. Fixtures are not meant to be called directly,\\n'\n        \"but are created automatically when test functions request them as parameters.\\n\"\n        \"See https://docs.pytest.org/en/latest/fixture.html for more information about fixtures, and\\n\"\n        \"https://docs.pytest.org/en/latest/deprecations.html#calling-fixtures-directly about how to update your code.\"\n    ).format(name=fixture_marker.name or function.__name__)\n\n    @functools.wraps(function)\n    def result(*args, **kwargs):\n        fail(message, pytrace=False)\n\n    # keep reference to the original function in our own custom attribute so we don't unwrap\n    # further than this point and lose useful wrappings like @mock.patch (#3774)\n    result.__pytest_wrapped__ = _PytestWrapper(function)\n\n    return result", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureFunctionMarker_FixtureFunctionMarker.__call__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_FixtureFunctionMarker_FixtureFunctionMarker.__call__", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1013, "end_line": 1043, "span_ids": ["FixtureFunctionMarker", "FixtureFunctionMarker.__call__"], "tokens": 228}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(frozen=True)\nclass FixtureFunctionMarker:\n    scope = attr.ib()\n    params = attr.ib(converter=attr.converters.optional(tuple))\n    autouse = attr.ib(default=False)\n    # Ignore type because of https://github.com/python/mypy/issues/6172.\n    ids = attr.ib(default=None, converter=_ensure_immutable_ids)  # type: ignore\n    name = attr.ib(default=None)\n\n    def __call__(self, function):\n        if inspect.isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            location = getlocation(function)\n            fail(\n                \"'request' is a reserved word for fixtures, use another name:\\n  {}\".format(\n                    location\n                ),\n                pytrace=False,\n            )\n        function._pytestfixturefunction = self\n        return function", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fixture_fixture.if_len_args_2_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fixture_fixture.if_len_args_2_", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1046, "end_line": 1127, "span_ids": ["fixture"], "tokens": 730}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def fixture(\n    fixture_function=None,\n    *args,\n    scope=\"function\",\n    params=None,\n    autouse=False,\n    ids=None,\n    name=None\n):\n    \"\"\"Decorator to mark a fixture factory function.\n\n    This decorator can be used, with or without parameters, to define a\n    fixture function.\n\n    The name of the fixture function can later be referenced to cause its\n    invocation ahead of running tests: test\n    modules or classes can use the ``pytest.mark.usefixtures(fixturename)``\n    marker.\n\n    Test functions can directly use fixture names as input\n    arguments in which case the fixture instance returned from the fixture\n    function will be injected.\n\n    Fixtures can provide their values to test functions using ``return`` or ``yield``\n    statements. When using ``yield`` the code block after the ``yield`` statement is executed\n    as teardown code regardless of the test outcome, and must yield exactly once.\n\n    :arg scope: the scope for which this fixture is shared, one of\n                ``\"function\"`` (default), ``\"class\"``, ``\"module\"``,\n                ``\"package\"`` or ``\"session\"`` (``\"package\"`` is considered **experimental**\n                at this time).\n\n                This parameter may also be a callable which receives ``(fixture_name, config)``\n                as parameters, and must return a ``str`` with one of the values mentioned above.\n\n                See :ref:`dynamic scope` in the docs for more information.\n\n    :arg params: an optional list of parameters which will cause multiple\n                invocations of the fixture function and all of the tests\n                using it.\n                The current parameter is available in ``request.param``.\n\n    :arg autouse: if True, the fixture func is activated for all tests that\n                can see it.  If False (the default) then an explicit\n                reference is needed to activate the fixture.\n\n    :arg ids: list of string ids each corresponding to the params\n                so that they are part of the test id. If no ids are provided\n                they will be generated automatically from the params.\n\n    :arg name: the name of the fixture. This defaults to the name of the\n                decorated function. If a fixture is used in the same module in\n                which it is defined, the function name of the fixture will be\n                shadowed by the function arg that requests the fixture; one way\n                to resolve this is to name the decorated function\n                ``fixture_<fixturename>`` and then use\n                ``@pytest.fixture(name='<fixturename>')``.\n    \"\"\"\n    # Positional arguments backward compatibility.\n    # If a kwarg is equal to its default, assume it was not explicitly\n    # passed, i.e. not duplicated. The more correct way is to use a\n    # **kwargs and check `in`, but that obfuscates the function signature.\n    if isinstance(fixture_function, str):\n        # It's actually the first positional argument, scope.\n        args = (fixture_function, *args)\n        fixture_function = None\n    duplicated_args = []\n    if len(args) > 0:\n        if scope == \"function\":\n            scope = args[0]\n        else:\n            duplicated_args.append(\"scope\")\n    if len(args) > 1:\n        if params is None:\n            params = args[1]\n        else:\n            duplicated_args.append(\"params\")\n    if len(args) > 2:\n        if autouse is False:\n            autouse = args[2]\n        else:\n            duplicated_args.append(\"autouse\")\n    # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fixture.if_len_args_3__fixture.return_FixtureFunctionMar": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/fixtures.py_fixture.if_len_args_3__fixture.return_FixtureFunctionMar", "embedding": null, "metadata": {"file_path": "src/_pytest/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1128, "end_line": 1160, "span_ids": ["fixture"], "tokens": 229}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def fixture(\n    fixture_function=None,\n    *args,\n    scope=\"function\",\n    params=None,\n    autouse=False,\n    ids=None,\n    name=None\n):\n    # ... other code\n    if len(args) > 3:\n        if ids is None:\n            ids = args[3]\n        else:\n            duplicated_args.append(\"ids\")\n    if len(args) > 4:\n        if name is None:\n            name = args[4]\n        else:\n            duplicated_args.append(\"name\")\n    if len(args) > 5:\n        raise TypeError(\n            \"fixture() takes 5 positional arguments but {} were given\".format(len(args))\n        )\n    if duplicated_args:\n        raise TypeError(\n            \"The fixture arguments are defined as positional and keyword: {}. \"\n            \"Use only keyword arguments.\".format(\", \".join(duplicated_args))\n        )\n    if args:\n        warnings.warn(FIXTURE_POSITIONAL_ARGUMENTS, stacklevel=2)\n    # End backward compatiblity.\n\n    if params is not None:\n        params = list(params)\n\n    if fixture_function and params is None and autouse is False:\n        # direct decoration\n        return FixtureFunctionMarker(scope, params, autouse, name=name)(\n            fixture_function\n        )\n\n    return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py__hook_specifications_f_pytest_plugin_registered": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py__hook_specifications_f_pytest_plugin_registered", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 48, "span_ids": ["docstring", "pytest_addhooks", "pytest_plugin_registered"], "tokens": 264}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" hook specifications for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom typing import Any\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n\nfrom pluggy import HookspecMarker\n\nfrom .deprecated import COLLECT_DIRECTORY_HOOK\nfrom _pytest.compat import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from _pytest.config import Config\n    from _pytest.main import Session\n    from _pytest.reports import BaseReport\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_addoption_pytest_addoption._register_argparse_styl": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_addoption_pytest_addoption._register_argparse_styl", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 51, "end_line": 86, "span_ids": ["pytest_addoption"], "tokens": 365}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.argparsing.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.argparsing.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.argparsing.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_configure_pytest_load_initial_conftests": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_configure_pytest_load_initial_conftests", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 89, "end_line": 166, "span_ids": ["impl:3", "pytest_cmdline_main", "pytest_cmdline_parse", "pytest_cmdline_preparse", "pytest_configure", "pytest_load_initial_conftests"], "tokens": 569}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    :param _pytest.config.Config config: pytest config object\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_main(config):\n    \"\"\" called for performing the main command line action. The default\n    implementation will invoke the configure hooks and runtest_mainloop.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files ahead\n    of command line option parsing.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    :param _pytest.config.Config early_config: pytest config object\n    :param list[str] args: list of arguments passed on the command line\n    :param _pytest.config.argparsing.Parser parser: to add command line options\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_8_pytest_collection": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_8_pytest_collection", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 169, "end_line": 196, "span_ids": ["impl:5", "pytest_collection"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# -------------------------------------------------------------------------\n# collection hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_collection(session: \"Session\") -> Optional[Any]:\n    \"\"\"Perform the collection protocol for the given session.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n    The return value is not used, but only stops further processing.\n\n    The hook is meant to set `session.items` to a sequence of items at least,\n    but normally should follow this procedure:\n\n      1. Call the pytest_collectstart hook.\n      2. Call the pytest_collectreport hook.\n      3. Call the pytest_collection_modifyitems hook.\n      4. Call the pytest_collection_finish hook.\n      5. Set session.testscollected to the amount of collect items.\n      6. Set `session.items` to a list of items.\n\n    You can implement this hook to only perform some action before collection,\n    for example the terminal plugin uses it to start displaying the collection\n    counter (and returns `None`).\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_collection_modifyitems_pytest_generate_tests": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_collection_modifyitems_pytest_generate_tests", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 199, "end_line": 306, "span_ids": ["impl:7", "impl:8", "pytest_collect_directory", "pytest_collect_file", "pytest_collection_finish", "pytest_collection_modifyitems", "pytest_collectreport", "pytest_collectstart", "pytest_deselected", "pytest_generate_tests", "pytest_ignore_collect", "pytest_itemcollected", "pytest_make_collect_report", "pytest_pycollect_makeitem", "pytest_pycollect_makemodule", "pytest_pyfunc_call"], "tokens": 700}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_collection_modifyitems(session, config, items):\n    \"\"\" called after collection has been performed, may filter or re-order\n    the items in-place.\n\n    :param _pytest.main.Session session: the pytest session object\n    :param _pytest.config.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n@hookspec(firstresult=True, warn_on_impl=COLLECT_DIRECTORY_HOOK)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"\n\n\ndef pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or None.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pyfunc_call(pyfuncitem):\n    \"\"\" call underlying test function.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_make_parametrize_id_pytest_runtest_makereport": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_make_parametrize_id_pytest_runtest_makereport", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 309, "end_line": 403, "span_ids": ["impl:10", "pytest_make_parametrize_id", "pytest_runtest_call", "pytest_runtest_logfinish", "pytest_runtest_logstart", "pytest_runtest_makereport", "pytest_runtest_protocol", "pytest_runtest_setup", "pytest_runtest_teardown", "pytest_runtestloop"], "tokens": 742}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str argname: the automatic parameter name produced by pytest\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# generic runtest related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_runtestloop(session):\n    \"\"\" called for performing the main runtest loop\n    (after collection finished).\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" implements the runtest_setup/call/teardown protocol for\n    the given test item, including capturing exceptions and calling\n    reporting hooks.\n\n    :arg item: test item for which the runtest protocol is performed.\n\n    :arg nextitem: the scheduled-to-be-next test item (or None if this\n                   is the end my friend).  This argument is passed on to\n                   :py:func:`pytest_runtest_teardown`.\n\n    :return boolean: True if no further hook implementations should be invoked.\n\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logstart(nodeid, location):\n    \"\"\" signal the start of running a single test item.\n\n    This hook will be called **before** :func:`pytest_runtest_setup`, :func:`pytest_runtest_call` and\n    :func:`pytest_runtest_teardown` hooks.\n\n    :param str nodeid: full id of the item\n    :param location: a triple of ``(filename, linenum, testname)``\n    \"\"\"\n\n\ndef pytest_runtest_logfinish(nodeid, location):\n    \"\"\" signal the complete finish of running a single test item.\n\n    This hook will be called **after** :func:`pytest_runtest_setup`, :func:`pytest_runtest_call` and\n    :func:`pytest_runtest_teardown` hooks.\n\n    :param str nodeid: full id of the item\n    :param location: a triple of ``(filename, linenum, testname)``\n    \"\"\"\n\n\ndef pytest_runtest_setup(item):\n    \"\"\" called before ``pytest_runtest_call(item)``. \"\"\"\n\n\ndef pytest_runtest_call(item):\n    \"\"\" called to execute the test ``item``. \"\"\"\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_makereport(item, call):\n    \"\"\" return a :py:class:`_pytest.runner.TestReport` object\n    for the given :py:class:`pytest.Item <_pytest.main.Item>` and\n    :py:class:`_pytest.runner.CallInfo`.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_runtest_logreport_pytest_assertrepr_compare": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_runtest_logreport_pytest_assertrepr_compare", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 406, "end_line": 494, "span_ids": ["impl:12", "impl:14", "impl:16", "pytest_assertrepr_compare", "pytest_fixture_post_finalizer", "pytest_fixture_setup", "pytest_report_from_serializable", "pytest_report_to_serializable", "pytest_runtest_logreport", "pytest_sessionfinish", "pytest_sessionstart", "pytest_unconfigure"], "tokens": 540}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_runtest_logreport(report):\n    \"\"\" process a test setup/call/teardown report relating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytest_report_to_serializable().\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Fixture related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_fixture_setup(fixturedef, request):\n    \"\"\" performs fixture setup execution.\n\n    :return: The return value of the call to the fixture function\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        If the fixture function returns None, other implementations of\n        this hook function will continue to be called, according to the\n        behavior of the :ref:`firstresult` option.\n    \"\"\"\n\n\ndef pytest_fixture_post_finalizer(fixturedef, request):\n    \"\"\"Called after fixture teardown, but before the cache is cleared, so\n    the fixture result ``fixturedef.cached_result`` is still available (not\n    ``None``).\"\"\"\n\n\n# -------------------------------------------------------------------------\n# test session related hooks\n# -------------------------------------------------------------------------\n\n\ndef pytest_sessionstart(session):\n    \"\"\" called after the ``Session`` object has been created and before performing collection\n    and entering the run test loop.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\ndef pytest_sessionfinish(session, exitstatus):\n    \"\"\" called after whole test run finished, right before returning the exit status to the system.\n\n    :param _pytest.main.Session session: the pytest session object\n    :param int exitstatus: the status which pytest will return to the system\n    \"\"\"\n\n\ndef pytest_unconfigure(config):\n    \"\"\" called before test process is exited.\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# hooks for customizing the assert methods\n# -------------------------------------------------------------------------\n\n\ndef pytest_assertrepr_compare(config, op, left, right):\n    \"\"\"return explanation for comparisons in failing assert expressions.\n\n    Return None for no custom explanation, otherwise return a list\n    of strings.  The strings will be joined by newlines but any newlines\n    *in* a string will be escaped.  Note that all but the first line will\n    be indented slightly, the intention is for the first line to be a summary.\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_27_pytest_report_collectionfinish": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_None_27_pytest_report_collectionfinish", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 535, "end_line": 579, "span_ids": ["pytest_assertion_pass", "pytest_report_collectionfinish", "pytest_report_header"], "tokens": 333}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# -------------------------------------------------------------------------\n# hooks for influencing reporting (invoked from _pytest_terminal)\n# -------------------------------------------------------------------------\n\n\ndef pytest_report_header(config, startdir):\n    \"\"\" return a string or list of strings to be displayed as header info for terminal reporting.\n\n    :param _pytest.config.Config config: pytest config object\n    :param startdir: py.path object with the starting dir\n\n    .. note::\n\n        Lines returned by a plugin are displayed before those of plugins which\n        ran before it.\n        If you want to have your line(s) displayed first, use\n        :ref:`trylast=True <plugin-hookorder>`.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n    \"\"\"\n\n\ndef pytest_report_collectionfinish(config, startdir, items):\n    \"\"\"\n    .. versionadded:: 3.2\n\n    return a string or list of strings to be displayed after collection has finished successfully.\n\n    These strings will be displayed after the standard \"collected X items\" message.\n\n    :param _pytest.config.Config config: pytest config object\n    :param startdir: py.path object with the starting dir\n    :param items: list of pytest items that are going to be executed; this list should not be modified.\n\n    .. note::\n\n        Lines returned by a plugin are displayed before those of plugins which\n        ran before it.\n        If you want to have your line(s) displayed first, use\n        :ref:`trylast=True <plugin-hookorder>`.\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_report_teststatus_pytest_report_teststatus._Return_result_category": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_report_teststatus_pytest_report_teststatus._Return_result_category", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 582, "end_line": 608, "span_ids": ["pytest_report_teststatus"], "tokens": 248}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookspec(firstresult=True)\ndef pytest_report_teststatus(\n    report: \"BaseReport\", config: \"Config\"\n) -> Tuple[\n    str, str, Union[str, Mapping[str, bool]],\n]:\n    \"\"\"Return result-category, shortletter and verbose word for status\n    reporting.\n\n    The result-category is a category in which to count the result, for\n    example \"passed\", \"skipped\", \"error\" or the empty string.\n\n    The shortletter is shown as testing progresses, for example \".\", \"s\",\n    \"E\" or the empty string.\n\n    The verbose word is shown as testing progresses in verbose mode, for\n    example \"PASSED\", \"SKIPPED\", \"ERROR\" or the empty string.\n\n    pytest may style these implicitly according to the report outcome.\n    To provide explicit styling, return a tuple for the verbose word,\n    for example ``\"rerun\", \"R\", (\"RERUN\", {\"yellow\": True})``.\n\n    :param report: The report object whose status is to be returned.\n    :param _pytest.config.Config config: The pytest config object.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_terminal_summary_pytest_warning_captured._": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/hookspec.py_pytest_terminal_summary_pytest_warning_captured._", "embedding": null, "metadata": {"file_path": "src/_pytest/hookspec.py", "file_name": "hookspec.py", "file_type": "text/x-python", "category": "implementation", "start_line": 611, "end_line": 648, "span_ids": ["pytest_terminal_summary", "pytest_warning_captured"], "tokens": 343}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_terminal_summary(terminalreporter, exitstatus, config):\n    \"\"\"Add a section to terminal summary reporting.\n\n    :param _pytest.terminal.TerminalReporter terminalreporter: the internal terminal reporter object\n    :param int exitstatus: the exit status that will be reported back to the OS\n    :param _pytest.config.Config config: pytest config object\n\n    .. versionadded:: 4.2\n        The ``config`` parameter.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_warning_captured(warning_message, when, item, location):\n    \"\"\"\n    Process a warning captured by the internal pytest warnings plugin.\n\n    :param warnings.WarningMessage warning_message:\n        The captured warning. This is the same object produced by :py:func:`warnings.catch_warnings`, and contains\n        the same attributes as the parameters of :py:func:`warnings.showwarning`.\n\n    :param str when:\n        Indicates when the warning was captured. Possible values:\n\n        * ``\"config\"``: during pytest configuration/initialization stage.\n        * ``\"collect\"``: during test collection.\n        * ``\"runtest\"``: during test execution.\n\n    :param pytest.Item|None item:\n        **DEPRECATED**: This parameter is incompatible with ``pytest-xdist``, and will always receive ``None``\n        in a future release.\n\n        The item being executed if ``when`` is ``\"runtest\"``, otherwise ``None``.\n\n    :param tuple location:\n        Holds information about the execution context of the captured warning (filename, linenumber, function).\n        ``function`` evaluates to <module> when the execution context is at the module level.\n    \"\"\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter.to_xml__NodeReporter.write_captured_output": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter.to_xml__NodeReporter.write_captured_output", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 155, "end_line": 188, "span_ids": ["_NodeReporter._add_simple", "_NodeReporter.to_xml", "_NodeReporter.write_captured_output"], "tokens": 306}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class _NodeReporter:\n\n    def to_xml(self):\n        testcase = Junit.testcase(time=\"%.3f\" % self.duration, **self.attrs)\n        testcase.append(self.make_properties_node())\n        for node in self.nodes:\n            testcase.append(node)\n        return testcase\n\n    def _add_simple(self, kind, message, data=None):\n        data = bin_xml_escape(data)\n        node = kind(data, message=message)\n        self.append(node)\n\n    def write_captured_output(self, report):\n        if not self.xml.log_passing_tests and report.passed:\n            return\n\n        content_out = report.capstdout\n        content_log = report.caplog\n        content_err = report.capstderr\n        if self.xml.logging == \"no\":\n            return\n        content_all = \"\"\n        if self.xml.logging in [\"log\", \"all\"]:\n            content_all = self._prepare_content(content_log, \" Captured Log \")\n        if self.xml.logging in [\"system-out\", \"out-err\", \"all\"]:\n            content_all += self._prepare_content(content_out, \" Captured Out \")\n            self._write_content(report, content_all, \"system-out\")\n            content_all = \"\"\n        if self.xml.logging in [\"system-err\", \"out-err\", \"all\"]:\n            content_all += self._prepare_content(content_err, \" Captured Err \")\n            self._write_content(report, content_all, \"system-err\")\n            content_all = \"\"\n        if content_all:\n            self._write_content(report, content_all, \"system-out\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter._prepare_content__NodeReporter.finalize": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/junitxml.py__NodeReporter._prepare_content__NodeReporter.finalize", "embedding": null, "metadata": {"file_path": "src/_pytest/junitxml.py", "file_name": "junitxml.py", "file_type": "text/x-python", "category": "implementation", "start_line": 190, "end_line": 260, "span_ids": ["_NodeReporter._prepare_content", "_NodeReporter._write_content", "_NodeReporter.append_collect_error", "_NodeReporter.append_collect_skipped", "_NodeReporter.append_error", "_NodeReporter.append_failure", "_NodeReporter.append_pass", "_NodeReporter.append_skipped", "_NodeReporter.finalize"], "tokens": 548}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class _NodeReporter:\n\n    def _prepare_content(self, content, header):\n        return \"\\n\".join([header.center(80, \"-\"), content, \"\"])\n\n    def _write_content(self, report, content, jheader):\n        tag = getattr(Junit, jheader)\n        self.append(tag(bin_xml_escape(content)))\n\n    def append_pass(self, report):\n        self.add_stats(\"passed\")\n\n    def append_failure(self, report):\n        # msg = str(report.longrepr.reprtraceback.extraline)\n        if hasattr(report, \"wasxfail\"):\n            self._add_simple(Junit.skipped, \"xfail-marked test passes unexpectedly\")\n        else:\n            if hasattr(report.longrepr, \"reprcrash\"):\n                message = report.longrepr.reprcrash.message\n            elif isinstance(report.longrepr, str):\n                message = report.longrepr\n            else:\n                message = str(report.longrepr)\n            message = bin_xml_escape(message)\n            fail = Junit.failure(message=message)\n            fail.append(bin_xml_escape(report.longrepr))\n            self.append(fail)\n\n    def append_collect_error(self, report):\n        # msg = str(report.longrepr.reprtraceback.extraline)\n        self.append(\n            Junit.error(bin_xml_escape(report.longrepr), message=\"collection failure\")\n        )\n\n    def append_collect_skipped(self, report):\n        self._add_simple(Junit.skipped, \"collection skipped\", report.longrepr)\n\n    def append_error(self, report):\n        if report.when == \"teardown\":\n            msg = \"test teardown failure\"\n        else:\n            msg = \"test setup failure\"\n        self._add_simple(Junit.error, msg, report.longrepr)\n\n    def append_skipped(self, report):\n        if hasattr(report, \"wasxfail\"):\n            xfailreason = report.wasxfail\n            if xfailreason.startswith(\"reason: \"):\n                xfailreason = xfailreason[8:]\n            self.append(\n                Junit.skipped(\n                    \"\", type=\"pytest.xfail\", message=bin_xml_escape(xfailreason)\n                )\n            )\n        else:\n            filename, lineno, skipreason = report.longrepr\n            if skipreason.startswith(\"Skipped: \"):\n                skipreason = skipreason[9:]\n            details = \"{}:{}: {}\".format(filename, lineno, skipreason)\n\n            self.append(\n                Junit.skipped(\n                    bin_xml_escape(details),\n                    type=\"pytest.skip\",\n                    message=bin_xml_escape(skipreason),\n                )\n            )\n            self.write_captured_output(report)\n\n    def finalize(self):\n        data = self.to_xml().unicode(indent=0)\n        self.__dict__.clear()\n        self.to_xml = lambda: py.xml.raw(data)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_PercentStyleMultiline_PercentStyleMultiline.format": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_PercentStyleMultiline_PercentStyleMultiline.format", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 77, "end_line": 164, "span_ids": ["PercentStyleMultiline", "PercentStyleMultiline.__init__", "PercentStyleMultiline._get_auto_indent", "PercentStyleMultiline._update_message", "PercentStyleMultiline.format"], "tokens": 669}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PercentStyleMultiline(logging.PercentStyle):\n    \"\"\"A logging style with special support for multiline messages.\n\n    If the message of a record consists of multiple lines, this style\n    formats the message as if each line were logged separately.\n    \"\"\"\n\n    def __init__(self, fmt, auto_indent):\n        super().__init__(fmt)\n        self._auto_indent = self._get_auto_indent(auto_indent)\n\n    @staticmethod\n    def _update_message(record_dict, message):\n        tmp = record_dict.copy()\n        tmp[\"message\"] = message\n        return tmp\n\n    @staticmethod\n    def _get_auto_indent(auto_indent_option) -> int:\n        \"\"\"Determines the current auto indentation setting\n\n        Specify auto indent behavior (on/off/fixed) by passing in\n        extra={\"auto_indent\": [value]} to the call to logging.log() or\n        using a --log-auto-indent [value] command line or the\n        log_auto_indent [value] config option.\n\n        Default behavior is auto-indent off.\n\n        Using the string \"True\" or \"on\" or the boolean True as the value\n        turns auto indent on, using the string \"False\" or \"off\" or the\n        boolean False or the int 0 turns it off, and specifying a\n        positive integer fixes the indentation position to the value\n        specified.\n\n        Any other values for the option are invalid, and will silently be\n        converted to the default.\n\n        :param any auto_indent_option: User specified option for indentation\n            from command line, config or extra kwarg. Accepts int, bool or str.\n            str option accepts the same range of values as boolean config options,\n            as well as positive integers represented in str form.\n\n        :returns: indentation value, which can be\n            -1 (automatically determine indentation) or\n            0 (auto-indent turned off) or\n            >0 (explicitly set indentation position).\n        \"\"\"\n\n        if type(auto_indent_option) is int:\n            return int(auto_indent_option)\n        elif type(auto_indent_option) is str:\n            try:\n                return int(auto_indent_option)\n            except ValueError:\n                pass\n            try:\n                if _strtobool(auto_indent_option):\n                    return -1\n            except ValueError:\n                return 0\n        elif type(auto_indent_option) is bool:\n            if auto_indent_option:\n                return -1\n\n        return 0\n\n    def format(self, record):\n        if \"\\n\" in record.message:\n            if hasattr(record, \"auto_indent\"):\n                # passed in from the \"extra={}\" kwarg on the call to logging.log()\n                auto_indent = self._get_auto_indent(record.auto_indent)\n            else:\n                auto_indent = self._auto_indent\n\n            if auto_indent:\n                lines = record.message.splitlines()\n                formatted = self._fmt % self._update_message(record.__dict__, lines[0])\n\n                if auto_indent < 0:\n                    indentation = _remove_ansi_escape_sequences(formatted).find(\n                        lines[0]\n                    )\n                else:\n                    # optimizes logging by allowing a fixed indentation\n                    indentation = auto_indent\n                lines[0] = formatted\n                return (\"\\n\" + \" \" * indentation).join(lines)\n        return self._fmt % record.__dict__", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_get_option_ini_pytest_addoption.None_12": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_get_option_ini_pytest_addoption.None_12", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 167, "end_line": 268, "span_ids": ["get_option_ini", "pytest_addoption"], "tokens": 667}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        metavar=\"LEVEL\",\n        help=(\n            \"level of messages to catch/display.\\n\"\n            \"Not set by default, so it depends on the root/parent log handler's\"\n            ' effective level, where it is \"WARNING\" by default.'\n        ),\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-auto-indent\",\n        dest=\"log_auto_indent\",\n        default=None,\n        help=\"Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LogCaptureFixture_LogCaptureFixture.clear": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LogCaptureFixture_LogCaptureFixture.clear", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 317, "end_line": 400, "span_ids": ["LogCaptureFixture", "LogCaptureFixture.__init__", "LogCaptureFixture._finalize", "LogCaptureFixture.clear", "LogCaptureFixture.get_records", "LogCaptureFixture.handler", "LogCaptureFixture.messages", "LogCaptureFixture.record_tuples", "LogCaptureFixture.records", "LogCaptureFixture.text"], "tokens": 619}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LogCaptureFixture:\n    \"\"\"Provides access and control of log capturing.\"\"\"\n\n    def __init__(self, item) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_log_levels = {}  # type: Dict[str, int]\n\n    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_log_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n\n    @property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item.catch_log_handler  # type: ignore[no-any-return]  # noqa: F723\n\n    def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        handler = self._item.catch_log_handlers.get(when)\n        if handler:\n            return handler.records  # type: ignore[no-any-return]  # noqa: F723\n        else:\n            return []\n\n    @property\n    def text(self):\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n\n    @property\n    def records(self):\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records\n\n    @property\n    def record_tuples(self):\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n\n    @property\n    def messages(self):\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]\n\n    def clear(self):\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LogCaptureFixture.set_level_LogCaptureFixture.at_level": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/logging.py_LogCaptureFixture.set_level_LogCaptureFixture.at_level", "embedding": null, "metadata": {"file_path": "src/_pytest/logging.py", "file_name": "logging.py", "file_type": "text/x-python", "category": "implementation", "start_line": 402, "end_line": 433, "span_ids": ["LogCaptureFixture.at_level", "LogCaptureFixture.set_level"], "tokens": 276}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LogCaptureFixture:\n\n    def set_level(self, level, logger=None):\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_name = logger\n        logger = logging.getLogger(logger_name)\n        # save the original log-level to restore it during teardown\n        self._initial_log_levels.setdefault(logger_name, logger.level)\n        logger.setLevel(level)\n\n    @contextmanager\n    def at_level(self, level, logger=None):\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger = logging.getLogger(logger)\n        orig_level = logger.level\n        logger.setLevel(level)\n        try:\n            yield\n        finally:\n            logger.setLevel(orig_level)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_ignore_collect_pytest_ignore_collect.return_None": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_pytest_ignore_collect_pytest_ignore_collect.return_None", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 297, "end_line": 323, "span_ids": ["pytest_ignore_collect"], "tokens": 228}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_ignore_collect(\n    path: py.path.local, config: Config\n) -> \"Optional[Literal[True]]\":\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):\n        return True\n\n    allow_in_venv = config.getoption(\"collect_in_virtualenv\")\n    if not allow_in_venv and _in_venv(path):\n        return True\n    return None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._visit_filter_Session.matchnodes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/main.py_Session._visit_filter_Session.matchnodes", "embedding": null, "metadata": {"file_path": "src/_pytest/main.py", "file_name": "main.py", "file_type": "text/x-python", "category": "implementation", "start_line": 590, "end_line": 635, "span_ids": ["Session._parsearg", "Session._tryconvertpyarg", "Session._visit_filter", "Session.matchnodes"], "tokens": 393}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Session(nodes.FSCollector):\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_r__ParseError.__str__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_r__ParseError.__str__", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/expression.py", "file_name": "expression.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 68, "span_ids": ["ParseError", "ParseError.__init__", "ParseError.__str__", "Token", "TokenType", "docstring"], "tokens": 354}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "r\"\"\"\nEvaluate match expressions, as used by `-k` and `-m`.\n\nThe grammar is:\n\nexpression: expr? EOF\nexpr:       and_expr ('or' and_expr)*\nand_expr:   not_expr ('and' not_expr)*\nnot_expr:   'not' not_expr | '(' expr ')' | ident\nident:      (\\w|:|\\+|-|\\.|\\[|\\])+\n\nThe semantics are:\n\n- Empty expression evaluates to False.\n- ident evaluates to True of False according to a provided matcher function.\n- or/and/not evaluate according to the usual boolean semantics.\n\"\"\"\nimport enum\nimport re\nfrom typing import Callable\nfrom typing import Iterator\nfrom typing import Optional\nfrom typing import Sequence\n\nimport attr\n\nfrom _pytest.compat import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import NoReturn\n\n\n__all__ = [\n    \"evaluate\",\n    \"ParseError\",\n]\n\n\nclass TokenType(enum.Enum):\n    LPAREN = \"left parenthesis\"\n    RPAREN = \"right parenthesis\"\n    OR = \"or\"\n    AND = \"and\"\n    NOT = \"not\"\n    IDENT = \"identifier\"\n    EOF = \"end of input\"\n\n\n@attr.s(frozen=True, slots=True)\nclass Token:\n    type = attr.ib(type=TokenType)\n    value = attr.ib(type=str)\n    pos = attr.ib(type=int)\n\n\nclass ParseError(Exception):\n    \"\"\"The expression contains invalid syntax.\n\n    :param column: The column in the line where the error occurred (1-based).\n    :param message: A description of the error.\n    \"\"\"\n\n    def __init__(self, column: int, message: str) -> None:\n        self.column = column\n        self.message = message\n\n    def __str__(self) -> str:\n        return \"at column {}: {}\".format(self.column, self.message)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_Scanner_Scanner.reject": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_Scanner_Scanner.reject", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/expression.py", "file_name": "expression.py", "file_type": "text/x-python", "category": "implementation", "start_line": 71, "end_line": 124, "span_ids": ["Scanner", "Scanner.__init__", "Scanner.accept", "Scanner.lex", "Scanner.reject"], "tokens": 404}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Scanner:\n    __slots__ = (\"tokens\", \"current\")\n\n    def __init__(self, input: str) -> None:\n        self.tokens = self.lex(input)\n        self.current = next(self.tokens)\n\n    def lex(self, input: str) -> Iterator[Token]:\n        pos = 0\n        while pos < len(input):\n            if input[pos] in (\" \", \"\\t\"):\n                pos += 1\n            elif input[pos] == \"(\":\n                yield Token(TokenType.LPAREN, \"(\", pos)\n                pos += 1\n            elif input[pos] == \")\":\n                yield Token(TokenType.RPAREN, \")\", pos)\n                pos += 1\n            else:\n                match = re.match(r\"(:?\\w|:|\\+|-|\\.|\\[|\\])+\", input[pos:])\n                if match:\n                    value = match.group(0)\n                    if value == \"or\":\n                        yield Token(TokenType.OR, value, pos)\n                    elif value == \"and\":\n                        yield Token(TokenType.AND, value, pos)\n                    elif value == \"not\":\n                        yield Token(TokenType.NOT, value, pos)\n                    else:\n                        yield Token(TokenType.IDENT, value, pos)\n                    pos += len(value)\n                else:\n                    raise ParseError(\n                        pos + 1, 'unexpected character \"{}\"'.format(input[pos]),\n                    )\n        yield Token(TokenType.EOF, \"\", pos)\n\n    def accept(self, type: TokenType, *, reject: bool = False) -> Optional[Token]:\n        if self.current.type is type:\n            token = self.current\n            if token.type is not TokenType.EOF:\n                self.current = next(self.tokens)\n            return token\n        if reject:\n            self.reject((type,))\n        return None\n\n    def reject(self, expected: Sequence[TokenType]) -> \"NoReturn\":\n        raise ParseError(\n            self.current.pos + 1,\n            \"expected {}; got {}\".format(\n                \" OR \".join(type.value for type in expected), self.current.type.value,\n            ),\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_expression_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/expression.py_expression_", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/expression.py", "file_name": "expression.py", "file_type": "text/x-python", "category": "implementation", "start_line": 127, "end_line": 174, "span_ids": ["and_expr", "evaluate", "expr", "expression", "not_expr"], "tokens": 348}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def expression(s: Scanner, matcher: Callable[[str], bool]) -> bool:\n    if s.accept(TokenType.EOF):\n        return False\n    ret = expr(s, matcher)\n    s.accept(TokenType.EOF, reject=True)\n    return ret\n\n\ndef expr(s: Scanner, matcher: Callable[[str], bool]) -> bool:\n    ret = and_expr(s, matcher)\n    while s.accept(TokenType.OR):\n        rhs = and_expr(s, matcher)\n        ret = ret or rhs\n    return ret\n\n\ndef and_expr(s: Scanner, matcher: Callable[[str], bool]) -> bool:\n    ret = not_expr(s, matcher)\n    while s.accept(TokenType.AND):\n        rhs = not_expr(s, matcher)\n        ret = ret and rhs\n    return ret\n\n\ndef not_expr(s: Scanner, matcher: Callable[[str], bool]) -> bool:\n    if s.accept(TokenType.NOT):\n        return not not_expr(s, matcher)\n    if s.accept(TokenType.LPAREN):\n        ret = expr(s, matcher)\n        s.accept(TokenType.RPAREN, reject=True)\n        return ret\n    ident = s.accept(TokenType.IDENT)\n    if ident:\n        return matcher(ident.value)\n    s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n\n\ndef evaluate(input: str, matcher: Callable[[str], bool]) -> bool:\n    \"\"\"Evaluate a match expression as used by -k and -m.\n\n    :param input: The input expression - one line.\n    :param matcher: Given an identifier, should return whether it matches or not.\n                    Should be prepared to handle arbitrary strings as input.\n\n    Returns whether the entire expression matches or not.\n    \"\"\"\n    return expression(Scanner(input), matcher)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/legacy.py___KeywordMatcher.__call__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/legacy.py___KeywordMatcher.__call__", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/legacy.py", "file_name": "legacy.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 74, "span_ids": ["KeywordMatcher", "KeywordMatcher.__call__", "KeywordMatcher.from_item", "MarkMatcher", "MarkMatcher.__call__", "MarkMatcher.from_item", "docstring"], "tokens": 439}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nthis is a place where we put datastructures used by legacy apis\nwe hope to remove\n\"\"\"\nfrom typing import Set\n\nimport attr\n\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import UsageError\nfrom _pytest.mark.expression import evaluate\nfrom _pytest.mark.expression import ParseError\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item  # noqa: F401 (used in type string)\n\n\n@attr.s\nclass MarkMatcher:\n    \"\"\"A matcher for markers which are present.\"\"\"\n\n    own_mark_names = attr.ib()\n\n    @classmethod\n    def from_item(cls, item) -> \"MarkMatcher\":\n        mark_names = {mark.name for mark in item.iter_markers()}\n        return cls(mark_names)\n\n    def __call__(self, name: str) -> bool:\n        return name in self.own_mark_names\n\n\n@attr.s\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n    \"\"\"\n\n    _names = attr.ib(type=Set[str])\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items\n        import pytest\n\n        for item in item.listchain():\n            if not isinstance(item, pytest.Instance):\n                mapped_names.add(item.name)\n\n        # Add the names added as extra keywords to current or parent items\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # add the markers to the keywords as we no longer handle them correctly\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)\n\n    def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/legacy.py_matchmark_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/legacy.py_matchmark_", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/legacy.py", "file_name": "legacy.py", "file_type": "text/x-python", "category": "implementation", "start_line": 77, "end_line": 102, "span_ids": ["matchkeyword", "matchmark"], "tokens": 231}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def matchmark(colitem, markexpr: str) -> bool:\n    \"\"\"Tries to match on any marker names, attached to the given colitem.\"\"\"\n    try:\n        return evaluate(markexpr, MarkMatcher.from_item(colitem))\n    except ParseError as e:\n        raise UsageError(\n            \"Wrong expression passed to '-m': {}: {}\".format(markexpr, e)\n        ) from None\n\n\ndef matchkeyword(colitem, keywordexpr: str) -> bool:\n    \"\"\"Tries to match given keyword expression to given collector item.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n    try:\n        return evaluate(keywordexpr, KeywordMatcher.from_item(colitem))\n    except ParseError as e:\n        raise UsageError(\n            \"Wrong expression passed to '-k': {}: {}\".format(keywordexpr, e)\n        ) from None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_ParameterSet._for_parametrize_ParameterSet._for_parametrize.return_argnames_paramete": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_ParameterSet._for_parametrize_ParameterSet._for_parametrize.return_argnames_paramete", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 109, "end_line": 142, "span_ids": ["ParameterSet._for_parametrize"], "tokens": 282}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class ParameterSet(namedtuple(\"ParameterSet\", \"values, marks, id\")):\n\n    @classmethod\n    def _for_parametrize(cls, argnames, argvalues, func, config, function_definition):\n        argnames, force_tuple = cls._parse_parametrize_args(argnames, argvalues)\n        parameters = cls._parse_parametrize_parameters(argvalues, force_tuple)\n        del argvalues\n\n        if parameters:\n            # check all parameter sets have the correct number of values\n            for param in parameters:\n                if len(param.values) != len(argnames):\n                    msg = (\n                        '{nodeid}: in \"parametrize\" the number of names ({names_len}):\\n'\n                        \"  {names}\\n\"\n                        \"must be equal to the number of values ({values_len}):\\n\"\n                        \"  {values}\"\n                    )\n                    fail(\n                        msg.format(\n                            nodeid=function_definition.nodeid,\n                            values=param.values,\n                            names=argnames,\n                            names_len=len(argnames),\n                            values_len=len(param.values),\n                        ),\n                        pytrace=False,\n                    )\n        else:\n            # empty parameter set (likely computed at runtime): create a single\n            # parameter set with NOTSET values, with the \"empty parameter set\" mark applied to it\n            mark = get_empty_parameterset_mark(config, argnames, func)\n            parameters.append(\n                ParameterSet(values=(NOTSET,) * len(argnames), marks=[mark], id=None)\n            )\n        return argnames, parameters", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_Mark_Mark.combined_with.return_Mark_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/mark/structures.py_Mark_Mark.combined_with.return_Mark_", "embedding": null, "metadata": {"file_path": "src/_pytest/mark/structures.py", "file_name": "structures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 145, "end_line": 189, "span_ids": ["Mark", "Mark._has_param_ids", "Mark.combined_with"], "tokens": 316}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s(frozen=True)\nclass Mark:\n    #: Name of the mark.\n    name = attr.ib(type=str)\n    #: Positional arguments of the mark decorator.\n    args = attr.ib(type=Tuple[Any, ...])\n    #: Keyword arguments of the mark decorator.\n    kwargs = attr.ib(type=Mapping[str, Any])\n\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.\n    _param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )\n\n    def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_os_tracebackcutdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_os_tracebackcutdir", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 40, "span_ids": ["imports"], "tokens": 247}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport warnings\nfrom functools import lru_cache\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Set\nfrom typing import Tuple\nfrom typing import Union\n\nimport py\n\nimport _pytest._code\nfrom _pytest._code import getfslineno\nfrom _pytest._code.code import ExceptionChainRepr\nfrom _pytest._code.code import ExceptionInfo\nfrom _pytest._code.code import ReprExceptionInfo\nfrom _pytest.compat import cached_property\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import PytestPluginManager\nfrom _pytest.deprecated import NODE_USE_FROM_PARENT\nfrom _pytest.fixtures import FixtureDef\nfrom _pytest.fixtures import FixtureLookupError\nfrom _pytest.fixtures import FixtureLookupErrorRepr\nfrom _pytest.mark.structures import Mark\nfrom _pytest.mark.structures import MarkDecorator\nfrom _pytest.mark.structures import NodeKeywords\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Failed\nfrom _pytest.store import Store\n\nif TYPE_CHECKING:\n    # Imported here due to circular import.\n    from _pytest.main import Session  # noqa: F401\n\nSEP = \"/\"\n\ntracebackcutdir = py.path.local(_pytest.__file__).dirpath()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py__splitnode_NodeMeta._create": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py__splitnode_NodeMeta._create", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 43, "end_line": 87, "span_ids": ["NodeMeta", "NodeMeta.__call__", "NodeMeta._create", "_splitnode", "ischildnode"], "tokens": 407}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@lru_cache(maxsize=None)\ndef _splitnode(nodeid):\n    \"\"\"Split a nodeid into constituent 'parts'.\n\n    Node IDs are strings, and can be things like:\n        ''\n        'testing/code'\n        'testing/code/test_excinfo.py'\n        'testing/code/test_excinfo.py::TestFormattedExcinfo'\n\n    Return values are lists e.g.\n        []\n        ['testing', 'code']\n        ['testing', 'code', 'test_excinfo.py']\n        ['testing', 'code', 'test_excinfo.py', 'TestFormattedExcinfo']\n    \"\"\"\n    if nodeid == \"\":\n        # If there is no root node at all, return an empty list so the caller's logic can remain sane\n        return ()\n    parts = nodeid.split(SEP)\n    # Replace single last element 'test_foo.py::Bar' with multiple elements 'test_foo.py', 'Bar'\n    parts[-1:] = parts[-1].split(\"::\")\n    # Convert parts into a tuple to avoid possible errors with caching of a mutable type\n    return tuple(parts)\n\n\ndef ischildnode(baseid, nodeid):\n    \"\"\"Return True if the nodeid is a child node of the baseid.\n\n    E.g. 'foo/bar::Baz' is a child of 'foo', 'foo/bar' and 'foo/bar::Baz', but not of 'foo/blorp'\n    \"\"\"\n    base_parts = _splitnode(baseid)\n    node_parts = _splitnode(nodeid)\n    if len(node_parts) < len(base_parts):\n        return False\n    return node_parts[: len(base_parts)] == base_parts\n\n\nclass NodeMeta(type):\n    def __call__(self, *k, **kw):\n        warnings.warn(NODE_USE_FROM_PARENT.format(name=self.__name__), stacklevel=2)\n        return super().__call__(*k, **kw)\n\n    def _create(self, *k, **kw):\n        return super().__call__(*k, **kw)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node_Node.__repr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node_Node.__repr__", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 90, "end_line": 191, "span_ids": ["Node", "Node.__init__", "Node.__repr__", "Node.from_parent", "Node.ihook"], "tokens": 690}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Node(metaclass=NodeMeta):\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    # Use __slots__ to make attribute access faster.\n    # Note that __dict__ is still available.\n    __slots__ = (\n        \"name\",\n        \"parent\",\n        \"config\",\n        \"session\",\n        \"fspath\",\n        \"_nodeid\",\n        \"_store\",\n        \"__dict__\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        parent: Optional[\"Node\"] = None,\n        config: Optional[Config] = None,\n        session: Optional[\"Session\"] = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        if config:\n            self.config = config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: the session this node is part of\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n\n    @classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"\n        Public Constructor for Nodes\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the construction\n\n        :param parent: the parent node of this test Node\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")\n        return cls._create(parent=parent, **kw)\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node.warn_Node.get_closest_marker": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node.warn_Node.get_closest_marker", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 193, "end_line": 302, "span_ids": ["Node.__hash__", "Node.add_marker", "Node.get_closest_marker", "Node.iter_markers", "Node.iter_markers_with_node", "Node.listchain", "Node.nodeid", "Node.setup", "Node.teardown", "Node.warn"], "tokens": 721}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Node(metaclass=NodeMeta):\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        warnings.warn_explicit(\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self._nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self  # type: Optional[Node]\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node.listextrakeywords_Node._prunetraceback": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_Node.listextrakeywords_Node._prunetraceback", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 304, "end_line": 331, "span_ids": ["Node._prunetraceback", "Node.addfinalizer", "Node.getparent", "Node.listextrakeywords", "Node.listnames"], "tokens": 210}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Node(metaclass=NodeMeta):\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self  # type: Optional[Node]\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_get_fslocation_from_item_FSHookProxy.__getattr__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_get_fslocation_from_item_FSHookProxy.__getattr__", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 388, "end_line": 469, "span_ids": ["Collector", "Collector.CollectError", "Collector._prunetraceback", "Collector.collect", "Collector.repr_failure", "FSHookProxy", "FSHookProxy.__getattr__", "FSHookProxy.__init__", "_check_initialpaths_for_relpath", "get_fslocation_from_item"], "tokens": 609}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def get_fslocation_from_item(\n    item: \"Item\",\n) -> Tuple[Union[str, py.path.local], Optional[int]]:\n    \"\"\"Tries to extract the actual location from an item, depending on available attributes:\n\n    * \"fslocation\": a pair (path, lineno)\n    * \"obj\": a Python object that the item wraps.\n    * \"fspath\": just a path\n\n    :rtype: a tuple of (str|LocalPath, int) with filename and line number.\n    \"\"\"\n    try:\n        return item.location[:2]\n    except AttributeError:\n        pass\n    obj = getattr(item, \"obj\", None)\n    if obj is not None:\n        return getfslineno(obj)\n    return getattr(item, \"fspath\", \"unknown location\"), -1\n\n\nclass Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\"\n        Return a representation of a collection failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        if excinfo.errisinstance(self.CollectError) and not self.config.getoption(\n            \"fulltrace\", False\n        ):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (_repr_failure_py uses \"long\" with \"fulltrace\" option always).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSHookProxy:\n    def __init__(\n        self, fspath: py.path.local, pm: PytestPluginManager, remove_mods\n    ) -> None:\n        self.fspath = fspath\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name: str):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_FSCollector_FSCollector._collectfile": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_FSCollector_FSCollector._collectfile", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 472, "end_line": 552, "span_ids": ["FSCollector", "FSCollector.__init__", "FSCollector._collectfile", "FSCollector._gethookproxy", "FSCollector._recurse", "FSCollector.from_parent"], "tokens": 689}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class FSCollector(Collector):\n    def __init__(\n        self, fspath: py.path.local, parent=None, config=None, session=None, nodeid=None\n    ) -> None:\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n        self._norecursepatterns = self.config.getini(\"norecursedirs\")\n\n    @classmethod\n    def from_parent(cls, parent, *, fspath, **kw):\n        \"\"\"\n        The public constructor\n        \"\"\"\n        return super().from_parent(parent=parent, fspath=fspath, **kw)\n\n    def _gethookproxy(self, fspath: py.path.local):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def _recurse(self, dirpath: py.path.local) -> bool:\n        if dirpath.basename == \"__pycache__\":\n            return False\n        ihook = self._gethookproxy(dirpath.dirpath())\n        if ihook.pytest_ignore_collect(path=dirpath, config=self.config):\n            return False\n        for pat in self._norecursepatterns:\n            if dirpath.check(fnmatch=pat):\n                return False\n        ihook = self._gethookproxy(dirpath)\n        ihook.pytest_collect_directory(path=dirpath, parent=self)\n        return True\n\n    def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_File_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/nodes.py_File_", "embedding": null, "metadata": {"file_path": "src/_pytest/nodes.py", "file_name": "nodes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 555, "end_line": 609, "span_ids": ["File", "Item", "Item.__init__", "Item.add_report_section", "Item.location", "Item.reportinfo", "Item.runtest"], "tokens": 465}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def runtest(self) -> None:\n        raise NotImplementedError(\"runtest must be implemented by Item subclass\")\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n        return self.fspath, None, \"\"\n\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py____exposed_helper_methods": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py____exposed_helper_methods", "embedding": null, "metadata": {"file_path": "src/_pytest/outcomes.py", "file_name": "outcomes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 109, "span_ids": ["Exit", "Exit.__init__", "Failed", "OutcomeException", "OutcomeException.__init__", "OutcomeException.__repr__", "OutcomeException:3", "Skipped", "Skipped.__init__", "_WithException", "_with_exception", "docstring", "impl:3", "impl:4", "impl:8"], "tokens": 710}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nexception classes and constants handling test outcomes\nas well as functions creating them\n\"\"\"\nimport sys\nfrom typing import Any\nfrom typing import Callable\nfrom typing import cast\nfrom typing import Optional\nfrom typing import TypeVar\n\nfrom packaging.version import Version\n\nTYPE_CHECKING = False  # avoid circular import through compat\n\nif TYPE_CHECKING:\n    from typing import NoReturn\n    from typing import Type  # noqa: F401 (Used in string type annotation.)\n    from typing_extensions import Protocol\nelse:\n    # typing.Protocol is only available starting from Python 3.8. It is also\n    # available from typing_extensions, but we don't want a runtime dependency\n    # on that. So use a dummy runtime implementation.\n    from typing import Generic\n\n    Protocol = Generic\n\n\nclass OutcomeException(BaseException):\n    \"\"\" OutcomeException and its subclass instances indicate and\n        contain info about test and collection outcomes.\n    \"\"\"\n\n    def __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:\n        if msg is not None and not isinstance(msg, str):\n            error_msg = (\n                \"{} expected string as 'msg' parameter, got '{}' instead.\\n\"\n                \"Perhaps you meant to use a mark?\"\n            )\n            raise TypeError(error_msg.format(type(self).__name__, type(msg).__name__))\n        BaseException.__init__(self, msg)\n        self.msg = msg\n        self.pytrace = pytrace\n\n    def __repr__(self) -> str:\n        if self.msg:\n            return self.msg\n        return \"<{} instance>\".format(self.__class__.__name__)\n\n    __str__ = __repr__\n\n\nTEST_OUTCOME = (OutcomeException, Exception)\n\n\nclass Skipped(OutcomeException):\n    # XXX hackish: on 3k we fake to live in the builtins\n    # in order to have Skipped exception printing shorter/nicer\n    __module__ = \"builtins\"\n\n    def __init__(\n        self,\n        msg: Optional[str] = None,\n        pytrace: bool = True,\n        allow_module_level: bool = False,\n    ) -> None:\n        OutcomeException.__init__(self, msg=msg, pytrace=pytrace)\n        self.allow_module_level = allow_module_level\n\n\nclass Failed(OutcomeException):\n    \"\"\" raised from an explicit call to pytest.fail() \"\"\"\n\n    __module__ = \"builtins\"\n\n\nclass Exit(Exception):\n    \"\"\" raised for immediate program exits (no tracebacks/summaries)\"\"\"\n\n    def __init__(\n        self, msg: str = \"unknown reason\", returncode: Optional[int] = None\n    ) -> None:\n        self.msg = msg\n        self.returncode = returncode\n        super().__init__(msg)\n\n\n# Elaborate hack to work around https://github.com/python/mypy/issues/2087.\n# Ideally would just be `exit.Exception = Exit` etc.\n\n_F = TypeVar(\"_F\", bound=Callable)\n_ET = TypeVar(\"_ET\", bound=\"Type[BaseException]\")\n\n\nclass _WithException(Protocol[_F, _ET]):\n    Exception = None  # type: _ET\n    __call__ = None  # type: _F\n\n\ndef _with_exception(exception_type: _ET) -> Callable[[_F], _WithException[_F, _ET]]:\n    def decorate(func: _F) -> _WithException[_F, _ET]:\n        func_with_exception = cast(_WithException[_F, _ET], func)\n        func_with_exception.Exception = exception_type\n        return func_with_exception\n\n    return decorate\n\n\n# exposed helper methods", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_exit_skip": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_exit_skip", "embedding": null, "metadata": {"file_path": "src/_pytest/outcomes.py", "file_name": "outcomes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 112, "end_line": 145, "span_ids": ["exit", "skip"], "tokens": 320}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@_with_exception(Exit)\ndef exit(msg: str, returncode: Optional[int] = None) -> \"NoReturn\":\n    \"\"\"\n    Exit testing process.\n\n    :param str msg: message to display upon exit.\n    :param int returncode: return code to be used when exiting pytest.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Exit(msg, returncode)\n\n\n@_with_exception(Skipped)\ndef skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n    \"\"\"\n    Skip an executing test with the given message.\n\n    This function should be called only during testing (setup, call or teardown) or\n    during collection by using the ``allow_module_level`` flag.  This function can\n    be called in doctests as well.\n\n    :kwarg bool allow_module_level: allows this function to be called at\n        module level, skipping the rest of the module. Default to False.\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.skipif ref` marker when possible to declare a test to be\n        skipped under certain conditions like mismatching platforms or\n        dependencies.\n        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n        <https://docs.python.org/3/library/doctest.html#doctest.SKIP>`_)\n        to skip a doctest statically.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Skipped(msg=msg, allow_module_level=allow_module_level)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_fail_xfail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_fail_xfail", "embedding": null, "metadata": {"file_path": "src/_pytest/outcomes.py", "file_name": "outcomes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 148, "end_line": 177, "span_ids": ["XFailed", "fail", "xfail"], "tokens": 239}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@_with_exception(Failed)\ndef fail(msg: str = \"\", pytrace: bool = True) -> \"NoReturn\":\n    \"\"\"\n    Explicitly fail an executing test with the given message.\n\n    :param str msg: the message to show the user as reason for the failure.\n    :param bool pytrace: if false the msg represents the full failure information and no\n        python traceback will be reported.\n    \"\"\"\n    __tracebackhide__ = True\n    raise Failed(msg=msg, pytrace=pytrace)\n\n\nclass XFailed(Failed):\n    \"\"\" raised from an explicit call to pytest.xfail() \"\"\"\n\n\n@_with_exception(XFailed)\ndef xfail(reason: str = \"\") -> \"NoReturn\":\n    \"\"\"\n    Imperatively xfail an executing test or setup functions with the given reason.\n\n    This function should be called only during testing (setup, call or teardown).\n\n    .. note::\n        It is better to use the :ref:`pytest.mark.xfail ref` marker when possible to declare a test to be\n        xfailed under certain conditions like known bugs or missing features.\n    \"\"\"\n    __tracebackhide__ = True\n    raise XFailed(reason)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_importorskip_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/outcomes.py_importorskip_", "embedding": null, "metadata": {"file_path": "src/_pytest/outcomes.py", "file_name": "outcomes.py", "file_type": "text/x-python", "category": "implementation", "start_line": 180, "end_line": 227, "span_ids": ["importorskip"], "tokens": 393}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def importorskip(\n    modname: str, minversion: Optional[str] = None, reason: Optional[str] = None\n) -> Any:\n    \"\"\"Imports and returns the requested module ``modname``, or skip the\n    current test if the module cannot be imported.\n\n    :param str modname: the name of the module to import\n    :param str minversion: if given, the imported module's ``__version__``\n        attribute must be at least this minimal version, otherwise the test is\n        still skipped.\n    :param str reason: if given, this reason is shown as the message when the\n        module cannot be imported.\n    :returns: The imported module. This should be assigned to its canonical\n        name.\n\n    Example::\n\n        docutils = pytest.importorskip(\"docutils\")\n    \"\"\"\n    import warnings\n\n    __tracebackhide__ = True\n    compile(modname, \"\", \"eval\")  # to catch syntaxerrors\n\n    with warnings.catch_warnings():\n        # make sure to ignore ImportWarnings that might happen because\n        # of existing directories with the same name we're trying to\n        # import but without a __init__.py file\n        warnings.simplefilter(\"ignore\")\n        try:\n            __import__(modname)\n        except ImportError as exc:\n            if reason is None:\n                reason = \"could not import {!r}: {}\".format(modname, exc)\n            raise Skipped(reason, allow_module_level=True) from None\n    mod = sys.modules[modname]\n    if minversion is None:\n        return mod\n    verattr = getattr(mod, \"__version__\", None)\n    if minversion is not None:\n        if verattr is None or Version(verattr) < Version(minversion):\n            raise Skipped(\n                \"module %r has __version__ %r, required is: %r\"\n                % (modname, verattr, minversion),\n                allow_module_level=True,\n            )\n    return mod", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_atexit_ensure_reset_dir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_atexit_ensure_reset_dir", "embedding": null, "metadata": {"file_path": "src/_pytest/pathlib.py", "file_name": "pathlib.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 47, "span_ids": ["ensure_reset_dir", "get_lock_path", "imports"], "tokens": 220}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import atexit\nimport fnmatch\nimport itertools\nimport os\nimport shutil\nimport sys\nimport uuid\nimport warnings\nfrom functools import partial\nfrom os.path import expanduser\nfrom os.path import expandvars\nfrom os.path import isabs\nfrom os.path import sep\nfrom posixpath import sep as posix_sep\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Set\nfrom typing import TypeVar\nfrom typing import Union\n\nfrom _pytest.warning_types import PytestWarning\n\nif sys.version_info[:2] >= (3, 6):\n    from pathlib import Path, PurePath\nelse:\n    from pathlib2 import Path, PurePath\n\n__all__ = [\"Path\", \"PurePath\"]\n\n\nLOCK_TIMEOUT = 60 * 60 * 3\n\n\n_AnyPurePath = TypeVar(\"_AnyPurePath\", bound=PurePath)\n\n\ndef get_lock_path(path: _AnyPurePath) -> _AnyPurePath:\n    return path.joinpath(\".lock\")\n\n\ndef ensure_reset_dir(path: Path) -> None:\n    \"\"\"\n    ensures the given path is an empty directory\n    \"\"\"\n    if path.exists():\n        rm_rf(path)\n    path.mkdir()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_on_rm_rf_error_on_rm_rf_error.return_True": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pathlib.py_on_rm_rf_error_on_rm_rf_error.return_True", "embedding": null, "metadata": {"file_path": "src/_pytest/pathlib.py", "file_name": "pathlib.py", "file_type": "text/x-python", "category": "implementation", "start_line": 50, "end_line": 100, "span_ids": ["on_rm_rf_error"], "tokens": 353}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def on_rm_rf_error(func, path: str, exc, *, start_path: Path) -> bool:\n    \"\"\"Handles known read-only errors during rmtree.\n\n    The returned value is used only by our own tests.\n    \"\"\"\n    exctype, excvalue = exc[:2]\n\n    # another process removed the file in the middle of the \"rm_rf\" (xdist for example)\n    # more context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018\n    if isinstance(excvalue, FileNotFoundError):\n        return False\n\n    if not isinstance(excvalue, PermissionError):\n        warnings.warn(\n            PytestWarning(\n                \"(rm_rf) error removing {}\\n{}: {}\".format(path, exctype, excvalue)\n            )\n        )\n        return False\n\n    if func not in (os.rmdir, os.remove, os.unlink):\n        if func not in (os.open,):\n            warnings.warn(\n                PytestWarning(\n                    \"(rm_rf) unknown function {} when removing {}:\\n{}: {}\".format(\n                        func, path, exctype, excvalue\n                    )\n                )\n            )\n        return False\n\n    # Chmod + retry.\n    import stat\n\n    def chmod_rw(p: str) -> None:\n        mode = os.stat(p).st_mode\n        os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)\n\n    # For files, we need to recursively go upwards in the directories to\n    # ensure they all are also writable.\n    p = Path(path)\n    if p.is_file():\n        for parent in p.parents:\n            chmod_rw(str(parent))\n            # stop when we reach the original path passed to rm_rf\n            if parent == start_path:\n                break\n    chmod_rw(str(path))\n\n    func(path)\n    return True", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py__used_at_least_by_pytest_ParsedCall.if_TYPE_CHECKING_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py__used_at_least_by_pytest_ParsedCall.if_TYPE_CHECKING_", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 163, "end_line": 204, "span_ids": ["ParsedCall", "ParsedCall.__init__", "ParsedCall.__repr__", "ParsedCall:2", "PytestArg", "PytestArg.__init__", "PytestArg.gethookrecorder", "_pytest", "get_public_names", "impl:3"], "tokens": 279}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# used at least by pytest-xdist plugin\n\n\n@pytest.fixture\ndef _pytest(request: FixtureRequest) -> \"PytestArg\":\n    \"\"\"Return a helper which offers a gethookrecorder(hook) method which\n    returns a HookRecorder instance which helps to make assertions about called\n    hooks.\n\n    \"\"\"\n    return PytestArg(request)\n\n\nclass PytestArg:\n    def __init__(self, request: FixtureRequest) -> None:\n        self.request = request\n\n    def gethookrecorder(self, hook) -> \"HookRecorder\":\n        hookrecorder = HookRecorder(hook._pm)\n        self.request.addfinalizer(hookrecorder.finish_recording)\n        return hookrecorder\n\n\ndef get_public_names(values):\n    \"\"\"Only return names from iterator values without a leading underscore.\"\"\"\n    return [x for x in values if x[0] != \"_\"]\n\n\nclass ParsedCall:\n    def __init__(self, name, kwargs):\n        self.__dict__.update(kwargs)\n        self._name = name\n\n    def __repr__(self):\n        d = self.__dict__.copy()\n        del d[\"_name\"]\n        return \"<ParsedCall {!r}(**{!r})>\".format(self._name, d)\n\n    if TYPE_CHECKING:\n        # The class has undetermined attributes, this tells mypy about it.\n        def __getattr__(self, key):\n            raise NotImplementedError()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir_Testdir.__take_sys_modules_snapshot": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir_Testdir.__take_sys_modules_snapshot", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 533, "end_line": 617, "span_ids": ["Testdir", "Testdir.TimeoutExpired", "Testdir.__init__", "Testdir.__repr__", "Testdir.__str__", "Testdir.__take_sys_modules_snapshot", "Testdir.finalize"], "tokens": 708}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n    \"\"\"Temporary test directory with tools to test/run pytest itself.\n\n    This is based on the ``tmpdir`` fixture but provides a number of methods\n    which aid with testing pytest itself.  Unless :py:meth:`chdir` is used all\n    methods will use :py:attr:`tmpdir` as their current working directory.\n\n    Attributes:\n\n    :ivar tmpdir: The :py:class:`py.path.local` instance of the temporary directory.\n\n    :ivar plugins: A list of plugins to use with :py:meth:`parseconfig` and\n       :py:meth:`runpytest`.  Initially this is an empty list but plugins can\n       be added to the list.  The type of items to add to the list depends on\n       the method using them so refer to them for details.\n\n    \"\"\"\n\n    __test__ = False\n\n    CLOSE_STDIN = object\n\n    class TimeoutExpired(Exception):\n        pass\n\n    def __init__(self, request: FixtureRequest, tmpdir_factory: TempdirFactory) -> None:\n        self.request = request\n        self._mod_collections = (\n            WeakKeyDictionary()\n        )  # type: WeakKeyDictionary[Module, List[Union[Item, Collector]]]\n        if request.function:\n            name = request.function.__name__  # type: str\n        else:\n            name = request.node.name\n        self._name = name\n        self.tmpdir = tmpdir_factory.mktemp(name, numbered=True)\n        self.test_tmproot = tmpdir_factory.mktemp(\"tmp-\" + name, numbered=True)\n        self.plugins = []  # type: List[Union[str, _PluggyPlugin]]\n        self._cwd_snapshot = CwdSnapshot()\n        self._sys_path_snapshot = SysPathsSnapshot()\n        self._sys_modules_snapshot = self.__take_sys_modules_snapshot()\n        self.chdir()\n        self.request.addfinalizer(self.finalize)\n        self._method = self.request.config.getoption(\"--runpytest\")\n\n        mp = self.monkeypatch = MonkeyPatch()\n        mp.setenv(\"PYTEST_DEBUG_TEMPROOT\", str(self.test_tmproot))\n        # Ensure no unexpected caching via tox.\n        mp.delenv(\"TOX_ENV_DIR\", raising=False)\n        # Discard outer pytest options.\n        mp.delenv(\"PYTEST_ADDOPTS\", raising=False)\n        # Ensure no user config is used.\n        tmphome = str(self.tmpdir)\n        mp.setenv(\"HOME\", tmphome)\n        mp.setenv(\"USERPROFILE\", tmphome)\n        # Do not use colors for inner runs by default.\n        mp.setenv(\"PY_COLORS\", \"0\")\n\n    def __repr__(self):\n        return \"<Testdir {!r}>\".format(self.tmpdir)\n\n    def __str__(self):\n        return str(self.tmpdir)\n\n    def finalize(self):\n        \"\"\"Clean up global state artifacts.\n\n        Some methods modify the global interpreter state and this tries to\n        clean this up.  It does not remove the temporary directory however so\n        it can be looked at after the test run has finished.\n\n        \"\"\"\n        self._sys_modules_snapshot.restore()\n        self._sys_path_snapshot.restore()\n        self._cwd_snapshot.restore()\n        self.monkeypatch.undo()\n\n    def __take_sys_modules_snapshot(self):\n        # some zope modules used by twisted-related tests keep internal state\n        # and can't be deleted; we had some trouble in the past with\n        # `zope.interface` for example\n        def preserve_module(name):\n            return name.startswith(\"zope\")\n\n        return SysModulesSnapshot(preserve=preserve_module)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.make_hook_recorder_Testdir.mkdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.make_hook_recorder_Testdir.mkdir", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 619, "end_line": 710, "span_ids": ["Testdir._makefile", "Testdir.chdir", "Testdir.getinicfg", "Testdir.make_hook_recorder", "Testdir.makeconftest", "Testdir.makefile", "Testdir.makeini", "Testdir.makepyfile", "Testdir.maketxtfile", "Testdir.mkdir", "Testdir.syspathinsert"], "tokens": 734}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def make_hook_recorder(self, pluginmanager):\n        \"\"\"Create a new :py:class:`HookRecorder` for a PluginManager.\"\"\"\n        pluginmanager.reprec = reprec = HookRecorder(pluginmanager)\n        self.request.addfinalizer(reprec.finish_recording)\n        return reprec\n\n    def chdir(self):\n        \"\"\"Cd into the temporary directory.\n\n        This is done automatically upon instantiation.\n\n        \"\"\"\n        self.tmpdir.chdir()\n\n    def _makefile(self, ext, lines, files, encoding=\"utf-8\"):\n        items = list(files.items())\n\n        def to_text(s):\n            return s.decode(encoding) if isinstance(s, bytes) else str(s)\n\n        if lines:\n            source = \"\\n\".join(to_text(x) for x in lines)\n            basename = self._name\n            items.insert(0, (basename, source))\n\n        ret = None\n        for basename, value in items:\n            p = self.tmpdir.join(basename).new(ext=ext)\n            p.dirpath().ensure_dir()\n            source = Source(value)\n            source = \"\\n\".join(to_text(line) for line in source.lines)\n            p.write(source.strip().encode(encoding), \"wb\")\n            if ret is None:\n                ret = p\n        return ret\n\n    def makefile(self, ext, *args, **kwargs):\n        r\"\"\"Create new file(s) in the testdir.\n\n        :param str ext: The extension the file(s) should use, including the dot, e.g. `.py`.\n        :param list[str] args: All args will be treated as strings and joined using newlines.\n           The result will be written as contents to the file.  The name of the\n           file will be based on the test function requesting this fixture.\n        :param kwargs: Each keyword is the name of a file, while the value of it will\n           be written as contents of the file.\n\n        Examples:\n\n        .. code-block:: python\n\n            testdir.makefile(\".txt\", \"line1\", \"line2\")\n\n            testdir.makefile(\".ini\", pytest=\"[pytest]\\naddopts=-rs\\n\")\n\n        \"\"\"\n        return self._makefile(ext, args, kwargs)\n\n    def makeconftest(self, source):\n        \"\"\"Write a contest.py file with 'source' as contents.\"\"\"\n        return self.makepyfile(conftest=source)\n\n    def makeini(self, source):\n        \"\"\"Write a tox.ini file with 'source' as contents.\"\"\"\n        return self.makefile(\".ini\", tox=source)\n\n    def getinicfg(self, source):\n        \"\"\"Return the pytest section from the tox.ini config file.\"\"\"\n        p = self.makeini(source)\n        return py.iniconfig.IniConfig(p)[\"pytest\"]\n\n    def makepyfile(self, *args, **kwargs):\n        \"\"\"Shortcut for .makefile() with a .py extension.\"\"\"\n        return self._makefile(\".py\", args, kwargs)\n\n    def maketxtfile(self, *args, **kwargs):\n        \"\"\"Shortcut for .makefile() with a .txt extension.\"\"\"\n        return self._makefile(\".txt\", args, kwargs)\n\n    def syspathinsert(self, path=None):\n        \"\"\"Prepend a directory to sys.path, defaults to :py:attr:`tmpdir`.\n\n        This is undone automatically when this object dies at the end of each\n        test.\n        \"\"\"\n        if path is None:\n            path = self.tmpdir\n\n        self.monkeypatch.syspath_prepend(str(path))\n\n    def mkdir(self, name):\n        \"\"\"Create a new (sub)directory.\"\"\"\n        return self.tmpdir.mkdir(name)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.mkpydir_Testdir.copy_example.if_example_path_isdir_a": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.mkpydir_Testdir.copy_example.if_example_path_isdir_a", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 712, "end_line": 771, "span_ids": ["Testdir.copy_example", "Testdir.mkpydir"], "tokens": 430}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def mkpydir(self, name):\n        \"\"\"Create a new python package.\n\n        This creates a (sub)directory with an empty ``__init__.py`` file so it\n        gets recognised as a python package.\n\n        \"\"\"\n        p = self.mkdir(name)\n        p.ensure(\"__init__.py\")\n        return p\n\n    def copy_example(self, name=None):\n        \"\"\"Copy file from project's directory into the testdir.\n\n        :param str name: The name of the file to copy.\n        :return: path to the copied directory (inside ``self.tmpdir``).\n\n        \"\"\"\n        import warnings\n        from _pytest.warning_types import PYTESTER_COPY_EXAMPLE\n\n        warnings.warn(PYTESTER_COPY_EXAMPLE, stacklevel=2)\n        example_dir = self.request.config.getini(\"pytester_example_dir\")\n        if example_dir is None:\n            raise ValueError(\"pytester_example_dir is unset, can't copy examples\")\n        example_dir = self.request.config.rootdir.join(example_dir)\n\n        for extra_element in self.request.node.iter_markers(\"pytester_example_path\"):\n            assert extra_element.args\n            example_dir = example_dir.join(*extra_element.args)\n\n        if name is None:\n            func_name = self._name\n            maybe_dir = example_dir / func_name\n            maybe_file = example_dir / (func_name + \".py\")\n\n            if maybe_dir.isdir():\n                example_path = maybe_dir\n            elif maybe_file.isfile():\n                example_path = maybe_file\n            else:\n                raise LookupError(\n                    \"{} cant be found as module or package in {}\".format(\n                        func_name, example_dir.bestrelpath(self.request.config.rootdir)\n                    )\n                )\n        else:\n            example_path = example_dir.join(name)\n\n        if example_path.isdir() and not example_path.join(\"__init__.py\").isfile():\n            example_path.copy(self.tmpdir)\n            return self.tmpdir\n        elif example_path.isfile():\n            result = self.tmpdir.join(example_path.basename)\n            example_path.copy(result)\n            return result\n        else:\n            raise LookupError(\n                'example \"{}\" is not found as a file or directory'.format(example_path)\n            )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.runpytest_Testdir.parseconfig": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.runpytest_Testdir.parseconfig", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 978, "end_line": 1020, "span_ids": ["Testdir._ensure_basetemp", "Testdir.parseconfig", "Testdir.runpytest"], "tokens": 401}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def runpytest(self, *args, **kwargs) -> RunResult:\n        \"\"\"Run pytest inline or in a subprocess, depending on the command line\n        option \"--runpytest\" and return a :py:class:`RunResult`.\n\n        \"\"\"\n        args = self._ensure_basetemp(args)\n        if self._method == \"inprocess\":\n            return self.runpytest_inprocess(*args, **kwargs)\n        elif self._method == \"subprocess\":\n            return self.runpytest_subprocess(*args, **kwargs)\n        raise RuntimeError(\"Unrecognized runpytest option: {}\".format(self._method))\n\n    def _ensure_basetemp(self, args):\n        args = list(args)\n        for x in args:\n            if str(x).startswith(\"--basetemp\"):\n                break\n        else:\n            args.append(\"--basetemp=%s\" % self.tmpdir.dirpath(\"basetemp\"))\n        return args\n\n    def parseconfig(self, *args: Union[str, py.path.local]) -> Config:\n        \"\"\"Return a new pytest Config instance from given commandline args.\n\n        This invokes the pytest bootstrapping code in _pytest.config to create\n        a new :py:class:`_pytest.core.PluginManager` and call the\n        pytest_cmdline_parse hook to create a new\n        :py:class:`_pytest.config.Config` instance.\n\n        If :py:attr:`plugins` has been populated they should be plugin modules\n        to be registered with the PluginManager.\n\n        \"\"\"\n        args = self._ensure_basetemp(args)\n\n        import _pytest.config\n\n        config = _pytest.config._prepareconfig(args, self.plugins)  # type: Config\n        # we don't know what the test will do with this half-setup config\n        # object and thus we make sure it gets unconfigured properly in any\n        # case (otherwise capturing could still be active, for example)\n        self.request.addfinalizer(config._ensure_unconfigure)\n        return config", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.parseconfigure_Testdir.getitems": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_Testdir.parseconfigure_Testdir.getitems", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1022, "end_line": 1061, "span_ids": ["Testdir.getitem", "Testdir.getitems", "Testdir.parseconfigure"], "tokens": 288}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Testdir:\n\n    def parseconfigure(self, *args):\n        \"\"\"Return a new pytest configured Config instance.\n\n        This returns a new :py:class:`_pytest.config.Config` instance like\n        :py:meth:`parseconfig`, but also calls the pytest_configure hook.\n        \"\"\"\n        config = self.parseconfig(*args)\n        config._do_configure()\n        return config\n\n    def getitem(self, source, funcname=\"test_func\"):\n        \"\"\"Return the test item for a test function.\n\n        This writes the source to a python file and runs pytest's collection on\n        the resulting module, returning the test item for the requested\n        function name.\n\n        :param source: the module source\n\n        :param funcname: the name of the test function for which to return a\n            test item\n\n        \"\"\"\n        items = self.getitems(source)\n        for item in items:\n            if item.name == funcname:\n                return item\n        assert 0, \"{!r} item not found in module:\\n{}\\nitems: {}\".format(\n            funcname, source, items\n        )\n\n    def getitems(self, source):\n        \"\"\"Return all test items collected from the module.\n\n        This writes the source to a python file and runs pytest's collection on\n        the resulting module, returning all test items contained within.\n\n        \"\"\"\n        modcol = self.getmodulecol(source)\n        return self.genitems([modcol])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher_LineMatcher.fnmatch_lines": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher_LineMatcher.fnmatch_lines", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1322, "end_line": 1400, "span_ids": ["LineMatcher", "LineMatcher.__init__", "LineMatcher._getlines", "LineMatcher._log", "LineMatcher._log_text", "LineMatcher._match_lines_random", "LineMatcher.fnmatch_lines", "LineMatcher.fnmatch_lines_random", "LineMatcher.get_lines_after", "LineMatcher.re_match_lines_random"], "tokens": 693}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LineMatcher:\n    \"\"\"Flexible matching of text.\n\n    This is a convenience class to test large texts like the output of\n    commands.\n\n    The constructor takes a list of lines without their trailing newlines, i.e.\n    ``text.splitlines()``.\n    \"\"\"\n\n    def __init__(self, lines: List[str]) -> None:\n        self.lines = lines\n        self._log_output = []  # type: List[str]\n\n    def _getlines(self, lines2: Union[str, Sequence[str], Source]) -> Sequence[str]:\n        if isinstance(lines2, str):\n            lines2 = Source(lines2)\n        if isinstance(lines2, Source):\n            lines2 = lines2.strip().lines\n        return lines2\n\n    def fnmatch_lines_random(self, lines2: Sequence[str]) -> None:\n        \"\"\"Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`).\n        \"\"\"\n        __tracebackhide__ = True\n        self._match_lines_random(lines2, fnmatch)\n\n    def re_match_lines_random(self, lines2: Sequence[str]) -> None:\n        \"\"\"Check lines exist in the output in any order (using :func:`python:re.match`).\n        \"\"\"\n        __tracebackhide__ = True\n        self._match_lines_random(lines2, lambda name, pat: bool(re.match(pat, name)))\n\n    def _match_lines_random(\n        self, lines2: Sequence[str], match_func: Callable[[str, str], bool]\n    ) -> None:\n        __tracebackhide__ = True\n        lines2 = self._getlines(lines2)\n        for line in lines2:\n            for x in self.lines:\n                if line == x or match_func(x, line):\n                    self._log(\"matched: \", repr(line))\n                    break\n            else:\n                msg = \"line %r not found in output\" % line\n                self._log(msg)\n                self._fail(msg)\n\n    def get_lines_after(self, fnline: str) -> Sequence[str]:\n        \"\"\"Return all lines following the given line in the text.\n\n        The given line can contain glob wildcards.\n        \"\"\"\n        for i, line in enumerate(self.lines):\n            if fnline == line or fnmatch(line, fnline):\n                return self.lines[i + 1 :]\n        raise ValueError(\"line %r not found in output\" % fnline)\n\n    def _log(self, *args) -> None:\n        self._log_output.append(\" \".join(str(x) for x in args))\n\n    @property\n    def _log_text(self) -> str:\n        return \"\\n\".join(self._log_output)\n\n    def fnmatch_lines(\n        self, lines2: Sequence[str], *, consecutive: bool = False\n    ) -> None:\n        \"\"\"Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).\n\n        The argument is a list of lines which have to match and can use glob\n        wildcards.  If they do not match a pytest.fail() is called.  The\n        matches and non-matches are also shown as part of the error message.\n\n        :param lines2: string patterns to match.\n        :param consecutive: match lines consecutive?\n        \"\"\"\n        __tracebackhide__ = True\n        self._match_lines(lines2, fnmatch, \"fnmatch\", consecutive=consecutive)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher.re_match_lines_LineMatcher._match_lines.self._log_output": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher.re_match_lines_LineMatcher._match_lines.self._log_output", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1402, "end_line": 1485, "span_ids": ["LineMatcher._match_lines", "LineMatcher.re_match_lines"], "tokens": 681}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LineMatcher:\n\n    def re_match_lines(\n        self, lines2: Sequence[str], *, consecutive: bool = False\n    ) -> None:\n        \"\"\"Check lines exist in the output (using :func:`python:re.match`).\n\n        The argument is a list of lines which have to match using ``re.match``.\n        If they do not match a pytest.fail() is called.\n\n        The matches and non-matches are also shown as part of the error message.\n\n        :param lines2: string patterns to match.\n        :param consecutive: match lines consecutively?\n        \"\"\"\n        __tracebackhide__ = True\n        self._match_lines(\n            lines2,\n            lambda name, pat: bool(re.match(pat, name)),\n            \"re.match\",\n            consecutive=consecutive,\n        )\n\n    def _match_lines(\n        self,\n        lines2: Sequence[str],\n        match_func: Callable[[str, str], bool],\n        match_nickname: str,\n        *,\n        consecutive: bool = False\n    ) -> None:\n        \"\"\"Underlying implementation of ``fnmatch_lines`` and ``re_match_lines``.\n\n        :param list[str] lines2: list of string patterns to match. The actual\n            format depends on ``match_func``\n        :param match_func: a callable ``match_func(line, pattern)`` where line\n            is the captured line from stdout/stderr and pattern is the matching\n            pattern\n        :param str match_nickname: the nickname for the match function that\n            will be logged to stdout when a match occurs\n        :param consecutive: match lines consecutively?\n        \"\"\"\n        if not isinstance(lines2, collections.abc.Sequence):\n            raise TypeError(\"invalid type for lines2: {}\".format(type(lines2).__name__))\n        lines2 = self._getlines(lines2)\n        lines1 = self.lines[:]\n        nextline = None\n        extralines = []\n        __tracebackhide__ = True\n        wnick = len(match_nickname) + 1\n        started = False\n        for line in lines2:\n            nomatchprinted = False\n            while lines1:\n                nextline = lines1.pop(0)\n                if line == nextline:\n                    self._log(\"exact match:\", repr(line))\n                    started = True\n                    break\n                elif match_func(nextline, line):\n                    self._log(\"%s:\" % match_nickname, repr(line))\n                    self._log(\n                        \"{:>{width}}\".format(\"with:\", width=wnick), repr(nextline)\n                    )\n                    started = True\n                    break\n                else:\n                    if consecutive and started:\n                        msg = \"no consecutive match: {!r}\".format(line)\n                        self._log(msg)\n                        self._log(\n                            \"{:>{width}}\".format(\"with:\", width=wnick), repr(nextline)\n                        )\n                        self._fail(msg)\n                    if not nomatchprinted:\n                        self._log(\n                            \"{:>{width}}\".format(\"nomatch:\", width=wnick), repr(line)\n                        )\n                        nomatchprinted = True\n                    self._log(\"{:>{width}}\".format(\"and:\", width=wnick), repr(nextline))\n                extralines.append(nextline)\n            else:\n                msg = \"remains unmatched: {!r}\".format(line)\n                self._log(msg)\n                self._fail(msg)\n        self._log_output = []", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher.no_fnmatch_line_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/pytester.py_LineMatcher.no_fnmatch_line_", "embedding": null, "metadata": {"file_path": "src/_pytest/pytester.py", "file_name": "pytester.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1487, "end_line": 1537, "span_ids": ["LineMatcher._fail", "LineMatcher._no_match_line", "LineMatcher.no_fnmatch_line", "LineMatcher.no_re_match_line", "LineMatcher.str"], "tokens": 458}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class LineMatcher:\n\n    def no_fnmatch_line(self, pat: str) -> None:\n        \"\"\"Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.\n\n        :param str pat: the pattern to match lines.\n        \"\"\"\n        __tracebackhide__ = True\n        self._no_match_line(pat, fnmatch, \"fnmatch\")\n\n    def no_re_match_line(self, pat: str) -> None:\n        \"\"\"Ensure captured lines do not match the given pattern, using ``re.match``.\n\n        :param str pat: the regular expression to match lines.\n        \"\"\"\n        __tracebackhide__ = True\n        self._no_match_line(\n            pat, lambda name, pat: bool(re.match(pat, name)), \"re.match\"\n        )\n\n    def _no_match_line(\n        self, pat: str, match_func: Callable[[str, str], bool], match_nickname: str\n    ) -> None:\n        \"\"\"Ensure captured lines does not have a the given pattern, using ``fnmatch.fnmatch``\n\n        :param str pat: the pattern to match lines\n        \"\"\"\n        __tracebackhide__ = True\n        nomatch_printed = False\n        wnick = len(match_nickname) + 1\n        for line in self.lines:\n            if match_func(line, pat):\n                msg = \"{}: {!r}\".format(match_nickname, pat)\n                self._log(msg)\n                self._log(\"{:>{width}}\".format(\"with:\", width=wnick), repr(line))\n                self._fail(msg)\n            else:\n                if not nomatch_printed:\n                    self._log(\"{:>{width}}\".format(\"nomatch:\", width=wnick), repr(pat))\n                    nomatch_printed = True\n                self._log(\"{:>{width}}\".format(\"and:\", width=wnick), repr(line))\n        self._log_output = []\n\n    def _fail(self, msg: str) -> None:\n        __tracebackhide__ = True\n        log_text = self._log_text\n        self._log_output = []\n        pytest.fail(log_text)\n\n    def str(self) -> str:\n        \"\"\"Return the entire original text.\"\"\"\n        return \"\\n\".join(self.lines)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_async_warn_and_skip_pytest_pycollect_makemodule": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_async_warn_and_skip_pytest_pycollect_makemodule", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 162, "end_line": 208, "span_ids": ["async_warn_and_skip", "path_matches_patterns", "pytest_collect_file", "pytest_pycollect_makemodule", "pytest_pyfunc_call"], "tokens": 432}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\"):\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n\n\ndef path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package.from_parent(parent, fspath=path)\n    return Module.from_parent(parent, fspath=path)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_pycollect_makeitem_pytest_pycollect_makeitem.if_safe_isclass_obj_.elif_collector_istestfunc.if_not_inspect_isfunctio": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_pytest_pycollect_makeitem_pytest_pycollect_makeitem.if_safe_isclass_obj_.elif_collector_istestfunc.if_not_inspect_isfunctio", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 211, "end_line": 247, "span_ids": ["pytest_pycollect_makeitem"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n        return\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            outcome.force_result(Class.from_parent(collector, name=name, obj=obj))\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            outcome.force_result(res)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector_PyCollector._matches_prefix_or_glob_option": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector_PyCollector._matches_prefix_or_glob_option", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 313, "end_line": 359, "span_ids": ["PyCollector", "PyCollector._matches_prefix_or_glob_option", "PyCollector.classnamefilter", "PyCollector.funcnamefilter", "PyCollector.isnosetest", "PyCollector.istestclass", "PyCollector.istestfunction"], "tokens": 398}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PyCollector(PyobjMixin, nodes.Collector):\n    def funcnamefilter(self, name):\n        return self._matches_prefix_or_glob_option(\"python_functions\", name)\n\n    def isnosetest(self, obj):\n        \"\"\" Look for the __test__ attribute, which is applied by the\n        @nose.tools.istest decorator\n        \"\"\"\n        # We explicitly check for \"is True\" here to not mistakenly treat\n        # classes with a custom __getattr__ returning something truthy (like a\n        # function) as test classes.\n        return safe_getattr(obj, \"__test__\", False) is True\n\n    def classnamefilter(self, name):\n        return self._matches_prefix_or_glob_option(\"python_classes\", name)\n\n    def istestfunction(self, obj, name):\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # static methods need to be unwrapped\n                obj = safe_getattr(obj, \"__func__\", False)\n            return (\n                safe_getattr(obj, \"__call__\", False)\n                and fixtures.getfixturemarker(obj) is None\n            )\n        else:\n            return False\n\n    def istestclass(self, obj, name):\n        return self.classnamefilter(name) or self.isnosetest(obj)\n\n    def _matches_prefix_or_glob_option(self, option_name, name):\n        \"\"\"\n        checks if the given name matches the prefix or glob-pattern defined\n        in ini configuration.\n        \"\"\"\n        for option in self.config.getini(option_name):\n            if name.startswith(option):\n                return True\n            # check that name looks like a glob-string before calling fnmatch\n            # because this is called for every name in each collected module,\n            # and fnmatch is somewhat expensive to call\n            elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n                name, option\n            ):\n                return True\n        return False", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector.collect_PyCollector._makeitem": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_PyCollector.collect_PyCollector._makeitem", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 361, "end_line": 395, "span_ids": ["PyCollector._makeitem", "PyCollector.collect"], "tokens": 268}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class PyCollector(PyobjMixin, nodes.Collector):\n\n    def collect(self):\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # NB. we avoid random getattrs and peek in the __dict__ instead\n        # (XXX originally introduced from a PyPy need, still true?)\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        for basecls in self.obj.__class__.__mro__:\n            dicts.append(basecls.__dict__)\n        seen = set()\n        values = []\n        for dic in dicts:\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name, obj in list(dic.items()):\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = self._makeitem(name, obj)\n                if res is None:\n                    continue\n                if not isinstance(res, list):\n                    res = [res]\n                values.extend(res)\n\n        def sort_key(item):\n            fspath, lineno, _ = item.reportinfo()\n            return (str(fspath), lineno)\n\n        values.sort(key=sort_key)\n        return values\n\n    def _makeitem(self, name, obj):\n        # assert self.ihook.fspath == self.fspath, self\n        return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Package.collect_Package.collect.for_path_in_this_path_vis": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Package.collect_Package.collect.for_path_in_this_path_vis", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 596, "end_line": 624, "span_ids": ["Package.collect"], "tokens": 241}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Package(Module):\n\n    def collect(self):\n        this_path = self.fspath.dirpath()\n        init_module = this_path.join(\"__init__.py\")\n        if init_module.check(file=1) and path_matches_patterns(\n            init_module, self.config.getini(\"python_files\")\n        ):\n            yield Module.from_parent(self, fspath=init_module)\n        pkg_prefixes = set()\n        for path in this_path.visit(rec=self._recurse, bf=True, sort=True):\n            # We will visit our own __init__.py file, in which case we skip it.\n            is_file = path.isfile()\n            if is_file:\n                if path.basename == \"__init__.py\" and path.dirpath() == this_path:\n                    continue\n\n            parts_ = parts(path.strpath)\n            if any(\n                pkg_prefix in parts_ and pkg_prefix.join(\"__init__.py\") != path\n                for pkg_prefix in pkg_prefixes\n            ):\n                continue\n\n            if is_file:\n                yield from self._collectfile(path)\n            elif not path.isdir():\n                # Broken symlink or invalid/missing file.\n                continue\n            elif path.join(\"__init__.py\").check(file=1):\n                pkg_prefixes.add(path)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__call_with_optional_argument_Class.collect.return_Instance_from_par": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__call_with_optional_argument_Class.collect.return_Instance_from_par", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 627, "end_line": 685, "span_ids": ["Class", "Class.collect", "Class.from_parent", "_call_with_optional_argument", "_get_first_non_fixture_func"], "tokens": 383}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _call_with_optional_argument(func, arg):\n    \"\"\"Call the given function with the given argument if func accepts one argument, otherwise\n    calls func without arguments\"\"\"\n    arg_count = func.__code__.co_argcount\n    if inspect.ismethod(func):\n        arg_count -= 1\n    if arg_count:\n        func(arg)\n    else:\n        func()\n\n\ndef _get_first_non_fixture_func(obj, names):\n    \"\"\"Return the attribute from the given object to be used as a setup/teardown\n    xunit-style function, but only if not marked as a fixture to\n    avoid calling it twice.\n    \"\"\"\n    for name in names:\n        meth = getattr(obj, name, None)\n        if meth is not None and fixtures.getfixturemarker(meth) is None:\n            return meth\n\n\nclass Class(PyCollector):\n    \"\"\" Collector for test methods. \"\"\"\n\n    @classmethod\n    def from_parent(cls, parent, *, name, obj=None):\n        \"\"\"\n        The public constructor\n        \"\"\"\n        return super().from_parent(name=name, parent=parent)\n\n    def collect(self):\n        if not safe_getattr(self.obj, \"__test__\", True):\n            return []\n        if hasinit(self.obj):\n            self.warn(\n                PytestCollectionWarning(\n                    \"cannot collect test class %r because it has a \"\n                    \"__init__ constructor (from: %s)\"\n                    % (self.obj.__name__, self.parent.nodeid)\n                )\n            )\n            return []\n        elif hasnew(self.obj):\n            self.warn(\n                PytestCollectionWarning(\n                    \"cannot collect test class %r because it has a \"\n                    \"__new__ constructor (from: %s)\"\n                    % (self.obj.__name__, self.parent.nodeid)\n                )\n            )\n            return []\n\n        self._inject_setup_class_fixture()\n        self._inject_setup_method_fixture()\n\n        return [Instance.from_parent(self, name=\"()\")]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Class._inject_setup_class_fixture_Class._inject_setup_class_fixture": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Class._inject_setup_class_fixture_Class._inject_setup_class_fixture", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 687, "end_line": 709, "span_ids": ["Class._inject_setup_class_fixture"], "tokens": 211}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Class(PyCollector):\n\n    def _inject_setup_class_fixture(self):\n        \"\"\"Injects a hidden autouse, class scoped fixture into the collected class object\n        that invokes setup_class/teardown_class if either or both are available.\n\n        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        \"\"\"\n        setup_class = _get_first_non_fixture_func(self.obj, (\"setup_class\",))\n        teardown_class = getattr(self.obj, \"teardown_class\", None)\n        if setup_class is None and teardown_class is None:\n            return\n\n        @fixtures.fixture(autouse=True, scope=\"class\")\n        def xunit_setup_class_fixture(cls):\n            if setup_class is not None:\n                func = getimfunc(setup_class)\n                _call_with_optional_argument(func, self.obj)\n            yield\n            if teardown_class is not None:\n                func = getimfunc(teardown_class)\n                _call_with_optional_argument(func, self.obj)\n\n        self.obj.__pytest_setup_class = xunit_setup_class_fixture", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Class._inject_setup_method_fixture_hasnew": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Class._inject_setup_method_fixture_hasnew", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 711, "end_line": 764, "span_ids": ["Class._inject_setup_method_fixture", "Instance", "Instance._getobj", "Instance.collect", "Instance.newinstance", "hasinit", "hasnew"], "tokens": 372}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Class(PyCollector):\n\n    def _inject_setup_method_fixture(self):\n        \"\"\"Injects a hidden autouse, function scoped fixture into the collected class object\n        that invokes setup_method/teardown_method if either or both are available.\n\n        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n        other fixtures (#517).\n        \"\"\"\n        setup_method = _get_first_non_fixture_func(self.obj, (\"setup_method\",))\n        teardown_method = getattr(self.obj, \"teardown_method\", None)\n        if setup_method is None and teardown_method is None:\n            return\n\n        @fixtures.fixture(autouse=True, scope=\"function\")\n        def xunit_setup_method_fixture(self, request):\n            method = request.function\n            if setup_method is not None:\n                func = getattr(self, \"setup_method\")\n                _call_with_optional_argument(func, method)\n            yield\n            if teardown_method is not None:\n                func = getattr(self, \"teardown_method\")\n                _call_with_optional_argument(func, method)\n\n        self.obj.__pytest_setup_method = xunit_setup_method_fixture\n\n\nclass Instance(PyCollector):\n    _ALLOW_MARKERS = False  # hack, destroy later\n    # instances share the object with their parents in a way\n    # that duplicates markers instances if not taken out\n    # can be removed at node structure reorganization time\n\n    def _getobj(self):\n        return self.parent.obj()\n\n    def collect(self):\n        self.session._fixturemanager.parsefactories(self)\n        return super().collect()\n\n    def newinstance(self):\n        self.obj = self._getobj()\n        return self.obj\n\n\ndef hasinit(obj):\n    init = getattr(obj, \"__init__\", None)\n    if init:\n        return init != object.__init__\n\n\ndef hasnew(obj):\n    new = getattr(obj, \"__new__\", None)\n    if new:\n        return new != object.__new__", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc_Metafunc.funcargnames": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc_Metafunc.funcargnames", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 812, "end_line": 852, "span_ids": ["Metafunc", "Metafunc.__init__", "Metafunc.funcargnames"], "tokens": 270}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n    \"\"\"\n    Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n    They help to inspect a test function and to generate tests according to\n    test configuration or values specified in the class or module where a\n    test function is defined.\n    \"\"\"\n\n    def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n\n    @property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc.parametrize_Metafunc.parametrize.if_request_in_argnames_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc.parametrize_Metafunc.parametrize.if_request_in_argnames_", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 854, "end_line": 930, "span_ids": ["Metafunc.parametrize"], "tokens": 722}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n\n    def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[str]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            function_definition=self.definition,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n        # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc.parametrize.if_scope_is_None__Metafunc.parametrize.self._calls": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc.parametrize.if_scope_is_None__Metafunc.parametrize.self._calls", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 932, "end_line": 974, "span_ids": ["Metafunc.parametrize"], "tokens": 357}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n\n    def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[str]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        # ... other code\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        self._validate_explicit_parameters(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._resolve_arg_ids_Metafunc._resolve_arg_ids.return_idmaker_argnames_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._resolve_arg_ids_Metafunc._resolve_arg_ids.return_idmaker_argnames_", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 976, "end_line": 1007, "span_ids": ["Metafunc._resolve_arg_ids"], "tokens": 280}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n\n    def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        item,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param Item item: the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, item=item)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_ids_Metafunc._validate_ids.return_new_ids": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_ids_Metafunc._validate_ids.return_new_ids", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1009, "end_line": 1041, "span_ids": ["Metafunc._validate_ids"], "tokens": 310}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n\n    def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type] # noqa: F821\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError:\n                raise TypeError(\"ids must be a callable or an iterable\")\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_explicit_parameters_Metafunc._validate_explicit_parameters.for_arg_in_parametrized_a": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Metafunc._validate_explicit_parameters_Metafunc._validate_explicit_parameters.for_arg_in_parametrized_a", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1113, "end_line": 1144, "span_ids": ["Metafunc._validate_explicit_parameters"], "tokens": 278}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Metafunc:\n\n    def _validate_explicit_parameters(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        The argnames in *parametrize* should either be declared explicitly via\n        indirect list or in the function signature\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails\n        \"\"\"\n        if isinstance(indirect, bool):\n            parametrized_argnames = [] if indirect else argnames\n        else:\n            parametrized_argnames = [arg for arg in argnames if arg not in indirect]\n\n        if not parametrized_argnames:\n            return\n\n        funcargnames = _pytest.compat.getfuncargnames(self.function)\n        usefixtures = fixtures.get_use_fixtures_for_node(self.definition)\n\n        for arg in parametrized_argnames:\n            if arg not in funcargnames and arg not in usefixtures:\n                func_name = self.function.__name__\n                msg = (\n                    'In function \"{func_name}\":\\n'\n                    'Parameter \"{arg}\" should be declared explicitly via indirect or in function itself'\n                ).format(func_name=func_name, arg=arg)\n                fail(msg, pytrace=False)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__idvalset_idmaker.return_resolved_ids": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py__idvalset_idmaker.return_resolved_ids", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1232, "end_line": 1283, "span_ids": ["_idvalset", "idmaker"], "tokens": 431}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _idvalset(\n    idx: int,\n    parameterset: ParameterSet,\n    argnames: Iterable[str],\n    idfn: Optional[Callable[[object], Optional[object]]],\n    ids: Optional[List[Union[None, str]]],\n    item,\n    config: Optional[Config],\n):\n    if parameterset.id is not None:\n        return parameterset.id\n    id = None if ids is None or idx >= len(ids) else ids[idx]\n    if id is None:\n        this_id = [\n            _idval(val, argname, idx, idfn, item=item, config=config)\n            for val, argname in zip(parameterset.values, argnames)\n        ]\n        return \"-\".join(this_id)\n    else:\n        return _ascii_escaped_by_config(id, config)\n\n\ndef idmaker(\n    argnames: Iterable[str],\n    parametersets: Iterable[ParameterSet],\n    idfn: Optional[Callable[[object], Optional[object]]] = None,\n    ids: Optional[List[Union[None, str]]] = None,\n    config: Optional[Config] = None,\n    item=None,\n) -> List[str]:\n    resolved_ids = [\n        _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)\n        for valindex, parameterset in enumerate(parametersets)\n    ]\n\n    # All IDs must be unique!\n    unique_ids = set(resolved_ids)\n    if len(unique_ids) != len(resolved_ids):\n\n        # Record the number of occurrences of each test ID\n        test_id_counts = Counter(resolved_ids)\n\n        # Map the test ID to its next suffix\n        test_id_suffixes = defaultdict(int)  # type: Dict[str, int]\n\n        # Suffix non-unique IDs to make them unique\n        for index, test_id in enumerate(resolved_ids):\n            if test_id_counts[test_id] > 1:\n                resolved_ids[index] = \"{}{}\".format(test_id, test_id_suffixes[test_id])\n                test_id_suffixes[test_id] += 1\n\n    return resolved_ids", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_show_fixtures_per_test__show_fixtures_per_test.for_session_item_in_sessi": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_show_fixtures_per_test__show_fixtures_per_test.for_session_item_in_sessi", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1286, "end_line": 1341, "span_ids": ["_show_fixtures_per_test", "show_fixtures_per_test"], "tokens": 399}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def show_fixtures_per_test(config):\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _show_fixtures_per_test)\n\n\ndef _show_fixtures_per_test(config, session):\n    import _pytest.config\n\n    session.perform_collect()\n    curdir = py.path.local()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    def get_best_relpath(func):\n        loc = getlocation(func, curdir)\n        return curdir.bestrelpath(loc)\n\n    def write_fixture(fixture_def):\n        argname = fixture_def.argname\n        if verbose <= 0 and argname.startswith(\"_\"):\n            return\n        if verbose > 0:\n            bestrel = get_best_relpath(fixture_def.func)\n            funcargspec = \"{} -- {}\".format(argname, bestrel)\n        else:\n            funcargspec = argname\n        tw.line(funcargspec, green=True)\n        fixture_doc = inspect.getdoc(fixture_def.func)\n        if fixture_doc:\n            write_docstring(tw, fixture_doc)\n        else:\n            tw.line(\"    no docstring available\", red=True)\n\n    def write_item(item):\n        try:\n            info = item._fixtureinfo\n        except AttributeError:\n            # doctests items have no _fixtureinfo attribute\n            return\n        if not info.name2fixturedefs:\n            # this test item does not use any fixtures\n            return\n        tw.line()\n        tw.sep(\"-\", \"fixtures used by {}\".format(item.name))\n        tw.sep(\"-\", \"({})\".format(get_best_relpath(item.function)))\n        # dict key not used in loop but needed for sorting\n        for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n            assert fixturedefs is not None\n            if not fixturedefs:\n                continue\n            # last item is expected to be the one used by the test item\n            write_fixture(fixturedefs[-1])\n\n    for session_item in session.items:\n        write_item(session_item)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_showfixtures_write_docstring": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_showfixtures_write_docstring", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1344, "end_line": 1409, "span_ids": ["_showfixtures_main", "showfixtures", "write_docstring"], "tokens": 441}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def showfixtures(config):\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)\n\n\ndef _showfixtures_main(config, session):\n    import _pytest.config\n\n    session.perform_collect()\n    curdir = py.path.local()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    fm = session._fixturemanager\n\n    available = []\n    seen = set()\n\n    for argname, fixturedefs in fm._arg2fixturedefs.items():\n        assert fixturedefs is not None\n        if not fixturedefs:\n            continue\n        for fixturedef in fixturedefs:\n            loc = getlocation(fixturedef.func, curdir)\n            if (fixturedef.argname, loc) in seen:\n                continue\n            seen.add((fixturedef.argname, loc))\n            available.append(\n                (\n                    len(fixturedef.baseid),\n                    fixturedef.func.__module__,\n                    curdir.bestrelpath(loc),\n                    fixturedef.argname,\n                    fixturedef,\n                )\n            )\n\n    available.sort()\n    currentmodule = None\n    for baseid, module, bestrel, argname, fixturedef in available:\n        if currentmodule != module:\n            if not module.startswith(\"_pytest.\"):\n                tw.line()\n                tw.sep(\"-\", \"fixtures defined from {}\".format(module))\n                currentmodule = module\n        if verbose <= 0 and argname[0] == \"_\":\n            continue\n        tw.write(argname, green=True)\n        if fixturedef.scope != \"function\":\n            tw.write(\" [%s scope]\" % fixturedef.scope, cyan=True)\n        if verbose > 0:\n            tw.write(\" -- %s\" % bestrel, yellow=True)\n        tw.write(\"\\n\")\n        loc = getlocation(fixturedef.func, curdir)\n        doc = inspect.getdoc(fixturedef.func)\n        if doc:\n            write_docstring(tw, doc)\n        else:\n            tw.line(\"    {}: no docstring available\".format(loc), red=True)\n        tw.line()\n\n\ndef write_docstring(tw: TerminalWriter, doc: str, indent: str = \"    \") -> None:\n    for line in doc.split(\"\\n\"):\n        tw.line(indent + line)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Function_Function.setup": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Function_Function.setup", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1412, "end_line": 1520, "span_ids": ["Function", "Function.__init__", "Function._getobj", "Function._initrequest", "Function._pyfuncitem", "Function.from_parent", "Function.funcargnames", "Function.function", "Function.runtest", "Function.setup"], "tokens": 725}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name,\n        parent,\n        args=None,\n        config=None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session=None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname=None,\n    ) -> None:\n        super().__init__(name, parent, config=config, session=session)\n        self._args = args\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n        #: original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self):\n        self.funcargs = {}\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        name = self.name\n        i = name.find(\"[\")  # parametrization\n        if i != -1:\n            name = name[:i]\n        return getattr(self.parent.obj, name)\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self):\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Function._prunetraceback_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/python.py_Function._prunetraceback_", "embedding": null, "metadata": {"file_path": "src/_pytest/python.py", "file_name": "python.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1522, "end_line": 1561, "span_ids": ["Function._prunetraceback", "Function.repr_failure", "FunctionDefinition", "FunctionDefinition.runtest", "FunctionDefinition:3"], "tokens": 351}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class Function(PyobjMixin, nodes.Item):\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)\n\n\nclass FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py__basic_collect_and_run_pytest_addoption": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py__basic_collect_and_run_pytest_addoption", "embedding": null, "metadata": {"file_path": "src/_pytest/runner.py", "file_name": "runner.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 44, "span_ids": ["docstring", "pytest_addoption"], "tokens": 252}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" basic collect and runtest protocol implementations \"\"\"\nimport bdb\nimport os\nimport sys\nfrom time import perf_counter  # Intentionally not `import time` to avoid being\nfrom time import time  # affected by tests which monkeypatch `time` (issue #185).\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\nimport attr\n\nfrom .reports import CollectErrorRepr\nfrom .reports import CollectReport\nfrom .reports import TestReport\nfrom _pytest._code.code import ExceptionChainRepr\nfrom _pytest._code.code import ExceptionInfo\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.nodes import Collector\nfrom _pytest.nodes import Node\nfrom _pytest.outcomes import Exit\nfrom _pytest.outcomes import Skipped\nfrom _pytest.outcomes import TEST_OUTCOME\n\nif TYPE_CHECKING:\n    from typing import Type\n    from typing_extensions import Literal\n\n#\n# pytest plugin hooks\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"terminal reporting\", \"reporting\", after=\"general\")\n    group.addoption(\n        \"--durations\",\n        action=\"store\",\n        type=int,\n        default=None,\n        metavar=\"N\",\n        help=\"show N slowest setup/test durations (N=0 for all).\",\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_terminal_summary_pytest_terminal_summary.for_i_rep_in_enumerate_d": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/runner.py_pytest_terminal_summary_pytest_terminal_summary.for_i_rep_in_enumerate_d", "embedding": null, "metadata": {"file_path": "src/_pytest/runner.py", "file_name": "runner.py", "file_type": "text/x-python", "category": "implementation", "start_line": 47, "end_line": 76, "span_ids": ["pytest_terminal_summary"], "tokens": 238}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_terminal_summary(terminalreporter):\n    durations = terminalreporter.config.option.durations\n    verbose = terminalreporter.config.getvalue(\"verbose\")\n    if durations is None:\n        return\n    tr = terminalreporter\n    dlist = []\n    for replist in tr.stats.values():\n        for rep in replist:\n            if hasattr(rep, \"duration\"):\n                dlist.append(rep)\n    if not dlist:\n        return\n    dlist.sort(key=lambda x: x.duration)\n    dlist.reverse()\n    if not durations:\n        tr.write_sep(\"=\", \"slowest durations\")\n    else:\n        tr.write_sep(\"=\", \"slowest %s durations\" % durations)\n        dlist = dlist[:durations]\n\n    for i, rep in enumerate(dlist):\n        if verbose < 2 and rep.duration < 0.005:\n            tr.write_line(\"\")\n            tr.write_line(\n                \"(%s durations < 0.005s hidden.  Use -vv to show these durations.)\"\n                % (len(dlist) - i)\n            )\n            break\n        tr.write_line(\"{:02.2f}s {:<8} {}\".format(rep.duration, rep.when, rep.nodeid))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/store.py_from_typing_import_Any_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/store.py_from_typing_import_Any_", "embedding": null, "metadata": {"file_path": "src/_pytest/store.py", "file_name": "store.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 126, "span_ids": ["Store", "Store.__contains__", "Store.__delitem__", "Store.__getitem__", "Store.__init__", "Store.__setitem__", "Store.get", "Store.setdefault", "StoreKey", "imports"], "tokens": 825}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from typing import Any\nfrom typing import cast\nfrom typing import Dict\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import Union\n\n\n__all__ = [\"Store\", \"StoreKey\"]\n\n\nT = TypeVar(\"T\")\nD = TypeVar(\"D\")\n\n\nclass StoreKey(Generic[T]):\n    \"\"\"StoreKey is an object used as a key to a Store.\n\n    A StoreKey is associated with the type T of the value of the key.\n\n    A StoreKey is unique and cannot conflict with another key.\n    \"\"\"\n\n    __slots__ = ()\n\n\nclass Store:\n    \"\"\"Store is a type-safe heterogenous mutable mapping that\n    allows keys and value types to be defined separately from\n    where it (the Store) is created.\n\n    Usually you will be given an object which has a ``Store``:\n\n    .. code-block:: python\n\n        store: Store = some_object.store\n\n    If a module wants to store data in this Store, it creates StoreKeys\n    for its keys (at the module level):\n\n    .. code-block:: python\n\n        some_str_key = StoreKey[str]()\n        some_bool_key = StoreKey[bool]()\n\n    To store information:\n\n    .. code-block:: python\n\n        # Value type must match the key.\n        store[some_str_key] = \"value\"\n        store[some_bool_key] = True\n\n    To retrieve the information:\n\n    .. code-block:: python\n\n        # The static type of some_str is str.\n        some_str = store[some_str_key]\n        # The static type of some_bool is bool.\n        some_bool = store[some_bool_key]\n\n    Why use this?\n    -------------\n\n    Problem: module Internal defines an object. Module External, which\n    module Internal doesn't know about, receives the object and wants to\n    attach information to it, to be retrieved later given the object.\n\n    Bad solution 1: Module External assigns private attributes directly on\n    the object. This doesn't work well because the type checker doesn't\n    know about these attributes and it complains about undefined attributes.\n\n    Bad solution 2: module Internal adds a ``Dict[str, Any]`` attribute to\n    the object. Module External stores its data in private keys of this dict.\n    This doesn't work well because retrieved values are untyped.\n\n    Good solution: module Internal adds a ``Store`` to the object. Module\n    External mints StoreKeys for its own keys. Module External stores and\n    retrieves its data using these keys.\n    \"\"\"\n\n    __slots__ = (\"_store\",)\n\n    def __init__(self) -> None:\n        self._store = {}  # type: Dict[StoreKey[Any], object]\n\n    def __setitem__(self, key: StoreKey[T], value: T) -> None:\n        \"\"\"Set a value for key.\"\"\"\n        self._store[key] = value\n\n    def __getitem__(self, key: StoreKey[T]) -> T:\n        \"\"\"Get the value for key.\n\n        Raises KeyError if the key wasn't set before.\n        \"\"\"\n        return cast(T, self._store[key])\n\n    def get(self, key: StoreKey[T], default: D) -> Union[T, D]:\n        \"\"\"Get the value for key, or return default if the key wasn't set\n        before.\"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def setdefault(self, key: StoreKey[T], default: T) -> T:\n        \"\"\"Return the value of key if already set, otherwise set the value\n        of key to default and return default.\"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            self[key] = default\n            return default\n\n    def __delitem__(self, key: StoreKey[T]) -> None:\n        \"\"\"Delete the value for key.\n\n        Raises KeyError if the key wasn't set before.\n        \"\"\"\n        del self._store[key]\n\n    def __contains__(self, key: StoreKey[T]) -> bool:\n        \"\"\"Returns whether key was set.\"\"\"\n        return key in self._store", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter_TerminalReporter.write_fspath_result": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter_TerminalReporter.write_fspath_result", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 262, "end_line": 347, "span_ids": ["TerminalReporter", "TerminalReporter.__init__", "TerminalReporter._determine_show_progress_info", "TerminalReporter.hasopt", "TerminalReporter.showfspath", "TerminalReporter.showfspath_6", "TerminalReporter.showheader", "TerminalReporter.showlongtestinfo", "TerminalReporter.verbosity", "TerminalReporter.write_fspath_result", "TerminalReporter.writer", "TerminalReporter.writer_1"], "tokens": 745}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n    def __init__(self, config: Config, file=None) -> None:\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None  # type: Optional[Session]\n        self._showfspath = None\n\n        self.stats = {}  # type: Dict[str, List[Any]]\n        self._main_color = None  # type: Optional[str]\n        self._known_types = None  # type: Optional[List]\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None  # type: Any\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()  # type: Set[str]\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None  # type: Optional[float]\n\n    @property\n    def writer(self) -> TerminalWriter:\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        return self._tw\n\n    @writer.setter\n    def writer(self, value: TerminalWriter):\n        warnings.warn(TERMINALWRITER_WRITER, stacklevel=2)\n        self._tw = value\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, flush=True, **markup)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.write_ensure_prefix_TerminalReporter.pytest_deselected": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.write_ensure_prefix_TerminalReporter.pytest_deselected", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 349, "end_line": 436, "span_ids": ["TerminalReporter._add_stats", "TerminalReporter.ensure_newline", "TerminalReporter.flush", "TerminalReporter.line", "TerminalReporter.pytest_deselected", "TerminalReporter.pytest_internalerror", "TerminalReporter.pytest_plugin_registered", "TerminalReporter.pytest_warning_captured", "TerminalReporter.rewrite", "TerminalReporter.section", "TerminalReporter.write", "TerminalReporter.write_ensure_prefix", "TerminalReporter.write_line", "TerminalReporter.write_sep"], "tokens": 693}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content: str, *, flush: bool = False, **markup: bool) -> None:\n        self._tw.write(content, flush=flush, **markup)\n\n    def flush(self) -> None:\n        self._tw.flush()\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def _add_stats(self, category: str, items: List) -> None:\n        set_main_color = category not in self.stats\n        self.stats.setdefault(category, []).extend(items[:])\n        if set_main_color:\n            self._set_main_color()\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        self._add_stats(\"warnings\", [warning_report])\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self._add_stats(\"deselected\", items)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_runtest_logstart_TerminalReporter.pytest_runtest_logreport.self_flush_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.pytest_runtest_logstart_TerminalReporter.pytest_runtest_logreport.self_flush_", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 438, "end_line": 500, "span_ids": ["TerminalReporter.pytest_runtest_logreport", "TerminalReporter.pytest_runtest_logstart"], "tokens": 512}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n            self.flush()\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")\n            self.flush()\n\n    def pytest_runtest_logreport(self, report: TestReport) -> None:\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self._add_stats(category, [rep])\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n        self.flush()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._is_last_item_TerminalReporter.pytest_collectreport": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._is_last_item_TerminalReporter.pytest_collectreport", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 502, "end_line": 572, "span_ids": ["TerminalReporter._get_progress_information_message", "TerminalReporter._is_last_item", "TerminalReporter._width_of_current_line", "TerminalReporter._write_progress_information_filling_space", "TerminalReporter.pytest_collection", "TerminalReporter.pytest_collectreport", "TerminalReporter.pytest_runtest_logfinish"], "tokens": 644}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    @property\n    def _is_last_item(self):\n        return len(self._progress_nodeids_reported) == self._session.testscollected\n\n    def pytest_runtest_logfinish(self, nodeid):\n        assert self._session\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n\n            if self._is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                main_color, _ = self._get_main_color()\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", **{main_color: True})\n\n    def _get_progress_information_message(self) -> str:\n        assert self._session\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                return \" [{:3d}%]\".format(\n                    len(self._progress_nodeids_reported) * 100 // collected\n                )\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        color, _ = self._get_main_color()\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), flush=True, **{color: True})\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        return self._tw.width_of_current_line\n\n    def pytest_collection(self) -> None:\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", flush=True, bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", flush=True, bold=True)\n\n    def pytest_collectreport(self, report: CollectReport) -> None:\n        if report.failed:\n            self._add_stats(\"error\", [report])\n        elif report.skipped:\n            self._add_stats(\"skipped\", [report])\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_passes_TerminalReporter._outrep_summary": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_passes_TerminalReporter._outrep_summary", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 883, "end_line": 964, "span_ids": ["TerminalReporter._get_teardown_reports", "TerminalReporter._handle_teardown_sections", "TerminalReporter._outrep_summary", "TerminalReporter.print_teardown_sections", "TerminalReporter.summary_errors", "TerminalReporter.summary_failures", "TerminalReporter.summary_passes"], "tokens": 654}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def _get_teardown_reports(self, nodeid: str) -> List[TestReport]:\n        return [\n            report\n            for report in self.getreports(\"\")\n            if report.when == \"teardown\" and report.nodeid == nodeid\n        ]\n\n    def _handle_teardown_sections(self, nodeid: str) -> None:\n        for report in self._get_teardown_reports(nodeid):\n            self.print_teardown_sections(report)\n\n    def print_teardown_sections(self, rep: TestReport) -> None:\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    self._handle_teardown_sections(rep.nodeid)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_stats_TerminalReporter.summary_stats.None_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter.summary_stats_TerminalReporter.summary_stats.None_5", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 966, "end_line": 1001, "span_ids": ["TerminalReporter.summary_stats"], "tokens": 276}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def summary_stats(self):\n        if self.verbosity < -1:\n            return\n\n        session_duration = time.time() - self._sessionstarttime\n        (parts, main_color) = self.build_summary_stats_line()\n        line_parts = []\n\n        display_sep = self.verbosity >= 0\n        if display_sep:\n            fullwidth = self._tw.fullwidth\n        for text, markup in parts:\n            with_markup = self._tw.markup(text, **markup)\n            if display_sep:\n                fullwidth += len(with_markup) - len(text)\n            line_parts.append(with_markup)\n        msg = \", \".join(line_parts)\n\n        main_markup = {main_color: True}\n        duration = \" in {}\".format(format_session_duration(session_duration))\n        duration_with_markup = self._tw.markup(duration, **main_markup)\n        if display_sep:\n            fullwidth += len(duration_with_markup) - len(duration)\n        msg += duration_with_markup\n\n        if display_sep:\n            markup_for_end_sep = self._tw.markup(\"\", **main_markup)\n            if markup_for_end_sep.endswith(\"\\x1b[0m\"):\n                markup_for_end_sep = markup_for_end_sep[:-4]\n            fullwidth += len(markup_for_end_sep)\n            msg += markup_for_end_sep\n\n        if display_sep:\n            self.write_sep(\"=\", msg, fullwidth=fullwidth, **main_markup)\n        else:\n            self.write_line(msg, **main_markup)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._get_main_color_TerminalReporter.build_summary_stats_line": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py_TerminalReporter._get_main_color_TerminalReporter.build_summary_stats_line", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1072, "end_line": 1117, "span_ids": ["TerminalReporter._determine_main_color", "TerminalReporter._get_main_color", "TerminalReporter._set_main_color", "TerminalReporter.build_summary_stats_line"], "tokens": 447}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TerminalReporter:\n\n    def _get_main_color(self) -> Tuple[str, List[str]]:\n        if self._main_color is None or self._known_types is None or self._is_last_item:\n            self._set_main_color()\n            assert self._main_color\n            assert self._known_types\n        return self._main_color, self._known_types\n\n    def _determine_main_color(self, unknown_type_seen: bool) -> str:\n        stats = self.stats\n        if \"failed\" in stats or \"error\" in stats:\n            main_color = \"red\"\n        elif \"warnings\" in stats or \"xpassed\" in stats or unknown_type_seen:\n            main_color = \"yellow\"\n        elif \"passed\" in stats or not self._is_last_item:\n            main_color = \"green\"\n        else:\n            main_color = \"yellow\"\n        return main_color\n\n    def _set_main_color(self) -> None:\n        unknown_types = []  # type: List[str]\n        for found_type in self.stats.keys():\n            if found_type:  # setup/teardown reports have an empty key, ignore them\n                if found_type not in KNOWN_TYPES and found_type not in unknown_types:\n                    unknown_types.append(found_type)\n        self._known_types = list(KNOWN_TYPES) + unknown_types\n        self._main_color = self._determine_main_color(bool(unknown_types))\n\n    def build_summary_stats_line(self) -> Tuple[List[Tuple[str, Dict[str, bool]]], str]:\n        main_color, known_types = self._get_main_color()\n\n        parts = []\n        for key in known_types:\n            reports = self.stats.get(key, None)\n            if reports:\n                count = sum(\n                    1 for rep in reports if getattr(rep, \"count_towards_summary\", True)\n                )\n                color = _color_for_type.get(key, _color_for_type_default)\n                markup = {color: True, \"bold\": color == main_color}\n                parts.append((\"%d %s\" % _make_plural(count, key), markup))\n\n        if not parts:\n            parts = [(\"no tests ran\", {_color_for_type_default: True})]\n\n        return parts, main_color", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__get_pos__get_line_with_reprcrash_message.return_line": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__get_pos__get_line_with_reprcrash_message.return_line", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1120, "end_line": 1160, "span_ids": ["_get_line_with_reprcrash_message", "_get_pos"], "tokens": 293}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _get_pos(config, rep):\n    nodeid = config.cwd_relative_nodeid(rep.nodeid)\n    return nodeid\n\n\ndef _get_line_with_reprcrash_message(config, rep, termwidth):\n    \"\"\"Get summary line for a report, trying to add reprcrash message.\"\"\"\n    from wcwidth import wcswidth\n\n    verbose_word = rep._get_verbose_word(config)\n    pos = _get_pos(config, rep)\n\n    line = \"{} {}\".format(verbose_word, pos)\n    len_line = wcswidth(line)\n    ellipsis, len_ellipsis = \"...\", 3\n    if len_line > termwidth - len_ellipsis:\n        # No space for an additional message.\n        return line\n\n    try:\n        msg = rep.longrepr.reprcrash.message\n    except AttributeError:\n        pass\n    else:\n        # Only use the first line.\n        i = msg.find(\"\\n\")\n        if i != -1:\n            msg = msg[:i]\n        len_msg = wcswidth(msg)\n\n        sep, len_sep = \" - \", 3\n        max_len_msg = termwidth - len_line - len_sep\n        if max_len_msg >= len_ellipsis:\n            if len_msg > max_len_msg:\n                max_len_msg -= len_ellipsis\n                msg = msg[:max_len_msg]\n                while wcswidth(msg) > max_len_msg:\n                    msg = msg[:-1]\n                msg += ellipsis\n            line += sep + msg\n    return line", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__folded_skips__folded_skips": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__folded_skips__folded_skips", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1163, "end_line": 1186, "span_ids": ["_folded_skips"], "tokens": 222}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _folded_skips(startdir, skipped):\n    d = {}\n    for event in skipped:\n        assert len(event.longrepr) == 3, (event, event.longrepr)\n        fspath, lineno, reason = event.longrepr\n        # For consistency, report all fspaths in relative form.\n        fspath = startdir.bestrelpath(py.path.local(fspath))\n        keywords = getattr(event, \"keywords\", {})\n        # folding reports with global pytestmark variable\n        # this is workaround, because for now we cannot identify the scope of a skip marker\n        # TODO: revisit after marks scope would be fixed\n        if (\n            event.when == \"setup\"\n            and \"skip\" in keywords\n            and \"pytestmark\" not in keywords\n        ):\n            key = (fspath, None, reason)\n        else:\n            key = (fspath, lineno, reason)\n        d.setdefault(key, []).append(event)\n    values = []\n    for key, events in d.items():\n        values.append((len(events),) + key)\n    return values", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__color_for_type_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/terminal.py__color_for_type_", "embedding": null, "metadata": {"file_path": "src/_pytest/terminal.py", "file_name": "terminal.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1189, "end_line": 1233, "span_ids": ["_make_plural", "_plugin_nameversions", "format_session_duration", "impl:4"], "tokens": 351}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "_color_for_type = {\n    \"failed\": \"red\",\n    \"error\": \"red\",\n    \"warnings\": \"yellow\",\n    \"passed\": \"green\",\n}\n_color_for_type_default = \"yellow\"\n\n\ndef _make_plural(count, noun):\n    # No need to pluralize words such as `failed` or `passed`.\n    if noun not in [\"error\", \"warnings\"]:\n        return count, noun\n\n    # The `warnings` key is plural. To avoid API breakage, we keep it that way but\n    # set it to singular here so we can determine plurality in the same way as we do\n    # for `error`.\n    noun = noun.replace(\"warnings\", \"warning\")\n\n    return count, noun + \"s\" if count != 1 else noun\n\n\ndef _plugin_nameversions(plugininfo) -> List[str]:\n    values = []  # type: List[str]\n    for plugin, dist in plugininfo:\n        # gets us name and version!\n        name = \"{dist.project_name}-{dist.version}\".format(dist=dist)\n        # questionable convenience, but it keeps things short\n        if name.startswith(\"pytest-\"):\n            name = name[7:]\n        # we decided to print python package names\n        # they can have more than one plugin\n        if name not in values:\n            values.append(name)\n    return values\n\n\ndef format_session_duration(seconds: float) -> str:\n    \"\"\"Format the given seconds in a human readable manner to show in the final summary\"\"\"\n    if seconds < 60:\n        return \"{:.2f}s\".format(seconds)\n    else:\n        dt = datetime.timedelta(seconds=int(seconds))\n        return \"{:.2f}s ({})\".format(seconds, dt)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py__support_for_providing_TempPathFactory._ensure_relative_to_basetemp": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py__support_for_providing_TempPathFactory._ensure_relative_to_basetemp", "embedding": null, "metadata": {"file_path": "src/_pytest/tmpdir.py", "file_name": "tmpdir.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 54, "span_ids": ["TempPathFactory", "TempPathFactory._ensure_relative_to_basetemp", "TempPathFactory.from_config", "docstring"], "tokens": 386}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\" support for providing temporary directories to test functions.  \"\"\"\nimport os\nimport re\nimport tempfile\nfrom typing import Optional\n\nimport attr\nimport py\n\nimport pytest\nfrom .pathlib import ensure_reset_dir\nfrom .pathlib import LOCK_TIMEOUT\nfrom .pathlib import make_numbered_dir\nfrom .pathlib import make_numbered_dir_with_cleanup\nfrom .pathlib import Path\nfrom _pytest.fixtures import FixtureRequest\nfrom _pytest.monkeypatch import MonkeyPatch\n\n\n@attr.s\nclass TempPathFactory:\n    \"\"\"Factory for temporary directories under the common base temp directory.\n\n    The base directory can be configured using the ``--basetemp`` option.\"\"\"\n\n    _given_basetemp = attr.ib(\n        type=Path,\n        # using os.path.abspath() to get absolute path instead of resolve() as it\n        # does not work the same in all platforms (see #4427)\n        # Path.absolute() exists, but it is not public (see https://bugs.python.org/issue25012)\n        # Ignore type because of https://github.com/python/mypy/issues/6172.\n        converter=attr.converters.optional(\n            lambda p: Path(os.path.abspath(str(p)))  # type: ignore\n        ),\n    )\n    _trace = attr.ib()\n    _basetemp = attr.ib(type=Optional[Path], default=None)\n\n    @classmethod\n    def from_config(cls, config) -> \"TempPathFactory\":\n        \"\"\"\n        :param config: a pytest configuration\n        \"\"\"\n        return cls(\n            given_basetemp=config.option.basetemp, trace=config.trace.get(\"tmpdir\")\n        )\n\n    def _ensure_relative_to_basetemp(self, basename: str):\n        basename = os.path.normpath(basename)\n        if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():\n            raise ValueError(\n                \"{} is not a normalized and relative path\".format(basename)\n            )\n        return basename", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempPathFactory.mktemp_TempPathFactory.mktemp": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/tmpdir.py_TempPathFactory.mktemp_TempPathFactory.mktemp", "embedding": null, "metadata": {"file_path": "src/_pytest/tmpdir.py", "file_name": "tmpdir.py", "file_type": "text/x-python", "category": "implementation", "start_line": 56, "end_line": 78, "span_ids": ["TempPathFactory.mktemp"], "tokens": 206}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@attr.s\nclass TempPathFactory:\n\n    def mktemp(self, basename: str, numbered: bool = True) -> Path:\n        \"\"\"Creates a new temporary directory managed by the factory.\n\n        :param basename:\n            Directory base name, must be a relative path.\n\n        :param numbered:\n            If ``True``, ensure the directory is unique by adding a numbered\n            suffix greater than any existing one: ``basename=\"foo-\"`` and ``numbered=True``\n            means that this function will create directories named ``\"foo-0\"``,\n            ``\"foo-1\"``, ``\"foo-2\"`` and so on.\n\n        :return:\n            The path to the new directory.\n        \"\"\"\n        basename = self._ensure_relative_to_basetemp(basename)\n        if not numbered:\n            p = self.getbasetemp().joinpath(basename)\n            p.mkdir()\n        else:\n            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)\n            self._trace(\"mktemp\", p)\n        return p", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_TestCaseFunction.addError_TestCaseFunction._expecting_failure": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_TestCaseFunction.addError_TestCaseFunction._expecting_failure", "embedding": null, "metadata": {"file_path": "src/_pytest/unittest.py", "file_name": "unittest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 166, "end_line": 206, "span_ids": ["TestCaseFunction._expecting_failure", "TestCaseFunction.addError", "TestCaseFunction.addExpectedFailure", "TestCaseFunction.addFailure", "TestCaseFunction.addSkip", "TestCaseFunction.addSuccess", "TestCaseFunction.addUnexpectedSuccess", "TestCaseFunction.stopTest"], "tokens": 287}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaseFunction(Function):\n\n    def addError(self, testcase, rawexcinfo):\n        try:\n            if isinstance(rawexcinfo[1], exit.Exception):\n                exit(rawexcinfo[1].msg)\n        except TypeError:\n            pass\n        self._addexcinfo(rawexcinfo)\n\n    def addFailure(self, testcase, rawexcinfo):\n        self._addexcinfo(rawexcinfo)\n\n    def addSkip(self, testcase, reason):\n        try:\n            skip(reason)\n        except skip.Exception:\n            self._store[skipped_by_mark_key] = True\n            self._addexcinfo(sys.exc_info())\n\n    def addExpectedFailure(self, testcase, rawexcinfo, reason=\"\"):\n        try:\n            xfail(str(reason))\n        except xfail.Exception:\n            self._addexcinfo(sys.exc_info())\n\n    def addUnexpectedSuccess(self, testcase, reason=\"\"):\n        self._store[unexpectedsuccess_key] = reason\n\n    def addSuccess(self, testcase):\n        pass\n\n    def stopTest(self, testcase):\n        pass\n\n    def _expecting_failure(self, test_method) -> bool:\n        \"\"\"Return True if the given unittest method (or the entire class) is marked\n        with @expectedFailure\"\"\"\n        expecting_failure_method = getattr(\n            test_method, \"__unittest_expecting_failure__\", False\n        )\n        expecting_failure_class = getattr(self, \"__unittest_expecting_failure__\", False)\n        return bool(expecting_failure_class or expecting_failure_method)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_TestCaseFunction.runtest_TestCaseFunction._prunetraceback": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/unittest.py_TestCaseFunction.runtest_TestCaseFunction._prunetraceback", "embedding": null, "metadata": {"file_path": "src/_pytest/unittest.py", "file_name": "unittest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 208, "end_line": 241, "span_ids": ["TestCaseFunction._prunetraceback", "TestCaseFunction.runtest"], "tokens": 310}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaseFunction(Function):\n\n    def runtest(self):\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # let the unittest framework handle async functions\n        if is_async_function(self.obj):\n            self._testcase(self)\n        else:\n            # when --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug\n            # arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed\n            if self.config.getoption(\"usepdb\"):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # we need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)\n            finally:\n                delattr(self._testcase, self.name)\n\n    def _prunetraceback(self, excinfo):\n        Function._prunetraceback(self, excinfo)\n        traceback = excinfo.traceback.filter(\n            lambda x: not x.frame.f_globals.get(\"__unittest\")\n        )\n        if traceback:\n            excinfo.traceback = traceback", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warning_types.py_from_typing_import_Any_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warning_types.py_from_typing_import_Any_", "embedding": null, "metadata": {"file_path": "src/_pytest/warning_types.py", "file_name": "warning_types.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 107, "span_ids": ["PytestAssertRewriteWarning", "PytestCacheWarning", "PytestCollectionWarning", "PytestConfigWarning", "PytestDeprecationWarning", "PytestExperimentalApiWarning", "PytestExperimentalApiWarning.simple", "PytestUnhandledCoroutineWarning", "PytestUnknownMarkWarning", "PytestWarning", "UnformattedWarning", "UnformattedWarning.format", "impl:2", "impl:3", "imports"], "tokens": 563}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\n\nimport attr\n\nfrom _pytest.compat import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Type  # noqa: F401 (used in type string)\n\n\nclass PytestWarning(UserWarning):\n    \"\"\"Base class for all warnings emitted by pytest.\"\"\"\n\n    __module__ = \"pytest\"\n\n\nclass PytestAssertRewriteWarning(PytestWarning):\n    \"\"\"Warning emitted by the pytest assert rewrite module.\"\"\"\n\n    __module__ = \"pytest\"\n\n\nclass PytestCacheWarning(PytestWarning):\n    \"\"\"Warning emitted by the cache plugin in various situations.\"\"\"\n\n    __module__ = \"pytest\"\n\n\nclass PytestConfigWarning(PytestWarning):\n    \"\"\"Warning emitted for configuration issues.\"\"\"\n\n    __module__ = \"pytest\"\n\n\nclass PytestCollectionWarning(PytestWarning):\n    \"\"\"Warning emitted when pytest is not able to collect a file or symbol in a module.\"\"\"\n\n    __module__ = \"pytest\"\n\n\nclass PytestDeprecationWarning(PytestWarning, DeprecationWarning):\n    \"\"\"Warning class for features that will be removed in a future version.\"\"\"\n\n    __module__ = \"pytest\"\n\n\nclass PytestExperimentalApiWarning(PytestWarning, FutureWarning):\n    \"\"\"Warning category used to denote experiments in pytest.\n\n    Use sparingly as the API might change or even be removed completely in a\n    future version.\n    \"\"\"\n\n    __module__ = \"pytest\"\n\n    @classmethod\n    def simple(cls, apiname: str) -> \"PytestExperimentalApiWarning\":\n        return cls(\n            \"{apiname} is an experimental api that may change over time\".format(\n                apiname=apiname\n            )\n        )\n\n\nclass PytestUnhandledCoroutineWarning(PytestWarning):\n    \"\"\"Warning emitted for an unhandled coroutine.\n\n    A coroutine was encountered when collecting test functions, but was not\n    handled by any async-aware plugin.\n    Coroutine test functions are not natively supported.\n    \"\"\"\n\n    __module__ = \"pytest\"\n\n\nclass PytestUnknownMarkWarning(PytestWarning):\n    \"\"\"Warning emitted on use of unknown markers.\n\n    See https://docs.pytest.org/en/latest/mark.html for details.\n    \"\"\"\n\n    __module__ = \"pytest\"\n\n\n_W = TypeVar(\"_W\", bound=PytestWarning)\n\n\n@attr.s\nclass UnformattedWarning(Generic[_W]):\n    \"\"\"A warning meant to be formatted during runtime.\n\n    This is used to hold warnings that need to format their message at runtime,\n    as opposed to a direct message.\n    \"\"\"\n\n    category = attr.ib(type=\"Type[_W]\")\n    template = attr.ib(type=str)\n\n    def format(self, **kwargs: Any) -> _W:\n        \"\"\"Returns an instance of the warning category, formatted with given kwargs\"\"\"\n        return self.category(self.template.format(**kwargs))\n\n\nPYTESTER_COPY_EXAMPLE = PytestExperimentalApiWarning.simple(\"testdir.copy_example\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_re__parse_filter.return_action_message_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_re__parse_filter.return_action_message_", "embedding": null, "metadata": {"file_path": "src/_pytest/warnings.py", "file_name": "warnings.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 49, "span_ids": ["_parse_filter", "imports"], "tokens": 345}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import re\nimport sys\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import lru_cache\nfrom typing import Generator\nfrom typing import Tuple\n\nimport pytest\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.main import Session\n\nif TYPE_CHECKING:\n    from typing_extensions import Type\n\n\n@lru_cache(maxsize=50)\ndef _parse_filter(\n    arg: str, *, escape: bool\n) -> \"Tuple[str, str, Type[Warning], str, int]\":\n    \"\"\"Parse a warnings filter string.\n\n    This is copied from warnings._setoption, but does not apply the filter,\n    only parses it, and makes the escaping optional.\n    \"\"\"\n    parts = arg.split(\":\")\n    if len(parts) > 5:\n        raise warnings._OptionError(\"too many fields (max 5): {!r}\".format(arg))\n    while len(parts) < 5:\n        parts.append(\"\")\n    action_, message, category_, module, lineno_ = [s.strip() for s in parts]\n    action = warnings._getaction(action_)  # type: str # type: ignore[attr-defined]\n    category = warnings._getcategory(\n        category_\n    )  # type: Type[Warning] # type: ignore[attr-defined]\n    if message and escape:\n        message = re.escape(message)\n    if module and escape:\n        module = re.escape(module) + r\"\\Z\"\n    if lineno_:\n        try:\n            lineno = int(lineno_)\n            if lineno < 0:\n                raise ValueError\n        except (ValueError, OverflowError):\n            raise warnings._OptionError(\"invalid lineno {!r}\".format(lineno_))\n    else:\n        lineno = 0\n    return (action, message, category, module, lineno)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_pytest_addoption_catch_warnings_for_item.with_warnings_catch_warni.for_warning_message_in_lo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_pytest_addoption_catch_warnings_for_item.with_warnings_catch_warni.for_warning_message_in_lo", "embedding": null, "metadata": {"file_path": "src/_pytest/warnings.py", "file_name": "warnings.py", "file_type": "text/x-python", "category": "implementation", "start_line": 52, "end_line": 115, "span_ids": ["catch_warnings_for_item", "pytest_addoption", "pytest_configure"], "tokens": 477}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def pytest_addoption(parser):\n    group = parser.getgroup(\"pytest-warnings\")\n    group.addoption(\n        \"-W\",\n        \"--pythonwarnings\",\n        action=\"append\",\n        help=\"set which warnings to report, see -W option of python itself.\",\n    )\n    parser.addini(\n        \"filterwarnings\",\n        type=\"linelist\",\n        help=\"Each line specifies a pattern for \"\n        \"warnings.filterwarnings. \"\n        \"Processed after -W/--pythonwarnings.\",\n    )\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\",\n        \"filterwarnings(warning): add a warning filter to the given test. \"\n        \"see https://docs.pytest.org/en/latest/warnings.html#pytest-mark-filterwarnings \",\n    )\n\n\n@contextmanager\ndef catch_warnings_for_item(config, ihook, when, item):\n    \"\"\"\n    Context manager that catches warnings generated in the contained execution block.\n\n    ``item`` can be None if we are not in the context of an item execution.\n\n    Each warning captured triggers the ``pytest_warning_captured`` hook.\n    \"\"\"\n    cmdline_filters = config.getoption(\"pythonwarnings\") or []\n    inifilters = config.getini(\"filterwarnings\")\n    with warnings.catch_warnings(record=True) as log:\n        # mypy can't infer that record=True means log is not None; help it.\n        assert log is not None\n\n        if not sys.warnoptions:\n            # if user is not explicitly configuring warning filters, show deprecation warnings by default (#2908)\n            warnings.filterwarnings(\"always\", category=DeprecationWarning)\n            warnings.filterwarnings(\"always\", category=PendingDeprecationWarning)\n\n        # filters should have this precedence: mark, cmdline options, ini\n        # filters should be applied in the inverse order of precedence\n        for arg in inifilters:\n            warnings.filterwarnings(*_parse_filter(arg, escape=False))\n\n        for arg in cmdline_filters:\n            warnings.filterwarnings(*_parse_filter(arg, escape=True))\n\n        if item is not None:\n            for mark in item.iter_markers(name=\"filterwarnings\"):\n                for arg in mark.args:\n                    warnings.filterwarnings(*_parse_filter(arg, escape=False))\n\n        yield\n\n        for warning_message in log:\n            ihook.pytest_warning_captured.call_historic(\n                kwargs=dict(warning_message=warning_message, when=when, item=item)\n            )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_warning_record_to_str_pytest_sessionfinish": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py_warning_record_to_str_pytest_sessionfinish", "embedding": null, "metadata": {"file_path": "src/_pytest/warnings.py", "file_name": "warnings.py", "file_type": "text/x-python", "category": "implementation", "start_line": 118, "end_line": 163, "span_ids": ["pytest_collection", "pytest_runtest_protocol", "pytest_sessionfinish", "pytest_terminal_summary", "warning_record_to_str"], "tokens": 282}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def warning_record_to_str(warning_message):\n    \"\"\"Convert a warnings.WarningMessage to a string.\"\"\"\n    warn_msg = warning_message.message\n    msg = warnings.formatwarning(\n        warn_msg,\n        warning_message.category,\n        warning_message.filename,\n        warning_message.lineno,\n        warning_message.line,\n    )\n    return msg\n\n\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_runtest_protocol(item):\n    with catch_warnings_for_item(\n        config=item.config, ihook=item.ihook, when=\"runtest\", item=item\n    ):\n        yield\n\n\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_collection(session: Session) -> Generator[None, None, None]:\n    config = session.config\n    with catch_warnings_for_item(\n        config=config, ihook=config.hook, when=\"collect\", item=None\n    ):\n        yield\n\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_terminal_summary(terminalreporter):\n    config = terminalreporter.config\n    with catch_warnings_for_item(\n        config=config, ihook=config.hook, when=\"config\", item=None\n    ):\n        yield\n\n\n@pytest.hookimpl(hookwrapper=True)\ndef pytest_sessionfinish(session):\n    config = session.config\n    with catch_warnings_for_item(\n        config=config, ihook=config.hook, when=\"config\", item=None\n    ):\n        yield", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py__issue_warning_captured_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/_pytest/warnings.py__issue_warning_captured_", "embedding": null, "metadata": {"file_path": "src/_pytest/warnings.py", "file_name": "warnings.py", "file_type": "text/x-python", "category": "implementation", "start_line": 166, "end_line": 188, "span_ids": ["_issue_warning_captured"], "tokens": 252}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def _issue_warning_captured(warning, hook, stacklevel):\n    \"\"\"\n    This function should be used instead of calling ``warnings.warn`` directly when we are in the \"configure\" stage:\n    at this point the actual options might not have been set, so we manually trigger the pytest_warning_captured\n    hook so we can display these warnings in the terminal. This is a hack until we can sort out #2891.\n\n    :param warning: the warning instance.\n    :param hook: the hook caller\n    :param stacklevel: stacklevel forwarded to warnings.warn\n    \"\"\"\n    with warnings.catch_warnings(record=True) as records:\n        warnings.simplefilter(\"always\", type(warning))\n        warnings.warn(warning, stacklevel=stacklevel)\n    # Mypy can't infer that record=True means records is not None; help it.\n    assert records is not None\n    frame = sys._getframe(stacklevel - 1)\n    location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n    hook.pytest_warning_captured.call_historic(\n        kwargs=dict(\n            warning_message=records[0], when=\"config\", item=None, location=location\n        )\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/__init__.py__PYTHON_ARGCOMPLETE_OK_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/__init__.py__PYTHON_ARGCOMPLETE_OK_", "embedding": null, "metadata": {"file_path": "src/pytest/__init__.py", "file_name": "__init__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 100, "span_ids": ["docstring"], "tokens": 625}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# PYTHON_ARGCOMPLETE_OK\n\"\"\"\npytest: unit and functional testing with Python.\n\"\"\"\nfrom . import collect\nfrom _pytest import __version__\nfrom _pytest.assertion import register_assert_rewrite\nfrom _pytest.config import cmdline\nfrom _pytest.config import console_main\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import hookspec\nfrom _pytest.config import main\nfrom _pytest.config import UsageError\nfrom _pytest.debugging import pytestPDB as __pytestPDB\nfrom _pytest.fixtures import fillfixtures as _fillfuncargs\nfrom _pytest.fixtures import fixture\nfrom _pytest.fixtures import FixtureLookupError\nfrom _pytest.fixtures import yield_fixture\nfrom _pytest.freeze_support import freeze_includes\nfrom _pytest.main import Session\nfrom _pytest.mark import MARK_GEN as mark\nfrom _pytest.mark import param\nfrom _pytest.nodes import Collector\nfrom _pytest.nodes import File\nfrom _pytest.nodes import Item\nfrom _pytest.outcomes import exit\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import importorskip\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.python import Class\nfrom _pytest.python import Function\nfrom _pytest.python import Instance\nfrom _pytest.python import Module\nfrom _pytest.python import Package\nfrom _pytest.python_api import approx\nfrom _pytest.python_api import raises\nfrom _pytest.recwarn import deprecated_call\nfrom _pytest.recwarn import warns\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom _pytest.warning_types import PytestCacheWarning\nfrom _pytest.warning_types import PytestCollectionWarning\nfrom _pytest.warning_types import PytestConfigWarning\nfrom _pytest.warning_types import PytestDeprecationWarning\nfrom _pytest.warning_types import PytestExperimentalApiWarning\nfrom _pytest.warning_types import PytestUnhandledCoroutineWarning\nfrom _pytest.warning_types import PytestUnknownMarkWarning\nfrom _pytest.warning_types import PytestWarning\n\nset_trace = __pytestPDB.set_trace\n\n__all__ = [\n    \"__version__\",\n    \"_fillfuncargs\",\n    \"approx\",\n    \"Class\",\n    \"cmdline\",\n    \"collect\",\n    \"Collector\",\n    \"console_main\",\n    \"deprecated_call\",\n    \"exit\",\n    \"ExitCode\",\n    \"fail\",\n    \"File\",\n    \"fixture\",\n    \"FixtureLookupError\",\n    \"freeze_includes\",\n    \"Function\",\n    \"hookimpl\",\n    \"hookspec\",\n    \"importorskip\",\n    \"Instance\",\n    \"Item\",\n    \"main\",\n    \"mark\",\n    \"Module\",\n    \"Package\",\n    \"param\",\n    \"PytestAssertRewriteWarning\",\n    \"PytestCacheWarning\",\n    \"PytestCollectionWarning\",\n    \"PytestConfigWarning\",\n    \"PytestDeprecationWarning\",\n    \"PytestExperimentalApiWarning\",\n    \"PytestUnhandledCoroutineWarning\",\n    \"PytestUnknownMarkWarning\",\n    \"PytestWarning\",\n    \"raises\",\n    \"register_assert_rewrite\",\n    \"Session\",\n    \"set_trace\",\n    \"skip\",\n    \"UsageError\",\n    \"warns\",\n    \"xfail\",\n    \"yield_fixture\",\n]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/__main__.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/__main__.py__", "embedding": null, "metadata": {"file_path": "src/pytest/__main__.py", "file_name": "__main__.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 8, "span_ids": ["docstring"], "tokens": 25}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\npytest entry point\n\"\"\"\nimport pytest\n\nif __name__ == \"__main__\":\n    raise SystemExit(pytest.console_main())", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/collect.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/src/pytest/collect.py__", "embedding": null, "metadata": {"file_path": "src/pytest/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 39, "span_ids": ["FakeCollectModule", "FakeCollectModule.__dir__", "FakeCollectModule.__getattr__", "FakeCollectModule.__init__", "impl:2", "imports"], "tokens": 189}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\nimport warnings\nfrom types import ModuleType\n\nimport pytest\nfrom _pytest.deprecated import PYTEST_COLLECT_MODULE\n\n\nCOLLECT_FAKEMODULE_ATTRIBUTES = [\n    \"Collector\",\n    \"Module\",\n    \"Function\",\n    \"Instance\",\n    \"Session\",\n    \"Item\",\n    \"Class\",\n    \"File\",\n    \"_fillfuncargs\",\n]\n\n\nclass FakeCollectModule(ModuleType):\n    def __init__(self):\n        super().__init__(\"pytest.collect\")\n        self.__all__ = list(COLLECT_FAKEMODULE_ATTRIBUTES)\n        self.__pytest = pytest\n\n    def __dir__(self):\n        return dir(super()) + self.__all__\n\n    def __getattr__(self, name):\n        if name not in self.__all__:\n            raise AttributeError(name)\n        warnings.warn(PYTEST_COLLECT_MODULE.format(name=name), stacklevel=2)\n        return getattr(pytest, name)\n\n\nsys.modules[\"pytest.collect\"] = FakeCollectModule()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_better_reporting_on_conftest_load_failure_TestGeneralUsage.test_better_reporting_on_conftest_load_failure.assert_result_stderr_line": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestGeneralUsage.test_better_reporting_on_conftest_load_failure_TestGeneralUsage.test_better_reporting_on_conftest_load_failure.assert_result_stderr_line", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 195, "end_line": 225, "span_ids": ["TestGeneralUsage.test_better_reporting_on_conftest_load_failure"], "tokens": 233}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGeneralUsage:\n\n    @pytest.mark.filterwarnings(\"default\")\n    def test_better_reporting_on_conftest_load_failure(self, testdir):\n        \"\"\"Show a user-friendly traceback on conftest import failures (#486, #3332)\"\"\"\n        testdir.makepyfile(\"\")\n        conftest = testdir.makeconftest(\n            \"\"\"\n            def foo():\n                import qwerty\n            foo()\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--help\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *--version*\n            *warning*conftest.py*\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        exc_name = (\n            \"ModuleNotFoundError\" if sys.version_info >= (3, 6) else \"ImportError\"\n        )\n        assert result.stdout.lines == []\n        assert result.stderr.lines == [\n            \"ImportError while loading conftest '{}'.\".format(conftest),\n            \"conftest.py:3: in <module>\",\n            \"    foo()\",\n            \"conftest.py:2: in foo\",\n            \"    import qwerty\",\n            \"E   {}: No module named 'qwerty'\".format(exc_name),\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_not_exists_fake_time": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestInvocationVariants.test_cmdline_python_package_not_exists_fake_time", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 839, "end_line": 911, "span_ids": ["TestInvocationVariants.test_cmdline_python_package_not_exists", "TestInvocationVariants.test_core_backward_compatibility", "TestInvocationVariants.test_doctest_id", "TestInvocationVariants.test_has_plugin", "TestInvocationVariants.test_noclass_discovery_if_not_testcase", "fake_time"], "tokens": 575}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestInvocationVariants:\n\n    def test_cmdline_python_package_not_exists(self, testdir):\n        result = testdir.runpytest(\"--pyargs\", \"tpkgwhatv\")\n        assert result.ret\n        result.stderr.fnmatch_lines([\"ERROR*file*or*package*not*found*\"])\n\n    @pytest.mark.xfail(reason=\"decide: feature or bug\")\n    def test_noclass_discovery_if_not_testcase(self, testdir):\n        testpath = testdir.makepyfile(\n            \"\"\"\n            import unittest\n            class TestHello(object):\n                def test_hello(self):\n                    assert self.attr\n\n            class RealTest(unittest.TestCase, TestHello):\n                attr = 42\n        \"\"\"\n        )\n        reprec = testdir.inline_run(testpath)\n        reprec.assertoutcome(passed=1)\n\n    def test_doctest_id(self, testdir):\n        testdir.makefile(\n            \".txt\",\n            \"\"\"\n            >>> x=3\n            >>> x\n            4\n        \"\"\",\n        )\n        testid = \"test_doctest_id.txt::test_doctest_id.txt\"\n        expected_lines = [\n            \"*= FAILURES =*\",\n            \"*_ ?doctest? test_doctest_id.txt _*\",\n            \"FAILED test_doctest_id.txt::test_doctest_id.txt\",\n            \"*= 1 failed in*\",\n        ]\n        result = testdir.runpytest(testid, \"-rf\", \"--tb=short\")\n        result.stdout.fnmatch_lines(expected_lines)\n\n        # Ensure that re-running it will still handle it as\n        # doctest.DocTestFailure, which was not the case before when\n        # re-importing doctest, but not creating a new RUNNER_CLASS.\n        result = testdir.runpytest(testid, \"-rf\", \"--tb=short\")\n        result.stdout.fnmatch_lines(expected_lines)\n\n    def test_core_backward_compatibility(self):\n        \"\"\"Test backward compatibility for get_plugin_manager function. See #787.\"\"\"\n        import _pytest.config\n\n        assert (\n            type(_pytest.config.get_plugin_manager())\n            is _pytest.config.PytestPluginManager\n        )\n\n    def test_has_plugin(self, request):\n        \"\"\"Test hasplugin function of the plugin manager (#932).\"\"\"\n        assert request.config.pluginmanager.hasplugin(\"python\")\n\n\ndef fake_time(monkeypatch: MonkeyPatch) -> None:\n    \"\"\"Monkeypatch time functions to make TestDurations not rely on actual time.\"\"\"\n    import time\n\n    current_time = 1586202699.9859412\n\n    def sleep(seconds: float) -> None:\n        nonlocal current_time\n        current_time += seconds\n\n    monkeypatch.setattr(time, \"sleep\", sleep)\n    monkeypatch.setattr(_pytest.runner, \"time\", lambda: current_time)\n    monkeypatch.setattr(_pytest.runner, \"perf_counter\", lambda: current_time)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestDurationsWithFixture_test_deferred_hook_checking.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_TestDurationsWithFixture_test_deferred_hook_checking.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1006, "end_line": 1104, "span_ids": ["TestDurationsWithFixture", "TestDurationsWithFixture.test_setup_function", "test_deferred_hook_checking", "test_import_plugin_unicode_name", "test_pytest_plugins_as_module", "test_zipimport_hook"], "tokens": 648}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDurationsWithFixture:\n    source = \"\"\"\n        import pytest\n        import time\n\n        @pytest.fixture\n        def setup_fixt():\n            time.sleep(0.02)\n\n        def test_1(setup_fixt):\n            time.sleep(0.02)\n    \"\"\"\n\n    def test_setup_function(self, testdir):\n        testdir.makepyfile(self.source)\n        fake_time(testdir.monkeypatch)\n        result = testdir.runpytest_inprocess(\"--durations=10\")\n        assert result.ret == 0\n\n        result.stdout.fnmatch_lines_random(\n            \"\"\"\n            *durations*\n            * setup *test_1*\n            * call *test_1*\n        \"\"\"\n        )\n\n\ndef test_zipimport_hook(testdir, tmpdir):\n    \"\"\"Test package loader is being used correctly (see #1837).\"\"\"\n    zipapp = pytest.importorskip(\"zipapp\")\n    testdir.tmpdir.join(\"app\").ensure(dir=1)\n    testdir.makepyfile(\n        **{\n            \"app/foo.py\": \"\"\"\n            import pytest\n            def main():\n                pytest.main(['--pyargs', 'foo'])\n        \"\"\"\n        }\n    )\n    target = tmpdir.join(\"foo.zip\")\n    zipapp.create_archive(str(testdir.tmpdir.join(\"app\")), str(target), main=\"foo:main\")\n    result = testdir.runpython(target)\n    assert result.ret == 0\n    result.stderr.fnmatch_lines([\"*not found*foo*\"])\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR>*\")\n\n\ndef test_import_plugin_unicode_name(testdir):\n    testdir.makepyfile(myplugin=\"\")\n    testdir.makepyfile(\"def test(): pass\")\n    testdir.makeconftest(\"pytest_plugins = ['myplugin']\")\n    r = testdir.runpytest()\n    assert r.ret == 0\n\n\ndef test_pytest_plugins_as_module(testdir):\n    \"\"\"Do not raise an error if pytest_plugins attribute is a module (#3899)\"\"\"\n    testdir.makepyfile(\n        **{\n            \"__init__.py\": \"\",\n            \"pytest_plugins.py\": \"\",\n            \"conftest.py\": \"from . import pytest_plugins\",\n            \"test_foo.py\": \"def test(): pass\",\n        }\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n\n\ndef test_deferred_hook_checking(testdir):\n    \"\"\"\n    Check hooks as late as possible (#1821).\n    \"\"\"\n    testdir.syspathinsert()\n    testdir.makepyfile(\n        **{\n            \"plugin.py\": \"\"\"\n        class Hooks(object):\n            def pytest_my_hook(self, config):\n                pass\n\n        def pytest_configure(config):\n            config.pluginmanager.add_hookspecs(Hooks)\n        \"\"\",\n            \"conftest.py\": \"\"\"\n            pytest_plugins = ['plugin']\n            def pytest_my_hook(config):\n                return 40\n        \"\"\",\n            \"test_foo.py\": \"\"\"\n            def test(request):\n                assert request.config.hook.pytest_my_hook(config=request.config) == [40]\n        \"\"\",\n        }\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"* 1 passed *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_fixture_order_respects_scope_test_warn_on_async_function.assert_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_fixture_order_respects_scope_test_warn_on_async_function.assert_", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1155, "end_line": 1250, "span_ids": ["test_fixture_mock_integration", "test_fixture_order_respects_scope", "test_frame_leak_on_failing_test", "test_usage_error_code", "test_warn_on_async_function"], "tokens": 564}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fixture_order_respects_scope(testdir):\n    \"\"\"Ensure that fixtures are created according to scope order, regression test for #2405\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        data = {}\n\n        @pytest.fixture(scope='module')\n        def clean_data():\n            data.clear()\n\n        @pytest.fixture(autouse=True)\n        def add_data():\n            data.update(value=True)\n\n        @pytest.mark.usefixtures('clean_data')\n        def test_value():\n            assert data.get('value')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 0\n\n\ndef test_frame_leak_on_failing_test(testdir):\n    \"\"\"pytest would leak garbage referencing the frames of tests that failed that could never be reclaimed (#2798)\n\n    Unfortunately it was not possible to remove the actual circles because most of them\n    are made of traceback objects which cannot be weakly referenced. Those objects at least\n    can be eventually claimed by the garbage collector.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import gc\n        import weakref\n\n        class Obj:\n            pass\n\n        ref = None\n\n        def test1():\n            obj = Obj()\n            global ref\n            ref = weakref.ref(obj)\n            assert 0\n\n        def test2():\n            gc.collect()\n            assert ref() is None\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess()\n    result.stdout.fnmatch_lines([\"*1 failed, 1 passed in*\"])\n\n\ndef test_fixture_mock_integration(testdir):\n    \"\"\"Test that decorators applied to fixture are left working (#3774)\"\"\"\n    p = testdir.copy_example(\"acceptance/fixture_mock_integration.py\")\n    result = testdir.runpytest(p)\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\ndef test_usage_error_code(testdir):\n    result = testdir.runpytest(\"-unknown-option-\")\n    assert result.ret == ExitCode.USAGE_ERROR\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_warn_on_async_function(testdir):\n    testdir.makepyfile(\n        test_async=\"\"\"\n        async def test_1():\n            pass\n        async def test_2():\n            pass\n        def test_3():\n            return test_2()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"test_async.py::test_1\",\n            \"test_async.py::test_2\",\n            \"test_async.py::test_3\",\n            \"*async def functions are not natively supported*\",\n            \"*3 skipped, 3 warnings in*\",\n        ]\n    )\n    # ensure our warning message appears only once\n    assert (\n        result.stdout.str().count(\"async def functions are not natively supported\") == 1\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_warn_on_async_gen_function_test_pdb_can_be_rewritten.assert_result_ret_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_warn_on_async_gen_function_test_pdb_can_be_rewritten.assert_result_ret_1", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1253, "end_line": 1318, "span_ids": ["test_pdb_can_be_rewritten", "test_warn_on_async_gen_function"], "tokens": 424}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"default\")\n@pytest.mark.skipif(\n    sys.version_info < (3, 6), reason=\"async gen syntax available in Python 3.6+\"\n)\ndef test_warn_on_async_gen_function(testdir):\n    testdir.makepyfile(\n        test_async=\"\"\"\n        async def test_1():\n            yield\n        async def test_2():\n            yield\n        def test_3():\n            return test_2()\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"test_async.py::test_1\",\n            \"test_async.py::test_2\",\n            \"test_async.py::test_3\",\n            \"*async def functions are not natively supported*\",\n            \"*3 skipped, 3 warnings in*\",\n        ]\n    )\n    # ensure our warning message appears only once\n    assert (\n        result.stdout.str().count(\"async def functions are not natively supported\") == 1\n    )\n\n\ndef test_pdb_can_be_rewritten(testdir):\n    testdir.makepyfile(\n        **{\n            \"conftest.py\": \"\"\"\n                import pytest\n                pytest.register_assert_rewrite(\"pdb\")\n                \"\"\",\n            \"__init__.py\": \"\",\n            \"pdb.py\": \"\"\"\n                def check():\n                    assert 1 == 2\n                \"\"\",\n            \"test_pdb.py\": \"\"\"\n                def test():\n                    import pdb\n                    assert pdb.check()\n                \"\"\",\n        }\n    )\n    # Disable debugging plugin itself to avoid:\n    # > INTERNALERROR> AttributeError: module 'pdb' has no attribute 'set_trace'\n    result = testdir.runpytest_subprocess(\"-p\", \"no:debugging\", \"-vv\")\n    result.stdout.fnmatch_lines(\n        [\n            \"    def check():\",\n            \">       assert 1 == 2\",\n            \"E       assert 1 == 2\",\n            \"E         +1\",\n            \"E         -2\",\n            \"\",\n            \"pdb.py:2: AssertionError\",\n            \"*= 1 failed in *\",\n        ]\n    )\n    assert result.ret == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_tee_stdio_captures_and_live_prints_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/acceptance_test.py_test_tee_stdio_captures_and_live_prints_", "embedding": null, "metadata": {"file_path": "testing/acceptance_test.py", "file_name": "acceptance_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1321, "end_line": 1365, "span_ids": ["test_no_brokenpipeerror_message", "test_tee_stdio_captures_and_live_prints"], "tokens": 356}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_tee_stdio_captures_and_live_prints(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import sys\n        def test_simple():\n            print (\"@this is stdout@\")\n            print (\"@this is stderr@\", file=sys.stderr)\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess(\n        testpath,\n        \"--capture=tee-sys\",\n        \"--junitxml=output.xml\",\n        \"-o\",\n        \"junit_logging=all\",\n    )\n\n    # ensure stdout/stderr were 'live printed'\n    result.stdout.fnmatch_lines([\"*@this is stdout@*\"])\n    result.stderr.fnmatch_lines([\"*@this is stderr@*\"])\n\n    # now ensure the output is in the junitxml\n    with open(os.path.join(testdir.tmpdir.strpath, \"output.xml\")) as f:\n        fullXml = f.read()\n    assert \"@this is stdout@\\n\" in fullXml\n    assert \"@this is stderr@\\n\" in fullXml\n\n\n@pytest.mark.skipif(\n    sys.platform == \"win32\",\n    reason=\"Windows raises `OSError: [Errno 22] Invalid argument` instead\",\n)\ndef test_no_brokenpipeerror_message(testdir: Testdir) -> None:\n    \"\"\"Ensure that the broken pipe error message is supressed.\n\n    In some Python versions, it reaches sys.unraisablehook, in others\n    a BrokenPipeError exception is propagated, but either way it prints\n    to stderr on shutdown, so checking nothing is printed is enough.\n    \"\"\"\n    popen = testdir.popen((*testdir._getpytestargs(), \"--help\"))\n    popen.stdout.close()\n    ret = popen.wait()\n    assert popen.stderr.read() == b\"\"\n    assert ret == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_io_h": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_io_h", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 94, "span_ids": ["f", "g", "h", "impl:2", "imports", "limited_recursion_depth", "test_excinfo_from_exc_info_simple", "test_excinfo_getstatement", "test_excinfo_simple"], "tokens": 453}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import io\nimport operator\nimport os\nimport queue\nimport sys\nimport textwrap\nfrom typing import Union\n\nimport py\n\nimport _pytest\nimport pytest\nfrom _pytest._code.code import ExceptionChainRepr\nfrom _pytest._code.code import ExceptionInfo\nfrom _pytest._code.code import FormattedExcinfo\nfrom _pytest._io import TerminalWriter\nfrom _pytest.pytester import LineMatcher\n\ntry:\n    import importlib\nexcept ImportError:\n    invalidate_import_caches = None\nelse:\n    invalidate_import_caches = getattr(importlib, \"invalidate_caches\", None)\n\n\n@pytest.fixture\ndef limited_recursion_depth():\n    before = sys.getrecursionlimit()\n    sys.setrecursionlimit(150)\n    yield\n    sys.setrecursionlimit(before)\n\n\ndef test_excinfo_simple() -> None:\n    try:\n        raise ValueError\n    except ValueError:\n        info = _pytest._code.ExceptionInfo.from_current()\n    assert info.type == ValueError\n\n\ndef test_excinfo_from_exc_info_simple():\n    try:\n        raise ValueError\n    except ValueError as e:\n        info = _pytest._code.ExceptionInfo.from_exc_info((type(e), e, e.__traceback__))\n    assert info.type == ValueError\n\n\ndef test_excinfo_getstatement():\n    def g():\n        raise ValueError\n\n    def f():\n        g()\n\n    try:\n        f()\n    except ValueError:\n        excinfo = _pytest._code.ExceptionInfo.from_current()\n    linenumbers = [\n        f.__code__.co_firstlineno - 1 + 4,\n        f.__code__.co_firstlineno - 1 + 1,\n        g.__code__.co_firstlineno - 1 + 1,\n    ]\n    values = list(excinfo.traceback)\n    foundlinenumbers = [x.lineno for x in values]\n    assert foundlinenumbers == linenumbers\n    # for x in info:\n    #    print \"%s:%d  %s\" %(x.path.relto(root), x.lineno, x.statement)\n    # xxx\n\n\n# testchain for getentries test below\n\n\ndef f():\n    #\n    raise ValueError\n    #\n\n\ndef g():\n    #\n    __tracebackhide__ = True\n    f()\n    #\n\n\ndef h():\n    #\n    g()\n    #", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_test_excinfo_exconly_test_match_raises_error": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_test_excinfo_exconly_test_match_raises_error", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 310, "end_line": 424, "span_ids": ["test_codepath_Queue_example", "test_entrysource_Queue_example", "test_excinfo_errisinstance", "test_excinfo_exconly", "test_excinfo_for_later", "test_excinfo_no_python_sourcecode", "test_excinfo_no_sourcecode", "test_excinfo_repr_str", "test_match_raises_error", "test_match_succeeds"], "tokens": 868}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_excinfo_exconly():\n    excinfo = pytest.raises(ValueError, h)\n    assert excinfo.exconly().startswith(\"ValueError\")\n    with pytest.raises(ValueError) as excinfo:\n        raise ValueError(\"hello\\nworld\")\n    msg = excinfo.exconly(tryshort=True)\n    assert msg.startswith(\"ValueError\")\n    assert msg.endswith(\"world\")\n\n\ndef test_excinfo_repr_str():\n    excinfo = pytest.raises(ValueError, h)\n    assert repr(excinfo) == \"<ExceptionInfo ValueError() tblen=4>\"\n    assert str(excinfo) == \"<ExceptionInfo ValueError() tblen=4>\"\n\n    class CustomException(Exception):\n        def __repr__(self):\n            return \"custom_repr\"\n\n    def raises():\n        raise CustomException()\n\n    excinfo = pytest.raises(CustomException, raises)\n    assert repr(excinfo) == \"<ExceptionInfo custom_repr tblen=2>\"\n    assert str(excinfo) == \"<ExceptionInfo custom_repr tblen=2>\"\n\n\ndef test_excinfo_for_later():\n    e = ExceptionInfo.for_later()\n    assert \"for raises\" in repr(e)\n    assert \"for raises\" in str(e)\n\n\ndef test_excinfo_errisinstance():\n    excinfo = pytest.raises(ValueError, h)\n    assert excinfo.errisinstance(ValueError)\n\n\ndef test_excinfo_no_sourcecode():\n    try:\n        exec(\"raise ValueError()\")\n    except ValueError:\n        excinfo = _pytest._code.ExceptionInfo.from_current()\n    s = str(excinfo.traceback[-1])\n    assert s == \"  File '<string>':1 in <module>\\n  ???\\n\"\n\n\ndef test_excinfo_no_python_sourcecode(tmpdir):\n    # XXX: simplified locally testable version\n    tmpdir.join(\"test.txt\").write(\"{{ h()}}:\")\n\n    jinja2 = pytest.importorskip(\"jinja2\")\n    loader = jinja2.FileSystemLoader(str(tmpdir))\n    env = jinja2.Environment(loader=loader)\n    template = env.get_template(\"test.txt\")\n    excinfo = pytest.raises(ValueError, template.render, h=h)\n    for item in excinfo.traceback:\n        print(item)  # XXX: for some reason jinja.Template.render is printed in full\n        item.source  # shouldn't fail\n        if item.path.basename == \"test.txt\":\n            assert str(item.source) == \"{{ h()}}:\"\n\n\ndef test_entrysource_Queue_example():\n    try:\n        queue.Queue().get(timeout=0.001)\n    except queue.Empty:\n        excinfo = _pytest._code.ExceptionInfo.from_current()\n    entry = excinfo.traceback[-1]\n    source = entry.getsource()\n    assert source is not None\n    s = str(source).strip()\n    assert s.startswith(\"def get\")\n\n\ndef test_codepath_Queue_example():\n    try:\n        queue.Queue().get(timeout=0.001)\n    except queue.Empty:\n        excinfo = _pytest._code.ExceptionInfo.from_current()\n    entry = excinfo.traceback[-1]\n    path = entry.path\n    assert isinstance(path, py.path.local)\n    assert path.basename.lower() == \"queue.py\"\n    assert path.check()\n\n\ndef test_match_succeeds():\n    with pytest.raises(ZeroDivisionError) as excinfo:\n        0 // 0\n    excinfo.match(r\".*zero.*\")\n\n\ndef test_match_raises_error(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_division_zero():\n            with pytest.raises(ZeroDivisionError) as excinfo:\n                0 / 0\n            excinfo.match(r'[123]+')\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret != 0\n\n    exc_msg = \"Pattern '[[]123[]]+' does not match 'division by zero'\"\n    result.stdout.fnmatch_lines([\"E * AssertionError: {}\".format(exc_msg)])\n    result.stdout.no_fnmatch_line(\"*__tracebackhide__ = True*\")\n\n    result = testdir.runpytest(\"--fulltrace\")\n    assert result.ret != 0\n    result.stdout.fnmatch_lines(\n        [\"*__tracebackhide__ = True*\", \"E * AssertionError: {}\".format(exc_msg)]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo_TestFormattedExcinfo.test_repr_source_failing_fullsource": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo_TestFormattedExcinfo.test_repr_source_failing_fullsource", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 427, "end_line": 523, "span_ids": ["TestFormattedExcinfo", "TestFormattedExcinfo.excinfo_from_exec", "TestFormattedExcinfo.importasmod", "TestFormattedExcinfo.test_repr_many_line_source_not_existing", "TestFormattedExcinfo.test_repr_source", "TestFormattedExcinfo.test_repr_source_excinfo", "TestFormattedExcinfo.test_repr_source_failing_fullsource", "TestFormattedExcinfo.test_repr_source_not_existing"], "tokens": 738}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n    @pytest.fixture\n    def importasmod(self, request, _sys_snapshot):\n        def importasmod(source):\n            source = textwrap.dedent(source)\n            tmpdir = request.getfixturevalue(\"tmpdir\")\n            modpath = tmpdir.join(\"mod.py\")\n            tmpdir.ensure(\"__init__.py\")\n            modpath.write(source)\n            if invalidate_import_caches is not None:\n                invalidate_import_caches()\n            return modpath.pyimport()\n\n        return importasmod\n\n    def excinfo_from_exec(self, source):\n        source = _pytest._code.Source(source).strip()\n        try:\n            exec(source.compile())\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            return _pytest._code.ExceptionInfo.from_current()\n        assert 0, \"did not raise\"\n\n    def test_repr_source(self):\n        pr = FormattedExcinfo()\n        source = _pytest._code.Source(\n            \"\"\"\\\n            def f(x):\n                pass\n            \"\"\"\n        ).strip()\n        pr.flow_marker = \"|\"\n        lines = pr.get_source(source, 0)\n        assert len(lines) == 2\n        assert lines[0] == \"|   def f(x):\"\n        assert lines[1] == \"        pass\"\n\n    def test_repr_source_excinfo(self):\n        \"\"\" check if indentation is right \"\"\"\n        pr = FormattedExcinfo()\n        excinfo = self.excinfo_from_exec(\n            \"\"\"\n                def f():\n                    assert 0\n                f()\n        \"\"\"\n        )\n        pr = FormattedExcinfo()\n        source = pr._getentrysource(excinfo.traceback[-1])\n        lines = pr.get_source(source, 1, excinfo)\n        assert lines == [\"    def f():\", \">       assert 0\", \"E       AssertionError\"]\n\n    def test_repr_source_not_existing(self):\n        pr = FormattedExcinfo()\n        co = compile(\"raise ValueError()\", \"\", \"exec\")\n        try:\n            exec(co)\n        except ValueError:\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n        repr = pr.repr_excinfo(excinfo)\n        assert repr.reprtraceback.reprentries[1].lines[0] == \">   ???\"\n        assert repr.chain[0][0].reprentries[1].lines[0] == \">   ???\"\n\n    def test_repr_many_line_source_not_existing(self):\n        pr = FormattedExcinfo()\n        co = compile(\n            \"\"\"\na = 1\nraise ValueError()\n\"\"\",\n            \"\",\n            \"exec\",\n        )\n        try:\n            exec(co)\n        except ValueError:\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n        repr = pr.repr_excinfo(excinfo)\n        assert repr.reprtraceback.reprentries[1].lines[0] == \">   ???\"\n        assert repr.chain[0][0].reprentries[1].lines[0] == \">   ???\"\n\n    def test_repr_source_failing_fullsource(self, monkeypatch) -> None:\n        pr = FormattedExcinfo()\n\n        try:\n            1 / 0\n        except ZeroDivisionError:\n            excinfo = ExceptionInfo.from_current()\n\n        with monkeypatch.context() as m:\n            m.setattr(_pytest._code.Code, \"fullsource\", property(lambda self: None))\n            repr = pr.repr_excinfo(excinfo)\n\n        assert repr.reprtraceback.reprentries[0].lines[0] == \">   ???\"\n        assert repr.chain[0][0].reprentries[0].lines[0] == \">   ???\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_traceback_with_invalid_cwd_TestFormattedExcinfo.test_repr_traceback_with_invalid_cwd.assert_raised_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_traceback_with_invalid_cwd_TestFormattedExcinfo.test_repr_traceback_with_invalid_cwd.assert_raised_3", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 771, "end_line": 818, "span_ids": ["TestFormattedExcinfo.test_repr_traceback_with_invalid_cwd"], "tokens": 294}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_traceback_with_invalid_cwd(self, importasmod, monkeypatch):\n        mod = importasmod(\n            \"\"\"\n            def f(x):\n                raise ValueError(x)\n            def entry():\n                f(0)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n\n        p = FormattedExcinfo(abspath=False)\n\n        raised = 0\n\n        orig_getcwd = os.getcwd\n\n        def raiseos():\n            nonlocal raised\n            if sys._getframe().f_back.f_code.co_name == \"checked_call\":\n                # Only raise with expected calls, but not via e.g. inspect for\n                # py38-windows.\n                raised += 1\n                raise OSError(2, \"custom_oserror\")\n            return orig_getcwd()\n\n        monkeypatch.setattr(os, \"getcwd\", raiseos)\n        assert p._makepath(__file__) == __file__\n        assert raised == 1\n        repr_tb = p.repr_traceback(excinfo)\n\n        matcher = LineMatcher(str(repr_tb).splitlines())\n        matcher.fnmatch_lines(\n            [\n                \"def entry():\",\n                \">       f(0)\",\n                \"\",\n                \"{}:5: \".format(mod.__file__),\n                \"_ _ *\",\n                \"\",\n                \"    def f(x):\",\n                \">       raise ValueError(x)\",\n                \"E       ValueError: 0\",\n                \"\",\n                \"{}:3: ValueError\".format(mod.__file__),\n            ]\n        )\n        assert raised == 3", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_excinfo_addouterr_TestFormattedExcinfo.test_reprexcinfo_unicode": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_repr_excinfo_addouterr_TestFormattedExcinfo.test_reprexcinfo_unicode", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 820, "end_line": 895, "span_ids": ["TestFormattedExcinfo.test_repr_excinfo_addouterr", "TestFormattedExcinfo.test_repr_excinfo_reprcrash", "TestFormattedExcinfo.test_repr_traceback_recursion", "TestFormattedExcinfo.test_reprexcinfo_getrepr", "TestFormattedExcinfo.test_reprexcinfo_unicode"], "tokens": 557}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_repr_excinfo_addouterr(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def entry():\n                raise ValueError()\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n        repr = excinfo.getrepr()\n        repr.addsection(\"title\", \"content\")\n        repr.toterminal(tw_mock)\n        assert tw_mock.lines[-1] == \"content\"\n        assert tw_mock.lines[-2] == (\"-\", \"title\")\n\n    def test_repr_excinfo_reprcrash(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def entry():\n                raise ValueError()\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n        repr = excinfo.getrepr()\n        assert repr.reprcrash.path.endswith(\"mod.py\")\n        assert repr.reprcrash.lineno == 3\n        assert repr.reprcrash.message == \"ValueError\"\n        assert str(repr.reprcrash).endswith(\"mod.py:3: ValueError\")\n\n    def test_repr_traceback_recursion(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def rec2(x):\n                return rec1(x+1)\n            def rec1(x):\n                return rec2(x-1)\n            def entry():\n                rec1(42)\n        \"\"\"\n        )\n        excinfo = pytest.raises(RuntimeError, mod.entry)\n\n        for style in (\"short\", \"long\", \"no\"):\n            p = FormattedExcinfo(style=\"short\")\n            reprtb = p.repr_traceback(excinfo)\n            assert reprtb.extraline == \"!!! Recursion detected (same locals & position)\"\n            assert str(reprtb)\n\n    def test_reprexcinfo_getrepr(self, importasmod):\n        mod = importasmod(\n            \"\"\"\n            def f(x):\n                raise ValueError(x)\n            def entry():\n                f(0)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.entry)\n\n        for style in (\"short\", \"long\", \"no\"):\n            for showlocals in (True, False):\n                repr = excinfo.getrepr(style=style, showlocals=showlocals)\n                assert repr.reprtraceback.style == style\n\n                assert isinstance(repr, ExceptionChainRepr)\n                for repr in repr.chain:\n                    assert repr[0].style == style\n\n    def test_reprexcinfo_unicode(self):\n        from _pytest._code.code import TerminalRepr\n\n        class MyRepr(TerminalRepr):\n            def toterminal(self, tw: TerminalWriter) -> None:\n                tw.line(\"\u044f\")\n\n        x = str(MyRepr())\n        assert x == \"\u044f\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_filenames_TestFormattedExcinfo.test_format_excinfo.assert_file_getvalue_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_excinfo.py_TestFormattedExcinfo.test_toterminal_long_filenames_TestFormattedExcinfo.test_format_excinfo.assert_file_getvalue_", "embedding": null, "metadata": {"file_path": "testing/code/test_excinfo.py", "file_name": "test_excinfo.py", "file_type": "text/x-python", "category": "test", "start_line": 988, "end_line": 1045, "span_ids": ["TestFormattedExcinfo.test_format_excinfo", "TestFormattedExcinfo.test_toterminal_long_filenames"], "tokens": 390}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFormattedExcinfo:\n\n    def test_toterminal_long_filenames(self, importasmod, tw_mock):\n        mod = importasmod(\n            \"\"\"\n            def f():\n                raise ValueError()\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.f)\n        path = py.path.local(mod.__file__)\n        old = path.dirpath().chdir()\n        try:\n            repr = excinfo.getrepr(abspath=False)\n            repr.toterminal(tw_mock)\n            x = py.path.local().bestrelpath(path)\n            if len(x) < len(str(path)):\n                msg = tw_mock.get_write_msg(-2)\n                assert msg == \"mod.py\"\n                assert tw_mock.lines[-1] == \":3: ValueError\"\n\n            repr = excinfo.getrepr(abspath=True)\n            repr.toterminal(tw_mock)\n            msg = tw_mock.get_write_msg(-2)\n            assert msg == path\n            line = tw_mock.lines[-1]\n            assert line == \":3: ValueError\"\n        finally:\n            old.chdir()\n\n    @pytest.mark.parametrize(\n        \"reproptions\",\n        [\n            {\n                \"style\": style,\n                \"showlocals\": showlocals,\n                \"funcargs\": funcargs,\n                \"tbfilter\": tbfilter,\n            }\n            for style in (\"long\", \"short\", \"no\")\n            for showlocals in (True, False)\n            for tbfilter in (True, False)\n            for funcargs in (True, False)\n        ],\n    )\n    def test_format_excinfo(self, importasmod, reproptions):\n        mod = importasmod(\n            \"\"\"\n            def g(x):\n                raise ValueError(x)\n            def f():\n                g(3)\n        \"\"\"\n        )\n        excinfo = pytest.raises(ValueError, mod.f)\n        file = io.StringIO()\n        tw = TerminalWriter(file=file)\n        repr = excinfo.getrepr(**reproptions)\n        repr.toterminal(tw)\n        assert file.getvalue()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py__flake8_noqa_test_syntaxerror_rerepresentation": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py__flake8_noqa_test_syntaxerror_rerepresentation", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 126, "span_ids": ["docstring", "test_source_from_function", "test_source_from_inner_function", "test_source_from_lines", "test_source_from_method", "test_source_putaround", "test_source_putaround_simple", "test_source_str_function", "test_source_strip_multiline", "test_source_strips", "test_syntaxerror_rerepresentation", "test_unicode"], "tokens": 732}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# flake8: noqa\n# disable flake check on this file because some constructs are strange\n# or redundant on purpose and can't be disable on a line-by-line basis\nimport ast\nimport inspect\nimport sys\nfrom types import CodeType\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Optional\n\nimport py.path\n\nimport _pytest._code\nimport pytest\nfrom _pytest._code import getfslineno\nfrom _pytest._code import Source\n\n\ndef test_source_str_function() -> None:\n    x = Source(\"3\")\n    assert str(x) == \"3\"\n\n    x = Source(\"   3\")\n    assert str(x) == \"3\"\n\n    x = Source(\n        \"\"\"\n        3\n        \"\"\"\n    )\n    assert str(x) == \"\\n3\"\n\n\ndef test_unicode() -> None:\n    x = Source(\"4\")\n    assert str(x) == \"4\"\n    co = _pytest._code.compile('\"\u00e5\"', mode=\"eval\")\n    val = eval(co)\n    assert isinstance(val, str)\n\n\ndef test_source_from_function() -> None:\n    source = _pytest._code.Source(test_source_str_function)\n    assert str(source).startswith(\"def test_source_str_function() -> None:\")\n\n\ndef test_source_from_method() -> None:\n    class TestClass:\n        def test_method(self):\n            pass\n\n    source = _pytest._code.Source(TestClass().test_method)\n    assert source.lines == [\"def test_method(self):\", \"    pass\"]\n\n\ndef test_source_from_lines() -> None:\n    lines = [\"a \\n\", \"b\\n\", \"c\"]\n    source = _pytest._code.Source(lines)\n    assert source.lines == [\"a \", \"b\", \"c\"]\n\n\ndef test_source_from_inner_function() -> None:\n    def f():\n        pass\n\n    source = _pytest._code.Source(f, deindent=False)\n    assert str(source).startswith(\"    def f():\")\n    source = _pytest._code.Source(f)\n    assert str(source).startswith(\"def f():\")\n\n\ndef test_source_putaround_simple() -> None:\n    source = Source(\"raise ValueError\")\n    source = source.putaround(\n        \"try:\",\n        \"\"\"\\\n        except ValueError:\n            x = 42\n        else:\n            x = 23\"\"\",\n    )\n    assert (\n        str(source)\n        == \"\"\"\\\ntry:\n    raise ValueError\nexcept ValueError:\n    x = 42\nelse:\n    x = 23\"\"\"\n    )\n\n\ndef test_source_putaround() -> None:\n    source = Source()\n    source = source.putaround(\n        \"\"\"\n        if 1:\n            x=1\n    \"\"\"\n    )\n    assert str(source).strip() == \"if 1:\\n    x=1\"\n\n\ndef test_source_strips() -> None:\n    source = Source(\"\")\n    assert source == Source()\n    assert str(source) == \"\"\n    assert source.strip() == source\n\n\ndef test_source_strip_multiline() -> None:\n    source = Source()\n    source.lines = [\"\", \" hello\", \"  \"]\n    source2 = source.strip()\n    assert source2.lines == [\" hello\"]\n\n\ndef test_syntaxerror_rerepresentation() -> None:\n    ex = pytest.raises(SyntaxError, _pytest._code.compile, \"xyz xyz\")\n    assert ex is not None\n    assert ex.value.lineno == 1\n    assert ex.value.offset in {5, 7}  # cpython: 7, pypy3.6 7.1.1: 5\n    assert ex.value.text\n    assert ex.value.text.rstrip(\"\\n\") == \"xyz xyz\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_isparseable_TestAccesses.test_iter": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_isparseable_TestAccesses.test_iter", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 129, "end_line": 168, "span_ids": ["TestAccesses", "TestAccesses.setup_class", "TestAccesses.test_getline", "TestAccesses.test_getrange", "TestAccesses.test_getrange_step_not_supported", "TestAccesses.test_iter", "TestAccesses.test_len", "test_isparseable"], "tokens": 293}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_isparseable() -> None:\n    assert Source(\"hello\").isparseable()\n    assert Source(\"if 1:\\n  pass\").isparseable()\n    assert Source(\" \\nif 1:\\n  pass\").isparseable()\n    assert not Source(\"if 1:\\n\").isparseable()\n    assert not Source(\" \\nif 1:\\npass\").isparseable()\n    assert not Source(chr(0)).isparseable()\n\n\nclass TestAccesses:\n    def setup_class(self) -> None:\n        self.source = Source(\n            \"\"\"\\\n            def f(x):\n                pass\n            def g(x):\n                pass\n        \"\"\"\n        )\n\n    def test_getrange(self) -> None:\n        x = self.source[0:2]\n        assert x.isparseable()\n        assert len(x.lines) == 2\n        assert str(x) == \"def f(x):\\n    pass\"\n\n    def test_getrange_step_not_supported(self) -> None:\n        with pytest.raises(IndexError, match=r\"step\"):\n            self.source[::2]\n\n    def test_getline(self) -> None:\n        x = self.source[0]\n        assert x == \"def f(x):\"\n\n    def test_len(self) -> None:\n        assert len(self.source) == 4\n\n    def test_iter(self) -> None:\n        values = [x for x in self.source]\n        assert len(values) == 4", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_TestSourceParsingAndCompiling_TestSourceParsingAndCompiling.test_getstatementrange_bug2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_TestSourceParsingAndCompiling_TestSourceParsingAndCompiling.test_getstatementrange_bug2", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 171, "end_line": 286, "span_ids": ["TestSourceParsingAndCompiling", "TestSourceParsingAndCompiling.setup_class", "TestSourceParsingAndCompiling.test_compile", "TestSourceParsingAndCompiling.test_compile_and_getsource_simple", "TestSourceParsingAndCompiling.test_compile_and_getsource_through_same_function", "TestSourceParsingAndCompiling.test_getstatement", "TestSourceParsingAndCompiling.test_getstatementrange_bug", "TestSourceParsingAndCompiling.test_getstatementrange_bug2", "TestSourceParsingAndCompiling.test_getstatementrange_triple_quoted", "TestSourceParsingAndCompiling.test_getstatementrange_within_constructs"], "tokens": 737}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestSourceParsingAndCompiling:\n    def setup_class(self) -> None:\n        self.source = Source(\n            \"\"\"\\\n            def f(x):\n                assert (x ==\n                        3 +\n                        4)\n        \"\"\"\n        ).strip()\n\n    def test_compile(self) -> None:\n        co = _pytest._code.compile(\"x=3\")\n        d = {}  # type: Dict[str, Any]\n        exec(co, d)\n        assert d[\"x\"] == 3\n\n    def test_compile_and_getsource_simple(self) -> None:\n        co = _pytest._code.compile(\"x=3\")\n        exec(co)\n        source = _pytest._code.Source(co)\n        assert str(source) == \"x=3\"\n\n    def test_compile_and_getsource_through_same_function(self) -> None:\n        def gensource(source):\n            return _pytest._code.compile(source)\n\n        co1 = gensource(\n            \"\"\"\n            def f():\n                raise KeyError()\n        \"\"\"\n        )\n        co2 = gensource(\n            \"\"\"\n            def f():\n                raise ValueError()\n        \"\"\"\n        )\n        source1 = inspect.getsource(co1)\n        assert \"KeyError\" in source1\n        source2 = inspect.getsource(co2)\n        assert \"ValueError\" in source2\n\n    def test_getstatement(self) -> None:\n        # print str(self.source)\n        ass = str(self.source[1:])\n        for i in range(1, 4):\n            # print \"trying start in line %r\" % self.source[i]\n            s = self.source.getstatement(i)\n            # x = s.deindent()\n            assert str(s) == ass\n\n    def test_getstatementrange_triple_quoted(self) -> None:\n        # print str(self.source)\n        source = Source(\n            \"\"\"hello('''\n        ''')\"\"\"\n        )\n        s = source.getstatement(0)\n        assert s == str(source)\n        s = source.getstatement(1)\n        assert s == str(source)\n\n    def test_getstatementrange_within_constructs(self) -> None:\n        source = Source(\n            \"\"\"\\\n            try:\n                try:\n                    raise ValueError\n                except SomeThing:\n                    pass\n            finally:\n                42\n        \"\"\"\n        )\n        assert len(source) == 7\n        # check all lineno's that could occur in a traceback\n        # assert source.getstatementrange(0) == (0, 7)\n        # assert source.getstatementrange(1) == (1, 5)\n        assert source.getstatementrange(2) == (2, 3)\n        assert source.getstatementrange(3) == (3, 4)\n        assert source.getstatementrange(4) == (4, 5)\n        # assert source.getstatementrange(5) == (0, 7)\n        assert source.getstatementrange(6) == (6, 7)\n\n    def test_getstatementrange_bug(self) -> None:\n        source = Source(\n            \"\"\"\\\n            try:\n                x = (\n                   y +\n                   z)\n            except:\n                pass\n        \"\"\"\n        )\n        assert len(source) == 6\n        assert source.getstatementrange(2) == (1, 4)\n\n    def test_getstatementrange_bug2(self) -> None:\n        source = Source(\n            \"\"\"\\\n            assert (\n                33\n                ==\n                [\n                  X(3,\n                      b=1, c=2\n                   ),\n                ]\n              )\n        \"\"\"\n        )\n        assert len(source) == 9\n        assert source.getstatementrange(5) == (0, 9)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_getstartingblock_singleline_test_compile_ast": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_getstartingblock_singleline_test_compile_ast", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 350, "end_line": 466, "span_ids": ["impl", "test_compile_ast", "test_deindent", "test_getfuncsource_dynamic", "test_getfuncsource_with_multine_string", "test_getline_finally", "test_getsource_fallback", "test_getstartingblock_singleline", "test_idem_compile_and_getsource", "test_source_of_class_at_eof_without_newline"], "tokens": 739}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_getstartingblock_singleline() -> None:\n    class A:\n        def __init__(self, *args) -> None:\n            frame = sys._getframe(1)\n            self.source = _pytest._code.Frame(frame).statement\n\n    x = A(\"x\", \"y\")\n\n    values = [i for i in x.source.lines if i.strip()]\n    assert len(values) == 1\n\n\ndef test_getline_finally() -> None:\n    def c() -> None:\n        pass\n\n    with pytest.raises(TypeError) as excinfo:\n        teardown = None\n        try:\n            c(1)  # type: ignore\n        finally:\n            if teardown:\n                teardown()\n    source = excinfo.traceback[-1].statement\n    assert str(source).strip() == \"c(1)  # type: ignore\"\n\n\ndef test_getfuncsource_dynamic() -> None:\n    source = \"\"\"\n        def f():\n            raise ValueError\n\n        def g(): pass\n    \"\"\"\n    co = _pytest._code.compile(source)\n    exec(co, globals())\n    f_source = _pytest._code.Source(f)  # type: ignore\n    g_source = _pytest._code.Source(g)  # type: ignore\n    assert str(f_source).strip() == \"def f():\\n    raise ValueError\"\n    assert str(g_source).strip() == \"def g(): pass\"\n\n\ndef test_getfuncsource_with_multine_string() -> None:\n    def f():\n        c = \"\"\"while True:\n    pass\n\"\"\"\n\n    expected = '''\\\n    def f():\n        c = \"\"\"while True:\n    pass\n\"\"\"\n'''\n    assert str(_pytest._code.Source(f)) == expected.rstrip()\n\n\ndef test_deindent() -> None:\n    from _pytest._code.source import deindent as deindent\n\n    assert deindent([\"\\tfoo\", \"\\tbar\"]) == [\"foo\", \"bar\"]\n\n    source = \"\"\"\\\n        def f():\n            def g():\n                pass\n    \"\"\"\n    lines = deindent(source.splitlines())\n    assert lines == [\"def f():\", \"    def g():\", \"        pass\"]\n\n\ndef test_source_of_class_at_eof_without_newline(tmpdir, _sys_snapshot) -> None:\n    # this test fails because the implicit inspect.getsource(A) below\n    # does not return the \"x = 1\" last line.\n    source = _pytest._code.Source(\n        \"\"\"\n        class A(object):\n            def method(self):\n                x = 1\n    \"\"\"\n    )\n    path = tmpdir.join(\"a.py\")\n    path.write(source)\n    s2 = _pytest._code.Source(tmpdir.join(\"a.py\").pyimport().A)\n    assert str(source).strip() == str(s2).strip()\n\n\nif True:\n\n    def x():\n        pass\n\n\ndef test_getsource_fallback() -> None:\n    from _pytest._code.source import getsource\n\n    expected = \"\"\"def x():\n    pass\"\"\"\n    src = getsource(x)\n    assert src == expected\n\n\ndef test_idem_compile_and_getsource() -> None:\n    from _pytest._code.source import getsource\n\n    expected = \"def x(): pass\"\n    co = _pytest._code.compile(expected)\n    src = getsource(co)\n    assert src == expected\n\n\ndef test_compile_ast() -> None:\n    # We don't necessarily want to support this.\n    # This test was added just for coverage.\n    stmt = ast.parse(\"def x(): pass\")\n    co = _pytest._code.compile(stmt, filename=\"foo.py\")\n    assert isinstance(co, CodeType)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_findsource_fallback_test_getfslineno.if_hasattr_sys_pypy_ver": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_findsource_fallback_test_getfslineno.if_hasattr_sys_pypy_ver", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 469, "end_line": 534, "span_ids": ["test_findsource", "test_findsource_fallback", "test_getfslineno"], "tokens": 418}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_findsource_fallback() -> None:\n    from _pytest._code.source import findsource\n\n    src, lineno = findsource(x)\n    assert src is not None\n    assert \"test_findsource_simple\" in str(src)\n    assert src[lineno] == \"    def x():\"\n\n\ndef test_findsource() -> None:\n    from _pytest._code.source import findsource\n\n    co = _pytest._code.compile(\n        \"\"\"if 1:\n    def x():\n        pass\n\"\"\"\n    )\n\n    src, lineno = findsource(co)\n    assert src is not None\n    assert \"if 1:\" in str(src)\n\n    d = {}  # type: Dict[str, Any]\n    eval(co, d)\n    src, lineno = findsource(d[\"x\"])\n    assert src is not None\n    assert \"if 1:\" in str(src)\n    assert src[lineno] == \"    def x():\"\n\n\ndef test_getfslineno() -> None:\n    def f(x) -> None:\n        raise NotImplementedError()\n\n    fspath, lineno = getfslineno(f)\n\n    assert isinstance(fspath, py.path.local)\n    assert fspath.basename == \"test_source.py\"\n    assert lineno == f.__code__.co_firstlineno - 1  # see findsource\n\n    class A:\n        pass\n\n    fspath, lineno = getfslineno(A)\n\n    _, A_lineno = inspect.findsource(A)\n    assert isinstance(fspath, py.path.local)\n    assert fspath.basename == \"test_source.py\"\n    assert lineno == A_lineno\n\n    assert getfslineno(3) == (\"\", -1)\n\n    class B:\n        pass\n\n    B.__name__ = B.__qualname__ = \"B2\"\n    assert getfslineno(B)[1] == -1\n\n    co = compile(\"...\", \"\", \"eval\")\n    assert co.co_filename == \"\"\n\n    if hasattr(sys, \"pypy_version_info\"):\n        assert getfslineno(co) == (\"\", -1)\n    else:\n        assert getfslineno(co) == (\"\", 0)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_code_of_object_instance_with_call_test_single_line_finally": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_code_of_object_instance_with_call_test_single_line_finally", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 537, "end_line": 634, "span_ids": ["getstatement", "test_code_of_object_instance_with_call", "test_comment_and_no_newline_at_end", "test_comment_in_statement", "test_comments", "test_oneline", "test_oneline_and_comment", "test_single_line_else", "test_single_line_finally"], "tokens": 673}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_code_of_object_instance_with_call() -> None:\n    class A:\n        pass\n\n    pytest.raises(TypeError, lambda: _pytest._code.Source(A()))\n\n    class WithCall:\n        def __call__(self) -> None:\n            pass\n\n    code = _pytest._code.Code(WithCall())\n    assert \"pass\" in str(code.source())\n\n    class Hello:\n        def __call__(self) -> None:\n            pass\n\n    pytest.raises(TypeError, lambda: _pytest._code.Code(Hello))\n\n\ndef getstatement(lineno: int, source) -> Source:\n    from _pytest._code.source import getstatementrange_ast\n\n    src = _pytest._code.Source(source, deindent=False)\n    ast, start, end = getstatementrange_ast(lineno, src)\n    return src[start:end]\n\n\ndef test_oneline() -> None:\n    source = getstatement(0, \"raise ValueError\")\n    assert str(source) == \"raise ValueError\"\n\n\ndef test_comment_and_no_newline_at_end() -> None:\n    from _pytest._code.source import getstatementrange_ast\n\n    source = Source(\n        [\n            \"def test_basic_complex():\",\n            \"    assert 1 == 2\",\n            \"# vim: filetype=pyopencl:fdm=marker\",\n        ]\n    )\n    ast, start, end = getstatementrange_ast(1, source)\n    assert end == 2\n\n\ndef test_oneline_and_comment() -> None:\n    source = getstatement(0, \"raise ValueError\\n#hello\")\n    assert str(source) == \"raise ValueError\"\n\n\ndef test_comments() -> None:\n    source = '''def test():\n    \"comment 1\"\n    x = 1\n      # comment 2\n    # comment 3\n\n    assert False\n\n\"\"\"\ncomment 4\n\"\"\"\n'''\n    for line in range(2, 6):\n        assert str(getstatement(line, source)) == \"    x = 1\"\n    if sys.version_info >= (3, 8) or hasattr(sys, \"pypy_version_info\"):\n        tqs_start = 8\n    else:\n        tqs_start = 10\n        assert str(getstatement(10, source)) == '\"\"\"'\n    for line in range(6, tqs_start):\n        assert str(getstatement(line, source)) == \"    assert False\"\n    for line in range(tqs_start, 10):\n        assert str(getstatement(line, source)) == '\"\"\"\\ncomment 4\\n\"\"\"'\n\n\ndef test_comment_in_statement() -> None:\n    source = \"\"\"test(foo=1,\n    # comment 1\n    bar=2)\n\"\"\"\n    for line in range(1, 3):\n        assert (\n            str(getstatement(line, source))\n            == \"test(foo=1,\\n    # comment 1\\n    bar=2)\"\n        )\n\n\ndef test_single_line_else() -> None:\n    source = getstatement(1, \"if False: 2\\nelse: 3\")\n    assert str(source) == \"else: 3\"\n\n\ndef test_single_line_finally() -> None:\n    source = getstatement(1, \"try: 1\\nfinally: 3\")\n    assert str(source) == \"finally: 3\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_issue55_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/code/test_source.py_test_issue55_", "embedding": null, "metadata": {"file_path": "testing/code/test_source.py", "file_name": "test_source.py", "file_type": "text/x-python", "category": "test", "start_line": 637, "end_line": 775, "span_ids": ["TestIf", "TestIf.setup_class", "TestIf.test_body", "TestIf.test_elif", "TestIf.test_elif_clause", "TestIf.test_else", "TestTry", "TestTry.setup_class", "TestTry.test_body", "TestTry.test_else", "TestTry.test_except_body", "TestTry.test_except_line", "TestTryFinally", "TestTryFinally.setup_class", "TestTryFinally.test_body", "TestTryFinally.test_finally", "XXX_test_expression_multiline", "test_def_online", "test_getstartingblock_multiline", "test_issue55", "test_multiline", "test_semicolon"], "tokens": 798}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_issue55() -> None:\n    source = (\n        \"def round_trip(dinp):\\n  assert 1 == dinp\\n\"\n        'def test_rt():\\n  round_trip(\"\"\"\\n\"\"\")\\n'\n    )\n    s = getstatement(3, source)\n    assert str(s) == '  round_trip(\"\"\"\\n\"\"\")'\n\n\ndef test_multiline() -> None:\n    source = getstatement(\n        0,\n        \"\"\"\\\nraise ValueError(\n    23\n)\nx = 3\n\"\"\",\n    )\n    assert str(source) == \"raise ValueError(\\n    23\\n)\"\n\n\nclass TestTry:\n    def setup_class(self) -> None:\n        self.source = \"\"\"\\\ntry:\n    raise ValueError\nexcept Something:\n    raise IndexError(1)\nelse:\n    raise KeyError()\n\"\"\"\n\n    def test_body(self) -> None:\n        source = getstatement(1, self.source)\n        assert str(source) == \"    raise ValueError\"\n\n    def test_except_line(self) -> None:\n        source = getstatement(2, self.source)\n        assert str(source) == \"except Something:\"\n\n    def test_except_body(self) -> None:\n        source = getstatement(3, self.source)\n        assert str(source) == \"    raise IndexError(1)\"\n\n    def test_else(self) -> None:\n        source = getstatement(5, self.source)\n        assert str(source) == \"    raise KeyError()\"\n\n\nclass TestTryFinally:\n    def setup_class(self) -> None:\n        self.source = \"\"\"\\\ntry:\n    raise ValueError\nfinally:\n    raise IndexError(1)\n\"\"\"\n\n    def test_body(self) -> None:\n        source = getstatement(1, self.source)\n        assert str(source) == \"    raise ValueError\"\n\n    def test_finally(self) -> None:\n        source = getstatement(3, self.source)\n        assert str(source) == \"    raise IndexError(1)\"\n\n\nclass TestIf:\n    def setup_class(self) -> None:\n        self.source = \"\"\"\\\nif 1:\n    y = 3\nelif False:\n    y = 5\nelse:\n    y = 7\n\"\"\"\n\n    def test_body(self) -> None:\n        source = getstatement(1, self.source)\n        assert str(source) == \"    y = 3\"\n\n    def test_elif_clause(self) -> None:\n        source = getstatement(2, self.source)\n        assert str(source) == \"elif False:\"\n\n    def test_elif(self) -> None:\n        source = getstatement(3, self.source)\n        assert str(source) == \"    y = 5\"\n\n    def test_else(self) -> None:\n        source = getstatement(5, self.source)\n        assert str(source) == \"    y = 7\"\n\n\ndef test_semicolon() -> None:\n    s = \"\"\"\\\nhello ; pytest.skip()\n\"\"\"\n    source = getstatement(0, s)\n    assert str(source) == s.strip()\n\n\ndef test_def_online() -> None:\n    s = \"\"\"\\\ndef func(): raise ValueError(42)\n\ndef something():\n    pass\n\"\"\"\n    source = getstatement(0, s)\n    assert str(source) == \"def func(): raise ValueError(42)\"\n\n\ndef XXX_test_expression_multiline() -> None:\n    source = \"\"\"\\\nsomething\n'''\n'''\"\"\"\n    result = getstatement(1, source)\n    assert str(result) == \"'''\\n'''\"\n\n\ndef test_getstartingblock_multiline() -> None:\n    class A:\n        def __init__(self, *args):\n            frame = sys._getframe(1)\n            self.source = _pytest._code.Frame(frame).statement\n\n    # fmt: off\n    x = A('x',\n          'y'\n          ,\n          'z')\n    # fmt: on\n    values = [i for i in x.source.lines if i.strip()]\n    assert len(values) == 4", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_re_pytest_collection_modifyitems.yield": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_re_pytest_collection_modifyitems.yield", "embedding": null, "metadata": {"file_path": "testing/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 64, "span_ids": ["imports", "pytest_collection_modifyitems"], "tokens": 367}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import re\nimport sys\nfrom typing import List\n\nimport pytest\nfrom _pytest.pytester import RunResult\nfrom _pytest.pytester import Testdir\n\nif sys.gettrace():\n\n    @pytest.fixture(autouse=True)\n    def restore_tracing():\n        \"\"\"Restore tracing function (when run with Coverage.py).\n\n        https://bugs.python.org/issue37011\n        \"\"\"\n        orig_trace = sys.gettrace()\n        yield\n        if sys.gettrace() != orig_trace:\n            sys.settrace(orig_trace)\n\n\n@pytest.hookimpl(hookwrapper=True, tryfirst=True)\ndef pytest_collection_modifyitems(items):\n    \"\"\"Prefer faster tests.\n\n    Use a hookwrapper to do this in the beginning, so e.g. --ff still works\n    correctly.\n    \"\"\"\n    fast_items = []\n    slow_items = []\n    slowest_items = []\n    neutral_items = []\n\n    spawn_names = {\"spawn_pytest\", \"spawn\"}\n\n    for item in items:\n        try:\n            fixtures = item.fixturenames\n        except AttributeError:\n            # doctest at least\n            # (https://github.com/pytest-dev/pytest/issues/5070)\n            neutral_items.append(item)\n        else:\n            if \"testdir\" in fixtures:\n                co_names = item.function.__code__.co_names\n                if spawn_names.intersection(co_names):\n                    item.add_marker(pytest.mark.uses_pexpect)\n                    slowest_items.append(item)\n                elif \"runpytest_subprocess\" in co_names:\n                    slowest_items.append(item)\n                else:\n                    slow_items.append(item)\n                item.add_marker(pytest.mark.slow)\n            else:\n                marker = item.get_closest_marker(\"slow\")\n                if marker:\n                    slowest_items.append(item)\n                else:\n                    fast_items.append(item)\n\n    items[:] = fast_items + neutral_items + slow_items + slowest_items\n\n    yield", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_tw_mock_testdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_tw_mock_testdir", "embedding": null, "metadata": {"file_path": "testing/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 67, "end_line": 136, "span_ids": ["dummy_yaml_custom_test", "testdir", "tw_mock"], "tokens": 390}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.fixture\ndef tw_mock():\n    \"\"\"Returns a mock terminal writer\"\"\"\n\n    class TWMock:\n        WRITE = object()\n\n        def __init__(self):\n            self.lines = []\n            self.is_writing = False\n\n        def sep(self, sep, line=None):\n            self.lines.append((sep, line))\n\n        def write(self, msg, **kw):\n            self.lines.append((TWMock.WRITE, msg))\n\n        def _write_source(self, lines, indents=()):\n            if not indents:\n                indents = [\"\"] * len(lines)\n            for indent, line in zip(indents, lines):\n                self.line(indent + line)\n\n        def line(self, line, **kw):\n            self.lines.append(line)\n\n        def markup(self, text, **kw):\n            return text\n\n        def get_write_msg(self, idx):\n            flag, msg = self.lines[idx]\n            assert flag == TWMock.WRITE\n            return msg\n\n        fullwidth = 80\n\n    return TWMock()\n\n\n@pytest.fixture\ndef dummy_yaml_custom_test(testdir):\n    \"\"\"Writes a conftest file that collects and executes a dummy yaml test.\n\n    Taken from the docs, but stripped down to the bare minimum, useful for\n    tests which needs custom items collected.\n    \"\"\"\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n\n        def pytest_collect_file(parent, path):\n            if path.ext == \".yaml\" and path.basename.startswith(\"test\"):\n                return YamlFile(path, parent)\n\n        class YamlFile(pytest.File):\n            def collect(self):\n                yield YamlItem(self.fspath.basename, self)\n\n        class YamlItem(pytest.Item):\n            def runtest(self):\n                pass\n    \"\"\"\n    )\n    testdir.makefile(\".yaml\", test1=\"\")\n\n\n@pytest.fixture\ndef testdir(testdir: Testdir) -> Testdir:\n    testdir.monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    return testdir", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_color_mapping_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/conftest.py_color_mapping_", "embedding": null, "metadata": {"file_path": "testing/conftest.py", "file_name": "conftest.py", "file_type": "text/x-python", "category": "implementation", "start_line": 139, "end_line": 200, "span_ids": ["color_mapping"], "tokens": 553}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.fixture(scope=\"session\")\ndef color_mapping():\n    \"\"\"Returns a utility class which can replace keys in strings in the form \"{NAME}\"\n    by their equivalent ASCII codes in the terminal.\n\n    Used by tests which check the actual colors output by pytest.\n    \"\"\"\n\n    class ColorMapping:\n        COLORS = {\n            \"red\": \"\\x1b[31m\",\n            \"green\": \"\\x1b[32m\",\n            \"yellow\": \"\\x1b[33m\",\n            \"bold\": \"\\x1b[1m\",\n            \"reset\": \"\\x1b[0m\",\n            \"kw\": \"\\x1b[94m\",\n            \"hl-reset\": \"\\x1b[39;49;00m\",\n            \"function\": \"\\x1b[92m\",\n            \"number\": \"\\x1b[94m\",\n            \"str\": \"\\x1b[33m\",\n            \"print\": \"\\x1b[96m\",\n        }\n        RE_COLORS = {k: re.escape(v) for k, v in COLORS.items()}\n\n        @classmethod\n        def format(cls, lines: List[str]) -> List[str]:\n            \"\"\"Straightforward replacement of color names to their ASCII codes.\"\"\"\n            return [line.format(**cls.COLORS) for line in lines]\n\n        @classmethod\n        def format_for_fnmatch(cls, lines: List[str]) -> List[str]:\n            \"\"\"Replace color names for use with LineMatcher.fnmatch_lines\"\"\"\n            return [line.format(**cls.COLORS).replace(\"[\", \"[[]\") for line in lines]\n\n        @classmethod\n        def format_for_rematch(cls, lines: List[str]) -> List[str]:\n            \"\"\"Replace color names for use with LineMatcher.re_match_lines\"\"\"\n            return [line.format(**cls.RE_COLORS) for line in lines]\n\n        @classmethod\n        def requires_ordered_markup(cls, result: RunResult):\n            \"\"\"Should be called if a test expects markup to appear in the output\n            in the order they were passed, for example:\n\n                tw.write(line, bold=True, red=True)\n\n            In Python 3.5 there's no guarantee that the generated markup will appear\n            in the order called, so we do some limited color testing and skip the rest of\n            the test.\n            \"\"\"\n            if sys.version_info < (3, 6):\n                # terminal writer.write accepts keyword arguments, so\n                # py36+ is required so the markup appears in the expected order\n                output = result.stdout.str()\n                assert \"test session starts\" in output\n                assert \"\\x1b[1m\" in output\n                pytest.skip(\n                    \"doing limited testing because lacking ordered markup on py35\"\n                )\n\n    return ColorMapping", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_copy_test_pytest_collect_module_deprecated": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_copy_test_pytest_collect_module_deprecated", "embedding": null, "metadata": {"file_path": "testing/deprecated_test.py", "file_name": "deprecated_test.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 35, "span_ids": ["imports", "test_pytest_collect_module_deprecated", "test_resultlog_is_deprecated"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import copy\nimport inspect\nfrom unittest import mock\n\nimport pytest\nfrom _pytest import deprecated\nfrom _pytest import nodes\nfrom _pytest.config import Config\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_resultlog_is_deprecated(testdir):\n    result = testdir.runpytest(\"--help\")\n    result.stdout.fnmatch_lines([\"*DEPRECATED path for machine-readable result log*\"])\n\n    testdir.makepyfile(\n        \"\"\"\n        def test():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--result-log=%s\" % testdir.tmpdir.join(\"result.log\"))\n    result.stdout.fnmatch_lines(\n        [\n            \"*--result-log is deprecated, please try the new pytest-reportlog plugin.\",\n            \"*See https://docs.pytest.org/en/latest/deprecations.html#result-log-result-log for more information*\",\n        ]\n    )\n\n\n@pytest.mark.parametrize(\"attribute\", pytest.collect.__all__)  # type: ignore\n# false positive due to dynamic attribute\ndef test_pytest_collect_module_deprecated(attribute):\n    with pytest.warns(DeprecationWarning, match=attribute):\n        getattr(pytest.collect, attribute)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_test_terminal_reporter_writer_attr_test_terminal_reporter_writer_attr.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_test_terminal_reporter_writer_attr_test_terminal_reporter_writer_attr.None_3", "embedding": null, "metadata": {"file_path": "testing/deprecated_test.py", "file_name": "deprecated_test.py", "file_type": "text/x-python", "category": "test", "start_line": 38, "end_line": 64, "span_ids": ["test_terminal_reporter_writer_attr"], "tokens": 227}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_terminal_reporter_writer_attr(pytestconfig: Config) -> None:\n    \"\"\"Check that TerminalReporter._tw is also available as 'writer' (#2984)\n    This attribute has been deprecated in 5.4.\n    \"\"\"\n    try:\n        import xdist  # noqa\n\n        pytest.skip(\"xdist workers disable the terminal reporter plugin\")\n    except ImportError:\n        pass\n    terminal_reporter = pytestconfig.pluginmanager.get_plugin(\"terminalreporter\")\n    original_tw = terminal_reporter._tw\n\n    with pytest.warns(pytest.PytestDeprecationWarning) as cw:\n        assert terminal_reporter.writer is original_tw\n    assert len(cw) == 1\n    assert cw[0].filename == __file__\n\n    new_tw = copy.copy(original_tw)\n    with pytest.warns(pytest.PytestDeprecationWarning) as cw:\n        terminal_reporter.writer = new_tw\n        try:\n            assert terminal_reporter._tw is new_tw\n        finally:\n            terminal_reporter.writer = original_tw\n    assert len(cw) == 2\n    assert cw[0].filename == cw[1].filename == __file__", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_test_external_plugins_integrated_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/deprecated_test.py_test_external_plugins_integrated_", "embedding": null, "metadata": {"file_path": "testing/deprecated_test.py", "file_name": "deprecated_test.py", "file_type": "text/x-python", "category": "test", "start_line": 67, "end_line": 167, "span_ids": ["assert_no_print_logs", "test__fillfuncargs_is_deprecated", "test_external_plugins_integrated", "test_node_direct_ctor_warning", "test_noprintlogs_is_deprecated_cmdline", "test_noprintlogs_is_deprecated_ini", "test_warn_about_imminent_junit_family_default_change"], "tokens": 620}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"plugin\", sorted(deprecated.DEPRECATED_EXTERNAL_PLUGINS))\n@pytest.mark.filterwarnings(\"default\")\ndef test_external_plugins_integrated(testdir, plugin):\n    testdir.syspathinsert()\n    testdir.makepyfile(**{plugin: \"\"})\n\n    with pytest.warns(pytest.PytestConfigWarning):\n        testdir.parseconfig(\"-p\", plugin)\n\n\n@pytest.mark.parametrize(\"junit_family\", [None, \"legacy\", \"xunit2\"])\ndef test_warn_about_imminent_junit_family_default_change(testdir, junit_family):\n    \"\"\"Show a warning if junit_family is not defined and --junitxml is used (#6179)\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        def test_foo():\n            pass\n    \"\"\"\n    )\n    if junit_family:\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            junit_family={junit_family}\n        \"\"\".format(\n                junit_family=junit_family\n            )\n        )\n\n    result = testdir.runpytest(\"--junit-xml=foo.xml\")\n    warning_msg = (\n        \"*PytestDeprecationWarning: The 'junit_family' default value will change*\"\n    )\n    if junit_family:\n        result.stdout.no_fnmatch_line(warning_msg)\n    else:\n        result.stdout.fnmatch_lines([warning_msg])\n\n\ndef test_node_direct_ctor_warning():\n    class MockConfig:\n        pass\n\n    ms = MockConfig()\n    with pytest.warns(\n        DeprecationWarning,\n        match=\"Direct construction of .* has been deprecated, please use .*.from_parent.*\",\n    ) as w:\n        nodes.Node(name=\"test\", config=ms, session=ms, nodeid=\"None\")\n    assert w[0].lineno == inspect.currentframe().f_lineno - 1\n    assert w[0].filename == __file__\n\n\ndef assert_no_print_logs(testdir, args):\n    result = testdir.runpytest(*args)\n    result.stdout.fnmatch_lines(\n        [\n            \"*--no-print-logs is deprecated and scheduled for removal in pytest 6.0*\",\n            \"*Please use --show-capture instead.*\",\n        ]\n    )\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_noprintlogs_is_deprecated_cmdline(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_foo():\n            pass\n        \"\"\"\n    )\n\n    assert_no_print_logs(testdir, (\"--no-print-logs\",))\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_noprintlogs_is_deprecated_ini(testdir):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_print=False\n        \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        def test_foo():\n            pass\n        \"\"\"\n    )\n\n    assert_no_print_logs(testdir, ())\n\n\ndef test__fillfuncargs_is_deprecated() -> None:\n    with pytest.warns(\n        pytest.PytestDeprecationWarning,\n        match=\"The `_fillfuncargs` function is deprecated\",\n    ):\n        pytest._fillfuncargs(mock.Mock())", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_unittest_asyncio.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_unittest_asyncio.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/unittest/test_unittest_asyncio.py", "file_name": "test_unittest_asyncio.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 25, "span_ids": ["AsyncArguments", "AsyncArguments.asyncTearDown", "AsyncArguments.test_something_async", "AsyncArguments.test_something_async_fails", "AsyncArguments.test_teardowns", "imports"], "tokens": 131}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from unittest import IsolatedAsyncioTestCase  # type: ignore\n\n\nteardowns = []\n\n\nclass AsyncArguments(IsolatedAsyncioTestCase):\n    async def asyncTearDown(self):\n        teardowns.append(None)\n\n    async def test_something_async(self):\n        async def addition(x, y):\n            return x + y\n\n        self.assertEqual(await addition(2, 2), 4)\n\n    async def test_something_async_fails(self):\n        async def addition(x, y):\n            return x + y\n\n        self.assertEqual(await addition(2, 2), 3)\n\n    def test_teardowns(self):\n        assert len(teardowns) == 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_unittest_asynctest.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/unittest/test_unittest_asynctest.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/unittest/test_unittest_asynctest.py", "file_name": "test_unittest_asynctest.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 23, "span_ids": ["Test", "Test.tearDown", "Test.test_error", "Test.test_ok", "Test.test_teardowns", "docstring"], "tokens": 87}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"Issue #7110\"\"\"\nimport asyncio\n\nimport asynctest\n\n\nteardowns = []\n\n\nclass Test(asynctest.TestCase):\n    async def tearDown(self):\n        teardowns.append(None)\n\n    async def test_error(self):\n        await asyncio.sleep(0)\n        self.fail(\"failing on purpose\")\n\n    async def test_ok(self):\n        await asyncio.sleep(0)\n\n    def test_teardowns(self):\n        assert len(teardowns) == 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_1.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_1.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_1.py", "file_name": "test_1.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 22, "span_ids": ["func", "imports", "test_bar", "test_foo", "test_foo_1"], "tokens": 68}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import warnings\n\nimport pytest\n\n\ndef func(msg):\n    warnings.warn(UserWarning(msg))\n\n\n@pytest.mark.parametrize(\"i\", range(20))\ndef test_foo(i):\n    func(\"foo\")\n\n\ndef test_foo_1():\n    func(\"foo\")\n\n\n@pytest.mark.parametrize(\"i\", range(20))\ndef test_bar(i):\n    func(\"bar\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_2.py__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_2.py__", "embedding": null, "metadata": {"file_path": "testing/example_scripts/warnings/test_group_warnings_by_message_summary/test_2.py", "file_name": "test_2.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 6, "span_ids": ["imports", "test_2"], "tokens": 16}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from test_1 import func\n\n\ndef test_2():\n    func(\"foo\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_pytest_test_exceptions.assert_s2_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_pytest_test_exceptions.assert_s2_", "embedding": null, "metadata": {"file_path": "testing/io/test_saferepr.py", "file_name": "test_saferepr.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 56, "span_ids": ["imports", "test_exceptions", "test_maxsize", "test_maxsize_error_on_instance", "test_simple_repr"], "tokens": 375}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\nfrom _pytest._io.saferepr import _pformat_dispatch\nfrom _pytest._io.saferepr import saferepr\n\n\ndef test_simple_repr():\n    assert saferepr(1) == \"1\"\n    assert saferepr(None) == \"None\"\n\n\ndef test_maxsize():\n    s = saferepr(\"x\" * 50, maxsize=25)\n    assert len(s) == 25\n    expected = repr(\"x\" * 10 + \"...\" + \"x\" * 10)\n    assert s == expected\n\n\ndef test_maxsize_error_on_instance():\n    class A:\n        def __repr__(self):\n            raise ValueError(\"...\")\n\n    s = saferepr((\"*\" * 50, A()), maxsize=25)\n    assert len(s) == 25\n    assert s[0] == \"(\" and s[-1] == \")\"\n\n\ndef test_exceptions():\n    class BrokenRepr:\n        def __init__(self, ex):\n            self.ex = ex\n\n        def __repr__(self):\n            raise self.ex\n\n    class BrokenReprException(Exception):\n        __str__ = None\n        __repr__ = None\n\n    assert \"Exception\" in saferepr(BrokenRepr(Exception(\"broken\")))\n    s = saferepr(BrokenReprException(\"really broken\"))\n    assert \"TypeError\" in s\n    assert \"TypeError\" in saferepr(BrokenRepr(\"string\"))\n\n    none = None\n    try:\n        none()\n    except BaseException as exc:\n        exp_exc = repr(exc)\n    obj = BrokenRepr(BrokenReprException(\"omg even worse\"))\n    s2 = saferepr(obj)\n    assert s2 == (\n        \"<[unpresentable exception ({!s}) raised in repr()] BrokenRepr object at 0x{:x}>\".format(\n            exp_exc, id(obj)\n        )\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_test_baseexception_test_baseexception.None_5": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_test_baseexception_test_baseexception.None_5", "embedding": null, "metadata": {"file_path": "testing/io/test_saferepr.py", "file_name": "test_saferepr.py", "file_type": "text/x-python", "category": "test", "start_line": 59, "end_line": 119, "span_ids": ["test_baseexception"], "tokens": 434}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_baseexception():\n    \"\"\"Test saferepr() with BaseExceptions, which includes pytest outcomes.\"\"\"\n\n    class RaisingOnStrRepr(BaseException):\n        def __init__(self, exc_types):\n            self.exc_types = exc_types\n\n        def raise_exc(self, *args):\n            try:\n                self.exc_type = self.exc_types.pop(0)\n            except IndexError:\n                pass\n            if hasattr(self.exc_type, \"__call__\"):\n                raise self.exc_type(*args)\n            raise self.exc_type\n\n        def __str__(self):\n            self.raise_exc(\"__str__\")\n\n        def __repr__(self):\n            self.raise_exc(\"__repr__\")\n\n    class BrokenObj:\n        def __init__(self, exc):\n            self.exc = exc\n\n        def __repr__(self):\n            raise self.exc\n\n        __str__ = __repr__\n\n    baseexc_str = BaseException(\"__str__\")\n    obj = BrokenObj(RaisingOnStrRepr([BaseException]))\n    assert saferepr(obj) == (\n        \"<[unpresentable exception ({!r}) \"\n        \"raised in repr()] BrokenObj object at 0x{:x}>\".format(baseexc_str, id(obj))\n    )\n    obj = BrokenObj(RaisingOnStrRepr([RaisingOnStrRepr([BaseException])]))\n    assert saferepr(obj) == (\n        \"<[{!r} raised in repr()] BrokenObj object at 0x{:x}>\".format(\n            baseexc_str, id(obj)\n        )\n    )\n\n    with pytest.raises(KeyboardInterrupt):\n        saferepr(BrokenObj(KeyboardInterrupt()))\n\n    with pytest.raises(SystemExit):\n        saferepr(BrokenObj(SystemExit()))\n\n    with pytest.raises(KeyboardInterrupt):\n        saferepr(BrokenObj(RaisingOnStrRepr([KeyboardInterrupt])))\n\n    with pytest.raises(SystemExit):\n        saferepr(BrokenObj(RaisingOnStrRepr([SystemExit])))\n\n    with pytest.raises(KeyboardInterrupt):\n        print(saferepr(BrokenObj(RaisingOnStrRepr([BaseException, KeyboardInterrupt]))))\n\n    with pytest.raises(SystemExit):\n        saferepr(BrokenObj(RaisingOnStrRepr([BaseException, SystemExit])))", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_test_buggy_builtin_repr_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_saferepr.py_test_buggy_builtin_repr_", "embedding": null, "metadata": {"file_path": "testing/io/test_saferepr.py", "file_name": "test_saferepr.py", "file_type": "text/x-python", "category": "test", "start_line": 122, "end_line": 174, "span_ids": ["test_big_repr", "test_broken_getattribute", "test_buggy_builtin_repr", "test_pformat_dispatch", "test_repr_on_newstyle", "test_unicode"], "tokens": 342}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_buggy_builtin_repr():\n    # Simulate a case where a repr for a builtin raises.\n    # reprlib dispatches by type name, so use \"int\".\n\n    class int:\n        def __repr__(self):\n            raise ValueError(\"Buggy repr!\")\n\n    assert \"Buggy\" in saferepr(int())\n\n\ndef test_big_repr():\n    from _pytest._io.saferepr import SafeRepr\n\n    assert len(saferepr(range(1000))) <= len(\"[\" + SafeRepr(0).maxlist * \"1000\" + \"]\")\n\n\ndef test_repr_on_newstyle():\n    class Function:\n        def __repr__(self):\n            return \"<%s>\" % (self.name)\n\n    assert saferepr(Function())\n\n\ndef test_unicode():\n    val = \"\u00a3\u20ac\"\n    reprval = \"'\u00a3\u20ac'\"\n    assert saferepr(val) == reprval\n\n\ndef test_pformat_dispatch():\n    assert _pformat_dispatch(\"a\") == \"'a'\"\n    assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n\n\ndef test_broken_getattribute():\n    \"\"\"saferepr() can create proper representations of classes with\n    broken __getattribute__ (#7145)\n    \"\"\"\n\n    class SomeClass:\n        def __getattribute__(self, attr):\n            raise RuntimeError\n\n        def __repr__(self):\n            raise RuntimeError\n\n    assert saferepr(SomeClass()).startswith(\n        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_io_win32": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_io_win32", "embedding": null, "metadata": {"file_path": "testing/io/test_terminalwriter.py", "file_name": "test_terminalwriter.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 52, "span_ids": ["impl", "imports", "test_terminal_width_COLUMNS", "test_terminalwriter_computes_width", "test_terminalwriter_dumb_term_no_markup", "test_terminalwriter_width_bogus"], "tokens": 343}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import io\nimport os\nimport re\nimport shutil\nimport sys\nfrom typing import Generator\nfrom unittest import mock\n\nimport pytest\nfrom _pytest._io import terminalwriter\nfrom _pytest.monkeypatch import MonkeyPatch\n\n\n# These tests were initially copied from py 1.8.1.\n\n\ndef test_terminal_width_COLUMNS(monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setenv(\"COLUMNS\", \"42\")\n    assert terminalwriter.get_terminal_width() == 42\n    monkeypatch.delenv(\"COLUMNS\", raising=False)\n\n\ndef test_terminalwriter_width_bogus(monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setattr(shutil, \"get_terminal_size\", mock.Mock(return_value=(10, 10)))\n    monkeypatch.delenv(\"COLUMNS\", raising=False)\n    tw = terminalwriter.TerminalWriter()\n    assert tw.fullwidth == 80\n\n\ndef test_terminalwriter_computes_width(monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setattr(terminalwriter, \"get_terminal_width\", lambda: 42)\n    tw = terminalwriter.TerminalWriter()\n    assert tw.fullwidth == 42\n\n\ndef test_terminalwriter_dumb_term_no_markup(monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setattr(os, \"environ\", {\"TERM\": \"dumb\", \"PATH\": \"\"})\n\n    class MyFile:\n        closed = False\n\n        def isatty(self):\n            return True\n\n    with monkeypatch.context() as m:\n        m.setattr(sys, \"stdout\", MyFile())\n        assert sys.stdout.isatty()\n        tw = terminalwriter.TerminalWriter()\n        assert not tw.hasmarkup\n\n\nwin32 = int(sys.platform == \"win32\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_TestTerminalWriter_TestTerminalWriter.test_attr_fullwidth": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_TestTerminalWriter_TestTerminalWriter.test_attr_fullwidth", "embedding": null, "metadata": {"file_path": "testing/io/test_terminalwriter.py", "file_name": "test_terminalwriter.py", "file_type": "text/x-python", "category": "test", "start_line": 55, "end_line": 141, "span_ids": ["TestTerminalWriter", "TestTerminalWriter.test_attr_fullwidth", "TestTerminalWriter.test_line", "TestTerminalWriter.test_line_unicode", "TestTerminalWriter.test_line_write_markup", "TestTerminalWriter.test_markup", "TestTerminalWriter.test_markup_bad", "TestTerminalWriter.test_sep_longer_than_width", "TestTerminalWriter.test_sep_no_title", "TestTerminalWriter.test_sep_with_title", "TestTerminalWriter.tw"], "tokens": 746}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminalWriter:\n    @pytest.fixture(params=[\"path\", \"stringio\"])\n    def tw(\n        self, request, tmpdir\n    ) -> Generator[terminalwriter.TerminalWriter, None, None]:\n        if request.param == \"path\":\n            p = tmpdir.join(\"tmpfile\")\n            f = open(str(p), \"w+\", encoding=\"utf8\")\n            tw = terminalwriter.TerminalWriter(f)\n\n            def getlines():\n                f.flush()\n                with open(str(p), encoding=\"utf8\") as fp:\n                    return fp.readlines()\n\n        elif request.param == \"stringio\":\n            f = io.StringIO()\n            tw = terminalwriter.TerminalWriter(f)\n\n            def getlines():\n                f.seek(0)\n                return f.readlines()\n\n        tw.getlines = getlines  # type: ignore\n        tw.getvalue = lambda: \"\".join(getlines())  # type: ignore\n\n        with f:\n            yield tw\n\n    def test_line(self, tw) -> None:\n        tw.line(\"hello\")\n        lines = tw.getlines()\n        assert len(lines) == 1\n        assert lines[0] == \"hello\\n\"\n\n    def test_line_unicode(self, tw) -> None:\n        msg = \"b\\u00f6y\"\n        tw.line(msg)\n        lines = tw.getlines()\n        assert lines[0] == msg + \"\\n\"\n\n    def test_sep_no_title(self, tw) -> None:\n        tw.sep(\"-\", fullwidth=60)\n        lines = tw.getlines()\n        assert len(lines) == 1\n        assert lines[0] == \"-\" * (60 - win32) + \"\\n\"\n\n    def test_sep_with_title(self, tw) -> None:\n        tw.sep(\"-\", \"hello\", fullwidth=60)\n        lines = tw.getlines()\n        assert len(lines) == 1\n        assert lines[0] == \"-\" * 26 + \" hello \" + \"-\" * (27 - win32) + \"\\n\"\n\n    def test_sep_longer_than_width(self, tw) -> None:\n        tw.sep(\"-\", \"a\" * 10, fullwidth=5)\n        (line,) = tw.getlines()\n        # even though the string is wider than the line, still have a separator\n        assert line == \"- aaaaaaaaaa -\\n\"\n\n    @pytest.mark.skipif(sys.platform == \"win32\", reason=\"win32 has no native ansi\")\n    @pytest.mark.parametrize(\"bold\", (True, False))\n    @pytest.mark.parametrize(\"color\", (\"red\", \"green\"))\n    def test_markup(self, tw, bold: bool, color: str) -> None:\n        text = tw.markup(\"hello\", **{color: True, \"bold\": bold})\n        assert \"hello\" in text\n\n    def test_markup_bad(self, tw) -> None:\n        with pytest.raises(ValueError):\n            tw.markup(\"x\", wronkw=3)\n        with pytest.raises(ValueError):\n            tw.markup(\"x\", wronkw=0)\n\n    def test_line_write_markup(self, tw) -> None:\n        tw.hasmarkup = True\n        tw.line(\"x\", bold=True)\n        tw.write(\"x\\n\", red=True)\n        lines = tw.getlines()\n        if sys.platform != \"win32\":\n            assert len(lines[0]) >= 2, lines\n            assert len(lines[1]) >= 2, lines\n\n    def test_attr_fullwidth(self, tw) -> None:\n        tw.sep(\"-\", \"hello\", fullwidth=70)\n        tw.fullwidth = 70\n        tw.sep(\"-\", \"hello\")\n        lines = tw.getlines()\n        assert len(lines[0]) == len(lines[1])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_test_attr_hasmarkup_test_should_do_markup_PY_COLORS_eq_0": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_test_attr_hasmarkup_test_should_do_markup_PY_COLORS_eq_0", "embedding": null, "metadata": {"file_path": "testing/io/test_terminalwriter.py", "file_name": "test_terminalwriter.py", "file_type": "text/x-python", "category": "test", "start_line": 144, "end_line": 177, "span_ids": ["test_attr_hasmarkup", "test_should_do_markup_PY_COLORS_eq_0", "test_should_do_markup_PY_COLORS_eq_1"], "tokens": 318}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.skipif(sys.platform == \"win32\", reason=\"win32 has no native ansi\")\ndef test_attr_hasmarkup() -> None:\n    file = io.StringIO()\n    tw = terminalwriter.TerminalWriter(file)\n    assert not tw.hasmarkup\n    tw.hasmarkup = True\n    tw.line(\"hello\", bold=True)\n    s = file.getvalue()\n    assert len(s) > len(\"hello\\n\")\n    assert \"\\x1b[1m\" in s\n    assert \"\\x1b[0m\" in s\n\n\ndef test_should_do_markup_PY_COLORS_eq_1(monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setitem(os.environ, \"PY_COLORS\", \"1\")\n    file = io.StringIO()\n    tw = terminalwriter.TerminalWriter(file)\n    assert tw.hasmarkup\n    tw.line(\"hello\", bold=True)\n    s = file.getvalue()\n    assert len(s) > len(\"hello\\n\")\n    assert \"\\x1b[1m\" in s\n    assert \"\\x1b[0m\" in s\n\n\ndef test_should_do_markup_PY_COLORS_eq_0(monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setitem(os.environ, \"PY_COLORS\", \"0\")\n    f = io.StringIO()\n    f.isatty = lambda: True  # type: ignore\n    tw = terminalwriter.TerminalWriter(file=f)\n    assert not tw.hasmarkup\n    tw.line(\"hello\", bold=True)\n    s = f.getvalue()\n    assert s == \"hello\\n\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_TestTerminalWriterLineWidth_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/io/test_terminalwriter.py_TestTerminalWriterLineWidth_", "embedding": null, "metadata": {"file_path": "testing/io/test_terminalwriter.py", "file_name": "test_terminalwriter.py", "file_type": "text/x-python", "category": "test", "start_line": 180, "end_line": 236, "span_ids": ["TestTerminalWriterLineWidth", "TestTerminalWriterLineWidth.test_combining", "TestTerminalWriterLineWidth.test_composed", "TestTerminalWriterLineWidth.test_init", "TestTerminalWriterLineWidth.test_update", "TestTerminalWriterLineWidth.test_update_with_newline", "TestTerminalWriterLineWidth.test_update_with_wide_text", "test_code_highlight"], "tokens": 455}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminalWriterLineWidth:\n    def test_init(self) -> None:\n        tw = terminalwriter.TerminalWriter()\n        assert tw.width_of_current_line == 0\n\n    def test_update(self) -> None:\n        tw = terminalwriter.TerminalWriter()\n        tw.write(\"hello world\")\n        assert tw.width_of_current_line == 11\n\n    def test_update_with_newline(self) -> None:\n        tw = terminalwriter.TerminalWriter()\n        tw.write(\"hello\\nworld\")\n        assert tw.width_of_current_line == 5\n\n    def test_update_with_wide_text(self) -> None:\n        tw = terminalwriter.TerminalWriter()\n        tw.write(\"\u4e47\u4e42\u3112\u5c3a\u5342 \u3112\u5344\u4e28\u531a\u531a\")\n        assert tw.width_of_current_line == 21  # 5*2 + 1 + 5*2\n\n    def test_composed(self) -> None:\n        tw = terminalwriter.TerminalWriter()\n        text = \"caf\u00e9 food\"\n        assert len(text) == 9\n        tw.write(text)\n        assert tw.width_of_current_line == 9\n\n    def test_combining(self) -> None:\n        tw = terminalwriter.TerminalWriter()\n        text = \"cafe\u0301 food\"\n        assert len(text) == 10\n        tw.write(text)\n        assert tw.width_of_current_line == 9\n\n\n@pytest.mark.parametrize(\n    \"has_markup, expected\",\n    [\n        pytest.param(\n            True, \"{kw}assert{hl-reset} {number}0{hl-reset}\\n\", id=\"with markup\"\n        ),\n        pytest.param(False, \"assert 0\\n\", id=\"no markup\"),\n    ],\n)\ndef test_code_highlight(has_markup, expected, color_mapping):\n    f = io.StringIO()\n    tw = terminalwriter.TerminalWriter(f)\n    tw.hasmarkup = has_markup\n    tw._write_source([\"assert 0\"])\n    assert f.getvalue().splitlines(keepends=True) == color_mapping.format([expected])\n\n    with pytest.raises(\n        ValueError,\n        match=re.escape(\"indents size (2) should have same size as lines (1)\"),\n    ):\n        tw._write_source([\"assert 0\"], [\" \", \" \"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_formatter.py_logging_test_coloredlogformatter.assert_output_dummyp": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_formatter.py_logging_test_coloredlogformatter.assert_output_dummyp", "embedding": null, "metadata": {"file_path": "testing/logging/test_formatter.py", "file_name": "test_formatter.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 35, "span_ids": ["imports", "test_coloredlogformatter"], "tokens": 204}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import logging\n\nfrom _pytest._io import TerminalWriter\nfrom _pytest.logging import ColoredLevelFormatter\n\n\ndef test_coloredlogformatter():\n    logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n\n    record = logging.LogRecord(\n        name=\"dummy\",\n        level=logging.INFO,\n        pathname=\"dummypath\",\n        lineno=10,\n        msg=\"Test Message\",\n        args=(),\n        exc_info=False,\n    )\n\n    class ColorConfig:\n        class option:\n            pass\n\n    tw = TerminalWriter()\n    tw.hasmarkup = True\n    formatter = ColoredLevelFormatter(tw, logfmt)\n    output = formatter.format(record)\n    assert output == (\n        \"dummypath                   10 \\x1b[32mINFO    \\x1b[0m Test Message\"\n    )\n\n    tw.hasmarkup = False\n    formatter = ColoredLevelFormatter(tw, logfmt)\n    output = formatter.format(record)\n    assert output == (\"dummypath                   10 INFO     Test Message\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_formatter.py_test_multiline_message_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_formatter.py_test_multiline_message_", "embedding": null, "metadata": {"file_path": "testing/logging/test_formatter.py", "file_name": "test_formatter.py", "file_type": "text/x-python", "category": "test", "start_line": 38, "end_line": 150, "span_ids": ["test_colored_short_level", "test_multiline_message"], "tokens": 733}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_multiline_message():\n    from _pytest.logging import PercentStyleMultiline\n\n    logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n\n    record = logging.LogRecord(\n        name=\"dummy\",\n        level=logging.INFO,\n        pathname=\"dummypath\",\n        lineno=10,\n        msg=\"Test Message line1\\nline2\",\n        args=(),\n        exc_info=False,\n    )\n    # this is called by logging.Formatter.format\n    record.message = record.getMessage()\n\n    ai_on_style = PercentStyleMultiline(logfmt, True)\n    output = ai_on_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\n\"\n        \"                                        line2\"\n    )\n\n    ai_off_style = PercentStyleMultiline(logfmt, False)\n    output = ai_off_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\nline2\"\n    )\n\n    ai_none_style = PercentStyleMultiline(logfmt, None)\n    output = ai_none_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\nline2\"\n    )\n\n    record.auto_indent = False\n    output = ai_on_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\nline2\"\n    )\n\n    record.auto_indent = True\n    output = ai_off_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\n\"\n        \"                                        line2\"\n    )\n\n    record.auto_indent = \"False\"\n    output = ai_on_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\nline2\"\n    )\n\n    record.auto_indent = \"True\"\n    output = ai_off_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\n\"\n        \"                                        line2\"\n    )\n\n    # bad string values default to False\n    record.auto_indent = \"junk\"\n    output = ai_off_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\nline2\"\n    )\n\n    # anything other than string or int will default to False\n    record.auto_indent = dict()\n    output = ai_off_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\nline2\"\n    )\n\n    record.auto_indent = \"5\"\n    output = ai_off_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\n     line2\"\n    )\n\n    record.auto_indent = 5\n    output = ai_off_style.format(record)\n    assert output == (\n        \"dummypath                   10 INFO     Test Message line1\\n     line2\"\n    )\n\n\ndef test_colored_short_level():\n    logfmt = \"%(levelname).1s %(message)s\"\n\n    record = logging.LogRecord(\n        name=\"dummy\",\n        level=logging.INFO,\n        pathname=\"dummypath\",\n        lineno=10,\n        msg=\"Test Message\",\n        args=(),\n        exc_info=False,\n    )\n\n    class ColorConfig:\n        class option:\n            pass\n\n    tw = TerminalWriter()\n    tw.hasmarkup = True\n    formatter = ColoredLevelFormatter(tw, logfmt)\n    output = formatter.format(record)\n    # the I (of INFO) is colored\n    assert output == (\"\\x1b[32mI\\x1b[0m Test Message\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_level_test_log_cli_level.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/logging/test_reporting.py_test_log_cli_level_test_log_cli_level.None_1", "embedding": null, "metadata": {"file_path": "testing/logging/test_reporting.py", "file_name": "test_reporting.py", "file_type": "text/x-python", "category": "test", "start_line": 539, "end_line": 586, "span_ids": ["test_log_cli_level"], "tokens": 355}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_log_cli_level(testdir):\n    # Default log file level\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        def test_log_cli(request):\n            plugin = request.config.pluginmanager.getplugin('logging-plugin')\n            assert plugin.log_cli_handler.level == logging.INFO\n            logging.getLogger('catchlog').debug(\"This log message won't be shown\")\n            logging.getLogger('catchlog').info(\"This log message will be shown\")\n            print('PASSED')\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        log_cli=true\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"-s\", \"--log-cli-level=INFO\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"*test_log_cli_level.py*This log message will be shown\",\n            \"PASSED\",  # 'PASSED' on its own line because the log message prints a new line\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*This log message won't be shown*\")\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0\n\n    result = testdir.runpytest(\"-s\", \"--log-level=INFO\")\n\n    # fnmatch_lines does an assertion internally\n    result.stdout.fnmatch_lines(\n        [\n            \"*test_log_cli_level.py* This log message will be shown\",\n            \"PASSED\",  # 'PASSED' on its own line because the log message prints a new line\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*This log message won't be shown*\")\n\n    # make sure that that we get a '0' exit code for the testsuite\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_operator_TestApprox.test_repr_string": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_operator_TestApprox.test_repr_string", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 56, "span_ids": ["TestApprox", "TestApprox.test_repr_string", "imports", "mocked_doctest_runner"], "tokens": 467}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import operator\nfrom decimal import Decimal\nfrom fractions import Fraction\nfrom operator import eq\nfrom operator import ne\n\nimport pytest\nfrom pytest import approx\n\ninf, nan = float(\"inf\"), float(\"nan\")\n\n\n@pytest.fixture\ndef mocked_doctest_runner(monkeypatch):\n    import doctest\n\n    class MockedPdb:\n        def __init__(self, out):\n            pass\n\n        def set_trace(self):\n            raise NotImplementedError(\"not used\")\n\n        def reset(self):\n            pass\n\n        def set_continue(self):\n            pass\n\n    monkeypatch.setattr(\"doctest._OutputRedirectingPdb\", MockedPdb)\n\n    class MyDocTestRunner(doctest.DocTestRunner):\n        def report_failure(self, out, test, example, got):\n            raise AssertionError(\n                \"'{}' evaluates to '{}', not '{}'\".format(\n                    example.source.strip(), got.strip(), example.want.strip()\n                )\n            )\n\n    return MyDocTestRunner()\n\n\nclass TestApprox:\n    def test_repr_string(self):\n        assert repr(approx(1.0)) == \"1.0 \u00b1 1.0e-06\"\n        assert repr(approx([1.0, 2.0])) == \"approx([1.0 \u00b1 1.0e-06, 2.0 \u00b1 2.0e-06])\"\n        assert repr(approx((1.0, 2.0))) == \"approx((1.0 \u00b1 1.0e-06, 2.0 \u00b1 2.0e-06))\"\n        assert repr(approx(inf)) == \"inf\"\n        assert repr(approx(1.0, rel=nan)) == \"1.0 \u00b1 ???\"\n        assert repr(approx(1.0, rel=inf)) == \"1.0 \u00b1 inf\"\n\n        # Dictionaries aren't ordered, so we need to check both orders.\n        assert repr(approx({\"a\": 1.0, \"b\": 2.0})) in (\n            \"approx({'a': 1.0 \u00b1 1.0e-06, 'b': 2.0 \u00b1 2.0e-06})\",\n            \"approx({'b': 2.0 \u00b1 2.0e-06, 'a': 1.0 \u00b1 1.0e-06})\",\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_repr_complex_numbers_TestApprox.test_repr_complex_numbers": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/approx.py_TestApprox.test_repr_complex_numbers_TestApprox.test_repr_complex_numbers", "embedding": null, "metadata": {"file_path": "testing/python/approx.py", "file_name": "approx.py", "file_type": "text/x-python", "category": "implementation", "start_line": 58, "end_line": 71, "span_ids": ["TestApprox.test_repr_complex_numbers"], "tokens": 219}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestApprox:\n\n    def test_repr_complex_numbers(self):\n        assert repr(approx(inf + 1j)) == \"(inf+1j)\"\n        assert repr(approx(1.0j, rel=inf)) == \"1j \u00b1 inf\"\n\n        # can't compute a sensible tolerance\n        assert repr(approx(nan + 1j)) == \"(nan+1j) \u00b1 ???\"\n\n        assert repr(approx(1.0j)) == \"1j \u00b1 1.0e-06 \u2220 \u00b1180\u00b0\"\n\n        # relative tolerance is scaled to |3+4j| = 5\n        assert repr(approx(3 + 4 * 1j)) == \"(3+4j) \u00b1 5.0e-06 \u2220 \u00b1180\u00b0\"\n\n        # absolute tolerance is not scaled\n        assert repr(approx(3.3 + 4.4 * 1j, abs=0.02)) == \"(3.3+4.4j) \u00b1 2.0e-02 \u2220 \u00b1180\u00b0\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_overrides_indirect_dependency_fixture_TestFunction.test_pyfunc_call": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_overrides_indirect_dependency_fixture_TestFunction.test_pyfunc_call", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 443, "end_line": 535, "span_ids": ["TestFunction.test_function_equality_with_callspec", "TestFunction.test_parametrize_overrides_indirect_dependency_fixture", "TestFunction.test_parametrize_with_empty_string_arguments", "TestFunction.test_parametrize_with_mark", "TestFunction.test_pyfunc_call"], "tokens": 624}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunction:\n\n    def test_parametrize_overrides_indirect_dependency_fixture(self, testdir):\n        \"\"\"Test parametrization when parameter overrides a fixture that a test indirectly depends on\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            fix3_instantiated = False\n\n            @pytest.fixture\n            def fix1(fix2):\n               return fix2 + '1'\n\n            @pytest.fixture\n            def fix2(fix3):\n               return fix3 + '2'\n\n            @pytest.fixture\n            def fix3():\n               global fix3_instantiated\n               fix3_instantiated = True\n               return '3'\n\n            @pytest.mark.parametrize('fix2', ['2'])\n            def test_it(fix1, fix2):\n               assert fix1 == '21'\n               assert not fix3_instantiated\n        \"\"\"\n        )\n        rec = testdir.inline_run()\n        rec.assertoutcome(passed=1)\n\n    def test_parametrize_with_mark(self, testdir):\n        items = testdir.getitems(\n            \"\"\"\n            import pytest\n            @pytest.mark.foo\n            @pytest.mark.parametrize('arg', [\n                1,\n                pytest.param(2, marks=[pytest.mark.baz, pytest.mark.bar])\n            ])\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        keywords = [item.keywords for item in items]\n        assert (\n            \"foo\" in keywords[0]\n            and \"bar\" not in keywords[0]\n            and \"baz\" not in keywords[0]\n        )\n        assert \"foo\" in keywords[1] and \"bar\" in keywords[1] and \"baz\" in keywords[1]\n\n    def test_parametrize_with_empty_string_arguments(self, testdir):\n        items = testdir.getitems(\n            \"\"\"\\\n            import pytest\n\n            @pytest.mark.parametrize('v', ('', ' '))\n            @pytest.mark.parametrize('w', ('', ' '))\n            def test(v, w): ...\n            \"\"\"\n        )\n        names = {item.name for item in items}\n        assert names == {\"test[-]\", \"test[ -]\", \"test[- ]\", \"test[ - ]\"}\n\n    def test_function_equality_with_callspec(self, testdir):\n        items = testdir.getitems(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('arg', [1,2])\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        assert items[0] != items[1]\n        assert not (items[0] == items[1])\n\n    def test_pyfunc_call(self, testdir):\n        item = testdir.getitem(\"def test_func(): raise ValueError\")\n        config = item.config\n\n        class MyPlugin1:\n            def pytest_pyfunc_call(self):\n                raise ValueError\n\n        class MyPlugin2:\n            def pytest_pyfunc_call(self):\n                return True\n\n        config.pluginmanager.register(MyPlugin1())\n        config.pluginmanager.register(MyPlugin2())\n        config.hook.pytest_runtest_setup(item=item)\n        config.hook.pytest_pyfunc_call(pyfuncitem=item)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_multiple_parametrize_TestFunction.test_parametrize_xfail": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_multiple_parametrize_TestFunction.test_parametrize_xfail", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 537, "end_line": 630, "span_ids": ["TestFunction.test_issue751_multiple_parametrize_with_ids", "TestFunction.test_multiple_parametrize", "TestFunction.test_parametrize_skip", "TestFunction.test_parametrize_skipif", "TestFunction.test_parametrize_skipif_no_skip", "TestFunction.test_parametrize_xfail"], "tokens": 719}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunction:\n\n    def test_multiple_parametrize(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('x', [0, 1])\n            @pytest.mark.parametrize('y', [2, 3])\n            def test1(x, y):\n                pass\n        \"\"\"\n        )\n        colitems = modcol.collect()\n        assert colitems[0].name == \"test1[2-0]\"\n        assert colitems[1].name == \"test1[2-1]\"\n        assert colitems[2].name == \"test1[3-0]\"\n        assert colitems[3].name == \"test1[3-1]\"\n\n    def test_issue751_multiple_parametrize_with_ids(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('x', [0], ids=['c'])\n            @pytest.mark.parametrize('y', [0, 1], ids=['a', 'b'])\n            class Test(object):\n                def test1(self, x, y):\n                    pass\n                def test2(self, x, y):\n                    pass\n        \"\"\"\n        )\n        colitems = modcol.collect()[0].collect()[0].collect()\n        assert colitems[0].name == \"test1[a-c]\"\n        assert colitems[1].name == \"test1[b-c]\"\n        assert colitems[2].name == \"test2[a-c]\"\n        assert colitems[3].name == \"test2[b-c]\"\n\n    def test_parametrize_skipif(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            m = pytest.mark.skipif('True')\n\n            @pytest.mark.parametrize('x', [0, 1, pytest.param(2, marks=m)])\n            def test_skip_if(x):\n                assert x < 2\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed, 1 skipped in *\"])\n\n    def test_parametrize_skip(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            m = pytest.mark.skip('')\n\n            @pytest.mark.parametrize('x', [0, 1, pytest.param(2, marks=m)])\n            def test_skip(x):\n                assert x < 2\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed, 1 skipped in *\"])\n\n    def test_parametrize_skipif_no_skip(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            m = pytest.mark.skipif('False')\n\n            @pytest.mark.parametrize('x', [0, 1, m(2)])\n            def test_skipif_no_skip(x):\n                assert x < 2\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 1 failed, 2 passed in *\"])\n\n    def test_parametrize_xfail(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            m = pytest.mark.xfail('True')\n\n            @pytest.mark.parametrize('x', [0, 1, pytest.param(2, marks=m)])\n            def test_xfail(x):\n                assert x < 2\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed, 1 xfailed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_passed_TestFunction.test_function_original_name": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestFunction.test_parametrize_passed_TestFunction.test_function_original_name", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 632, "end_line": 671, "span_ids": ["TestFunction.test_function_original_name", "TestFunction.test_parametrize_passed", "TestFunction.test_parametrize_xfail_passed"], "tokens": 254}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunction:\n\n    def test_parametrize_passed(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            m = pytest.mark.xfail('True')\n\n            @pytest.mark.parametrize('x', [0, 1, pytest.param(2, marks=m)])\n            def test_xfail(x):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed, 1 xpassed in *\"])\n\n    def test_parametrize_xfail_passed(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            m = pytest.mark.xfail('False')\n\n            @pytest.mark.parametrize('x', [0, 1, m(2)])\n            def test_passed(x):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 3 passed in *\"])\n\n    def test_function_original_name(self, testdir):\n        items = testdir.getitems(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('arg', [1,2])\n            def test_func(arg):\n                pass\n        \"\"\"\n        )\n        assert [x.originalname for x in items] == [\"test_func\", \"test_func\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestTracebackCutting_TestTracebackCutting.test_traceback_filter_error_during_fixture_collection.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestTracebackCutting_TestTracebackCutting.test_traceback_filter_error_during_fixture_collection.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 901, "end_line": 981, "span_ids": ["TestTracebackCutting", "TestTracebackCutting.test_skip_simple", "TestTracebackCutting.test_traceback_argsetup", "TestTracebackCutting.test_traceback_error_during_import", "TestTracebackCutting.test_traceback_filter_error_during_fixture_collection"], "tokens": 611}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTracebackCutting:\n    def test_skip_simple(self):\n        with pytest.raises(pytest.skip.Exception) as excinfo:\n            pytest.skip(\"xxx\")\n        assert excinfo.traceback[-1].frame.code.name == \"skip\"\n        assert excinfo.traceback[-1].ishidden()\n        assert excinfo.traceback[-2].frame.code.name == \"test_skip_simple\"\n        assert not excinfo.traceback[-2].ishidden()\n\n    def test_traceback_argsetup(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def hello(request):\n                raise ValueError(\"xyz\")\n        \"\"\"\n        )\n        p = testdir.makepyfile(\"def test(hello): pass\")\n        result = testdir.runpytest(p)\n        assert result.ret != 0\n        out = result.stdout.str()\n        assert \"xyz\" in out\n        assert \"conftest.py:5: ValueError\" in out\n        numentries = out.count(\"_ _ _\")  # separator for traceback entries\n        assert numentries == 0\n\n        result = testdir.runpytest(\"--fulltrace\", p)\n        out = result.stdout.str()\n        assert \"conftest.py:5: ValueError\" in out\n        numentries = out.count(\"_ _ _ _\")  # separator for traceback entries\n        assert numentries > 3\n\n    def test_traceback_error_during_import(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            x = 1\n            x = 2\n            x = 17\n            asd\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret != 0\n        out = result.stdout.str()\n        assert \"x = 1\" not in out\n        assert \"x = 2\" not in out\n        result.stdout.fnmatch_lines([\" *asd*\", \"E*NameError*\"])\n        result = testdir.runpytest(\"--fulltrace\")\n        out = result.stdout.str()\n        assert \"x = 1\" in out\n        assert \"x = 2\" in out\n        result.stdout.fnmatch_lines([\">*asd*\", \"E*NameError*\"])\n\n    def test_traceback_filter_error_during_fixture_collection(self, testdir):\n        \"\"\"integration test for issue #995.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def fail_me(func):\n                ns = {}\n                exec('def w(): raise ValueError(\"fail me\")', ns)\n                return ns['w']\n\n            @pytest.fixture(scope='class')\n            @fail_me\n            def fail_fixture():\n                pass\n\n            def test_failing_fixture(fail_fixture):\n               pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret != 0\n        out = result.stdout.str()\n        assert \"INTERNALERROR>\" not in out\n        result.stdout.fnmatch_lines([\"*ValueError: fail me*\", \"* 1 error in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestTracebackCutting.test_filter_traceback_generated_code_TestTracebackCutting.test_filter_traceback_path_no_longer_valid.assert_filter_traceback_t": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/collect.py_TestTracebackCutting.test_filter_traceback_generated_code_TestTracebackCutting.test_filter_traceback_path_no_longer_valid.assert_filter_traceback_t", "embedding": null, "metadata": {"file_path": "testing/python/collect.py", "file_name": "collect.py", "file_type": "text/x-python", "category": "implementation", "start_line": 983, "end_line": 1029, "span_ids": ["TestTracebackCutting.test_filter_traceback_generated_code", "TestTracebackCutting.test_filter_traceback_path_no_longer_valid"], "tokens": 348}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTracebackCutting:\n\n    def test_filter_traceback_generated_code(self):\n        \"\"\"test that filter_traceback() works with the fact that\n        _pytest._code.code.Code.path attribute might return an str object.\n        In this case, one of the entries on the traceback was produced by\n        dynamically generated code.\n        See: https://bitbucket.org/pytest-dev/py/issues/71\n        This fixes #995.\n        \"\"\"\n        from _pytest.python import filter_traceback\n\n        try:\n            ns = {}\n            exec(\"def foo(): raise ValueError\", ns)\n            ns[\"foo\"]()\n        except ValueError:\n            _, _, tb = sys.exc_info()\n\n        tb = _pytest._code.Traceback(tb)\n        assert isinstance(tb[-1].path, str)\n        assert not filter_traceback(tb[-1])\n\n    def test_filter_traceback_path_no_longer_valid(self, testdir):\n        \"\"\"test that filter_traceback() works with the fact that\n        _pytest._code.code.Code.path attribute might return an str object.\n        In this case, one of the files in the traceback no longer exists.\n        This fixes #1133.\n        \"\"\"\n        from _pytest.python import filter_traceback\n\n        testdir.syspathinsert()\n        testdir.makepyfile(\n            filter_traceback_entry_as_str=\"\"\"\n            def foo():\n                raise ValueError\n        \"\"\"\n        )\n        try:\n            import filter_traceback_entry_as_str\n\n            filter_traceback_entry_as_str.foo()\n        except ValueError:\n            _, _, tb = sys.exc_info()\n\n        testdir.tmpdir.join(\"filter_traceback_entry_as_str.py\").remove()\n        tb = _pytest._code.Traceback(tb)\n        assert isinstance(tb[-1].path, str)\n        assert filter_traceback(tb[-1])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages_TestFixtureUsages.test_invalid_scope": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages_TestFixtureUsages.test_invalid_scope", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1003, "end_line": 1103, "span_ids": ["TestFixtureUsages", "TestFixtureUsages.test_invalid_scope", "TestFixtureUsages.test_noargfixturedec", "TestFixtureUsages.test_receives_funcargs", "TestFixtureUsages.test_receives_funcargs_scope_mismatch", "TestFixtureUsages.test_receives_funcargs_scope_mismatch_issue660"], "tokens": 598}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureUsages:\n    def test_noargfixturedec(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def arg1():\n                return 1\n\n            def test_func(arg1):\n                assert arg1 == 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_receives_funcargs(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture()\n            def arg1():\n                return 1\n\n            @pytest.fixture()\n            def arg2(arg1):\n                return arg1 + 1\n\n            def test_add(arg2):\n                assert arg2 == 2\n            def test_all(arg1, arg2):\n                assert arg1 == 1\n                assert arg2 == 2\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_receives_funcargs_scope_mismatch(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=\"function\")\n            def arg1():\n                return 1\n\n            @pytest.fixture(scope=\"module\")\n            def arg2(arg1):\n                return arg1 + 1\n\n            def test_add(arg2):\n                assert arg2 == 2\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*ScopeMismatch*involved factories*\",\n                \"test_receives_funcargs_scope_mismatch.py:6:  def arg2(arg1)\",\n                \"test_receives_funcargs_scope_mismatch.py:2:  def arg1()\",\n                \"*1 error*\",\n            ]\n        )\n\n    def test_receives_funcargs_scope_mismatch_issue660(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=\"function\")\n            def arg1():\n                return 1\n\n            @pytest.fixture(scope=\"module\")\n            def arg2(arg1):\n                return arg1 + 1\n\n            def test_add(arg1, arg2):\n                assert arg2 == 2\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\"*ScopeMismatch*involved factories*\", \"* def arg2*\", \"*1 error*\"]\n        )\n\n    def test_invalid_scope(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=\"functions\")\n            def badscope():\n                pass\n\n            def test_nothing(badscope):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest_inprocess()\n        result.stdout.fnmatch_lines(\n            \"*Fixture 'badscope' from test_invalid_scope.py got an unexpected scope value 'functions'\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages.test_parameters_without_eq_semantics_TestFixtureUsages.test_usefixtures_marker": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages.test_parameters_without_eq_semantics_TestFixtureUsages.test_usefixtures_marker", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1105, "end_line": 1225, "span_ids": ["TestFixtureUsages.test_factory_setup_as_classes_fails", "TestFixtureUsages.test_factory_uses_unknown_funcarg_as_dependency_error", "TestFixtureUsages.test_funcarg_parametrized_and_used_twice", "TestFixtureUsages.test_parameters_without_eq_semantics", "TestFixtureUsages.test_usefixtures_marker"], "tokens": 690}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureUsages:\n\n    @pytest.mark.parametrize(\"scope\", [\"function\", \"session\"])\n    def test_parameters_without_eq_semantics(self, scope, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class NoEq1:  # fails on `a == b` statement\n                def __eq__(self, _):\n                    raise RuntimeError\n\n            class NoEq2:  # fails on `if a == b:` statement\n                def __eq__(self, _):\n                    class NoBool:\n                        def __bool__(self):\n                            raise RuntimeError\n                    return NoBool()\n\n            import pytest\n            @pytest.fixture(params=[NoEq1(), NoEq2()], scope={scope!r})\n            def no_eq(request):\n                return request.param\n\n            def test1(no_eq):\n                pass\n\n            def test2(no_eq):\n                pass\n        \"\"\".format(\n                scope=scope\n            )\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*4 passed*\"])\n\n    def test_funcarg_parametrized_and_used_twice(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            @pytest.fixture(params=[1,2])\n            def arg1(request):\n                values.append(1)\n                return request.param\n\n            @pytest.fixture()\n            def arg2(arg1):\n                return arg1 + 1\n\n            def test_add(arg1, arg2):\n                assert arg2 == arg1 + 1\n                assert len(values) == arg1\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*2 passed*\"])\n\n    def test_factory_uses_unknown_funcarg_as_dependency_error(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture()\n            def fail(missing):\n                return\n\n            @pytest.fixture()\n            def call_fail(fail):\n                return\n\n            def test_missing(call_fail):\n                pass\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *pytest.fixture()*\n            *def call_fail(fail)*\n            *pytest.fixture()*\n            *def fail*\n            *fixture*'missing'*not found*\n        \"\"\"\n        )\n\n    def test_factory_setup_as_classes_fails(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            class arg1(object):\n                def __init__(self, request):\n                    self.x = 1\n            arg1 = pytest.fixture()(arg1)\n\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        values = reprec.getfailedcollections()\n        assert len(values) == 1\n\n    def test_usefixtures_marker(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            values = []\n\n            @pytest.fixture(scope=\"class\")\n            def myfix(request):\n                request.cls.hello = \"world\"\n                values.append(1)\n\n            class TestClass(object):\n                def test_one(self):\n                    assert self.hello == \"world\"\n                    assert len(values) == 1\n                def test_two(self):\n                    assert self.hello == \"world\"\n                    assert len(values) == 1\n            pytest.mark.usefixtures(\"myfix\")(TestClass)\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages.test_usefixtures_ini_TestFixtureUsages.test_setup_functions_as_fixtures.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureUsages.test_usefixtures_ini_TestFixtureUsages.test_setup_functions_as_fixtures.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1227, "end_line": 1347, "span_ids": ["TestFixtureUsages.test_fixture_parametrized_with_iterator", "TestFixtureUsages.test_request_instance_issue203", "TestFixtureUsages.test_setup_functions_as_fixtures", "TestFixtureUsages.test_usefixtures_ini", "TestFixtureUsages.test_usefixtures_seen_in_showmarkers"], "tokens": 643}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureUsages:\n\n    def test_usefixtures_ini(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            usefixtures = myfix\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"class\")\n            def myfix(request):\n                request.cls.hello = \"world\"\n\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            class TestClass(object):\n                def test_one(self):\n                    assert self.hello == \"world\"\n                def test_two(self):\n                    assert self.hello == \"world\"\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)\n\n    def test_usefixtures_seen_in_showmarkers(self, testdir):\n        result = testdir.runpytest(\"--markers\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *usefixtures(fixturename1*mark tests*fixtures*\n        \"\"\"\n        )\n\n    def test_request_instance_issue203(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            class TestClass(object):\n                @pytest.fixture\n                def setup1(self, request):\n                    assert self == request.instance\n                    self.arg1 = 1\n                def test_hello(self, setup1):\n                    assert self.arg1 == 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_fixture_parametrized_with_iterator(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            values = []\n            def f():\n                yield 1\n                yield 2\n            dec = pytest.fixture(scope=\"module\", params=f())\n\n            @dec\n            def arg(request):\n                return request.param\n            @dec\n            def arg2(request):\n                return request.param\n\n            def test_1(arg):\n                values.append(arg)\n            def test_2(arg2):\n                values.append(arg2*10)\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-v\")\n        reprec.assertoutcome(passed=4)\n        values = reprec.getcalls(\"pytest_runtest_call\")[0].item.module.values\n        assert values == [1, 2, 10, 20]\n\n    def test_setup_functions_as_fixtures(self, testdir):\n        \"\"\"Ensure setup_* methods obey fixture scope rules (#517, #3094).\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            DB_INITIALIZED = None\n\n            @pytest.yield_fixture(scope=\"session\", autouse=True)\n            def db():\n                global DB_INITIALIZED\n                DB_INITIALIZED = True\n                yield\n                DB_INITIALIZED = False\n\n            def setup_module():\n                assert DB_INITIALIZED\n\n            def teardown_module():\n                assert DB_INITIALIZED\n\n            class TestClass(object):\n\n                def setup_method(self, method):\n                    assert DB_INITIALIZED\n\n                def teardown_method(self, method):\n                    assert DB_INITIALIZED\n\n                def test_printer_1(self):\n                    pass\n\n                def test_printer_2(self):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 2 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrized_fixture_teardown_order_TestFixtureMarker.test_parametrized_fixture_teardown_order.result_stdout_no_fnmatch_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestFixtureMarker.test_parametrized_fixture_teardown_order_TestFixtureMarker.test_parametrized_fixture_teardown_order.result_stdout_no_fnmatch_", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 2643, "end_line": 2682, "span_ids": ["TestFixtureMarker.test_parametrized_fixture_teardown_order"], "tokens": 239}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFixtureMarker:\n\n    def test_parametrized_fixture_teardown_order(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(params=[1,2], scope=\"class\")\n            def param1(request):\n                return request.param\n\n            values = []\n\n            class TestClass(object):\n                @classmethod\n                @pytest.fixture(scope=\"class\", autouse=True)\n                def setup1(self, request, param1):\n                    values.append(1)\n                    request.addfinalizer(self.teardown1)\n                @classmethod\n                def teardown1(self):\n                    assert values.pop() == 1\n                @pytest.fixture(scope=\"class\", autouse=True)\n                def setup2(self, request, param1):\n                    values.append(2)\n                    request.addfinalizer(self.teardown2)\n                @classmethod\n                def teardown2(self):\n                    assert values.pop() == 2\n                def test(self):\n                    pass\n\n            def test_finish():\n                assert not values\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *3 passed*\n        \"\"\"\n        )\n        result.stdout.no_fnmatch_line(\"*error*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestParameterizedSubRequest.test_non_relative_path_TestParameterizedSubRequest.test_non_relative_path.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_TestParameterizedSubRequest.test_non_relative_path_TestParameterizedSubRequest.test_non_relative_path.None_6", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 3660, "end_line": 3719, "span_ids": ["TestParameterizedSubRequest.test_non_relative_path"], "tokens": 371}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestParameterizedSubRequest:\n\n    def test_non_relative_path(self, testdir):\n        tests_dir = testdir.mkdir(\"tests\")\n        fixdir = testdir.mkdir(\"fixtures\")\n        fixfile = fixdir.join(\"fix.py\")\n        fixfile.write(\n            textwrap.dedent(\n                \"\"\"\\\n                import pytest\n\n                @pytest.fixture(params=[0, 1, 2])\n                def fix_with_param(request):\n                    return request.param\n                \"\"\"\n            )\n        )\n\n        testfile = tests_dir.join(\"test_foos.py\")\n        testfile.write(\n            textwrap.dedent(\n                \"\"\"\\\n                from fix import fix_with_param\n\n                def test_foo(request):\n                    request.getfixturevalue('fix_with_param')\n                \"\"\"\n            )\n        )\n\n        tests_dir.chdir()\n        testdir.syspathinsert(fixdir)\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"The requested fixture has no parameter defined for test:\",\n                \"    test_foos.py::test_foo\",\n                \"\",\n                \"Requested fixture 'fix_with_param' defined in:\",\n                \"{}:4\".format(fixfile),\n                \"Requested here:\",\n                \"test_foos.py:4\",\n                \"*1 failed*\",\n            ]\n        )\n\n        # With non-overlapping rootdir, passing tests_dir.\n        rootdir = testdir.mkdir(\"rootdir\")\n        rootdir.chdir()\n        result = testdir.runpytest(\"--rootdir\", rootdir, tests_dir)\n        result.stdout.fnmatch_lines(\n            [\n                \"The requested fixture has no parameter defined for test:\",\n                \"    test_foos.py::test_foo\",\n                \"\",\n                \"Requested fixture 'fix_with_param' defined in:\",\n                \"{}:4\".format(fixfile),\n                \"Requested here:\",\n                \"{}:4\".format(testfile),\n                \"*1 failed*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_named_request_test_fixture_duplicated_arguments.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_named_request_test_fixture_duplicated_arguments.None_1", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 4147, "end_line": 4193, "span_ids": ["test_fixture_duplicated_arguments", "test_fixture_named_request"], "tokens": 273}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fixture_named_request(testdir):\n    testdir.copy_example(\"fixtures/test_fixture_named_request.py\")\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*'request' is a reserved word for fixtures, use another name:\",\n            \"  *test_fixture_named_request.py:5\",\n        ]\n    )\n\n\ndef test_fixture_duplicated_arguments() -> None:\n    \"\"\"Raise error if there are positional and keyword arguments for the same parameter (#1682).\"\"\"\n    with pytest.raises(TypeError) as excinfo:\n\n        @pytest.fixture(\"session\", scope=\"session\")\n        def arg(arg):\n            pass\n\n    assert (\n        str(excinfo.value)\n        == \"The fixture arguments are defined as positional and keyword: scope. \"\n        \"Use only keyword arguments.\"\n    )\n\n    with pytest.raises(TypeError) as excinfo:\n\n        @pytest.fixture(\n            \"function\",\n            [\"p1\"],\n            True,\n            [\"id1\"],\n            \"name\",\n            scope=\"session\",\n            params=[\"p1\"],\n            autouse=True,\n            ids=[\"id1\"],\n            name=\"name\",\n        )\n        def arg2(request):\n            pass\n\n    assert (\n        str(excinfo.value)\n        == \"The fixture arguments are defined as positional and keyword: scope, params, autouse, ids, name. \"\n        \"Use only keyword arguments.\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_with_positionals_test_fixture_with_too_many_positionals": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_with_positionals_test_fixture_with_too_many_positionals", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 4196, "end_line": 4222, "span_ids": ["test_fixture_with_positionals", "test_fixture_with_too_many_positionals"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fixture_with_positionals() -> None:\n    \"\"\"Raise warning, but the positionals should still works (#1682).\"\"\"\n    from _pytest.deprecated import FIXTURE_POSITIONAL_ARGUMENTS\n\n    with pytest.warns(pytest.PytestDeprecationWarning) as warnings:\n\n        @pytest.fixture(\"function\", [0], True)\n        def fixture_with_positionals():\n            pass\n\n    assert str(warnings[0].message) == str(FIXTURE_POSITIONAL_ARGUMENTS)\n\n    assert fixture_with_positionals._pytestfixturefunction.scope == \"function\"\n    assert fixture_with_positionals._pytestfixturefunction.params == (0,)\n    assert fixture_with_positionals._pytestfixturefunction.autouse\n\n\ndef test_fixture_with_too_many_positionals() -> None:\n    with pytest.raises(TypeError) as excinfo:\n\n        @pytest.fixture(\"function\", [0], True, [\"id\"], \"name\", \"extra\")\n        def fixture_with_positionals():\n            pass\n\n    assert (\n        str(excinfo.value) == \"fixture() takes 5 positional arguments but 6 were given\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_indirect_fixture_does_not_break_scope_test_fixture_parametrization_nparray": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_indirect_fixture_does_not_break_scope_test_fixture_parametrization_nparray", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 4225, "end_line": 4293, "span_ids": ["test_fixture_parametrization_nparray", "test_indirect_fixture_does_not_break_scope"], "tokens": 420}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_indirect_fixture_does_not_break_scope(testdir):\n    \"\"\"Ensure that fixture scope is respected when using indirect fixtures (#570)\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        instantiated  = []\n\n        @pytest.fixture(scope=\"session\")\n        def fixture_1(request):\n            instantiated.append((\"fixture_1\", request.param))\n\n\n        @pytest.fixture(scope=\"session\")\n        def fixture_2(request):\n            instantiated.append((\"fixture_2\", request.param))\n\n\n        scenarios = [\n            (\"A\", \"a1\"),\n            (\"A\", \"a2\"),\n            (\"B\", \"b1\"),\n            (\"B\", \"b2\"),\n            (\"C\", \"c1\"),\n            (\"C\", \"c2\"),\n        ]\n\n        @pytest.mark.parametrize(\n            \"fixture_1,fixture_2\", scenarios, indirect=[\"fixture_1\", \"fixture_2\"]\n        )\n        def test_create_fixtures(fixture_1, fixture_2):\n            pass\n\n\n        def test_check_fixture_instantiations():\n            assert instantiated == [\n                ('fixture_1', 'A'),\n                ('fixture_2', 'a1'),\n                ('fixture_2', 'a2'),\n                ('fixture_1', 'B'),\n                ('fixture_2', 'b1'),\n                ('fixture_2', 'b2'),\n                ('fixture_1', 'C'),\n                ('fixture_2', 'c1'),\n                ('fixture_2', 'c2'),\n            ]\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(passed=7)\n\n\ndef test_fixture_parametrization_nparray(testdir):\n    pytest.importorskip(\"numpy\")\n\n    testdir.makepyfile(\n        \"\"\"\n        from numpy import linspace\n        from pytest import fixture\n\n        @fixture(params=linspace(1, 10, 10))\n        def value(request):\n            return request.param\n\n        def test_bug(value):\n            assert value == value\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(passed=10)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_arg_ordering_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/fixtures.py_test_fixture_arg_ordering_", "embedding": null, "metadata": {"file_path": "testing/python/fixtures.py", "file_name": "fixtures.py", "file_type": "text/x-python", "category": "implementation", "start_line": 4296, "end_line": 4349, "span_ids": ["test_fixture_arg_ordering", "test_yield_fixture_with_no_value"], "tokens": 387}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_fixture_arg_ordering(testdir):\n    \"\"\"\n    This test describes how fixtures in the same scope but without explicit dependencies\n    between them are created. While users should make dependencies explicit, often\n    they rely on this order, so this test exists to catch regressions in this regard.\n    See #6540 and #6492.\n    \"\"\"\n    p1 = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        suffixes = []\n\n        @pytest.fixture\n        def fix_1(): suffixes.append(\"fix_1\")\n        @pytest.fixture\n        def fix_2(): suffixes.append(\"fix_2\")\n        @pytest.fixture\n        def fix_3(): suffixes.append(\"fix_3\")\n        @pytest.fixture\n        def fix_4(): suffixes.append(\"fix_4\")\n        @pytest.fixture\n        def fix_5(): suffixes.append(\"fix_5\")\n\n        @pytest.fixture\n        def fix_combined(fix_1, fix_2, fix_3, fix_4, fix_5): pass\n\n        def test_suffix(fix_combined):\n            assert suffixes == [\"fix_1\", \"fix_2\", \"fix_3\", \"fix_4\", \"fix_5\"]\n        \"\"\"\n    )\n    result = testdir.runpytest(\"-vv\", str(p1))\n    assert result.ret == 0\n\n\ndef test_yield_fixture_with_no_value(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture(name='custom')\n        def empty_yield():\n            if False:\n                yield\n\n        def test_fixt(custom):\n            pass\n        \"\"\"\n    )\n    expected = \"E               ValueError: custom did not yield a value\"\n    result = testdir.runpytest()\n    result.assert_outcomes(error=1)\n    result.stdout.fnmatch_lines([expected])\n    assert result.ret == ExitCode.TESTS_FAILED", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_itertools_TestMetafunc.test_parametrize_error": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_itertools_TestMetafunc.test_parametrize_error", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 78, "span_ids": ["TestMetafunc", "TestMetafunc.Metafunc", "TestMetafunc.test_function_basic", "TestMetafunc.test_no_funcargs", "TestMetafunc.test_parametrize_error", "imports"], "tokens": 538}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import itertools\nimport re\nimport sys\nimport textwrap\nfrom typing import Any\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n\nimport attr\nimport hypothesis\nfrom hypothesis import strategies\n\nimport pytest\nfrom _pytest import fixtures\nfrom _pytest import python\nfrom _pytest.outcomes import fail\nfrom _pytest.pytester import Testdir\nfrom _pytest.python import _idval\n\n\nclass TestMetafunc:\n    def Metafunc(self, func, config=None) -> python.Metafunc:\n        # the unit tests of this class check if things work correctly\n        # on the funcarg level, so we don't need a full blown\n        # initialization\n        class FuncFixtureInfoMock:\n            name2fixturedefs = None\n\n            def __init__(self, names):\n                self.names_closure = names\n\n        @attr.s\n        class DefinitionMock(python.FunctionDefinition):\n            obj = attr.ib()\n\n            def listchain(self):\n                return []\n\n        names = fixtures.getfuncargnames(func)\n        fixtureinfo = FuncFixtureInfoMock(names)  # type: Any\n        definition = DefinitionMock._create(func)  # type: Any\n        return python.Metafunc(definition, fixtureinfo, config)\n\n    def test_no_funcargs(self) -> None:\n        def function():\n            pass\n\n        metafunc = self.Metafunc(function)\n        assert not metafunc.fixturenames\n        repr(metafunc._calls)\n\n    def test_function_basic(self) -> None:\n        def func(arg1, arg2=\"qwe\"):\n            pass\n\n        metafunc = self.Metafunc(func)\n        assert len(metafunc.fixturenames) == 1\n        assert \"arg1\" in metafunc.fixturenames\n        assert metafunc.function is func\n        assert metafunc.cls is None\n\n    def test_parametrize_error(self) -> None:\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x\", [1, 2])\n        pytest.raises(ValueError, lambda: metafunc.parametrize(\"x\", [5, 6]))\n        pytest.raises(ValueError, lambda: metafunc.parametrize(\"x\", [5, 6]))\n        metafunc.parametrize(\"y\", [1, 2])\n        pytest.raises(ValueError, lambda: metafunc.parametrize(\"y\", [5, 6]))\n        pytest.raises(ValueError, lambda: metafunc.parametrize(\"y\", [5, 6]))\n\n        with pytest.raises(TypeError, match=\"^ids must be a callable or an iterable$\"):\n            metafunc.parametrize(\"y\", [5, 6], ids=42)  # type: ignore[arg-type] # noqa: F821", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_error_iterator_TestMetafunc.test_parametrize_request_name": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_error_iterator_TestMetafunc.test_parametrize_request_name", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 80, "end_line": 132, "span_ids": ["TestMetafunc.test_parametrize_bad_scope", "TestMetafunc.test_parametrize_error_iterator", "TestMetafunc.test_parametrize_request_name"], "tokens": 429}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_error_iterator(self) -> None:\n        def func(x):\n            raise NotImplementedError()\n\n        class Exc(Exception):\n            def __repr__(self):\n                return \"Exc(from_gen)\"\n\n        def gen() -> Iterator[Union[int, None, Exc]]:\n            yield 0\n            yield None\n            yield Exc()\n\n        metafunc = self.Metafunc(func)\n        # When the input is an iterator, only len(args) are taken,\n        # so the bad Exc isn't reached.\n        metafunc.parametrize(\"x\", [1, 2], ids=gen())  # type: ignore[arg-type] # noqa: F821\n        assert [(x.funcargs, x.id) for x in metafunc._calls] == [\n            ({\"x\": 1}, \"0\"),\n            ({\"x\": 2}, \"2\"),\n        ]\n        with pytest.raises(\n            fail.Exception,\n            match=(\n                r\"In func: ids must be list of string/float/int/bool, found:\"\n                r\" Exc\\(from_gen\\) \\(type: <class .*Exc'>\\) at index 2\"\n            ),\n        ):\n            metafunc.parametrize(\"x\", [1, 2, 3], ids=gen())  # type: ignore[arg-type] # noqa: F821\n\n    def test_parametrize_bad_scope(self) -> None:\n        def func(x):\n            pass\n\n        metafunc = self.Metafunc(func)\n        with pytest.raises(\n            fail.Exception,\n            match=r\"parametrize\\(\\) call in func got an unexpected scope value 'doggy'\",\n        ):\n            metafunc.parametrize(\"x\", [1], scope=\"doggy\")\n\n    def test_parametrize_request_name(self, testdir: Testdir) -> None:\n        \"\"\"Show proper error  when 'request' is used as a parameter name in parametrize (#6183)\"\"\"\n\n        def func(request):\n            raise NotImplementedError()\n\n        metafunc = self.Metafunc(func)\n        with pytest.raises(\n            fail.Exception,\n            match=r\"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n        ):\n            metafunc.parametrize(\"request\", [1])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_and_id_TestMetafunc.test_parametrize_with_userobjects": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_and_id_TestMetafunc.test_parametrize_with_userobjects", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 180, "end_line": 269, "span_ids": ["TestMetafunc.test_parametrize_and_id", "TestMetafunc.test_parametrize_and_id_unicode", "TestMetafunc.test_parametrize_empty_list", "TestMetafunc.test_parametrize_ids_iterator_without_mark", "TestMetafunc.test_parametrize_with_userobjects", "TestMetafunc.test_parametrize_with_wrong_number_of_ids"], "tokens": 712}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_and_id(self) -> None:\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n\n        metafunc.parametrize(\"x\", [1, 2], ids=[\"basic\", \"advanced\"])\n        metafunc.parametrize(\"y\", [\"abc\", \"def\"])\n        ids = [x.id for x in metafunc._calls]\n        assert ids == [\"basic-abc\", \"basic-def\", \"advanced-abc\", \"advanced-def\"]\n\n    def test_parametrize_and_id_unicode(self) -> None:\n        \"\"\"Allow unicode strings for \"ids\" parameter in Python 2 (##1905)\"\"\"\n\n        def func(x):\n            pass\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x\", [1, 2], ids=[\"basic\", \"advanced\"])\n        ids = [x.id for x in metafunc._calls]\n        assert ids == [\"basic\", \"advanced\"]\n\n    def test_parametrize_with_wrong_number_of_ids(self) -> None:\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n\n        with pytest.raises(fail.Exception):\n            metafunc.parametrize(\"x\", [1, 2], ids=[\"basic\"])\n\n        with pytest.raises(fail.Exception):\n            metafunc.parametrize(\n                (\"x\", \"y\"), [(\"abc\", \"def\"), (\"ghi\", \"jkl\")], ids=[\"one\"]\n            )\n\n    def test_parametrize_ids_iterator_without_mark(self) -> None:\n        def func(x, y):\n            pass\n\n        it = itertools.count()\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x\", [1, 2], ids=it)\n        metafunc.parametrize(\"y\", [3, 4], ids=it)\n        ids = [x.id for x in metafunc._calls]\n        assert ids == [\"0-2\", \"0-3\", \"1-2\", \"1-3\"]\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x\", [1, 2], ids=it)\n        metafunc.parametrize(\"y\", [3, 4], ids=it)\n        ids = [x.id for x in metafunc._calls]\n        assert ids == [\"4-6\", \"4-7\", \"5-6\", \"5-7\"]\n\n    def test_parametrize_empty_list(self) -> None:\n        \"\"\"#510\"\"\"\n\n        def func(y):\n            pass\n\n        class MockConfig:\n            def getini(self, name):\n                return \"\"\n\n            @property\n            def hook(self):\n                return self\n\n            def pytest_make_parametrize_id(self, **kw):\n                pass\n\n        metafunc = self.Metafunc(func, MockConfig())\n        metafunc.parametrize(\"y\", [])\n        assert \"skip\" == metafunc._calls[0].marks[0].name\n\n    def test_parametrize_with_userobjects(self) -> None:\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n\n        class A:\n            pass\n\n        metafunc.parametrize(\"x\", [A(), A()])\n        metafunc.parametrize(\"y\", list(\"ab\"))\n        assert metafunc._calls[0].id == \"x0-a\"\n        assert metafunc._calls[1].id == \"x0-b\"\n        assert metafunc._calls[2].id == \"x1-a\"\n        assert metafunc._calls[3].id == \"x1-b\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idval_hypothesis_TestMetafunc.test_unicode_idval": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idval_hypothesis_TestMetafunc.test_unicode_idval", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 271, "end_line": 298, "span_ids": ["TestMetafunc.test_idval_hypothesis", "TestMetafunc.test_unicode_idval"], "tokens": 364}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    @hypothesis.given(strategies.text() | strategies.binary())\n    @hypothesis.settings(\n        deadline=400.0\n    )  # very close to std deadline and CI boxes are not reliable in CPU power\n    def test_idval_hypothesis(self, value) -> None:\n        escaped = _idval(value, \"a\", 6, None, item=None, config=None)\n        assert isinstance(escaped, str)\n        escaped.encode(\"ascii\")\n\n    def test_unicode_idval(self) -> None:\n        \"\"\"This tests that Unicode strings outside the ASCII character set get\n        escaped, using byte escapes if they're in that range or unicode\n        escapes if they're not.\n\n        \"\"\"\n        values = [\n            (\"\", \"\"),\n            (\"ascii\", \"ascii\"),\n            (\"a\u00e7\u00e3o\", \"a\\\\xe7\\\\xe3o\"),\n            (\"jos\u00e9@blah.com\", \"jos\\\\xe9@blah.com\"),\n            (\n                \"\u03b4\u03bf\u03ba.\u03b9\u03bc\u03ae@\u03c0\u03b1\u03c1\u03ac\u03b4\u03b5\u03b9\u03b3\u03bc\u03b1.\u03b4\u03bf\u03ba\u03b9\u03bc\u03ae\",\n                \"\\\\u03b4\\\\u03bf\\\\u03ba.\\\\u03b9\\\\u03bc\\\\u03ae@\\\\u03c0\\\\u03b1\\\\u03c1\\\\u03ac\\\\u03b4\\\\u03b5\\\\u03b9\\\\u03b3\"\n                \"\\\\u03bc\\\\u03b1.\\\\u03b4\\\\u03bf\\\\u03ba\\\\u03b9\\\\u03bc\\\\u03ae\",\n            ),\n        ]\n        for val, expected in values:\n            assert _idval(val, \"a\", 6, None, item=None, config=None) == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_unicode_idval_with_config_TestMetafunc.test_unicode_idval_with_config.for_val_config_expected": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_unicode_idval_with_config_TestMetafunc.test_unicode_idval_with_config.for_val_config_expected", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 300, "end_line": 328, "span_ids": ["TestMetafunc.test_unicode_idval_with_config"], "tokens": 204}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_unicode_idval_with_config(self) -> None:\n        \"\"\"unittest for expected behavior to obtain ids with\n        disable_test_id_escaping_and_forfeit_all_rights_to_community_support\n        option. (#5294)\n        \"\"\"\n\n        class MockConfig:\n            def __init__(self, config):\n                self.config = config\n\n            @property\n            def hook(self):\n                return self\n\n            def pytest_make_parametrize_id(self, **kw):\n                pass\n\n            def getini(self, name):\n                return self.config[name]\n\n        option = \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\"\n\n        values = [\n            (\"a\u00e7\u00e3o\", MockConfig({option: True}), \"a\u00e7\u00e3o\"),\n            (\"a\u00e7\u00e3o\", MockConfig({option: False}), \"a\\\\xe7\\\\xe3o\"),\n        ]  # type: List[Tuple[str, Any, str]]\n        for val, config, expected in values:\n            actual = _idval(val, \"a\", 6, None, item=None, config=config)\n            assert actual == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_bytes_idval_TestMetafunc.test_idmaker_with_bytes_regex": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_bytes_idval_TestMetafunc.test_idmaker_with_bytes_regex", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 330, "end_line": 382, "span_ids": ["TestMetafunc.test_bytes_idval", "TestMetafunc.test_class_or_function_idval", "TestMetafunc.test_idmaker_autoname", "TestMetafunc.test_idmaker_with_bytes_regex"], "tokens": 514}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_bytes_idval(self) -> None:\n        \"\"\"unittest for the expected behavior to obtain ids for parametrized\n        bytes values:\n        - python2: non-ascii strings are considered bytes and formatted using\n        \"binary escape\", where any byte < 127 is escaped into its hex form.\n        - python3: bytes objects are always escaped using \"binary escape\".\n        \"\"\"\n        values = [\n            (b\"\", \"\"),\n            (b\"\\xc3\\xb4\\xff\\xe4\", \"\\\\xc3\\\\xb4\\\\xff\\\\xe4\"),\n            (b\"ascii\", \"ascii\"),\n            (\"\u03b1\u03c1\u03ac\".encode(), \"\\\\xce\\\\xb1\\\\xcf\\\\x81\\\\xce\\\\xac\"),\n        ]\n        for val, expected in values:\n            assert _idval(val, \"a\", 6, idfn=None, item=None, config=None) == expected\n\n    def test_class_or_function_idval(self) -> None:\n        \"\"\"unittest for the expected behavior to obtain ids for parametrized\n        values that are classes or functions: their __name__.\n        \"\"\"\n\n        class TestClass:\n            pass\n\n        def test_function():\n            pass\n\n        values = [(TestClass, \"TestClass\"), (test_function, \"test_function\")]\n        for val, expected in values:\n            assert _idval(val, \"a\", 6, None, item=None, config=None) == expected\n\n    def test_idmaker_autoname(self) -> None:\n        \"\"\"#250\"\"\"\n        from _pytest.python import idmaker\n\n        result = idmaker(\n            (\"a\", \"b\"), [pytest.param(\"string\", 1.0), pytest.param(\"st-ring\", 2.0)]\n        )\n        assert result == [\"string-1.0\", \"st-ring-2.0\"]\n\n        result = idmaker(\n            (\"a\", \"b\"), [pytest.param(object(), 1.0), pytest.param(object(), object())]\n        )\n        assert result == [\"a0-1.0\", \"a1-b1\"]\n        # unicode mixing, issue250\n        result = idmaker((\"a\", \"b\"), [pytest.param({}, b\"\\xc3\\xb4\")])\n        assert result == [\"a0-\\\\xc3\\\\xb4\"]\n\n    def test_idmaker_with_bytes_regex(self) -> None:\n        from _pytest.python import idmaker\n\n        result = idmaker((\"a\"), [pytest.param(re.compile(b\"foo\"), 1.0)])\n        assert result == [\"foo\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_ids_and_config_TestMetafunc.test_parametrize_ids_exception": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_ids_and_config_TestMetafunc.test_parametrize_ids_exception", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 526, "end_line": 582, "span_ids": ["TestMetafunc.test_idmaker_with_ids_and_config", "TestMetafunc.test_parametrize_ids_exception"], "tokens": 362}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_idmaker_with_ids_and_config(self) -> None:\n        \"\"\"unittest for expected behavior to create ids with ids and\n        disable_test_id_escaping_and_forfeit_all_rights_to_community_support\n        option. (#5294)\n        \"\"\"\n        from _pytest.python import idmaker\n\n        class MockConfig:\n            def __init__(self, config):\n                self.config = config\n\n            @property\n            def hook(self):\n                return self\n\n            def pytest_make_parametrize_id(self, **kw):\n                pass\n\n            def getini(self, name):\n                return self.config[name]\n\n        option = \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\"\n\n        values = [\n            (MockConfig({option: True}), \"a\u00e7\u00e3o\"),\n            (MockConfig({option: False}), \"a\\\\xe7\\\\xe3o\"),\n        ]  # type: List[Tuple[Any, str]]\n        for config, expected in values:\n            result = idmaker(\n                (\"a\",), [pytest.param(\"string\")], ids=[\"a\u00e7\u00e3o\"], config=config,\n            )\n            assert result == [expected]\n\n    def test_parametrize_ids_exception(self, testdir: Testdir) -> None:\n        \"\"\"\n        :param testdir: the instance of Testdir class, a temporary\n        test directory.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n                import pytest\n\n                def ids(arg):\n                    raise Exception(\"bad ids\")\n\n                @pytest.mark.parametrize(\"arg\", [\"a\", \"b\"], ids=ids)\n                def test_foo(arg):\n                    pass\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"*Exception: bad ids\",\n                \"*test_foo: error raised while trying to determine id of parameter 'arg' at position 0\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_ids_returns_non_string_TestMetafunc.test_parametrize_ids_returns_non_string.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_ids_returns_non_string_TestMetafunc.test_parametrize_ids_returns_non_string.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 584, "end_line": 610, "span_ids": ["TestMetafunc.test_parametrize_ids_returns_non_string"], "tokens": 229}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_ids_returns_non_string(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\\\n            import pytest\n\n            def ids(d):\n                return d\n\n            @pytest.mark.parametrize(\"arg\", ({1: 2}, {3, 4}), ids=ids)\n            def test(arg):\n                assert arg\n\n            @pytest.mark.parametrize(\"arg\", (1, 2.0, True), ids=ids)\n            def test_int(arg):\n                assert arg\n            \"\"\"\n        )\n        result = testdir.runpytest(\"-vv\", \"-s\")\n        result.stdout.fnmatch_lines(\n            [\n                \"test_parametrize_ids_returns_non_string.py::test[arg0] PASSED\",\n                \"test_parametrize_ids_returns_non_string.py::test[arg1] PASSED\",\n                \"test_parametrize_ids_returns_non_string.py::test_int[1] PASSED\",\n                \"test_parametrize_ids_returns_non_string.py::test_int[2.0] PASSED\",\n                \"test_parametrize_ids_returns_non_string.py::test_int[True] PASSED\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_ids_TestMetafunc.test_parametrize_indirect_list_empty": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_idmaker_with_ids_TestMetafunc.test_parametrize_indirect_list_empty", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 612, "end_line": 684, "span_ids": ["TestMetafunc.test_idmaker_with_ids", "TestMetafunc.test_idmaker_with_ids_unique_names", "TestMetafunc.test_idmaker_with_paramset_id", "TestMetafunc.test_parametrize_indirect", "TestMetafunc.test_parametrize_indirect_list", "TestMetafunc.test_parametrize_indirect_list_all", "TestMetafunc.test_parametrize_indirect_list_empty"], "tokens": 657}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_idmaker_with_ids(self) -> None:\n        from _pytest.python import idmaker\n\n        result = idmaker(\n            (\"a\", \"b\"), [pytest.param(1, 2), pytest.param(3, 4)], ids=[\"a\", None]\n        )\n        assert result == [\"a\", \"3-4\"]\n\n    def test_idmaker_with_paramset_id(self) -> None:\n        from _pytest.python import idmaker\n\n        result = idmaker(\n            (\"a\", \"b\"),\n            [pytest.param(1, 2, id=\"me\"), pytest.param(3, 4, id=\"you\")],\n            ids=[\"a\", None],\n        )\n        assert result == [\"me\", \"you\"]\n\n    def test_idmaker_with_ids_unique_names(self) -> None:\n        from _pytest.python import idmaker\n\n        result = idmaker(\n            (\"a\"), map(pytest.param, [1, 2, 3, 4, 5]), ids=[\"a\", \"a\", \"b\", \"c\", \"b\"]\n        )\n        assert result == [\"a0\", \"a1\", \"b0\", \"c\", \"b1\"]\n\n    def test_parametrize_indirect(self) -> None:\n        \"\"\"#714\"\"\"\n\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x\", [1], indirect=True)\n        metafunc.parametrize(\"y\", [2, 3], indirect=True)\n        assert len(metafunc._calls) == 2\n        assert metafunc._calls[0].funcargs == {}\n        assert metafunc._calls[1].funcargs == {}\n        assert metafunc._calls[0].params == dict(x=1, y=2)\n        assert metafunc._calls[1].params == dict(x=1, y=3)\n\n    def test_parametrize_indirect_list(self) -> None:\n        \"\"\"#714\"\"\"\n\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x, y\", [(\"a\", \"b\")], indirect=[\"x\"])\n        assert metafunc._calls[0].funcargs == dict(y=\"b\")\n        assert metafunc._calls[0].params == dict(x=\"a\")\n\n    def test_parametrize_indirect_list_all(self) -> None:\n        \"\"\"#714\"\"\"\n\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x, y\", [(\"a\", \"b\")], indirect=[\"x\", \"y\"])\n        assert metafunc._calls[0].funcargs == {}\n        assert metafunc._calls[0].params == dict(x=\"a\", y=\"b\")\n\n    def test_parametrize_indirect_list_empty(self) -> None:\n        \"\"\"#714\"\"\"\n\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n        metafunc.parametrize(\"x, y\", [(\"a\", \"b\")], indirect=[])\n        assert metafunc._calls[0].funcargs == dict(x=\"a\", y=\"b\")\n        assert metafunc._calls[0].params == {}", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_indirect_wrong_type_TestMetafunc.test_parametrize_indirect_list_functional.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_indirect_wrong_type_TestMetafunc.test_parametrize_indirect_list_functional.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 686, "end_line": 724, "span_ids": ["TestMetafunc.test_parametrize_indirect_list_functional", "TestMetafunc.test_parametrize_indirect_wrong_type"], "tokens": 311}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_indirect_wrong_type(self) -> None:\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n        with pytest.raises(\n            fail.Exception,\n            match=\"In func: expected Sequence or boolean for indirect, got dict\",\n        ):\n            metafunc.parametrize(\"x, y\", [(\"a\", \"b\")], indirect={})  # type: ignore[arg-type] # noqa: F821\n\n    def test_parametrize_indirect_list_functional(self, testdir: Testdir) -> None:\n        \"\"\"\n        #714\n        Test parametrization with 'indirect' parameter applied on\n        particular arguments. As y is is direct, its value should\n        be used directly rather than being passed to the fixture\n        y.\n\n        :param testdir: the instance of Testdir class, a temporary\n        test directory.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope='function')\n            def x(request):\n                return request.param * 3\n            @pytest.fixture(scope='function')\n            def y(request):\n                return request.param * 2\n            @pytest.mark.parametrize('x, y', [('a', 'b')], indirect=['x'])\n            def test_simple(x,y):\n                assert len(x) == 3\n                assert len(y) == 1\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines([\"*test_simple*a-b*\", \"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_indirect_list_error_TestMetafunc.test_parametrize_indirect_uses_no_fixture_error_indirect_list": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_indirect_list_error_TestMetafunc.test_parametrize_indirect_uses_no_fixture_error_indirect_list", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 726, "end_line": 816, "span_ids": ["TestMetafunc.test_parametrize_indirect_list_error", "TestMetafunc.test_parametrize_indirect_uses_no_fixture_error_indirect_list", "TestMetafunc.test_parametrize_indirect_uses_no_fixture_error_indirect_string", "TestMetafunc.test_parametrize_uses_no_fixture_error_indirect_false", "TestMetafunc.test_parametrize_uses_no_fixture_error_indirect_true"], "tokens": 652}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_indirect_list_error(self) -> None:\n        \"\"\"#714\"\"\"\n\n        def func(x, y):\n            pass\n\n        metafunc = self.Metafunc(func)\n        with pytest.raises(fail.Exception):\n            metafunc.parametrize(\"x, y\", [(\"a\", \"b\")], indirect=[\"x\", \"z\"])\n\n    def test_parametrize_uses_no_fixture_error_indirect_false(\n        self, testdir: Testdir\n    ) -> None:\n        \"\"\"The 'uses no fixture' error tells the user at collection time\n        that the parametrize data they've set up doesn't correspond to the\n        fixtures in their test function, rather than silently ignoring this\n        and letting the test potentially pass.\n\n        #714\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize('x, y', [('a', 'b')], indirect=False)\n            def test_simple(x):\n                assert len(x) == 3\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*uses no argument 'y'*\"])\n\n    def test_parametrize_uses_no_fixture_error_indirect_true(\n        self, testdir: Testdir\n    ) -> None:\n        \"\"\"#714\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope='function')\n            def x(request):\n                return request.param * 3\n            @pytest.fixture(scope='function')\n            def y(request):\n                return request.param * 2\n\n            @pytest.mark.parametrize('x, y', [('a', 'b')], indirect=True)\n            def test_simple(x):\n                assert len(x) == 3\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*uses no fixture 'y'*\"])\n\n    def test_parametrize_indirect_uses_no_fixture_error_indirect_string(\n        self, testdir: Testdir\n    ) -> None:\n        \"\"\"#714\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope='function')\n            def x(request):\n                return request.param * 3\n\n            @pytest.mark.parametrize('x, y', [('a', 'b')], indirect='y')\n            def test_simple(x):\n                assert len(x) == 3\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*uses no fixture 'y'*\"])\n\n    def test_parametrize_indirect_uses_no_fixture_error_indirect_list(\n        self, testdir: Testdir\n    ) -> None:\n        \"\"\"#714\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope='function')\n            def x(request):\n                return request.param * 3\n\n            @pytest.mark.parametrize('x, y', [('a', 'b')], indirect=['y'])\n            def test_simple(x):\n                assert len(x) == 3\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*uses no fixture 'y'*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_argument_not_in_indirect_list_TestMetafunc.test_parametrize_twoargs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_argument_not_in_indirect_list_TestMetafunc.test_parametrize_twoargs", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 818, "end_line": 897, "span_ids": ["TestMetafunc.test_parametrize_argument_not_in_indirect_list", "TestMetafunc.test_parametrize_functional", "TestMetafunc.test_parametrize_gives_indicative_error_on_function_with_default_argument", "TestMetafunc.test_parametrize_onearg", "TestMetafunc.test_parametrize_onearg_indirect", "TestMetafunc.test_parametrize_twoargs"], "tokens": 734}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_argument_not_in_indirect_list(self, testdir: Testdir) -> None:\n        \"\"\"#714\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope='function')\n            def x(request):\n                return request.param * 3\n\n            @pytest.mark.parametrize('x, y', [('a', 'b')], indirect=['x'])\n            def test_simple(x):\n                assert len(x) == 3\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines([\"*uses no argument 'y'*\"])\n\n    def test_parametrize_gives_indicative_error_on_function_with_default_argument(\n        self, testdir\n    ) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize('x, y', [('a', 'b')])\n            def test_simple(x, y=1):\n                assert len(x) == 1\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--collect-only\")\n        result.stdout.fnmatch_lines(\n            [\"*already takes an argument 'y' with a default value\"]\n        )\n\n    def test_parametrize_functional(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('x', [1,2], indirect=True)\n                metafunc.parametrize('y', [2])\n            @pytest.fixture\n            def x(request):\n                return request.param * 10\n\n            def test_simple(x,y):\n                assert x in (10,20)\n                assert y == 2\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\"*test_simple*1-2*\", \"*test_simple*2-2*\", \"*2 passed*\"]\n        )\n\n    def test_parametrize_onearg(self) -> None:\n        metafunc = self.Metafunc(lambda x: None)\n        metafunc.parametrize(\"x\", [1, 2])\n        assert len(metafunc._calls) == 2\n        assert metafunc._calls[0].funcargs == dict(x=1)\n        assert metafunc._calls[0].id == \"1\"\n        assert metafunc._calls[1].funcargs == dict(x=2)\n        assert metafunc._calls[1].id == \"2\"\n\n    def test_parametrize_onearg_indirect(self) -> None:\n        metafunc = self.Metafunc(lambda x: None)\n        metafunc.parametrize(\"x\", [1, 2], indirect=True)\n        assert metafunc._calls[0].params == dict(x=1)\n        assert metafunc._calls[0].id == \"1\"\n        assert metafunc._calls[1].params == dict(x=2)\n        assert metafunc._calls[1].id == \"2\"\n\n    def test_parametrize_twoargs(self) -> None:\n        metafunc = self.Metafunc(lambda x, y: None)\n        metafunc.parametrize((\"x\", \"y\"), [(1, 2), (3, 4)])\n        assert len(metafunc._calls) == 2\n        assert metafunc._calls[0].funcargs == dict(x=1, y=2)\n        assert metafunc._calls[0].id == \"1-2\"\n        assert metafunc._calls[1].funcargs == dict(x=3, y=4)\n        assert metafunc._calls[1].id == \"3-4\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_multiple_times_TestMetafunc.test_parametrize_CSV": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_multiple_times_TestMetafunc.test_parametrize_CSV", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 899, "end_line": 926, "span_ids": ["TestMetafunc.test_parametrize_CSV", "TestMetafunc.test_parametrize_multiple_times"], "tokens": 215}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_multiple_times(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            pytestmark = pytest.mark.parametrize(\"x\", [1,2])\n            def test_func(x):\n                assert 0, x\n            class TestClass(object):\n                pytestmark = pytest.mark.parametrize(\"y\", [3,4])\n                def test_meth(self, x, y):\n                    assert 0, x\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.assert_outcomes(failed=6)\n\n    def test_parametrize_CSV(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize(\"x, y,\", [(1,2), (2,3)])\n            def test_func(x, y):\n                assert x+1 == y\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_class_scenarios_TestMetafunc.test_format_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafunc.test_parametrize_class_scenarios_TestMetafunc.test_format_args", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 928, "end_line": 989, "span_ids": ["TestMetafunc.test_format_args", "TestMetafunc.test_parametrize_class_scenarios"], "tokens": 434}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafunc:\n\n    def test_parametrize_class_scenarios(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n        # same as doc/en/example/parametrize scenario example\n        def pytest_generate_tests(metafunc):\n            idlist = []\n            argvalues = []\n            for scenario in metafunc.cls.scenarios:\n                idlist.append(scenario[0])\n                items = scenario[1].items()\n                argnames = [x[0] for x in items]\n                argvalues.append(([x[1] for x in items]))\n            metafunc.parametrize(argnames, argvalues, ids=idlist, scope=\"class\")\n\n        class Test(object):\n               scenarios = [['1', {'arg': {1: 2}, \"arg2\": \"value2\"}],\n                            ['2', {'arg':'value2', \"arg2\": \"value2\"}]]\n\n               def test_1(self, arg, arg2):\n                  pass\n\n               def test_2(self, arg2, arg):\n                  pass\n\n               def test_3(self, arg, arg2):\n                  pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *test_1*1*\n            *test_2*1*\n            *test_3*1*\n            *test_1*2*\n            *test_2*2*\n            *test_3*2*\n            *6 passed*\n        \"\"\"\n        )\n\n    def test_format_args(self) -> None:\n        def function1():\n            pass\n\n        assert fixtures._format_args(function1) == \"()\"\n\n        def function2(arg1):\n            pass\n\n        assert fixtures._format_args(function2) == \"(arg1)\"\n\n        def function3(arg1, arg2=\"qwe\"):\n            pass\n\n        assert fixtures._format_args(function3) == \"(arg1, arg2='qwe')\"\n\n        def function4(arg1, *args, **kwargs):\n            pass\n\n        assert fixtures._format_args(function4) == \"(arg1, *args, **kwargs)\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_two_functions_TestMetafuncFunctional.test_issue28_setup_method_in_generate_tests": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_two_functions_TestMetafuncFunctional.test_issue28_setup_method_in_generate_tests", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1023, "end_line": 1106, "span_ids": ["TestMetafuncFunctional.test_generate_tests_in_class", "TestMetafuncFunctional.test_issue28_setup_method_in_generate_tests", "TestMetafuncFunctional.test_noself_in_method", "TestMetafuncFunctional.test_two_functions", "TestMetafuncFunctional.test_two_functions_not_same_instance"], "tokens": 617}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n\n    def test_two_functions(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('arg1', [10, 20], ids=['0', '1'])\n\n            def test_func1(arg1):\n                assert arg1 == 10\n\n            def test_func2(arg1):\n                assert arg1 in (10, 20)\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\", p)\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_func1*0*PASS*\",\n                \"*test_func1*1*FAIL*\",\n                \"*test_func2*PASS*\",\n                \"*test_func2*PASS*\",\n                \"*1 failed, 3 passed*\",\n            ]\n        )\n\n    def test_noself_in_method(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                assert 'xyz' not in metafunc.fixturenames\n\n            class TestHello(object):\n                def test_hello(xyz):\n                    pass\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.assert_outcomes(passed=1)\n\n    def test_generate_tests_in_class(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            class TestClass(object):\n                def pytest_generate_tests(self, metafunc):\n                    metafunc.parametrize('hello', ['world'], ids=['hellow'])\n\n                def test_myfunc(self, hello):\n                    assert hello == \"world\"\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\", p)\n        result.stdout.fnmatch_lines([\"*test_myfunc*hello*PASS*\", \"*1 passed*\"])\n\n    def test_two_functions_not_same_instance(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('arg1', [10, 20], ids=[\"0\", \"1\"])\n\n            class TestClass(object):\n                def test_func(self, arg1):\n                    assert not hasattr(self, 'x')\n                    self.x = 1\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\", p)\n        result.stdout.fnmatch_lines(\n            [\"*test_func*0*PASS*\", \"*test_func*1*PASS*\", \"*2 pass*\"]\n        )\n\n    def test_issue28_setup_method_in_generate_tests(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize('arg1', [1])\n\n            class TestClass(object):\n                def test_method(self, arg1):\n                    assert arg1 == self.val\n                def setup_method(self, func):\n                    self.val = 1\n            \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_functional2_TestMetafuncFunctional.test_parametrize_with_ids": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_functional2_TestMetafuncFunctional.test_parametrize_with_ids", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1108, "end_line": 1192, "span_ids": ["TestMetafuncFunctional.test_parametrize_and_inner_getfixturevalue", "TestMetafuncFunctional.test_parametrize_functional2", "TestMetafuncFunctional.test_parametrize_on_setup_arg", "TestMetafuncFunctional.test_parametrize_with_ids"], "tokens": 625}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n\n    def test_parametrize_functional2(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize(\"arg1\", [1,2])\n                metafunc.parametrize(\"arg2\", [4,5])\n            def test_hello(arg1, arg2):\n                assert 0, (arg1, arg2)\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\"*(1, 4)*\", \"*(1, 5)*\", \"*(2, 4)*\", \"*(2, 5)*\", \"*4 failed*\"]\n        )\n\n    def test_parametrize_and_inner_getfixturevalue(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize(\"arg1\", [1], indirect=True)\n                metafunc.parametrize(\"arg2\", [10], indirect=True)\n\n            import pytest\n            @pytest.fixture\n            def arg1(request):\n                x = request.getfixturevalue(\"arg2\")\n                return x + request.param\n\n            @pytest.fixture\n            def arg2(request):\n                return request.param\n\n            def test_func1(arg1, arg2):\n                assert arg1 == 11\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\", p)\n        result.stdout.fnmatch_lines([\"*test_func1*1*PASS*\", \"*1 passed*\"])\n\n    def test_parametrize_on_setup_arg(self, testdir: Testdir) -> None:\n        p = testdir.makepyfile(\n            \"\"\"\n            def pytest_generate_tests(metafunc):\n                assert \"arg1\" in metafunc.fixturenames\n                metafunc.parametrize(\"arg1\", [1], indirect=True)\n\n            import pytest\n            @pytest.fixture\n            def arg1(request):\n                return request.param\n\n            @pytest.fixture\n            def arg2(request, arg1):\n                return 10 * arg1\n\n            def test_func(arg2):\n                assert arg2 == 10\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\", p)\n        result.stdout.fnmatch_lines([\"*test_func*1*PASS*\", \"*1 passed*\"])\n\n    def test_parametrize_with_ids(self, testdir: Testdir) -> None:\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style=classic\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize((\"a\", \"b\"), [(1,1), (1,2)],\n                                     ids=[\"basic\", \"advanced\"])\n\n            def test_function(a, b):\n                assert a == b\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        assert result.ret == 1\n        result.stdout.fnmatch_lines_random(\n            [\"*test_function*basic*PASSED\", \"*test_function*advanced*FAILED\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_without_ids_TestMetafuncFunctional.test_parametrized_ids_invalid_type": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_without_ids_TestMetafuncFunctional.test_parametrized_ids_invalid_type", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1194, "end_line": 1284, "span_ids": ["TestMetafuncFunctional.test_fixture_parametrized_empty_ids", "TestMetafuncFunctional.test_parametrize_with_None_in_ids", "TestMetafuncFunctional.test_parametrize_without_ids", "TestMetafuncFunctional.test_parametrized_empty_ids", "TestMetafuncFunctional.test_parametrized_ids_invalid_type"], "tokens": 659}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n\n    def test_parametrize_without_ids(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize((\"a\", \"b\"),\n                                     [(1,object()), (1.3,object())])\n\n            def test_function(a, b):\n                assert 1\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *test_function*1-b0*\n            *test_function*1.3-b1*\n        \"\"\"\n        )\n\n    def test_parametrize_with_None_in_ids(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize((\"a\", \"b\"), [(1,1), (1,1), (1,2)],\n                                     ids=[\"basic\", None, \"advanced\"])\n\n            def test_function(a, b):\n                assert a == b\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        assert result.ret == 1\n        result.stdout.fnmatch_lines_random(\n            [\n                \"*test_function*basic*PASSED*\",\n                \"*test_function*1-1*PASSED*\",\n                \"*test_function*advanced*FAILED*\",\n            ]\n        )\n\n    def test_fixture_parametrized_empty_ids(self, testdir: Testdir) -> None:\n        \"\"\"Fixtures parametrized with empty ids cause an internal error (#1849).\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope=\"module\", ids=[], params=[])\n            def temp(request):\n               return request.param\n\n            def test_temp(temp):\n                 pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 1 skipped *\"])\n\n    def test_parametrized_empty_ids(self, testdir: Testdir) -> None:\n        \"\"\"Tests parametrized with empty ids cause an internal error (#1849).\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize('temp', [], ids=list())\n            def test_temp(temp):\n                 pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"* 1 skipped *\"])\n\n    def test_parametrized_ids_invalid_type(self, testdir: Testdir) -> None:\n        \"\"\"Test error with non-strings/non-ints, without generator (#1857).\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize(\"x, expected\", [(1, 2), (3, 4), (5, 6)], ids=(None, 2, type))\n            def test_ids_numbers(x,expected):\n                assert x * 2 == expected\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines(\n            [\n                \"In test_ids_numbers: ids must be list of string/float/int/bool,\"\n                \" found: <class 'type'> (type: <class 'type'>) at index 2\"\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_with_identical_ids_get_unique_names_TestMetafuncFunctional.test_parametrize_scope_overrides.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_with_identical_ids_get_unique_names_TestMetafuncFunctional.test_parametrize_scope_overrides.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1286, "end_line": 1332, "span_ids": ["TestMetafuncFunctional.test_parametrize_scope_overrides", "TestMetafuncFunctional.test_parametrize_with_identical_ids_get_unique_names"], "tokens": 343}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n\n    def test_parametrize_with_identical_ids_get_unique_names(\n        self, testdir: Testdir\n    ) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                metafunc.parametrize((\"a\", \"b\"), [(1,1), (1,2)],\n                                     ids=[\"a\", \"a\"])\n\n            def test_function(a, b):\n                assert a == b\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        assert result.ret == 1\n        result.stdout.fnmatch_lines_random(\n            [\"*test_function*a0*PASSED*\", \"*test_function*a1*FAILED*\"]\n        )\n\n    @pytest.mark.parametrize((\"scope\", \"length\"), [(\"module\", 2), (\"function\", 4)])\n    def test_parametrize_scope_overrides(\n        self, testdir: Testdir, scope: str, length: int\n    ) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            values = []\n            def pytest_generate_tests(metafunc):\n                if \"arg\" in metafunc.fixturenames:\n                    metafunc.parametrize(\"arg\", [1,2], indirect=True,\n                                         scope=%r)\n            @pytest.fixture\n            def arg(request):\n                values.append(request.param)\n                return request.param\n            def test_hello(arg):\n                assert arg in (1,2)\n            def test_world(arg):\n                assert arg in (1,2)\n            def test_checklength():\n                assert len(values) == %d\n        \"\"\"\n            % (scope, length)\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=5)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_issue323_TestMetafuncFunctional.test_usefixtures_seen_in_generate_tests": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_parametrize_issue323_TestMetafuncFunctional.test_usefixtures_seen_in_generate_tests", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1334, "end_line": 1366, "span_ids": ["TestMetafuncFunctional.test_parametrize_issue323", "TestMetafuncFunctional.test_usefixtures_seen_in_generate_tests"], "tokens": 203}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n\n    def test_parametrize_issue323(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture(scope='module', params=range(966))\n            def foo(request):\n                return request.param\n\n            def test_it(foo):\n                pass\n            def test_it2(foo):\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"--collect-only\")\n        assert not reprec.getcalls(\"pytest_internalerror\")\n\n    def test_usefixtures_seen_in_generate_tests(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                assert \"abc\" in metafunc.fixturenames\n                metafunc.parametrize(\"abc\", [1])\n\n            @pytest.mark.usefixtures(\"abc\")\n            def test_function():\n                pass\n        \"\"\"\n        )\n        reprec = testdir.runpytest()\n        reprec.assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_generate_tests_only_done_in_subdir_TestMetafuncFunctional.test_generate_tests_only_done_in_subdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMetafuncFunctional.test_generate_tests_only_done_in_subdir_TestMetafuncFunctional.test_generate_tests_only_done_in_subdir", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1368, "end_line": 1390, "span_ids": ["TestMetafuncFunctional.test_generate_tests_only_done_in_subdir"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMetafuncFunctional:\n\n    def test_generate_tests_only_done_in_subdir(self, testdir: Testdir) -> None:\n        sub1 = testdir.mkpydir(\"sub1\")\n        sub2 = testdir.mkpydir(\"sub2\")\n        sub1.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def pytest_generate_tests(metafunc):\n                    assert metafunc.function.__name__ == \"test_1\"\n                \"\"\"\n            )\n        )\n        sub2.join(\"conftest.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def pytest_generate_tests(metafunc):\n                    assert metafunc.function.__name__ == \"test_2\"\n                \"\"\"\n            )\n        )\n        sub1.join(\"test_in_sub1.py\").write(\"def test_1(): pass\")\n        sub2.join(\"test_in_sub2.py\").write(\"def test_2(): pass\")\n        result = testdir.runpytest(\"--keep-duplicates\", \"-v\", \"-s\", sub1, sub2, sub1)\n        result.assert_outcomes(passed=3)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization_TestMarkersWithParametrization.test_xfail_with_arg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization_TestMarkersWithParametrization.test_xfail_with_arg", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1601, "end_line": 1691, "span_ids": ["TestMarkersWithParametrization", "TestMarkersWithParametrization.test_select_based_on_mark", "TestMarkersWithParametrization.test_simple_mark", "TestMarkersWithParametrization.test_simple_xfail", "TestMarkersWithParametrization.test_simple_xfail_single_argname", "TestMarkersWithParametrization.test_xfail_with_arg"], "tokens": 678}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMarkersWithParametrization:\n    \"\"\"#308\"\"\"\n\n    def test_simple_mark(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.foo\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(1, 3, marks=pytest.mark.bar),\n                (2, 3),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        items = testdir.getitems(s)\n        assert len(items) == 3\n        for item in items:\n            assert \"foo\" in item.keywords\n        assert \"bar\" not in items[0].keywords\n        assert \"bar\" in items[1].keywords\n        assert \"bar\" not in items[2].keywords\n\n    def test_select_based_on_mark(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(2, 3, marks=pytest.mark.foo),\n                (3, 4),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        testdir.makepyfile(s)\n        rec = testdir.inline_run(\"-m\", \"foo\")\n        passed, skipped, fail = rec.listoutcomes()\n        assert len(passed) == 1\n        assert len(skipped) == 0\n        assert len(fail) == 0\n\n    def test_simple_xfail(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(1, 3, marks=pytest.mark.xfail),\n                (2, 3),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        # xfail is skip??\n        reprec.assertoutcome(passed=2, skipped=1)\n\n    def test_simple_xfail_single_argname(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize(\"n\", [\n                2,\n                pytest.param(3, marks=pytest.mark.xfail),\n                4,\n            ])\n            def test_isEven(n):\n                assert n % 2 == 0\n        \"\"\"\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2, skipped=1)\n\n    def test_xfail_with_arg(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(1, 3, marks=pytest.mark.xfail(\"True\")),\n                (2, 3),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2, skipped=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_xfail_with_kwarg_TestMarkersWithParametrization.test_parametrize_ID_generation_string_int_works": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_xfail_with_kwarg_TestMarkersWithParametrization.test_parametrize_ID_generation_string_int_works", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1693, "end_line": 1786, "span_ids": ["TestMarkersWithParametrization.test_parametrize_ID_generation_string_int_works", "TestMarkersWithParametrization.test_parametrize_called_in_generate_tests", "TestMarkersWithParametrization.test_xfail_passing_is_xpass", "TestMarkersWithParametrization.test_xfail_with_arg_and_kwarg", "TestMarkersWithParametrization.test_xfail_with_kwarg"], "tokens": 708}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMarkersWithParametrization:\n\n    def test_xfail_with_kwarg(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(1, 3, marks=pytest.mark.xfail(reason=\"some bug\")),\n                (2, 3),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2, skipped=1)\n\n    def test_xfail_with_arg_and_kwarg(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(1, 3, marks=pytest.mark.xfail(\"True\", reason=\"some bug\")),\n                (2, 3),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2, skipped=1)\n\n    @pytest.mark.parametrize(\"strict\", [True, False])\n    def test_xfail_passing_is_xpass(self, testdir: Testdir, strict: bool) -> None:\n        s = \"\"\"\n            import pytest\n\n            m = pytest.mark.xfail(\"sys.version_info > (0, 0, 0)\", reason=\"some bug\", strict={strict})\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                (1, 2),\n                pytest.param(2, 3, marks=m),\n                (3, 4),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\".format(\n            strict=strict\n        )\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        passed, failed = (2, 1) if strict else (3, 0)\n        reprec.assertoutcome(passed=passed, failed=failed)\n\n    def test_parametrize_called_in_generate_tests(self, testdir: Testdir) -> None:\n        s = \"\"\"\n            import pytest\n\n\n            def pytest_generate_tests(metafunc):\n                passingTestData = [(1, 2),\n                                   (2, 3)]\n                failingTestData = [(1, 3),\n                                   (2, 2)]\n\n                testData = passingTestData + [pytest.param(*d, marks=pytest.mark.xfail)\n                                  for d in failingTestData]\n                metafunc.parametrize((\"n\", \"expected\"), testData)\n\n\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\"\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2, skipped=2)\n\n    def test_parametrize_ID_generation_string_int_works(self, testdir: Testdir) -> None:\n        \"\"\"#290\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def myfixture():\n                return 'example'\n            @pytest.mark.parametrize(\n                'limit', (0, '0'))\n            def test_limit(limit, myfixture):\n                return\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_marked_value_TestMarkersWithParametrization.test_parametrize_marked_value": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_marked_value_TestMarkersWithParametrization.test_parametrize_marked_value", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1788, "end_line": 1811, "span_ids": ["TestMarkersWithParametrization.test_parametrize_marked_value"], "tokens": 220}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMarkersWithParametrization:\n\n    @pytest.mark.parametrize(\"strict\", [True, False])\n    def test_parametrize_marked_value(self, testdir: Testdir, strict: bool) -> None:\n        s = \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize((\"n\", \"expected\"), [\n                pytest.param(\n                    2,3,\n                    marks=pytest.mark.xfail(\"sys.version_info > (0, 0, 0)\", reason=\"some bug\", strict={strict}),\n                ),\n                pytest.param(\n                    2,3,\n                    marks=[pytest.mark.xfail(\"sys.version_info > (0, 0, 0)\", reason=\"some bug\", strict={strict})],\n                ),\n            ])\n            def test_increment(n, expected):\n                assert n + 1 == expected\n        \"\"\".format(\n            strict=strict\n        )\n        testdir.makepyfile(s)\n        reprec = testdir.inline_run()\n        passed, failed = (0, 2) if strict else (2, 0)\n        reprec.assertoutcome(passed=passed, failed=failed)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_pytest_make_parametrize_id_TestMarkersWithParametrization.test_parametrize_positional_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_pytest_make_parametrize_id_TestMarkersWithParametrization.test_parametrize_positional_args", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1813, "end_line": 1868, "span_ids": ["TestMarkersWithParametrization.test_parametrize_positional_args", "TestMarkersWithParametrization.test_pytest_make_parametrize_id", "TestMarkersWithParametrization.test_pytest_make_parametrize_id_with_argname"], "tokens": 379}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMarkersWithParametrization:\n\n    def test_pytest_make_parametrize_id(self, testdir: Testdir) -> None:\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_make_parametrize_id(config, val):\n                return str(val * 2)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize(\"x\", range(2))\n                def test_func(x):\n                    pass\n                \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines([\"*test_func*0*PASS*\", \"*test_func*2*PASS*\"])\n\n    def test_pytest_make_parametrize_id_with_argname(self, testdir: Testdir) -> None:\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_make_parametrize_id(config, val, argname):\n                return str(val * 2 if argname == 'x' else val * 10)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n                import pytest\n\n                @pytest.mark.parametrize(\"x\", range(2))\n                def test_func_a(x):\n                    pass\n\n                @pytest.mark.parametrize(\"y\", [1])\n                def test_func_b(y):\n                    pass\n                \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            [\"*test_func_a*0*PASS*\", \"*test_func_a*2*PASS*\", \"*test_func_b*10*PASS*\"]\n        )\n\n    def test_parametrize_positional_args(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.parametrize(\"a\", [1], False)\n            def test_foo(a):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.assert_outcomes(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_iterator_TestMarkersWithParametrization.test_parametrize_iterator.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_iterator_TestMarkersWithParametrization.test_parametrize_iterator.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1870, "end_line": 1904, "span_ids": ["TestMarkersWithParametrization.test_parametrize_iterator"], "tokens": 284}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMarkersWithParametrization:\n\n    def test_parametrize_iterator(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import itertools\n            import pytest\n\n            id_parametrize = pytest.mark.parametrize(\n                ids=(\"param%d\" % i for i in itertools.count())\n            )\n\n            @id_parametrize('y', ['a', 'b'])\n            def test1(y):\n                pass\n\n            @id_parametrize('y', ['a', 'b'])\n            def test2(y):\n                pass\n\n            @pytest.mark.parametrize(\"a, b\", [(1, 2), (3, 4)], ids=itertools.count())\n            def test_converted_to_str(a, b):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-vv\", \"-s\")\n        result.stdout.fnmatch_lines(\n            [\n                \"test_parametrize_iterator.py::test1[param0] PASSED\",\n                \"test_parametrize_iterator.py::test1[param1] PASSED\",\n                \"test_parametrize_iterator.py::test2[param0] PASSED\",\n                \"test_parametrize_iterator.py::test2[param1] PASSED\",\n                \"test_parametrize_iterator.py::test_converted_to_str[0] PASSED\",\n                \"test_parametrize_iterator.py::test_converted_to_str[1] PASSED\",\n                \"*= 6 passed in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_explicit_parameters_func_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/metafunc.py_TestMarkersWithParametrization.test_parametrize_explicit_parameters_func_", "embedding": null, "metadata": {"file_path": "testing/python/metafunc.py", "file_name": "metafunc.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1906, "end_line": 1953, "span_ids": ["TestMarkersWithParametrization.test_parametrize_explicit_parameters_func", "TestMarkersWithParametrization.test_parametrize_explicit_parameters_method"], "tokens": 279}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestMarkersWithParametrization:\n\n    def test_parametrize_explicit_parameters_func(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n\n            @pytest.fixture\n            def fixture(arg):\n                return arg\n\n            @pytest.mark.parametrize(\"arg\", [\"baz\"])\n            def test_without_arg(fixture):\n                assert \"baz\" == fixture\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.assert_outcomes(error=1)\n        result.stdout.fnmatch_lines(\n            [\n                '*In function \"test_without_arg\"*',\n                '*Parameter \"arg\" should be declared explicitly via indirect or in function itself*',\n            ]\n        )\n\n    def test_parametrize_explicit_parameters_method(self, testdir: Testdir) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            class Test:\n                @pytest.fixture\n                def test_fixture(self, argument):\n                    return argument\n\n                @pytest.mark.parametrize(\"argument\", [\"foobar\"])\n                def test_without_argument(self, test_fixture):\n                    assert \"foobar\" == test_fixture\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.assert_outcomes(error=1)\n        result.stdout.fnmatch_lines(\n            [\n                '*In function \"test_without_argument\"*',\n                '*Parameter \"argument\" should be declared explicitly via indirect or in function itself*',\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_re_TestRaises.test_does_not_raise_does_raise": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_re_TestRaises.test_does_not_raise_does_raise", "embedding": null, "metadata": {"file_path": "testing/python/raises.py", "file_name": "raises.py", "file_type": "text/x-python", "category": "implementation", "start_line": 1, "end_line": 127, "span_ids": ["TestRaises", "TestRaises.test_check_callable", "TestRaises.test_does_not_raise", "TestRaises.test_does_not_raise_does_raise", "TestRaises.test_raises", "TestRaises.test_raises_as_contextmanager", "TestRaises.test_raises_callable_no_exception", "TestRaises.test_raises_falsey_type_error", "TestRaises.test_raises_function", "TestRaises.test_raises_repr_inflight", "imports"], "tokens": 757}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import re\nimport sys\n\nimport pytest\nfrom _pytest.outcomes import Failed\n\n\nclass TestRaises:\n    def test_check_callable(self):\n        with pytest.raises(TypeError, match=r\".* must be callable\"):\n            pytest.raises(RuntimeError, \"int('qwe')\")\n\n    def test_raises(self):\n        excinfo = pytest.raises(ValueError, int, \"qwe\")\n        assert \"invalid literal\" in str(excinfo.value)\n\n    def test_raises_function(self):\n        excinfo = pytest.raises(ValueError, int, \"hello\")\n        assert \"invalid literal\" in str(excinfo.value)\n\n    def test_raises_callable_no_exception(self):\n        class A:\n            def __call__(self):\n                pass\n\n        try:\n            pytest.raises(ValueError, A())\n        except pytest.raises.Exception:\n            pass\n\n    def test_raises_falsey_type_error(self):\n        with pytest.raises(TypeError):\n            with pytest.raises(AssertionError, match=0):\n                raise AssertionError(\"ohai\")\n\n    def test_raises_repr_inflight(self):\n        \"\"\"Ensure repr() on an exception info inside a pytest.raises with block works (#4386)\"\"\"\n\n        class E(Exception):\n            pass\n\n        with pytest.raises(E) as excinfo:\n            # this test prints the inflight uninitialized object\n            # using repr and str as well as pprint to demonstrate\n            # it works\n            print(str(excinfo))\n            print(repr(excinfo))\n            import pprint\n\n            pprint.pprint(excinfo)\n            raise E()\n\n    def test_raises_as_contextmanager(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            import _pytest._code\n\n            def test_simple():\n                with pytest.raises(ZeroDivisionError) as excinfo:\n                    assert isinstance(excinfo, _pytest._code.ExceptionInfo)\n                    1/0\n                print(excinfo)\n                assert excinfo.type == ZeroDivisionError\n                assert isinstance(excinfo.value, ZeroDivisionError)\n\n            def test_noraise():\n                with pytest.raises(pytest.raises.Exception):\n                    with pytest.raises(ValueError):\n                           int()\n\n            def test_raise_wrong_exception_passes_by():\n                with pytest.raises(ZeroDivisionError):\n                    with pytest.raises(ValueError):\n                           1/0\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*3 passed*\"])\n\n    def test_does_not_raise(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            from contextlib import contextmanager\n            import pytest\n\n            @contextmanager\n            def does_not_raise():\n                yield\n\n            @pytest.mark.parametrize('example_input,expectation', [\n                (3, does_not_raise()),\n                (2, does_not_raise()),\n                (1, does_not_raise()),\n                (0, pytest.raises(ZeroDivisionError)),\n            ])\n            def test_division(example_input, expectation):\n                '''Test how much I know division.'''\n                with expectation:\n                    assert (6 / example_input) is not None\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*4 passed*\"])\n\n    def test_does_not_raise_does_raise(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            from contextlib import contextmanager\n            import pytest\n\n            @contextmanager\n            def does_not_raise():\n                yield\n\n            @pytest.mark.parametrize('example_input,expectation', [\n                (0, does_not_raise()),\n                (1, pytest.raises(ZeroDivisionError)),\n            ])\n            def test_division(example_input, expectation):\n                '''Test how much I know division.'''\n                with expectation:\n                    assert (6 / example_input) is not None\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*2 failed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_raises_match_TestRaises.test_raises_match.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_raises_match_TestRaises.test_raises_match.None_3", "embedding": null, "metadata": {"file_path": "testing/python/raises.py", "file_name": "raises.py", "file_type": "text/x-python", "category": "implementation", "start_line": 190, "end_line": 219, "span_ids": ["TestRaises.test_raises_match"], "tokens": 238}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRaises:\n\n    def test_raises_match(self) -> None:\n        msg = r\"with base \\d+\"\n        with pytest.raises(ValueError, match=msg):\n            int(\"asdf\")\n\n        msg = \"with base 10\"\n        with pytest.raises(ValueError, match=msg):\n            int(\"asdf\")\n\n        msg = \"with base 16\"\n        expr = \"Pattern {!r} does not match \\\"invalid literal for int() with base 10: 'asdf'\\\"\".format(\n            msg\n        )\n        with pytest.raises(AssertionError, match=re.escape(expr)):\n            with pytest.raises(ValueError, match=msg):\n                int(\"asdf\", base=10)\n\n        # \"match\" without context manager.\n        pytest.raises(ValueError, int, \"asdf\").match(\"invalid literal\")\n        with pytest.raises(AssertionError) as excinfo:\n            pytest.raises(ValueError, int, \"asdf\").match(msg)\n        assert str(excinfo.value) == expr\n\n        pytest.raises(TypeError, int, match=\"invalid\")\n\n        def tfunc(match):\n            raise ValueError(\"match={}\".format(match))\n\n        pytest.raises(ValueError, tfunc, match=\"asdf\").match(\"match=asdf\")\n        pytest.raises(ValueError, tfunc, match=\"\").match(\"match=\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_match_failure_string_quoting_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/python/raises.py_TestRaises.test_match_failure_string_quoting_", "embedding": null, "metadata": {"file_path": "testing/python/raises.py", "file_name": "raises.py", "file_type": "text/x-python", "category": "implementation", "start_line": 221, "end_line": 274, "span_ids": ["TestRaises.test_match_failure_string_quoting", "TestRaises.test_raises_context_manager_with_kwargs", "TestRaises.test_raises_exception_looks_iterable", "TestRaises.test_raises_match_wrong_type", "TestRaises.test_raises_with_raising_dunder_class"], "tokens": 406}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRaises:\n\n    def test_match_failure_string_quoting(self):\n        with pytest.raises(AssertionError) as excinfo:\n            with pytest.raises(AssertionError, match=\"'foo\"):\n                raise AssertionError(\"'bar\")\n        (msg,) = excinfo.value.args\n        assert msg == 'Pattern \"\\'foo\" does not match \"\\'bar\"'\n\n    def test_raises_match_wrong_type(self):\n        \"\"\"Raising an exception with the wrong type and match= given.\n\n        pytest should throw the unexpected exception - the pattern match is not\n        really relevant if we got a different exception.\n        \"\"\"\n        with pytest.raises(ValueError):\n            with pytest.raises(IndexError, match=\"nomatch\"):\n                int(\"asdf\")\n\n    def test_raises_exception_looks_iterable(self):\n        class Meta(type):\n            def __getitem__(self, item):\n                return 1 / 0\n\n            def __len__(self):\n                return 1\n\n        class ClassLooksIterableException(Exception, metaclass=Meta):\n            pass\n\n        with pytest.raises(\n            Failed,\n            match=r\"DID NOT RAISE <class 'raises(\\..*)*ClassLooksIterableException'>\",\n        ):\n            pytest.raises(ClassLooksIterableException, lambda: None)\n\n    def test_raises_with_raising_dunder_class(self):\n        \"\"\"Test current behavior with regard to exceptions via __class__ (#4284).\"\"\"\n\n        class CrappyClass(Exception):\n            # Type ignored because it's bypassed intentionally.\n            @property  # type: ignore\n            def __class__(self):\n                assert False, \"via __class__\"\n\n        with pytest.raises(AssertionError) as excinfo:\n            with pytest.raises(CrappyClass()):\n                pass\n        assert \"via __class__\" in excinfo.value.args[0]\n\n    def test_raises_context_manager_with_kwargs(self):\n        with pytest.raises(TypeError) as excinfo:\n            with pytest.raises(Exception, foo=\"bar\"):\n                pass\n        assert \"Unexpected keyword arguments\" in str(excinfo.value)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_collections.abc_TestImportHookInstallation.test_conftest_assertion_rewrite.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_collections.abc_TestImportHookInstallation.test_conftest_assertion_rewrite.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 59, "span_ids": ["TestImportHookInstallation", "TestImportHookInstallation.test_conftest_assertion_rewrite", "imports", "mock_config"], "tokens": 375}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import collections.abc\nimport sys\nimport textwrap\nfrom typing import Any\nfrom typing import List\nfrom typing import Optional\n\nimport attr\n\nimport _pytest.assertion as plugin\nimport pytest\nfrom _pytest import outcomes\nfrom _pytest.assertion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.compat import ATTRS_EQ_FIELD\n\n\ndef mock_config(verbose=0):\n    class Config:\n        def getoption(self, name):\n            if name == \"verbose\":\n                return verbose\n            raise KeyError(\"Not mocked out: %s\" % name)\n\n    return Config()\n\n\nclass TestImportHookInstallation:\n    @pytest.mark.parametrize(\"initial_conftest\", [True, False])\n    @pytest.mark.parametrize(\"mode\", [\"plain\", \"rewrite\"])\n    def test_conftest_assertion_rewrite(self, testdir, initial_conftest, mode):\n        \"\"\"Test that conftest files are using assertion rewrite on import.\n        (#1619)\n        \"\"\"\n        testdir.tmpdir.join(\"foo/tests\").ensure(dir=1)\n        conftest_path = \"conftest.py\" if initial_conftest else \"foo/conftest.py\"\n        contents = {\n            conftest_path: \"\"\"\n                import pytest\n                @pytest.fixture\n                def check_first():\n                    def check(values, value):\n                        assert values.pop(0) == value\n                    return check\n            \"\"\",\n            \"foo/tests/test_foo.py\": \"\"\"\n                def test(check_first):\n                    check_first([10, 30], 30)\n            \"\"\",\n        }\n        testdir.makepyfile(**contents)\n        result = testdir.runpytest_subprocess(\"--assert=%s\" % mode)\n        if mode == \"plain\":\n            expected = \"E       AssertionError\"\n        elif mode == \"rewrite\":\n            expected = \"*assert 10 == 30*\"\n        else:\n            assert 0\n        result.stdout.fnmatch_lines([expected])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_rewrite_assertions_pytester_plugin_TestImportHookInstallation.test_rewrite_assertions_pytester_plugin.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_rewrite_assertions_pytester_plugin_TestImportHookInstallation.test_rewrite_assertions_pytester_plugin.None_2", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 61, "end_line": 92, "span_ids": ["TestImportHookInstallation.test_rewrite_assertions_pytester_plugin"], "tokens": 276}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestImportHookInstallation:\n\n    def test_rewrite_assertions_pytester_plugin(self, testdir):\n        \"\"\"\n        Assertions in the pytester plugin must also benefit from assertion\n        rewriting (#1920).\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            pytest_plugins = ['pytester']\n            def test_dummy_failure(testdir):  # how meta!\n                testdir.makepyfile('def test(): assert 0')\n                r = testdir.inline_run()\n                r.assertoutcome(passed=1)\n        \"\"\"\n        )\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines(\n            [\n                \">       r.assertoutcome(passed=1)\",\n                \"E       AssertionError: ([[][]], [[][]], [[]<TestReport *>[]])*\",\n                \"E       assert {'failed': 1,... 'skipped': 0} == {'failed': 0,... 'skipped': 0}\",\n                \"E         Omitting 1 identical items, use -vv to show\",\n                \"E         Differing items:\",\n                \"E         Use -v to get the full diff\",\n            ]\n        )\n        # XXX: unstable output.\n        result.stdout.fnmatch_lines_random(\n            [\n                \"E         {'failed': 1} != {'failed': 0}\",\n                \"E         {'passed': 0} != {'passed': 1}\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_pytest_plugins_rewrite_TestImportHookInstallation.test_pytest_plugins_rewrite_module_names_correctly": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_pytest_plugins_rewrite_TestImportHookInstallation.test_pytest_plugins_rewrite_module_names_correctly", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 94, "end_line": 164, "span_ids": ["TestImportHookInstallation.test_pytest_plugins_rewrite", "TestImportHookInstallation.test_pytest_plugins_rewrite_module_names", "TestImportHookInstallation.test_pytest_plugins_rewrite_module_names_correctly"], "tokens": 546}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestImportHookInstallation:\n\n    @pytest.mark.parametrize(\"mode\", [\"plain\", \"rewrite\"])\n    def test_pytest_plugins_rewrite(self, testdir, mode):\n        contents = {\n            \"conftest.py\": \"\"\"\n                pytest_plugins = ['ham']\n            \"\"\",\n            \"ham.py\": \"\"\"\n                import pytest\n                @pytest.fixture\n                def check_first():\n                    def check(values, value):\n                        assert values.pop(0) == value\n                    return check\n            \"\"\",\n            \"test_foo.py\": \"\"\"\n                def test_foo(check_first):\n                    check_first([10, 30], 30)\n            \"\"\",\n        }\n        testdir.makepyfile(**contents)\n        result = testdir.runpytest_subprocess(\"--assert=%s\" % mode)\n        if mode == \"plain\":\n            expected = \"E       AssertionError\"\n        elif mode == \"rewrite\":\n            expected = \"*assert 10 == 30*\"\n        else:\n            assert 0\n        result.stdout.fnmatch_lines([expected])\n\n    @pytest.mark.parametrize(\"mode\", [\"str\", \"list\"])\n    def test_pytest_plugins_rewrite_module_names(self, testdir, mode):\n        \"\"\"Test that pluginmanager correct marks pytest_plugins variables\n        for assertion rewriting if they are defined as plain strings or\n        list of strings (#1888).\n        \"\"\"\n        plugins = '\"ham\"' if mode == \"str\" else '[\"ham\"]'\n        contents = {\n            \"conftest.py\": \"\"\"\n                pytest_plugins = {plugins}\n            \"\"\".format(\n                plugins=plugins\n            ),\n            \"ham.py\": \"\"\"\n                import pytest\n            \"\"\",\n            \"test_foo.py\": \"\"\"\n                def test_foo(pytestconfig):\n                    assert 'ham' in pytestconfig.pluginmanager.rewrite_hook._must_rewrite\n            \"\"\",\n        }\n        testdir.makepyfile(**contents)\n        result = testdir.runpytest_subprocess(\"--assert=rewrite\")\n        assert result.ret == 0\n\n    def test_pytest_plugins_rewrite_module_names_correctly(self, testdir):\n        \"\"\"Test that we match files correctly when they are marked for rewriting (#2939).\"\"\"\n        contents = {\n            \"conftest.py\": \"\"\"\\\n                pytest_plugins = \"ham\"\n            \"\"\",\n            \"ham.py\": \"\",\n            \"hamster.py\": \"\",\n            \"test_foo.py\": \"\"\"\\\n                def test_foo(pytestconfig):\n                    assert pytestconfig.pluginmanager.rewrite_hook.find_spec('ham') is not None\n                    assert pytestconfig.pluginmanager.rewrite_hook.find_spec('hamster') is None\n            \"\"\",\n        }\n        testdir.makepyfile(**contents)\n        result = testdir.runpytest_subprocess(\"--assert=rewrite\")\n        assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_rewrite_ast_TestImportHookInstallation.test_register_assert_rewrite_checks_types": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestImportHookInstallation.test_rewrite_ast_TestImportHookInstallation.test_register_assert_rewrite_checks_types", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 237, "end_line": 287, "span_ids": ["TestImportHookInstallation.test_register_assert_rewrite_checks_types", "TestImportHookInstallation.test_rewrite_ast"], "tokens": 325}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestImportHookInstallation:\n\n    def test_rewrite_ast(self, testdir):\n        testdir.tmpdir.join(\"pkg\").ensure(dir=1)\n        contents = {\n            \"pkg/__init__.py\": \"\"\"\n                import pytest\n                pytest.register_assert_rewrite('pkg.helper')\n            \"\"\",\n            \"pkg/helper.py\": \"\"\"\n                def tool():\n                    a, b = 2, 3\n                    assert a == b\n            \"\"\",\n            \"pkg/plugin.py\": \"\"\"\n                import pytest, pkg.helper\n                @pytest.fixture\n                def tool():\n                    return pkg.helper.tool\n            \"\"\",\n            \"pkg/other.py\": \"\"\"\n                values = [3, 2]\n                def tool():\n                    assert values.pop() == 3\n            \"\"\",\n            \"conftest.py\": \"\"\"\n                pytest_plugins = ['pkg.plugin']\n            \"\"\",\n            \"test_pkg.py\": \"\"\"\n                import pkg.other\n                def test_tool(tool):\n                    tool()\n                def test_other():\n                    pkg.other.tool()\n            \"\"\",\n        }\n        testdir.makepyfile(**contents)\n        result = testdir.runpytest_subprocess(\"--assert=rewrite\")\n        result.stdout.fnmatch_lines(\n            [\n                \">*assert a == b*\",\n                \"E*assert 2 == 3*\",\n                \">*assert values.pop() == 3*\",\n                \"E*AssertionError\",\n            ]\n        )\n\n    def test_register_assert_rewrite_checks_types(self):\n        with pytest.raises(TypeError):\n            pytest.register_assert_rewrite([\"pytest_tests_internal_non_existing\"])\n        pytest.register_assert_rewrite(\n            \"pytest_tests_internal_non_existing\", \"pytest_tests_internal_non_existing2\"\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestBinReprIntegration_callequal": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestBinReprIntegration_callequal", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 290, "end_line": 322, "span_ids": ["TestBinReprIntegration", "TestBinReprIntegration.test_pytest_assertrepr_compare_called", "callequal", "callop"], "tokens": 241}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestBinReprIntegration:\n    def test_pytest_assertrepr_compare_called(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            values = []\n            def pytest_assertrepr_compare(op, left, right):\n                values.append((op, left, right))\n\n            @pytest.fixture\n            def list(request):\n                return values\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_hello():\n                assert 0 == 1\n            def test_check(list):\n                assert list == [(\"==\", 0, 1)]\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines([\"*test_hello*FAIL*\", \"*test_check*PASS*\"])\n\n\ndef callop(op: str, left: Any, right: Any, verbose: int = 0) -> Optional[List[str]]:\n    config = mock_config(verbose=verbose)\n    return plugin.pytest_assertrepr_compare(config, op, left, right)\n\n\ndef callequal(left: Any, right: Any, verbose: int = 0) -> Optional[List[str]]:\n    return callop(\"==\", left, right, verbose)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_different_lengths_TestAssert_reprcompare.test_list_wrap_for_multiple_lines.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_different_lengths_TestAssert_reprcompare.test_list_wrap_for_multiple_lines.None_1", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 435, "end_line": 469, "span_ids": ["TestAssert_reprcompare.test_list_different_lengths", "TestAssert_reprcompare.test_list_wrap_for_multiple_lines"], "tokens": 323}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_list_different_lengths(self):\n        expl = callequal([0, 1], [0, 1, 2])\n        assert len(expl) > 1\n        expl = callequal([0, 1, 2], [0, 1])\n        assert len(expl) > 1\n\n    def test_list_wrap_for_multiple_lines(self):\n        long_d = \"d\" * 80\n        l1 = [\"a\", \"b\", \"c\"]\n        l2 = [\"a\", \"b\", \"c\", long_d]\n        diff = callequal(l1, l2, verbose=True)\n        assert diff == [\n            \"['a', 'b', 'c'] == ['a', 'b', 'c...dddddddddddd']\",\n            \"Right contains one more item: '\" + long_d + \"'\",\n            \"Full diff:\",\n            \"  [\",\n            \"   'a',\",\n            \"   'b',\",\n            \"   'c',\",\n            \"-  '\" + long_d + \"',\",\n            \"  ]\",\n        ]\n\n        diff = callequal(l2, l1, verbose=True)\n        assert diff == [\n            \"['a', 'b', 'c...dddddddddddd'] == ['a', 'b', 'c']\",\n            \"Left contains one more item: '\" + long_d + \"'\",\n            \"Full diff:\",\n            \"  [\",\n            \"   'a',\",\n            \"   'b',\",\n            \"   'c',\",\n            \"+  '\" + long_d + \"',\",\n            \"  ]\",\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_wrap_for_width_rewrap_same_length_TestAssert_reprcompare.test_list_wrap_for_width_rewrap_same_length": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_wrap_for_width_rewrap_same_length_TestAssert_reprcompare.test_list_wrap_for_width_rewrap_same_length", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 471, "end_line": 488, "span_ids": ["TestAssert_reprcompare.test_list_wrap_for_width_rewrap_same_length"], "tokens": 205}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_list_wrap_for_width_rewrap_same_length(self):\n        long_a = \"a\" * 30\n        long_b = \"b\" * 30\n        long_c = \"c\" * 30\n        l1 = [long_a, long_b, long_c]\n        l2 = [long_b, long_c, long_a]\n        diff = callequal(l1, l2, verbose=True)\n        assert diff == [\n            \"['aaaaaaaaaaa...cccccccccccc'] == ['bbbbbbbbbbb...aaaaaaaaaaaa']\",\n            \"At index 0 diff: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' != 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'\",\n            \"Full diff:\",\n            \"  [\",\n            \"+  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\",\n            \"   'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',\",\n            \"   'cccccccccccccccccccccccccccccc',\",\n            \"-  'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\",\n            \"  ]\",\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_dont_wrap_strings_TestAssert_reprcompare.test_list_dont_wrap_strings": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_dont_wrap_strings_TestAssert_reprcompare.test_list_dont_wrap_strings", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 490, "end_line": 511, "span_ids": ["TestAssert_reprcompare.test_list_dont_wrap_strings"], "tokens": 217}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_list_dont_wrap_strings(self):\n        long_a = \"a\" * 10\n        l1 = [\"a\"] + [long_a for _ in range(0, 7)]\n        l2 = [\"should not get wrapped\"]\n        diff = callequal(l1, l2, verbose=True)\n        assert diff == [\n            \"['a', 'aaaaaa...aaaaaaa', ...] == ['should not get wrapped']\",\n            \"At index 0 diff: 'a' != 'should not get wrapped'\",\n            \"Left contains 7 more items, first extra item: 'aaaaaaaaaa'\",\n            \"Full diff:\",\n            \"  [\",\n            \"-  'should not get wrapped',\",\n            \"+  'a',\",\n            \"+  'aaaaaaaaaa',\",\n            \"+  'aaaaaaaaaa',\",\n            \"+  'aaaaaaaaaa',\",\n            \"+  'aaaaaaaaaa',\",\n            \"+  'aaaaaaaaaa',\",\n            \"+  'aaaaaaaaaa',\",\n            \"+  'aaaaaaaaaa',\",\n            \"  ]\",\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_wrap_TestAssert_reprcompare.test_dict_wrap.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_wrap_TestAssert_reprcompare.test_dict_wrap.None_1", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 513, "end_line": 546, "span_ids": ["TestAssert_reprcompare.test_dict_wrap"], "tokens": 432}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_dict_wrap(self):\n        d1 = {\"common\": 1, \"env\": {\"env1\": 1, \"env2\": 2}}\n        d2 = {\"common\": 1, \"env\": {\"env1\": 1}}\n\n        diff = callequal(d1, d2, verbose=True)\n        assert diff == [\n            \"{'common': 1,...1, 'env2': 2}} == {'common': 1,...: {'env1': 1}}\",\n            \"Omitting 1 identical items, use -vv to show\",\n            \"Differing items:\",\n            \"{'env': {'env1': 1, 'env2': 2}} != {'env': {'env1': 1}}\",\n            \"Full diff:\",\n            \"- {'common': 1, 'env': {'env1': 1}}\",\n            \"+ {'common': 1, 'env': {'env1': 1, 'env2': 2}}\",\n            \"?                                +++++++++++\",\n        ]\n\n        long_a = \"a\" * 80\n        sub = {\"long_a\": long_a, \"sub1\": {\"long_a\": \"substring that gets wrapped \" * 2}}\n        d1 = {\"env\": {\"sub\": sub}}\n        d2 = {\"env\": {\"sub\": sub}, \"new\": 1}\n        diff = callequal(d1, d2, verbose=True)\n        assert diff == [\n            \"{'env': {'sub... wrapped '}}}} == {'env': {'sub...}}}, 'new': 1}\",\n            \"Omitting 1 identical items, use -vv to show\",\n            \"Right contains 1 more item:\",\n            \"{'new': 1}\",\n            \"Full diff:\",\n            \"  {\",\n            \"   'env': {'sub': {'long_a': '\" + long_a + \"',\",\n            \"                   'sub1': {'long_a': 'substring that gets wrapped substring '\",\n            \"                                      'that gets wrapped '}}},\",\n            \"-  'new': 1,\",\n            \"  }\",\n        ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_TestAssert_reprcompare.test_dict_omitting_with_verbosity_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_dict_TestAssert_reprcompare.test_dict_omitting_with_verbosity_2", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 548, "end_line": 571, "span_ids": ["TestAssert_reprcompare.test_dict", "TestAssert_reprcompare.test_dict_omitting", "TestAssert_reprcompare.test_dict_omitting_with_verbosity_1", "TestAssert_reprcompare.test_dict_omitting_with_verbosity_2"], "tokens": 315}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_dict(self):\n        expl = callequal({\"a\": 0}, {\"a\": 1})\n        assert len(expl) > 1\n\n    def test_dict_omitting(self):\n        lines = callequal({\"a\": 0, \"b\": 1}, {\"a\": 1, \"b\": 1})\n        assert lines[1].startswith(\"Omitting 1 identical item\")\n        assert \"Common items\" not in lines\n        for line in lines[1:]:\n            assert \"b\" not in line\n\n    def test_dict_omitting_with_verbosity_1(self):\n        \"\"\" Ensure differing items are visible for verbosity=1 (#1512) \"\"\"\n        lines = callequal({\"a\": 0, \"b\": 1}, {\"a\": 1, \"b\": 1}, verbose=1)\n        assert lines[1].startswith(\"Omitting 1 identical item\")\n        assert lines[2].startswith(\"Differing items\")\n        assert lines[3] == \"{'a': 0} != {'a': 1}\"\n        assert \"Common items\" not in lines\n\n    def test_dict_omitting_with_verbosity_2(self):\n        lines = callequal({\"a\": 0, \"b\": 1}, {\"a\": 1, \"b\": 1}, verbose=2)\n        assert lines[1].startswith(\"Common items:\")\n        assert \"Omitting\" not in lines[1]\n        assert lines[2] == \"{'b': 1}\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_sequence_different_items_TestAssert_reprcompare.test_repr_verbose": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_sequence_different_items_TestAssert_reprcompare.test_repr_verbose", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 597, "end_line": 677, "span_ids": ["TestAssert_reprcompare.test_Sequence", "TestAssert_reprcompare.test_frozenzet", "TestAssert_reprcompare.test_list_tuples", "TestAssert_reprcompare.test_repr_verbose", "TestAssert_reprcompare.test_sequence_different_items", "TestAssert_reprcompare.test_set"], "tokens": 636}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_sequence_different_items(self):\n        lines = callequal((1, 2), (3, 4, 5), verbose=2)\n        assert lines == [\n            \"(1, 2) == (3, 4, 5)\",\n            \"At index 0 diff: 1 != 3\",\n            \"Right contains one more item: 5\",\n            \"Full diff:\",\n            \"- (3, 4, 5)\",\n            \"+ (1, 2)\",\n        ]\n        lines = callequal((1, 2, 3), (4,), verbose=2)\n        assert lines == [\n            \"(1, 2, 3) == (4,)\",\n            \"At index 0 diff: 1 != 4\",\n            \"Left contains 2 more items, first extra item: 2\",\n            \"Full diff:\",\n            \"- (4,)\",\n            \"+ (1, 2, 3)\",\n        ]\n\n    def test_set(self):\n        expl = callequal({0, 1}, {0, 2})\n        assert len(expl) > 1\n\n    def test_frozenzet(self):\n        expl = callequal(frozenset([0, 1]), {0, 2})\n        assert len(expl) > 1\n\n    def test_Sequence(self):\n        # Test comparing with a Sequence subclass.\n        class TestSequence(collections.abc.MutableSequence):\n            def __init__(self, iterable):\n                self.elements = list(iterable)\n\n            def __getitem__(self, item):\n                return self.elements[item]\n\n            def __len__(self):\n                return len(self.elements)\n\n            def __setitem__(self, item, value):\n                pass\n\n            def __delitem__(self, item):\n                pass\n\n            def insert(self, item, index):\n                pass\n\n        expl = callequal(TestSequence([0, 1]), list([0, 2]))\n        assert len(expl) > 1\n\n    def test_list_tuples(self):\n        expl = callequal([], [(1, 2)])\n        assert len(expl) > 1\n        expl = callequal([(1, 2)], [])\n        assert len(expl) > 1\n\n    def test_repr_verbose(self):\n        class Nums:\n            def __init__(self, nums):\n                self.nums = nums\n\n            def __repr__(self):\n                return str(self.nums)\n\n        list_x = list(range(5000))\n        list_y = list(range(5000))\n        list_y[len(list_y) // 2] = 3\n        nums_x = Nums(list_x)\n        nums_y = Nums(list_y)\n\n        assert callequal(nums_x, nums_y) is None\n\n        expl = callequal(nums_x, nums_y, verbose=1)\n        assert \"+\" + repr(nums_x) in expl\n        assert \"-\" + repr(nums_y) in expl\n\n        expl = callequal(nums_x, nums_y, verbose=2)\n        assert \"+\" + repr(nums_x) in expl\n        assert \"-\" + repr(nums_y) in expl", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_bad_repr_TestAssert_reprcompare.test_mojibake": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertion.py_TestAssert_reprcompare.test_list_bad_repr_TestAssert_reprcompare.test_mojibake", "embedding": null, "metadata": {"file_path": "testing/test_assertion.py", "file_name": "test_assertion.py", "file_type": "text/x-python", "category": "test", "start_line": 679, "end_line": 745, "span_ids": ["TestAssert_reprcompare.test_format_nonascii_explanation", "TestAssert_reprcompare.test_list_bad_repr", "TestAssert_reprcompare.test_mojibake", "TestAssert_reprcompare.test_nonascii_text", "TestAssert_reprcompare.test_one_repr_empty", "TestAssert_reprcompare.test_repr_no_exc", "TestAssert_reprcompare.test_unicode"], "tokens": 436}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssert_reprcompare:\n\n    def test_list_bad_repr(self):\n        class A:\n            def __repr__(self):\n                raise ValueError(42)\n\n        expl = callequal([], [A()])\n        assert \"ValueError\" in \"\".join(expl)\n        expl = callequal({}, {\"1\": A()}, verbose=2)\n        assert expl[0].startswith(\"{} == <[ValueError\")\n        assert \"raised in repr\" in expl[0]\n        assert expl[1:] == [\n            \"(pytest_assertion plugin: representation of details failed:\"\n            \" {}:{}: ValueError: 42.\".format(\n                __file__, A.__repr__.__code__.co_firstlineno + 1\n            ),\n            \" Probably an object has a faulty __repr__.)\",\n        ]\n\n    def test_one_repr_empty(self):\n        \"\"\"\n        the faulty empty string repr did trigger\n        an unbound local error in _diff_text\n        \"\"\"\n\n        class A(str):\n            def __repr__(self):\n                return \"\"\n\n        expl = callequal(A(), \"\")\n        assert not expl\n\n    def test_repr_no_exc(self):\n        expl = \" \".join(callequal(\"foo\", \"bar\"))\n        assert \"raised in repr()\" not in expl\n\n    def test_unicode(self):\n        assert callequal(\"\u00a3\u20ac\", \"\u00a3\") == [\n            \"'\u00a3\u20ac' == '\u00a3'\",\n            \"- \u00a3\",\n            \"+ \u00a3\u20ac\",\n        ]\n\n    def test_nonascii_text(self):\n        \"\"\"\n        :issue: 877\n        non ascii python2 str caused a UnicodeDecodeError\n        \"\"\"\n\n        class A(str):\n            def __repr__(self):\n                return \"\\xff\"\n\n        expl = callequal(A(), \"1\")\n        assert expl == [\"\u00ff == '1'\", \"- 1\"]\n\n    def test_format_nonascii_explanation(self):\n        assert util.format_explanation(\"\u03bb\")\n\n    def test_mojibake(self):\n        # issue 429\n        left = b\"e\"\n        right = b\"\\xc3\\xa9\"\n        expl = callequal(left, right)\n        for line in expl:\n            assert isinstance(line, str)\n        msg = \"\\n\".join(expl)\n        assert msg", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_name_TestAssertionRewrite.test_name.if_verbose_1_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_name_TestAssertionRewrite.test_name.if_verbose_1_", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 148, "end_line": 195, "span_ids": ["TestAssertionRewrite.test_name"], "tokens": 299}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_name(self, request):\n        def f():\n            assert False\n\n        assert getmsg(f) == \"assert False\"\n\n        def f():\n            f = False\n            assert f\n\n        assert getmsg(f) == \"assert False\"\n\n        def f():\n            assert a_global  # noqa\n\n        assert getmsg(f, {\"a_global\": False}) == \"assert False\"\n\n        def f():\n            assert sys == 42\n\n        verbose = request.config.getoption(\"verbose\")\n        msg = getmsg(f, {\"sys\": sys})\n        if verbose > 0:\n            assert msg == (\n                \"assert <module 'sys' (built-in)> == 42\\n\"\n                \"  +<module 'sys' (built-in)>\\n\"\n                \"  -42\"\n            )\n        else:\n            assert msg == \"assert sys == 42\"\n\n        def f():\n            assert cls == 42  # noqa: F821\n\n        class X:\n            pass\n\n        msg = getmsg(f, {\"cls\": X}).splitlines()\n        if verbose > 1:\n            assert msg == [\"assert {!r} == 42\".format(X), \"  +{!r}\".format(X), \"  -42\"]\n        elif verbose > 0:\n            assert msg == [\n                \"assert <class 'test_...e.<locals>.X'> == 42\",\n                \"  +{!r}\".format(X),\n                \"  -42\",\n            ]\n        else:\n            assert msg == [\"assert cls == 42\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_assertrepr_compare_same_width_TestAssertionRewrite.test_assertion_message_tuple": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_assertrepr_compare_same_width_TestAssertionRewrite.test_assertion_message_tuple", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 197, "end_line": 285, "span_ids": ["TestAssertionRewrite.test_assert_already_has_message", "TestAssertionRewrite.test_assertion_message", "TestAssertionRewrite.test_assertion_message_multiline", "TestAssertionRewrite.test_assertion_message_tuple", "TestAssertionRewrite.test_assertrepr_compare_same_width", "TestAssertionRewrite.test_dont_rewrite_if_hasattr_fails"], "tokens": 676}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_assertrepr_compare_same_width(self, request):\n        \"\"\"Should use same width/truncation with same initial width.\"\"\"\n\n        def f():\n            assert \"1234567890\" * 5 + \"A\" == \"1234567890\" * 5 + \"B\"\n\n        msg = getmsg(f).splitlines()[0]\n        if request.config.getoption(\"verbose\") > 1:\n            assert msg == (\n                \"assert '12345678901234567890123456789012345678901234567890A' \"\n                \"== '12345678901234567890123456789012345678901234567890B'\"\n            )\n        else:\n            assert msg == (\n                \"assert '123456789012...901234567890A' \"\n                \"== '123456789012...901234567890B'\"\n            )\n\n    def test_dont_rewrite_if_hasattr_fails(self, request):\n        class Y:\n            \"\"\" A class whos getattr fails, but not with `AttributeError` \"\"\"\n\n            def __getattr__(self, attribute_name):\n                raise KeyError()\n\n            def __repr__(self):\n                return \"Y\"\n\n            def __init__(self):\n                self.foo = 3\n\n        def f():\n            assert cls().foo == 2  # noqa\n\n        # XXX: looks like the \"where\" should also be there in verbose mode?!\n        message = getmsg(f, {\"cls\": Y}).splitlines()\n        if request.config.getoption(\"verbose\") > 0:\n            assert message == [\"assert 3 == 2\", \"  +3\", \"  -2\"]\n        else:\n            assert message == [\n                \"assert 3 == 2\",\n                \" +  where 3 = Y.foo\",\n                \" +    where Y = cls()\",\n            ]\n\n    def test_assert_already_has_message(self):\n        def f():\n            assert False, \"something bad!\"\n\n        assert getmsg(f) == \"AssertionError: something bad!\\nassert False\"\n\n    def test_assertion_message(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                assert 1 == 2, \"The failure message\"\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.stdout.fnmatch_lines(\n            [\"*AssertionError*The failure message*\", \"*assert 1 == 2*\"]\n        )\n\n    def test_assertion_message_multiline(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                assert 1 == 2, \"A multiline\\\\nfailure message\"\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.stdout.fnmatch_lines(\n            [\"*AssertionError*A multiline*\", \"*failure message*\", \"*assert 1 == 2*\"]\n        )\n\n    def test_assertion_message_tuple(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                assert 1 == 2, (1, 2)\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.stdout.fnmatch_lines(\n            [\"*AssertionError*%s*\" % repr((1, 2)), \"*assert 1 == 2*\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_assertion_message_expr_TestAssertionRewrite.test_assertion_messages_bytes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_assertion_message_expr_TestAssertionRewrite.test_assertion_messages_bytes", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 287, "end_line": 315, "span_ids": ["TestAssertionRewrite.test_assertion_message_escape", "TestAssertionRewrite.test_assertion_message_expr", "TestAssertionRewrite.test_assertion_messages_bytes"], "tokens": 247}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_assertion_message_expr(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                assert 1 == 2, 1 + 2\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.stdout.fnmatch_lines([\"*AssertionError*3*\", \"*assert 1 == 2*\"])\n\n    def test_assertion_message_escape(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                assert 1 == 2, 'To be escaped: %'\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.stdout.fnmatch_lines(\n            [\"*AssertionError: To be escaped: %\", \"*assert 1 == 2\"]\n        )\n\n    def test_assertion_messages_bytes(self, testdir):\n        testdir.makepyfile(\"def test_bytes_assertion():\\n    assert False, b'ohai!'\\n\")\n        result = testdir.runpytest()\n        assert result.ret == 1\n        result.stdout.fnmatch_lines([\"*AssertionError: b'ohai!'\", \"*assert False\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_boolop_TestAssertionRewrite.test_boolop.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewrite.test_boolop_TestAssertionRewrite.test_boolop.None_2", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 317, "end_line": 394, "span_ids": ["TestAssertionRewrite.test_boolop"], "tokens": 365}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewrite:\n\n    def test_boolop(self):\n        def f():\n            f = g = False\n            assert f and g\n\n        assert getmsg(f) == \"assert (False)\"\n\n        def f():\n            f = True\n            g = False\n            assert f and g\n\n        assert getmsg(f) == \"assert (True and False)\"\n\n        def f():\n            f = False\n            g = True\n            assert f and g\n\n        assert getmsg(f) == \"assert (False)\"\n\n        def f():\n            f = g = False\n            assert f or g\n\n        assert getmsg(f) == \"assert (False or False)\"\n\n        def f():\n            f = g = False\n            assert not f and not g\n\n        getmsg(f, must_pass=True)\n\n        def x():\n            return False\n\n        def f():\n            assert x() and x()\n\n        assert (\n            getmsg(f, {\"x\": x})\n            == \"\"\"assert (False)\n +  where False = x()\"\"\"\n        )\n\n        def f():\n            assert False or x()\n\n        assert (\n            getmsg(f, {\"x\": x})\n            == \"\"\"assert (False or False)\n +  where False = x()\"\"\"\n        )\n\n        def f():\n            assert 1 in {} and 2 in {}\n\n        assert getmsg(f) == \"assert (1 in {})\"\n\n        def f():\n            x = 1\n            y = 2\n            assert x in {1: None} and y in {}\n\n        assert getmsg(f) == \"assert (1 in {1: None} and 2 in {})\"\n\n        def f():\n            f = True\n            g = False\n            assert f or g\n\n        getmsg(f, must_pass=True)\n\n        def f():\n            f = g = h = lambda: True\n            assert f() and g() and h()\n\n        getmsg(f, must_pass=True)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails_TestAssertionRewriteHookDetails.test_write_pyc.assert_not__write_pyc_sta": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails_TestAssertionRewriteHookDetails.test_write_pyc.assert_not__write_pyc_sta", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 938, "end_line": 977, "span_ids": ["TestAssertionRewriteHookDetails", "TestAssertionRewriteHookDetails.test_sys_meta_path_munged", "TestAssertionRewriteHookDetails.test_write_pyc"], "tokens": 287}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewriteHookDetails:\n    def test_sys_meta_path_munged(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_meta_path():\n                import sys; sys.meta_path = []\"\"\"\n        )\n        assert testdir.runpytest().ret == 0\n\n    def test_write_pyc(self, testdir: Testdir, tmpdir, monkeypatch) -> None:\n        from _pytest.assertion.rewrite import _write_pyc\n        from _pytest.assertion import AssertionState\n\n        config = testdir.parseconfig()\n        state = AssertionState(config, \"rewrite\")\n        source_path = str(tmpdir.ensure(\"source.py\"))\n        pycpath = tmpdir.join(\"pyc\").strpath\n        assert _write_pyc(state, [1], os.stat(source_path), pycpath)\n\n        if sys.platform == \"win32\":\n            from contextlib import contextmanager\n\n            @contextmanager\n            def atomic_write_failed(fn, mode=\"r\", overwrite=False):\n                e = OSError()\n                e.errno = 10\n                raise e\n                yield\n\n            monkeypatch.setattr(\n                _pytest.assertion.rewrite, \"atomic_write\", atomic_write_failed\n            )\n        else:\n\n            def raise_oserror(*args):\n                raise OSError()\n\n            monkeypatch.setattr(\"os.rename\", raise_oserror)\n\n        assert not _write_pyc(state, [1], os.stat(source_path), pycpath)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails.test_resources_provider_for_loader_TestAssertionRewriteHookDetails.test_reload_is_same.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails.test_resources_provider_for_loader_TestAssertionRewriteHookDetails.test_reload_is_same.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 979, "end_line": 1057, "span_ids": ["TestAssertionRewriteHookDetails.test_read_pyc", "TestAssertionRewriteHookDetails.test_reload_is_same", "TestAssertionRewriteHookDetails.test_resources_provider_for_loader"], "tokens": 524}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewriteHookDetails:\n\n    def test_resources_provider_for_loader(self, testdir):\n        \"\"\"\n        Attempts to load resources from a package should succeed normally,\n        even when the AssertionRewriteHook is used to load the modules.\n\n        See #366 for details.\n        \"\"\"\n        pytest.importorskip(\"pkg_resources\")\n\n        testdir.mkpydir(\"testpkg\")\n        contents = {\n            \"testpkg/test_pkg\": \"\"\"\n                import pkg_resources\n\n                import pytest\n                from _pytest.assertion.rewrite import AssertionRewritingHook\n\n                def test_load_resource():\n                    assert isinstance(__loader__, AssertionRewritingHook)\n                    res = pkg_resources.resource_string(__name__, 'resource.txt')\n                    res = res.decode('ascii')\n                    assert res == 'Load me please.'\n                \"\"\"\n        }\n        testdir.makepyfile(**contents)\n        testdir.maketxtfile(**{\"testpkg/resource\": \"Load me please.\"})\n\n        result = testdir.runpytest_subprocess()\n        result.assert_outcomes(passed=1)\n\n    def test_read_pyc(self, tmpdir):\n        \"\"\"\n        Ensure that the `_read_pyc` can properly deal with corrupted pyc files.\n        In those circumstances it should just give up instead of generating\n        an exception that is propagated to the caller.\n        \"\"\"\n        import py_compile\n        from _pytest.assertion.rewrite import _read_pyc\n\n        source = tmpdir.join(\"source.py\")\n        pyc = source + \"c\"\n\n        source.write(\"def test(): pass\")\n        py_compile.compile(str(source), str(pyc))\n\n        contents = pyc.read(mode=\"rb\")\n        strip_bytes = 20  # header is around 8 bytes, strip a little more\n        assert len(contents) > strip_bytes\n        pyc.write(contents[:strip_bytes], mode=\"wb\")\n\n        assert _read_pyc(str(source), str(pyc)) is None  # no error\n\n    def test_reload_is_same(self, testdir):\n        # A file that will be picked up during collecting.\n        testdir.tmpdir.join(\"file.py\").ensure()\n        testdir.tmpdir.join(\"pytest.ini\").write(\n            textwrap.dedent(\n                \"\"\"\n            [pytest]\n            python_files = *.py\n        \"\"\"\n            )\n        )\n\n        testdir.makepyfile(\n            test_fun=\"\"\"\n            import sys\n            try:\n                from imp import reload\n            except ImportError:\n                pass\n\n            def test_loader():\n                import file\n                assert sys.modules[\"file\"] is reload(file)\n            \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines([\"* 1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails.test_reload_reloads_TestAssertionRewriteHookDetails.test_get_data_support": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestAssertionRewriteHookDetails.test_reload_reloads_TestAssertionRewriteHookDetails.test_get_data_support", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1059, "end_line": 1118, "span_ids": ["TestAssertionRewriteHookDetails.test_get_data_support", "TestAssertionRewriteHookDetails.test_reload_reloads"], "tokens": 345}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestAssertionRewriteHookDetails:\n\n    def test_reload_reloads(self, testdir):\n        \"\"\"Reloading a module after change picks up the change.\"\"\"\n        testdir.tmpdir.join(\"file.py\").write(\n            textwrap.dedent(\n                \"\"\"\n            def reloaded():\n                return False\n\n            def rewrite_self():\n                with open(__file__, 'w') as self:\n                    self.write('def reloaded(): return True')\n        \"\"\"\n            )\n        )\n        testdir.tmpdir.join(\"pytest.ini\").write(\n            textwrap.dedent(\n                \"\"\"\n            [pytest]\n            python_files = *.py\n        \"\"\"\n            )\n        )\n\n        testdir.makepyfile(\n            test_fun=\"\"\"\n            import sys\n            try:\n                from imp import reload\n            except ImportError:\n                pass\n\n            def test_loader():\n                import file\n                assert not file.reloaded()\n                file.rewrite_self()\n                reload(file)\n                assert file.reloaded()\n            \"\"\"\n        )\n        result = testdir.runpytest(\"-s\")\n        result.stdout.fnmatch_lines([\"* 1 passed*\"])\n\n    def test_get_data_support(self, testdir):\n        \"\"\"Implement optional PEP302 api (#808).\n        \"\"\"\n        path = testdir.mkpydir(\"foo\")\n        path.join(\"test_foo.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                class Test(object):\n                    def test_foo(self):\n                        import pkgutil\n                        data = pkgutil.get_data('foo.test_foo', 'data.txt')\n                        assert data == b'Hey'\n                \"\"\"\n            )\n        )\n        path.join(\"data.txt\").write(\"Hey\")\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_try_makedirs_test_try_makedirs.assert_exc_info_value_err": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_test_try_makedirs_test_try_makedirs.assert_exc_info_value_err", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1555, "end_line": 1592, "span_ids": ["test_try_makedirs"], "tokens": 274}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_try_makedirs(monkeypatch, tmp_path):\n    from _pytest.assertion.rewrite import try_makedirs\n\n    p = tmp_path / \"foo\"\n\n    # create\n    assert try_makedirs(str(p))\n    assert p.is_dir()\n\n    # already exist\n    assert try_makedirs(str(p))\n\n    # monkeypatch to simulate all error situations\n    def fake_mkdir(p, exist_ok=False, *, exc):\n        assert isinstance(p, str)\n        raise exc\n\n    monkeypatch.setattr(os, \"makedirs\", partial(fake_mkdir, exc=FileNotFoundError()))\n    assert not try_makedirs(str(p))\n\n    monkeypatch.setattr(os, \"makedirs\", partial(fake_mkdir, exc=NotADirectoryError()))\n    assert not try_makedirs(str(p))\n\n    monkeypatch.setattr(os, \"makedirs\", partial(fake_mkdir, exc=PermissionError()))\n    assert not try_makedirs(str(p))\n\n    err = OSError()\n    err.errno = errno.EROFS\n    monkeypatch.setattr(os, \"makedirs\", partial(fake_mkdir, exc=err))\n    assert not try_makedirs(str(p))\n\n    # unhandled OSError should raise\n    err = OSError()\n    err.errno = errno.ECHILD\n    monkeypatch.setattr(os, \"makedirs\", partial(fake_mkdir, exc=err))\n    with pytest.raises(OSError) as exc_info:\n        try_makedirs(str(p))\n    assert exc_info.value.errno == errno.ECHILD", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestPyCacheDir_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_assertrewrite.py_TestPyCacheDir_", "embedding": null, "metadata": {"file_path": "testing/test_assertrewrite.py", "file_name": "test_assertrewrite.py", "file_type": "text/x-python", "category": "test", "start_line": 1595, "end_line": 1649, "span_ids": ["TestPyCacheDir", "TestPyCacheDir.test_get_cache_dir", "TestPyCacheDir.test_sys_pycache_prefix_integration"], "tokens": 501}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPyCacheDir:\n    @pytest.mark.parametrize(\n        \"prefix, source, expected\",\n        [\n            (\"c:/tmp/pycs\", \"d:/projects/src/foo.py\", \"c:/tmp/pycs/projects/src\"),\n            (None, \"d:/projects/src/foo.py\", \"d:/projects/src/__pycache__\"),\n            (\"/tmp/pycs\", \"/home/projects/src/foo.py\", \"/tmp/pycs/home/projects/src\"),\n            (None, \"/home/projects/src/foo.py\", \"/home/projects/src/__pycache__\"),\n        ],\n    )\n    def test_get_cache_dir(self, monkeypatch, prefix, source, expected):\n        if prefix:\n            if sys.version_info < (3, 8):\n                pytest.skip(\"pycache_prefix not available in py<38\")\n            monkeypatch.setattr(sys, \"pycache_prefix\", prefix)\n\n        assert get_cache_dir(Path(source)) == Path(expected)\n\n    @pytest.mark.skipif(\n        sys.version_info < (3, 8), reason=\"pycache_prefix not available in py<38\"\n    )\n    def test_sys_pycache_prefix_integration(self, tmp_path, monkeypatch, testdir):\n        \"\"\"Integration test for sys.pycache_prefix (#4730).\"\"\"\n        pycache_prefix = tmp_path / \"my/pycs\"\n        monkeypatch.setattr(sys, \"pycache_prefix\", str(pycache_prefix))\n        monkeypatch.setattr(sys, \"dont_write_bytecode\", False)\n\n        testdir.makepyfile(\n            **{\n                \"src/test_foo.py\": \"\"\"\n                import bar\n                def test_foo():\n                    pass\n            \"\"\",\n                \"src/bar/__init__.py\": \"\",\n            }\n        )\n        result = testdir.runpytest()\n        assert result.ret == 0\n\n        test_foo = Path(testdir.tmpdir) / \"src/test_foo.py\"\n        bar_init = Path(testdir.tmpdir) / \"src/bar/__init__.py\"\n        assert test_foo.is_file()\n        assert bar_init.is_file()\n\n        # test file: rewritten, custom pytest cache tag\n        test_foo_pyc = get_cache_dir(test_foo) / (\"test_foo\" + PYC_TAIL)\n        assert test_foo_pyc.is_file()\n\n        # normal file: not touched by pytest, normal cache tag\n        bar_init_pyc = get_cache_dir(bar_init) / \"__init__.{cache_tag}.pyc\".format(\n            cache_tag=sys.implementation.cache_tag\n        )\n        assert bar_init_pyc.is_file()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_os_TestNewAPI.test_cache_writefail_permissions": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_os_TestNewAPI.test_cache_writefail_permissions", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 56, "span_ids": ["TestNewAPI", "TestNewAPI.test_cache_writefail_cachfile_silent", "TestNewAPI.test_cache_writefail_permissions", "TestNewAPI.test_config_cache_dataerror", "TestNewAPI.test_config_cache_makedir", "imports"], "tokens": 410}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport shutil\nimport stat\nimport sys\n\nimport py\n\nimport pytest\nfrom _pytest.config import ExitCode\n\npytest_plugins = (\"pytester\",)\n\n\nclass TestNewAPI:\n    def test_config_cache_makedir(self, testdir):\n        testdir.makeini(\"[pytest]\")\n        config = testdir.parseconfigure()\n        with pytest.raises(ValueError):\n            config.cache.makedir(\"key/name\")\n\n        p = config.cache.makedir(\"name\")\n        assert p.check()\n\n    def test_config_cache_dataerror(self, testdir):\n        testdir.makeini(\"[pytest]\")\n        config = testdir.parseconfigure()\n        cache = config.cache\n        pytest.raises(TypeError, lambda: cache.set(\"key/name\", cache))\n        config.cache.set(\"key/name\", 0)\n        config.cache._getvaluepath(\"key/name\").write_bytes(b\"123invalid\")\n        val = config.cache.get(\"key/name\", -2)\n        assert val == -2\n\n    @pytest.mark.filterwarnings(\"ignore:could not create cache path\")\n    def test_cache_writefail_cachfile_silent(self, testdir):\n        testdir.makeini(\"[pytest]\")\n        testdir.tmpdir.join(\".pytest_cache\").write(\"gone wrong\")\n        config = testdir.parseconfigure()\n        cache = config.cache\n        cache.set(\"test/broken\", [])\n\n    @pytest.mark.skipif(sys.platform.startswith(\"win\"), reason=\"no chmod on windows\")\n    @pytest.mark.filterwarnings(\n        \"ignore:could not create cache path:pytest.PytestWarning\"\n    )\n    def test_cache_writefail_permissions(self, testdir):\n        testdir.makeini(\"[pytest]\")\n        cache_dir = str(testdir.tmpdir.ensure_dir(\".pytest_cache\"))\n        mode = os.stat(cache_dir)[stat.ST_MODE]\n        testdir.tmpdir.ensure_dir(\".pytest_cache\").chmod(0)\n        try:\n            config = testdir.parseconfigure()\n            cache = config.cache\n            cache.set(\"test/broken\", [])\n        finally:\n            testdir.tmpdir.ensure_dir(\".pytest_cache\").chmod(mode)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewAPI.test_cache_failure_warns_TestNewAPI.test_cache_failure_warns": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewAPI.test_cache_failure_warns_TestNewAPI.test_cache_failure_warns", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 58, "end_line": 82, "span_ids": ["TestNewAPI.test_cache_failure_warns"], "tokens": 275}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNewAPI:\n\n    @pytest.mark.skipif(sys.platform.startswith(\"win\"), reason=\"no chmod on windows\")\n    @pytest.mark.filterwarnings(\"default\")\n    def test_cache_failure_warns(self, testdir, monkeypatch):\n        monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n        cache_dir = str(testdir.tmpdir.ensure_dir(\".pytest_cache\"))\n        mode = os.stat(cache_dir)[stat.ST_MODE]\n        testdir.tmpdir.ensure_dir(\".pytest_cache\").chmod(0)\n        try:\n            testdir.makepyfile(\"def test_error(): raise Exception\")\n            result = testdir.runpytest()\n            assert result.ret == 1\n            # warnings from nodeids, lastfailed, and stepwise\n            result.stdout.fnmatch_lines(\n                [\n                    # Validate location/stacklevel of warning from cacheprovider.\n                    \"*= warnings summary =*\",\n                    \"*/cacheprovider.py:*\",\n                    \"  */cacheprovider.py:*: PytestCacheWarning: could not create cache path \"\n                    \"{}/v/cache/nodeids\".format(cache_dir),\n                    '    config.cache.set(\"cache/nodeids\", sorted(self.cached_nodeids))',\n                    \"*1 failed, 3 warnings in*\",\n                ]\n            )\n        finally:\n            testdir.tmpdir.ensure_dir(\".pytest_cache\").chmod(mode)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewAPI.test_config_cache_TestNewAPI.test_custom_cache_dir_with_env_var": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestNewAPI.test_config_cache_TestNewAPI.test_custom_cache_dir_with_env_var", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 84, "end_line": 160, "span_ids": ["TestNewAPI.test_cachefuncarg", "TestNewAPI.test_config_cache", "TestNewAPI.test_custom_abs_cache_dir", "TestNewAPI.test_custom_cache_dir_with_env_var", "TestNewAPI.test_custom_rel_cache_dir"], "tokens": 564}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNewAPI:\n\n    def test_config_cache(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_configure(config):\n                # see that we get cache information early on\n                assert hasattr(config, \"cache\")\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_session(pytestconfig):\n                assert hasattr(pytestconfig, \"cache\")\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_cachefuncarg(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_cachefuncarg(cache):\n                val = cache.get(\"some/thing\", None)\n                assert val is None\n                cache.set(\"some/thing\", [1])\n                pytest.raises(TypeError, lambda: cache.get(\"some/thing\"))\n                val = cache.get(\"some/thing\", [])\n                assert val == [1]\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_custom_rel_cache_dir(self, testdir):\n        rel_cache_dir = os.path.join(\"custom_cache_dir\", \"subdir\")\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            cache_dir = {cache_dir}\n        \"\"\".format(\n                cache_dir=rel_cache_dir\n            )\n        )\n        testdir.makepyfile(test_errored=\"def test_error():\\n    assert False\")\n        testdir.runpytest()\n        assert testdir.tmpdir.join(rel_cache_dir).isdir()\n\n    def test_custom_abs_cache_dir(self, testdir, tmpdir_factory):\n        tmp = str(tmpdir_factory.mktemp(\"tmp\"))\n        abs_cache_dir = os.path.join(tmp, \"custom_cache_dir\")\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            cache_dir = {cache_dir}\n        \"\"\".format(\n                cache_dir=abs_cache_dir\n            )\n        )\n        testdir.makepyfile(test_errored=\"def test_error():\\n    assert False\")\n        testdir.runpytest()\n        assert py.path.local(abs_cache_dir).isdir()\n\n    def test_custom_cache_dir_with_env_var(self, testdir, monkeypatch):\n        monkeypatch.setenv(\"env_var\", \"custom_cache_dir\")\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            cache_dir = {cache_dir}\n        \"\"\".format(\n                cache_dir=\"$env_var\"\n            )\n        )\n        testdir.makepyfile(test_errored=\"def test_error():\\n    assert False\")\n        testdir.runpytest()\n        assert testdir.tmpdir.join(\"custom_cache_dir\").isdir()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_difference_invocations_TestLastFailed.test_lastfailed_difference_invocations": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_cacheprovider.py_TestLastFailed.test_lastfailed_difference_invocations_TestLastFailed.test_lastfailed_difference_invocations", "embedding": null, "metadata": {"file_path": "testing/test_cacheprovider.py", "file_name": "test_cacheprovider.py", "file_type": "text/x-python", "category": "test", "start_line": 327, "end_line": 348, "span_ids": ["TestLastFailed.test_lastfailed_difference_invocations"], "tokens": 228}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestLastFailed:\n\n    def test_lastfailed_difference_invocations(self, testdir, monkeypatch):\n        monkeypatch.setattr(\"sys.dont_write_bytecode\", True)\n        testdir.makepyfile(\n            test_a=\"\"\"\n                def test_a1(): assert 0\n                def test_a2(): assert 1\n            \"\"\",\n            test_b=\"def test_b1(): assert 0\",\n        )\n        p = testdir.tmpdir.join(\"test_a.py\")\n        p2 = testdir.tmpdir.join(\"test_b.py\")\n\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"*2 failed*\"])\n        result = testdir.runpytest(\"--lf\", p2)\n        result.stdout.fnmatch_lines([\"*1 failed*\"])\n\n        testdir.makepyfile(test_b=\"def test_b1(): assert 1\")\n        result = testdir.runpytest(\"--lf\", p2)\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result = testdir.runpytest(\"--lf\", p)\n        result.stdout.fnmatch_lines([\"collected 1 item\", \"*= 1 failed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_capfdbinary_TestCaptureFixture.test_capsysbinary.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_capfdbinary_TestCaptureFixture.test_capsysbinary.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 503, "end_line": 551, "span_ids": ["TestCaptureFixture.test_capfdbinary", "TestCaptureFixture.test_capsysbinary"], "tokens": 337}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaptureFixture:\n\n    def test_capfdbinary(self, testdir):\n        reprec = testdir.inline_runsource(\n            \"\"\"\\\n            def test_hello(capfdbinary):\n                import os\n                # some likely un-decodable bytes\n                os.write(1, b'\\\\xfe\\\\x98\\\\x20')\n                out, err = capfdbinary.readouterr()\n                assert out == b'\\\\xfe\\\\x98\\\\x20'\n                assert err == b''\n            \"\"\"\n        )\n        reprec.assertoutcome(passed=1)\n\n    def test_capsysbinary(self, testdir):\n        p1 = testdir.makepyfile(\n            r\"\"\"\n            def test_hello(capsysbinary):\n                import sys\n\n                sys.stdout.buffer.write(b'hello')\n\n                # Some likely un-decodable bytes.\n                sys.stdout.buffer.write(b'\\xfe\\x98\\x20')\n\n                sys.stdout.buffer.flush()\n\n                # Ensure writing in text mode still works and is captured.\n                # https://github.com/pytest-dev/pytest/issues/6871\n                print(\"world\", flush=True)\n\n                out, err = capsysbinary.readouterr()\n                assert out == b'hello\\xfe\\x98\\x20world\\n'\n                assert err == b''\n\n                print(\"stdout after\")\n                print(\"stderr after\", file=sys.stderr)\n            \"\"\"\n        )\n        result = testdir.runpytest(str(p1), \"-rA\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*- Captured stdout call -*\",\n                \"stdout after\",\n                \"*- Captured stderr call -*\",\n                \"stderr after\",\n                \"*= 1 passed in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_partial_setup_failure_TestCaptureFixture.test_capture_and_logging": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_partial_setup_failure_TestCaptureFixture.test_capture_and_logging", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 553, "end_line": 586, "span_ids": ["TestCaptureFixture.test_capture_and_logging", "TestCaptureFixture.test_keyboardinterrupt_disables_capturing", "TestCaptureFixture.test_partial_setup_failure"], "tokens": 223}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaptureFixture:\n\n    def test_partial_setup_failure(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_hello(capsys, missingarg):\n                pass\n            \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"*test_partial_setup_failure*\", \"*1 error*\"])\n\n    def test_keyboardinterrupt_disables_capturing(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\\\n            def test_hello(capfd):\n                import os\n                os.write(1, b'42')\n                raise KeyboardInterrupt()\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess(p)\n        result.stdout.fnmatch_lines([\"*KeyboardInterrupt*\"])\n        assert result.ret == 2\n\n    def test_capture_and_logging(self, testdir):\n        \"\"\"#14\"\"\"\n        p = testdir.makepyfile(\n            \"\"\"\\\n            import logging\n            def test_log(capsys):\n                logging.error('x')\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess(p)\n        assert \"closed\" not in result.stderr.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_fixture_use_by_other_fixtures_TestCaptureFixture.test_fixture_use_by_other_fixtures.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureFixture.test_fixture_use_by_other_fixtures_TestCaptureFixture.test_fixture_use_by_other_fixtures.None_3", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 616, "end_line": 651, "span_ids": ["TestCaptureFixture.test_fixture_use_by_other_fixtures"], "tokens": 267}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaptureFixture:\n\n    @pytest.mark.parametrize(\"fixture\", [\"capsys\", \"capfd\"])\n    def test_fixture_use_by_other_fixtures(self, testdir, fixture):\n        \"\"\"\n        Ensure that capsys and capfd can be used by other fixtures during setup and teardown.\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\\\n            import sys\n            import pytest\n\n            @pytest.fixture\n            def captured_print({fixture}):\n                print('stdout contents begin')\n                print('stderr contents begin', file=sys.stderr)\n                out, err = {fixture}.readouterr()\n\n                yield out, err\n\n                print('stdout contents end')\n                print('stderr contents end', file=sys.stderr)\n                out, err = {fixture}.readouterr()\n                assert out == 'stdout contents end\\\\n'\n                assert err == 'stderr contents end\\\\n'\n\n            def test_captured_print(captured_print):\n                out, err = captured_print\n                assert out == 'stdout contents begin\\\\n'\n                assert err == 'stderr contents begin\\\\n'\n        \"\"\".format(\n                fixture=fixture\n            )\n        )\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n        result.stdout.no_fnmatch_line(\"*stdout contents begin*\")\n        result.stdout.no_fnmatch_line(\"*stderr contents begin*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureIO_lsof_check": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestCaptureIO_lsof_check", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 785, "end_line": 860, "span_ids": ["TestCaptureIO", "TestCaptureIO.test_text", "TestCaptureIO.test_unicode_and_str_mixture", "TestCaptureIO.test_write_bytes_to_buffer", "TestTeeCaptureIO", "TestTeeCaptureIO.test_text", "TestTeeCaptureIO.test_unicode_and_str_mixture", "lsof_check", "test_dontreadfrominput", "tmpfile"], "tokens": 600}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCaptureIO:\n    def test_text(self):\n        f = capture.CaptureIO()\n        f.write(\"hello\")\n        s = f.getvalue()\n        assert s == \"hello\"\n        f.close()\n\n    def test_unicode_and_str_mixture(self):\n        f = capture.CaptureIO()\n        f.write(\"\\u00f6\")\n        pytest.raises(TypeError, f.write, b\"hello\")\n\n    def test_write_bytes_to_buffer(self):\n        \"\"\"In python3, stdout / stderr are text io wrappers (exposing a buffer\n        property of the underlying bytestream).  See issue #1407\n        \"\"\"\n        f = capture.CaptureIO()\n        f.buffer.write(b\"foo\\r\\n\")\n        assert f.getvalue() == \"foo\\r\\n\"\n\n\nclass TestTeeCaptureIO(TestCaptureIO):\n    def test_text(self):\n        sio = io.StringIO()\n        f = capture.TeeCaptureIO(sio)\n        f.write(\"hello\")\n        s1 = f.getvalue()\n        assert s1 == \"hello\"\n        s2 = sio.getvalue()\n        assert s2 == s1\n        f.close()\n        sio.close()\n\n    def test_unicode_and_str_mixture(self):\n        sio = io.StringIO()\n        f = capture.TeeCaptureIO(sio)\n        f.write(\"\\u00f6\")\n        pytest.raises(TypeError, f.write, b\"hello\")\n\n\ndef test_dontreadfrominput():\n    from _pytest.capture import DontReadFromInput\n\n    f = DontReadFromInput()\n    assert f.buffer is f\n    assert not f.isatty()\n    pytest.raises(OSError, f.read)\n    pytest.raises(OSError, f.readlines)\n    iter_f = iter(f)\n    pytest.raises(OSError, next, iter_f)\n    pytest.raises(UnsupportedOperation, f.fileno)\n    f.close()  # just for completeness\n\n\n@pytest.fixture\ndef tmpfile(testdir) -> Generator[BinaryIO, None, None]:\n    f = testdir.makepyfile(\"\").open(\"wb+\")\n    yield f\n    if not f.closed:\n        f.close()\n\n\n@contextlib.contextmanager\ndef lsof_check():\n    pid = os.getpid()\n    try:\n        out = subprocess.check_output((\"lsof\", \"-p\", str(pid))).decode()\n    except (OSError, subprocess.CalledProcessError, UnicodeDecodeError) as exc:\n        # about UnicodeDecodeError, see note on pytester\n        pytest.skip(\"could not run 'lsof' ({!r})\".format(exc))\n    yield\n    out2 = subprocess.check_output((\"lsof\", \"-p\", str(pid))).decode()\n    len1 = len([x for x in out.split(\"\\n\") if \"REG\" in x])\n    len2 = len([x for x in out2.split(\"\\n\") if \"REG\" in x])\n    assert len2 < len1 + 3, out2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestFDCapture_TestFDCapture.test_writeorg": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestFDCapture_TestFDCapture.test_writeorg", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 863, "end_line": 921, "span_ids": ["TestFDCapture", "TestFDCapture.test_simple", "TestFDCapture.test_simple_fail_second_start", "TestFDCapture.test_simple_many", "TestFDCapture.test_simple_many_check_open_files", "TestFDCapture.test_stderr", "TestFDCapture.test_stdin", "TestFDCapture.test_writeorg"], "tokens": 408}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFDCapture:\n    def test_simple(self, tmpfile):\n        fd = tmpfile.fileno()\n        cap = capture.FDCapture(fd)\n        data = b\"hello\"\n        os.write(fd, data)\n        s = cap.snap()\n        cap.done()\n        assert not s\n        cap = capture.FDCapture(fd)\n        cap.start()\n        os.write(fd, data)\n        s = cap.snap()\n        cap.done()\n        assert s == \"hello\"\n\n    def test_simple_many(self, tmpfile):\n        for i in range(10):\n            self.test_simple(tmpfile)\n\n    def test_simple_many_check_open_files(self, testdir):\n        with lsof_check():\n            with testdir.makepyfile(\"\").open(\"wb+\") as tmpfile:\n                self.test_simple_many(tmpfile)\n\n    def test_simple_fail_second_start(self, tmpfile):\n        fd = tmpfile.fileno()\n        cap = capture.FDCapture(fd)\n        cap.done()\n        pytest.raises(ValueError, cap.start)\n\n    def test_stderr(self):\n        cap = capture.FDCapture(2)\n        cap.start()\n        print(\"hello\", file=sys.stderr)\n        s = cap.snap()\n        cap.done()\n        assert s == \"hello\\n\"\n\n    def test_stdin(self):\n        cap = capture.FDCapture(0)\n        cap.start()\n        x = os.read(0, 100).strip()\n        cap.done()\n        assert x == b\"\"\n\n    def test_writeorg(self, tmpfile):\n        data1, data2 = b\"foo\", b\"bar\"\n        cap = capture.FDCapture(tmpfile.fileno())\n        cap.start()\n        tmpfile.write(data1)\n        tmpfile.flush()\n        cap.writeorg(data2.decode(\"ascii\"))\n        scap = cap.snap()\n        cap.done()\n        assert scap == data1.decode(\"ascii\")\n        with open(tmpfile.name, \"rb\") as stmp_file:\n            stmp = stmp_file.read()\n            assert stmp == data2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestFDCapture.test_simple_resume_suspend_saved_fd": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestFDCapture.test_simple_resume_suspend_saved_fd", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 923, "end_line": 968, "span_ids": ["TestFDCapture.test_capfd_sys_stdout_mode", "TestFDCapture.test_simple_resume_suspend", "saved_fd"], "tokens": 293}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFDCapture:\n\n    def test_simple_resume_suspend(self):\n        with saved_fd(1):\n            cap = capture.FDCapture(1)\n            cap.start()\n            data = b\"hello\"\n            os.write(1, data)\n            sys.stdout.write(\"whatever\")\n            s = cap.snap()\n            assert s == \"hellowhatever\"\n            cap.suspend()\n            os.write(1, b\"world\")\n            sys.stdout.write(\"qlwkej\")\n            assert not cap.snap()\n            cap.resume()\n            os.write(1, b\"but now\")\n            sys.stdout.write(\" yes\\n\")\n            s = cap.snap()\n            assert s == \"but now yes\\n\"\n            cap.suspend()\n            cap.done()\n            pytest.raises(AttributeError, cap.suspend)\n\n            assert repr(cap) == (\n                \"<FDCapture 1 oldfd=<UNSET> _state='done' tmpfile={!r}>\".format(\n                    cap.tmpfile\n                )\n            )\n            # Should not crash with missing \"_old\".\n            assert repr(cap.syscapture) == (\n                \"<SysCapture stdout _old=<UNSET> _state='done' tmpfile={!r}>\".format(\n                    cap.syscapture.tmpfile\n                )\n            )\n\n    def test_capfd_sys_stdout_mode(self, capfd):\n        assert \"b\" not in sys.stdout.mode\n\n\n@contextlib.contextmanager\ndef saved_fd(fd):\n    new_fd = os.dup(fd)\n    try:\n        yield\n    finally:\n        os.dup2(new_fd, fd)\n        os.close(new_fd)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestTeeStdCapture_TestStdCaptureFD.test_many": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_TestTeeStdCapture_TestStdCaptureFD.test_many", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1089, "end_line": 1145, "span_ids": ["TestStdCaptureFD", "TestStdCaptureFD.test_intermingling", "TestStdCaptureFD.test_many", "TestStdCaptureFD.test_simple_only_fd", "TestTeeStdCapture", "TestTeeStdCapture.test_capturing_error_recursive"], "tokens": 395}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTeeStdCapture(TestStdCapture):\n    captureclass = staticmethod(TeeStdCapture)\n\n    def test_capturing_error_recursive(self):\n        \"\"\" for TeeStdCapture since we passthrough stderr/stdout, cap1\n        should get all output, while cap2 should only get \"cap2\\n\" \"\"\"\n\n        with self.getcapture() as cap1:\n            print(\"cap1\")\n            with self.getcapture() as cap2:\n                print(\"cap2\")\n                out2, err2 = cap2.readouterr()\n                out1, err1 = cap1.readouterr()\n        assert out1 == \"cap1\\ncap2\\n\"\n        assert out2 == \"cap2\\n\"\n\n\nclass TestStdCaptureFD(TestStdCapture):\n    captureclass = staticmethod(StdCaptureFD)\n\n    def test_simple_only_fd(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\\\n            import os\n            def test_x():\n                os.write(1, b\"hello\\\\n\")\n                assert 0\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess()\n        result.stdout.fnmatch_lines(\n            \"\"\"\n            *test_x*\n            *assert 0*\n            *Captured stdout*\n        \"\"\"\n        )\n\n    def test_intermingling(self):\n        with self.getcapture() as cap:\n            os.write(1, b\"1\")\n            sys.stdout.write(str(2))\n            sys.stdout.flush()\n            os.write(1, b\"3\")\n            os.write(2, b\"a\")\n            sys.stderr.write(\"b\")\n            sys.stderr.flush()\n            os.write(2, b\"c\")\n            out, err = cap.readouterr()\n        assert out == \"123\"\n        assert err == \"abc\"\n\n    def test_many(self, capfd):\n        with lsof_check():\n            for i in range(10):\n                cap = StdCaptureFD()\n                cap.stop_capturing()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_error_attribute_issue555_test_crash_on_closing_tmpfile_py27.result_stdout_no_fnmatch_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_capture.py_test_error_attribute_issue555_test_crash_on_closing_tmpfile_py27.result_stdout_no_fnmatch_", "embedding": null, "metadata": {"file_path": "testing/test_capture.py", "file_name": "test_capture.py", "file_type": "text/x-python", "category": "test", "start_line": 1281, "end_line": 1359, "span_ids": ["test_crash_on_closing_tmpfile_py27", "test_dontreadfrominput_has_encoding", "test_error_attribute_issue555", "test_py36_windowsconsoleio_workaround_non_standard_streams"], "tokens": 475}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_error_attribute_issue555(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        def test_capattr():\n            assert sys.stdout.errors == \"replace\"\n            assert sys.stderr.errors == \"replace\"\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\n@pytest.mark.skipif(\n    not sys.platform.startswith(\"win\") and sys.version_info[:2] >= (3, 6),\n    reason=\"only py3.6+ on windows\",\n)\ndef test_py36_windowsconsoleio_workaround_non_standard_streams():\n    \"\"\"\n    Ensure _py36_windowsconsoleio_workaround function works with objects that\n    do not implement the full ``io``-based stream protocol, for example execnet channels (#2666).\n    \"\"\"\n    from _pytest.capture import _py36_windowsconsoleio_workaround\n\n    class DummyStream:\n        def write(self, s):\n            pass\n\n    stream = DummyStream()\n    _py36_windowsconsoleio_workaround(stream)\n\n\ndef test_dontreadfrominput_has_encoding(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import sys\n        def test_capattr():\n            # should not raise AttributeError\n            assert sys.stdout.encoding\n            assert sys.stderr.encoding\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\ndef test_crash_on_closing_tmpfile_py27(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import threading\n        import sys\n\n        printing = threading.Event()\n\n        def spam():\n            f = sys.stderr\n            print('SPAMBEFORE', end='', file=f)\n            printing.set()\n\n            while True:\n                try:\n                    f.flush()\n                except (OSError, ValueError):\n                    break\n\n        def test_spam_in_thread():\n            t = threading.Thread(target=spam)\n            t.daemon = True\n            t.start()\n\n            printing.wait()\n    \"\"\"\n    )\n    # Do not consider plugins like hypothesis, which might output to stderr.\n    testdir.monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    result = testdir.runpytest_subprocess(str(p))\n    assert result.ret == 0\n    assert result.stderr.str() == \"\"\n    result.stdout.no_fnmatch_line(\"*OSError*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_os_TestCollector.test_check_equality.assert_testdir_collect_by": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_os_TestCollector.test_check_equality.assert_testdir_collect_by", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 51, "span_ids": ["TestCollector", "TestCollector.test_check_equality", "TestCollector.test_collect_versus_item", "imports"], "tokens": 370}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport pprint\nimport sys\nimport textwrap\n\nimport py\n\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.main import _in_venv\nfrom _pytest.main import Session\nfrom _pytest.pytester import Testdir\n\n\nclass TestCollector:\n    def test_collect_versus_item(self):\n        from pytest import Collector, Item\n\n        assert not issubclass(Collector, Item)\n        assert not issubclass(Item, Collector)\n\n    def test_check_equality(self, testdir: Testdir) -> None:\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            def test_pass(): pass\n            def test_fail(): assert 0\n        \"\"\"\n        )\n        fn1 = testdir.collect_by_name(modcol, \"test_pass\")\n        assert isinstance(fn1, pytest.Function)\n        fn2 = testdir.collect_by_name(modcol, \"test_pass\")\n        assert isinstance(fn2, pytest.Function)\n\n        assert fn1 == fn2\n        assert fn1 != modcol\n        assert hash(fn1) == hash(fn2)\n\n        fn3 = testdir.collect_by_name(modcol, \"test_fail\")\n        assert isinstance(fn3, pytest.Function)\n        assert not (fn1 == fn3)\n        assert fn1 != fn3\n\n        for fn in fn1, fn2, fn3:\n            assert isinstance(fn, pytest.Function)\n            assert fn != 3  # type: ignore[comparison-overlap]  # noqa: F821\n            assert fn != modcol\n            assert fn != [1, 2, 3]  # type: ignore[comparison-overlap]  # noqa: F821\n            assert [1, 2, 3] != fn  # type: ignore[comparison-overlap]  # noqa: F821\n            assert modcol != fn\n\n        assert testdir.collect_by_name(modcol, \"doesnotexist\") is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS_TestCollectFS.test_ignored_virtualenvs.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS_TestCollectFS.test_ignored_virtualenvs.None_1", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 108, "end_line": 152, "span_ids": ["TestCollectFS", "TestCollectFS.test_ignored_certain_directories", "TestCollectFS.test_ignored_virtualenvs"], "tokens": 405}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCollectFS:\n    def test_ignored_certain_directories(self, testdir):\n        tmpdir = testdir.tmpdir\n        tmpdir.ensure(\"build\", \"test_notfound.py\")\n        tmpdir.ensure(\"dist\", \"test_notfound.py\")\n        tmpdir.ensure(\"_darcs\", \"test_notfound.py\")\n        tmpdir.ensure(\"CVS\", \"test_notfound.py\")\n        tmpdir.ensure(\"{arch}\", \"test_notfound.py\")\n        tmpdir.ensure(\".whatever\", \"test_notfound.py\")\n        tmpdir.ensure(\".bzr\", \"test_notfound.py\")\n        tmpdir.ensure(\"normal\", \"test_found.py\")\n        for x in tmpdir.visit(\"test_*.py\"):\n            x.write(\"def test_hello(): pass\")\n\n        result = testdir.runpytest(\"--collect-only\")\n        s = result.stdout.str()\n        assert \"test_notfound\" not in s\n        assert \"test_found\" in s\n\n    @pytest.mark.parametrize(\n        \"fname\",\n        (\n            \"activate\",\n            \"activate.csh\",\n            \"activate.fish\",\n            \"Activate\",\n            \"Activate.bat\",\n            \"Activate.ps1\",\n        ),\n    )\n    def test_ignored_virtualenvs(self, testdir, fname):\n        bindir = \"Scripts\" if sys.platform.startswith(\"win\") else \"bin\"\n        testdir.tmpdir.ensure(\"virtual\", bindir, fname)\n        testfile = testdir.tmpdir.ensure(\"virtual\", \"test_invenv.py\")\n        testfile.write(\"def test_hello(): pass\")\n\n        # by default, ignore tests inside a virtualenv\n        result = testdir.runpytest()\n        result.stdout.no_fnmatch_line(\"*test_invenv*\")\n        # allow test collection if user insists\n        result = testdir.runpytest(\"--collect-in-virtualenv\")\n        assert \"test_invenv\" in result.stdout.str()\n        # allow test collection if user directly passes in the directory\n        result = testdir.runpytest(\"virtual\")\n        assert \"test_invenv\" in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test_testpaths_ini_TestCollectFS.test_testpaths_ini.None_1": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectFS.test_testpaths_ini_TestCollectFS.test_testpaths_ini.None_1", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 214, "end_line": 242, "span_ids": ["TestCollectFS.test_testpaths_ini"], "tokens": 287}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCollectFS:\n\n    def test_testpaths_ini(self, testdir, monkeypatch):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            testpaths = gui uts\n        \"\"\"\n        )\n        tmpdir = testdir.tmpdir\n        tmpdir.ensure(\"env\", \"test_1.py\").write(\"def test_env(): pass\")\n        tmpdir.ensure(\"gui\", \"test_2.py\").write(\"def test_gui(): pass\")\n        tmpdir.ensure(\"uts\", \"test_3.py\").write(\"def test_uts(): pass\")\n\n        # executing from rootdir only tests from `testpaths` directories\n        # are collected\n        items, reprec = testdir.inline_genitems(\"-v\")\n        assert [x.name for x in items] == [\"test_gui\", \"test_uts\"]\n\n        # check that explicitly passing directories in the command-line\n        # collects the tests\n        for dirname in (\"env\", \"gui\", \"uts\"):\n            items, reprec = testdir.inline_genitems(tmpdir.join(dirname))\n            assert [x.name for x in items] == [\"test_%s\" % dirname]\n\n        # changing cwd to each subdirectory and running pytest without\n        # arguments collects the tests in that directory normally\n        for dirname in (\"env\", \"gui\", \"uts\"):\n            monkeypatch.chdir(testdir.tmpdir.join(dirname))\n            items, reprec = testdir.inline_genitems()\n            assert [x.name for x in items] == [\"test_%s\" % dirname]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectPluginHookRelay_TestCollectPluginHookRelay.test_pytest_collect_directory": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestCollectPluginHookRelay_TestCollectPluginHookRelay.test_pytest_collect_directory", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 245, "end_line": 272, "span_ids": ["TestCollectPluginHookRelay", "TestCollectPluginHookRelay.test_pytest_collect_directory", "TestCollectPluginHookRelay.test_pytest_collect_file"], "tokens": 205}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCollectPluginHookRelay:\n    def test_pytest_collect_file(self, testdir):\n        wascalled = []\n\n        class Plugin:\n            def pytest_collect_file(self, path):\n                if not path.basename.startswith(\".\"):\n                    # Ignore hidden files, e.g. .testmondata.\n                    wascalled.append(path)\n\n        testdir.makefile(\".abc\", \"xyz\")\n        pytest.main([testdir.tmpdir], plugins=[Plugin()])\n        assert len(wascalled) == 1\n        assert wascalled[0].ext == \".abc\"\n\n    @pytest.mark.filterwarnings(\"ignore:.*pytest_collect_directory.*\")\n    def test_pytest_collect_directory(self, testdir):\n        wascalled = []\n\n        class Plugin:\n            def pytest_collect_directory(self, path):\n                wascalled.append(path.basename)\n\n        testdir.mkdir(\"hello\")\n        testdir.mkdir(\"world\")\n        pytest.main(testdir.tmpdir, plugins=[Plugin()])\n        assert \"hello\" in wascalled\n        assert \"world\" in wascalled", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestNodekeywords_TestNodekeywords.test_keyword_matching_is_case_insensitive_by_default.for_expression_in_speci": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_TestNodekeywords_TestNodekeywords.test_keyword_matching_is_case_insensitive_by_default.for_expression_in_speci", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 790, "end_line": 852, "span_ids": ["TestNodekeywords", "TestNodekeywords.test_issue345", "TestNodekeywords.test_keyword_matching_is_case_insensitive_by_default", "TestNodekeywords.test_no_under"], "tokens": 396}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestNodekeywords:\n    def test_no_under(self, testdir):\n        modcol = testdir.getmodulecol(\n            \"\"\"\n            def test_pass(): pass\n            def test_fail(): assert 0\n        \"\"\"\n        )\n        values = list(modcol.keywords)\n        assert modcol.name in values\n        for x in values:\n            assert not x.startswith(\"_\")\n        assert modcol.name in repr(modcol.keywords)\n\n    def test_issue345(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test_should_not_be_selected():\n                assert False, 'I should not have been selected to run'\n\n            def test___repr__():\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-k repr\")\n        reprec.assertoutcome(passed=1, failed=0)\n\n    def test_keyword_matching_is_case_insensitive_by_default(self, testdir):\n        \"\"\"Check that selection via -k EXPRESSION is case-insensitive.\n\n        Since markers are also added to the node keywords, they too can\n        be matched without having to think about case sensitivity.\n\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def test_sPeCiFiCToPiC_1():\n                assert True\n\n            class TestSpecificTopic_2:\n                def test(self):\n                    assert True\n\n            @pytest.mark.sPeCiFiCToPic_3\n            def test():\n                assert True\n\n            @pytest.mark.sPeCiFiCToPic_4\n            class Test:\n                def test(self):\n                    assert True\n\n            def test_failing_5():\n                assert False, \"This should not match\"\n\n        \"\"\"\n        )\n        num_matching_tests = 4\n        for expression in (\"specifictopic\", \"SPECIFICTOPIC\", \"SpecificTopic\"):\n            reprec = testdir.inline_run(\"-k \" + expression)\n            reprec.assertoutcome(passed=num_matching_tests, failed=0)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_COLLECTION_ERROR_PY_FILES_test_continue_on_collection_errors": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_COLLECTION_ERROR_PY_FILES_test_continue_on_collection_errors", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 855, "end_line": 950, "span_ids": ["impl", "test_continue_on_collection_errors", "test_exit_on_collection_error", "test_exit_on_collection_with_maxfail_bigger_than_n_errors", "test_exit_on_collection_with_maxfail_smaller_than_n_errors"], "tokens": 657}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "COLLECTION_ERROR_PY_FILES = dict(\n    test_01_failure=\"\"\"\n        def test_1():\n            assert False\n        \"\"\",\n    test_02_import_error=\"\"\"\n        import asdfasdfasdf\n        def test_2():\n            assert True\n        \"\"\",\n    test_03_import_error=\"\"\"\n        import asdfasdfasdf\n        def test_3():\n            assert True\n    \"\"\",\n    test_04_success=\"\"\"\n        def test_4():\n            assert True\n    \"\"\",\n)\n\n\ndef test_exit_on_collection_error(testdir):\n    \"\"\"Verify that all collection errors are collected and no tests executed\"\"\"\n    testdir.makepyfile(**COLLECTION_ERROR_PY_FILES)\n\n    res = testdir.runpytest()\n    assert res.ret == 2\n\n    res.stdout.fnmatch_lines(\n        [\n            \"collected 2 items / 2 errors\",\n            \"*ERROR collecting test_02_import_error.py*\",\n            \"*No module named *asdfa*\",\n            \"*ERROR collecting test_03_import_error.py*\",\n            \"*No module named *asdfa*\",\n        ]\n    )\n\n\ndef test_exit_on_collection_with_maxfail_smaller_than_n_errors(testdir):\n    \"\"\"\n    Verify collection is aborted once maxfail errors are encountered ignoring\n    further modules which would cause more collection errors.\n    \"\"\"\n    testdir.makepyfile(**COLLECTION_ERROR_PY_FILES)\n\n    res = testdir.runpytest(\"--maxfail=1\")\n    assert res.ret == 1\n    res.stdout.fnmatch_lines(\n        [\n            \"collected 1 item / 1 error\",\n            \"*ERROR collecting test_02_import_error.py*\",\n            \"*No module named *asdfa*\",\n            \"*! stopping after 1 failures !*\",\n            \"*= 1 error in *\",\n        ]\n    )\n    res.stdout.no_fnmatch_line(\"*test_03*\")\n\n\ndef test_exit_on_collection_with_maxfail_bigger_than_n_errors(testdir):\n    \"\"\"\n    Verify the test run aborts due to collection errors even if maxfail count of\n    errors was not reached.\n    \"\"\"\n    testdir.makepyfile(**COLLECTION_ERROR_PY_FILES)\n\n    res = testdir.runpytest(\"--maxfail=4\")\n    assert res.ret == 2\n    res.stdout.fnmatch_lines(\n        [\n            \"collected 2 items / 2 errors\",\n            \"*ERROR collecting test_02_import_error.py*\",\n            \"*No module named *asdfa*\",\n            \"*ERROR collecting test_03_import_error.py*\",\n            \"*No module named *asdfa*\",\n            \"*! Interrupted: 2 errors during collection !*\",\n            \"*= 2 errors in *\",\n        ]\n    )\n\n\ndef test_continue_on_collection_errors(testdir):\n    \"\"\"\n    Verify tests are executed even when collection errors occur when the\n    --continue-on-collection-errors flag is set\n    \"\"\"\n    testdir.makepyfile(**COLLECTION_ERROR_PY_FILES)\n\n    res = testdir.runpytest(\"--continue-on-collection-errors\")\n    assert res.ret == 1\n\n    res.stdout.fnmatch_lines(\n        [\"collected 2 items / 2 errors\", \"*1 failed, 1 passed, 2 errors*\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_continue_on_collection_errors_maxfail_test_fixture_scope_sibling_conftests.res_stdout_fnmatch_lines_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_continue_on_collection_errors_maxfail_test_fixture_scope_sibling_conftests.res_stdout_fnmatch_lines_", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 953, "end_line": 997, "span_ids": ["test_continue_on_collection_errors_maxfail", "test_fixture_scope_sibling_conftests"], "tokens": 377}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_continue_on_collection_errors_maxfail(testdir):\n    \"\"\"\n    Verify tests are executed even when collection errors occur and that maxfail\n    is honoured (including the collection error count).\n    4 tests: 2 collection errors + 1 failure + 1 success\n    test_4 is never executed because the test run is with --maxfail=3 which\n    means it is interrupted after the 2 collection errors + 1 failure.\n    \"\"\"\n    testdir.makepyfile(**COLLECTION_ERROR_PY_FILES)\n\n    res = testdir.runpytest(\"--continue-on-collection-errors\", \"--maxfail=3\")\n    assert res.ret == 1\n\n    res.stdout.fnmatch_lines([\"collected 2 items / 2 errors\", \"*1 failed, 2 errors*\"])\n\n\ndef test_fixture_scope_sibling_conftests(testdir):\n    \"\"\"Regression test case for https://github.com/pytest-dev/pytest/issues/2836\"\"\"\n    foo_path = testdir.mkdir(\"foo\")\n    foo_path.join(\"conftest.py\").write(\n        textwrap.dedent(\n            \"\"\"\\\n            import pytest\n            @pytest.fixture\n            def fix():\n                return 1\n            \"\"\"\n        )\n    )\n    foo_path.join(\"test_foo.py\").write(\"def test_foo(fix): assert fix == 1\")\n\n    # Tests in `food/` should not see the conftest fixture from `foo/`\n    food_path = testdir.mkpydir(\"food\")\n    food_path.join(\"test_food.py\").write(\"def test_food(fix): assert fix == 1\")\n\n    res = testdir.runpytest()\n    assert res.ret == 1\n\n    res.stdout.fnmatch_lines(\n        [\n            \"*ERROR at setup of test_food*\",\n            \"E*fixture 'fix' not found\",\n            \"*1 passed, 1 error*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_init_tests_test_collect_init_tests.None_7": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_collection.py_test_collect_init_tests_test_collect_init_tests.None_7", "embedding": null, "metadata": {"file_path": "testing/test_collection.py", "file_name": "test_collection.py", "file_type": "text/x-python", "category": "test", "start_line": 1000, "end_line": 1058, "span_ids": ["test_collect_init_tests"], "tokens": 494}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_collect_init_tests(testdir):\n    \"\"\"Check that we collect files from __init__.py files when they patch the 'python_files' (#3773)\"\"\"\n    p = testdir.copy_example(\"collect/collect_init_tests\")\n    result = testdir.runpytest(p, \"--collect-only\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 2 items\",\n            \"<Package *\",\n            \"  <Module __init__.py>\",\n            \"    <Function test_init>\",\n            \"  <Module test_foo.py>\",\n            \"    <Function test_foo>\",\n        ]\n    )\n    result = testdir.runpytest(\"./tests\", \"--collect-only\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 2 items\",\n            \"<Package *\",\n            \"  <Module __init__.py>\",\n            \"    <Function test_init>\",\n            \"  <Module test_foo.py>\",\n            \"    <Function test_foo>\",\n        ]\n    )\n    # Ignores duplicates with \".\" and pkginit (#4310).\n    result = testdir.runpytest(\"./tests\", \".\", \"--collect-only\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 2 items\",\n            \"<Package */tests>\",\n            \"  <Module __init__.py>\",\n            \"    <Function test_init>\",\n            \"  <Module test_foo.py>\",\n            \"    <Function test_foo>\",\n        ]\n    )\n    # Same as before, but different order.\n    result = testdir.runpytest(\".\", \"tests\", \"--collect-only\")\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 2 items\",\n            \"<Package */tests>\",\n            \"  <Module __init__.py>\",\n            \"    <Function test_init>\",\n            \"  <Module test_foo.py>\",\n            \"    <Function test_foo>\",\n        ]\n    )\n    result = testdir.runpytest(\"./tests/test_foo.py\", \"--collect-only\")\n    result.stdout.fnmatch_lines(\n        [\"<Package */tests>\", \"  <Module test_foo.py>\", \"    <Function test_foo>\"]\n    )\n    result.stdout.no_fnmatch_line(\"*test_init*\")\n    result = testdir.runpytest(\"./tests/__init__.py\", \"--collect-only\")\n    result.stdout.fnmatch_lines(\n        [\"<Package */tests>\", \"  <Module __init__.py>\", \"    <Function test_init>\"]\n    )\n    result.stdout.no_fnmatch_line(\"*test_foo*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_disable_plugin_autoload_test_disable_plugin_autoload.if_should_load_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_disable_plugin_autoload_test_disable_plugin_autoload.if_should_load_", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 647, "end_line": 685, "span_ids": ["test_disable_plugin_autoload"], "tokens": 253}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"parse_args,should_load\", [((\"-p\", \"mytestplugin\"), True), ((), False)]\n)\ndef test_disable_plugin_autoload(testdir, monkeypatch, parse_args, should_load):\n    class DummyEntryPoint:\n        project_name = name = \"mytestplugin\"\n        group = \"pytest11\"\n        version = \"1.0\"\n\n        def load(self):\n            return sys.modules[self.name]\n\n    class Distribution:\n        entry_points = (DummyEntryPoint(),)\n        files = ()\n\n    class PseudoPlugin:\n        x = 42\n\n        attrs_used = []\n\n        def __getattr__(self, name):\n            assert name == \"__loader__\"\n            self.attrs_used.append(name)\n            return object()\n\n    def distributions():\n        return (Distribution(),)\n\n    monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n    monkeypatch.setattr(importlib_metadata, \"distributions\", distributions)\n    monkeypatch.setitem(sys.modules, \"mytestplugin\", PseudoPlugin())\n    config = testdir.parseconfig(*parse_args)\n    has_loaded = config.pluginmanager.get_plugin(\"mytestplugin\") is not None\n    assert has_loaded == should_load\n    if should_load:\n        assert PseudoPlugin.attrs_used == [\"__loader__\"]\n    else:\n        assert PseudoPlugin.attrs_used == []", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_plugin_loading_order_test_invalid_options_show_extra_information": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_plugin_loading_order_test_invalid_options_show_extra_information", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 688, "end_line": 741, "span_ids": ["test_cmdline_processargs_simple", "test_invalid_options_show_extra_information", "test_plugin_loading_order"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_plugin_loading_order(testdir):\n    \"\"\"Test order of plugin loading with `-p`.\"\"\"\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def test_terminal_plugin(request):\n            import myplugin\n            assert myplugin.terminal_plugin == [False, True]\n        \"\"\",\n        **{\n            \"myplugin\": \"\"\"\n            terminal_plugin = []\n\n            def pytest_configure(config):\n                terminal_plugin.append(bool(config.pluginmanager.get_plugin(\"terminalreporter\")))\n\n            def pytest_sessionstart(session):\n                config = session.config\n                terminal_plugin.append(bool(config.pluginmanager.get_plugin(\"terminalreporter\")))\n            \"\"\"\n        },\n    )\n    testdir.syspathinsert()\n    result = testdir.runpytest(\"-p\", \"myplugin\", str(p1))\n    assert result.ret == 0\n\n\ndef test_cmdline_processargs_simple(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_cmdline_preparse(args):\n            args.append(\"-h\")\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*pytest*\", \"*-h*\"])\n\n\ndef test_invalid_options_show_extra_information(testdir):\n    \"\"\"display extra information when pytest exits due to unrecognized\n    options in the command-line\"\"\"\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        addopts = --invalid-option\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stderr.fnmatch_lines(\n        [\n            \"*error: unrecognized arguments: --invalid-option*\",\n            \"*  inifile: %s*\" % testdir.tmpdir.join(\"tox.ini\"),\n            \"*  rootdir: %s*\" % testdir.tmpdir,\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_toolongargs_issue224_test_load_initial_conftest_last_ordering": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_toolongargs_issue224_test_load_initial_conftest_last_ordering", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 772, "end_line": 847, "span_ids": ["test_config_in_subdirectory_colon_command_line_issue2148", "test_load_initial_conftest_last_ordering", "test_no_terminal_discovery_error", "test_notify_exception", "test_toolongargs_issue224"], "tokens": 564}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.skipif(\"sys.platform == 'win32'\")\ndef test_toolongargs_issue224(testdir):\n    result = testdir.runpytest(\"-m\", \"hello\" * 500)\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_config_in_subdirectory_colon_command_line_issue2148(testdir):\n    conftest_source = \"\"\"\n        def pytest_addoption(parser):\n            parser.addini('foo', 'foo')\n    \"\"\"\n\n    testdir.makefile(\n        \".ini\",\n        **{\"pytest\": \"[pytest]\\nfoo = root\", \"subdir/pytest\": \"[pytest]\\nfoo = subdir\"},\n    )\n\n    testdir.makepyfile(\n        **{\n            \"conftest\": conftest_source,\n            \"subdir/conftest\": conftest_source,\n            \"subdir/test_foo\": \"\"\"\\\n            def test_foo(pytestconfig):\n                assert pytestconfig.getini('foo') == 'subdir'\n            \"\"\",\n        }\n    )\n\n    result = testdir.runpytest(\"subdir/test_foo.py::test_foo\")\n    assert result.ret == 0\n\n\ndef test_notify_exception(testdir, capfd):\n    config = testdir.parseconfig()\n    with pytest.raises(ValueError) as excinfo:\n        raise ValueError(1)\n    config.notify_exception(excinfo, config.option)\n    _, err = capfd.readouterr()\n    assert \"ValueError\" in err\n\n    class A:\n        def pytest_internalerror(self):\n            return True\n\n    config.pluginmanager.register(A())\n    config.notify_exception(excinfo, config.option)\n    _, err = capfd.readouterr()\n    assert not err\n\n    config = testdir.parseconfig(\"-p\", \"no:terminal\")\n    with pytest.raises(ValueError) as excinfo:\n        raise ValueError(1)\n    config.notify_exception(excinfo, config.option)\n    _, err = capfd.readouterr()\n    assert \"ValueError\" in err\n\n\ndef test_no_terminal_discovery_error(testdir):\n    testdir.makepyfile(\"raise TypeError('oops!')\")\n    result = testdir.runpytest(\"-p\", \"no:terminal\", \"--collect-only\")\n    assert result.ret == ExitCode.INTERRUPTED\n\n\ndef test_load_initial_conftest_last_ordering(_config_for_test):\n    pm = _config_for_test.pluginmanager\n\n    class My:\n        def pytest_load_initial_conftests(self):\n            pass\n\n    m = My()\n    pm.register(m)\n    hc = pm.hook.pytest_load_initial_conftests\n    values = hc._nonwrappers + hc._wrappers\n    expected = [\"_pytest.config\", m.__module__, \"_pytest.capture\"]\n    assert [x.function.__module__ for x in values] == expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_get_plugin_specs_as_list_test_collect_pytest_prefix_bug": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_get_plugin_specs_as_list_test_collect_pytest_prefix_bug", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 850, "end_line": 889, "span_ids": ["test_collect_pytest_prefix_bug", "test_collect_pytest_prefix_bug_integration", "test_get_plugin_specs_as_list"], "tokens": 349}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_get_plugin_specs_as_list():\n    from _pytest.config import _get_plugin_specs_as_list\n\n    def exp_match(val):\n        return (\n            \"Plugin specs must be a ','-separated string\"\n            \" or a list/tuple of strings for plugin names. Given: {}\".format(\n                re.escape(repr(val))\n            )\n        )\n\n    with pytest.raises(pytest.UsageError, match=exp_match({\"foo\"})):\n        _get_plugin_specs_as_list({\"foo\"})\n    with pytest.raises(pytest.UsageError, match=exp_match({})):\n        _get_plugin_specs_as_list(dict())\n\n    assert _get_plugin_specs_as_list(None) == []\n    assert _get_plugin_specs_as_list(\"\") == []\n    assert _get_plugin_specs_as_list(\"foo\") == [\"foo\"]\n    assert _get_plugin_specs_as_list(\"foo,bar\") == [\"foo\", \"bar\"]\n    assert _get_plugin_specs_as_list([\"foo\", \"bar\"]) == [\"foo\", \"bar\"]\n    assert _get_plugin_specs_as_list((\"foo\", \"bar\")) == [\"foo\", \"bar\"]\n\n\ndef test_collect_pytest_prefix_bug_integration(testdir):\n    \"\"\"Integration test for issue #3775\"\"\"\n    p = testdir.copy_example(\"config/collect_pytest_prefix\")\n    result = testdir.runpytest(p)\n    result.stdout.fnmatch_lines([\"* 1 passed *\"])\n\n\ndef test_collect_pytest_prefix_bug(pytestconfig):\n    \"\"\"Ensure we collect only actual functions from conftest files (#3775)\"\"\"\n\n    class Dummy:\n        class pytest_something:\n            pass\n\n    pm = pytestconfig.pluginmanager\n    assert pm.parse_hookimpl_opts(Dummy(), \"pytest_something\") is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestRootdir_TestRootdir.test_with_arg_outside_cwd_without_inifile": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestRootdir_TestRootdir.test_with_arg_outside_cwd_without_inifile", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 892, "end_line": 955, "span_ids": ["TestRootdir", "TestRootdir.test_nothing", "TestRootdir.test_pytestini_overrides_empty_other", "TestRootdir.test_setuppy_fallback", "TestRootdir.test_simple_noini", "TestRootdir.test_with_arg_outside_cwd_without_inifile", "TestRootdir.test_with_ini", "TestRootdir.test_with_specific_inifile"], "tokens": 717}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRootdir:\n    def test_simple_noini(self, tmpdir):\n        assert get_common_ancestor([tmpdir]) == tmpdir\n        a = tmpdir.mkdir(\"a\")\n        assert get_common_ancestor([a, tmpdir]) == tmpdir\n        assert get_common_ancestor([tmpdir, a]) == tmpdir\n        with tmpdir.as_cwd():\n            assert get_common_ancestor([]) == tmpdir\n            no_path = tmpdir.join(\"does-not-exist\")\n            assert get_common_ancestor([no_path]) == tmpdir\n            assert get_common_ancestor([no_path.join(\"a\")]) == tmpdir\n\n    @pytest.mark.parametrize(\"name\", \"setup.cfg tox.ini pytest.ini\".split())\n    def test_with_ini(self, tmpdir: py.path.local, name: str) -> None:\n        inifile = tmpdir.join(name)\n        inifile.write(\"[pytest]\\n\" if name != \"setup.cfg\" else \"[tool:pytest]\\n\")\n\n        a = tmpdir.mkdir(\"a\")\n        b = a.mkdir(\"b\")\n        for args in ([str(tmpdir)], [str(a)], [str(b)]):\n            rootdir, parsed_inifile, _ = determine_setup(None, args)\n            assert rootdir == tmpdir\n            assert parsed_inifile == inifile\n        rootdir, parsed_inifile, _ = determine_setup(None, [str(b), str(a)])\n        assert rootdir == tmpdir\n        assert parsed_inifile == inifile\n\n    @pytest.mark.parametrize(\"name\", \"setup.cfg tox.ini\".split())\n    def test_pytestini_overrides_empty_other(self, tmpdir: py.path.local, name) -> None:\n        inifile = tmpdir.ensure(\"pytest.ini\")\n        a = tmpdir.mkdir(\"a\")\n        a.ensure(name)\n        rootdir, parsed_inifile, _ = determine_setup(None, [str(a)])\n        assert rootdir == tmpdir\n        assert parsed_inifile == inifile\n\n    def test_setuppy_fallback(self, tmpdir: py.path.local) -> None:\n        a = tmpdir.mkdir(\"a\")\n        a.ensure(\"setup.cfg\")\n        tmpdir.ensure(\"setup.py\")\n        rootdir, inifile, inicfg = determine_setup(None, [str(a)])\n        assert rootdir == tmpdir\n        assert inifile is None\n        assert inicfg == {}\n\n    def test_nothing(self, tmpdir: py.path.local, monkeypatch) -> None:\n        monkeypatch.chdir(str(tmpdir))\n        rootdir, inifile, inicfg = determine_setup(None, [str(tmpdir)])\n        assert rootdir == tmpdir\n        assert inifile is None\n        assert inicfg == {}\n\n    def test_with_specific_inifile(self, tmpdir: py.path.local) -> None:\n        inifile = tmpdir.ensure(\"pytest.ini\")\n        rootdir, _, _ = determine_setup(str(inifile), [str(tmpdir)])\n        assert rootdir == tmpdir\n\n    def test_with_arg_outside_cwd_without_inifile(self, tmpdir, monkeypatch) -> None:\n        monkeypatch.chdir(str(tmpdir))\n        a = tmpdir.mkdir(\"a\")\n        b = tmpdir.mkdir(\"b\")\n        rootdir, inifile, _ = determine_setup(None, [str(a), str(b)])\n        assert rootdir == tmpdir\n        assert inifile is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestRootdir.test_with_arg_outside_cwd_with_inifile_TestRootdir.test_with_existing_file_in_subdir": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestRootdir.test_with_arg_outside_cwd_with_inifile_TestRootdir.test_with_existing_file_in_subdir", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 957, "end_line": 978, "span_ids": ["TestRootdir.test_with_arg_outside_cwd_with_inifile", "TestRootdir.test_with_existing_file_in_subdir", "TestRootdir.test_with_non_dir_arg"], "tokens": 243}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestRootdir:\n\n    def test_with_arg_outside_cwd_with_inifile(self, tmpdir) -> None:\n        a = tmpdir.mkdir(\"a\")\n        b = tmpdir.mkdir(\"b\")\n        inifile = a.ensure(\"pytest.ini\")\n        rootdir, parsed_inifile, _ = determine_setup(None, [str(a), str(b)])\n        assert rootdir == a\n        assert inifile == parsed_inifile\n\n    @pytest.mark.parametrize(\"dirs\", ([], [\"does-not-exist\"], [\"a/does-not-exist\"]))\n    def test_with_non_dir_arg(self, dirs, tmpdir) -> None:\n        with tmpdir.ensure(dir=True).as_cwd():\n            rootdir, inifile, _ = determine_setup(None, dirs)\n            assert rootdir == tmpdir\n            assert inifile is None\n\n    def test_with_existing_file_in_subdir(self, tmpdir) -> None:\n        a = tmpdir.mkdir(\"a\")\n        a.ensure(\"exist\")\n        with tmpdir.as_cwd():\n            rootdir, inifile, _ = determine_setup(None, [\"a/exist\"])\n            assert rootdir == tmpdir\n            assert inifile is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_override_ini_usage_error_bad_style_TestOverrideIniArgs.test_override_ini_does_not_contain_paths": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_TestOverrideIniArgs.test_override_ini_usage_error_bad_style_TestOverrideIniArgs.test_override_ini_does_not_contain_paths", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1087, "end_line": 1159, "span_ids": ["TestOverrideIniArgs.test_addopts_before_initini", "TestOverrideIniArgs.test_addopts_from_env_not_concatenated", "TestOverrideIniArgs.test_addopts_from_ini_not_concatenated", "TestOverrideIniArgs.test_override_ini_does_not_contain_paths", "TestOverrideIniArgs.test_override_ini_handled_asap", "TestOverrideIniArgs.test_override_ini_usage_error_bad_style"], "tokens": 658}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestOverrideIniArgs:\n\n    def test_override_ini_usage_error_bad_style(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            xdist_strict=False\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--override-ini\", \"xdist_strict\", \"True\")\n        result.stderr.fnmatch_lines(\n            [\n                \"ERROR: -o/--override-ini expects option=value style (got: 'xdist_strict').\",\n            ]\n        )\n\n    @pytest.mark.parametrize(\"with_ini\", [True, False])\n    def test_override_ini_handled_asap(self, testdir, with_ini):\n        \"\"\"-o should be handled as soon as possible and always override what's in ini files (#2238)\"\"\"\n        if with_ini:\n            testdir.makeini(\n                \"\"\"\n                [pytest]\n                python_files=test_*.py\n            \"\"\"\n            )\n        testdir.makepyfile(\n            unittest_ini_handle=\"\"\"\n            def test():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--override-ini\", \"python_files=unittest_*.py\")\n        result.stdout.fnmatch_lines([\"*1 passed in*\"])\n\n    def test_addopts_before_initini(self, monkeypatch, _config_for_test, _sys_snapshot):\n        cache_dir = \".custom_cache\"\n        monkeypatch.setenv(\"PYTEST_ADDOPTS\", \"-o cache_dir=%s\" % cache_dir)\n        config = _config_for_test\n        config._preparse([], addopts=True)\n        assert config._override_ini == [\"cache_dir=%s\" % cache_dir]\n\n    def test_addopts_from_env_not_concatenated(self, monkeypatch, _config_for_test):\n        \"\"\"PYTEST_ADDOPTS should not take values from normal args (#4265).\"\"\"\n        monkeypatch.setenv(\"PYTEST_ADDOPTS\", \"-o\")\n        config = _config_for_test\n        with pytest.raises(UsageError) as excinfo:\n            config._preparse([\"cache_dir=ignored\"], addopts=True)\n        assert (\n            \"error: argument -o/--override-ini: expected one argument (via PYTEST_ADDOPTS)\"\n            in excinfo.value.args[0]\n        )\n\n    def test_addopts_from_ini_not_concatenated(self, testdir):\n        \"\"\"addopts from ini should not take values from normal args (#4265).\"\"\"\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            addopts=-o\n        \"\"\"\n        )\n        result = testdir.runpytest(\"cache_dir=ignored\")\n        result.stderr.fnmatch_lines(\n            [\n                \"%s: error: argument -o/--override-ini: expected one argument (via addopts config)\"\n                % (testdir.request.config._parser.optparser.prog,)\n            ]\n        )\n        assert result.ret == _pytest.config.ExitCode.USAGE_ERROR\n\n    def test_override_ini_does_not_contain_paths(self, _config_for_test, _sys_snapshot):\n        \"\"\"Check that -o no longer swallows all options after it (#3103)\"\"\"\n        config = _config_for_test\n        config._preparse([\"-o\", \"cache_dir=/cache\", \"/some/test/path\"])\n        assert config._override_ini == [\"cache_dir=/cache\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_help_formatter_uses_py_get_terminal_width_test_config_does_not_load_blocked_plugin_from_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_help_formatter_uses_py_get_terminal_width_test_config_does_not_load_blocked_plugin_from_args", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1251, "end_line": 1275, "span_ids": ["test_config_does_not_load_blocked_plugin_from_args", "test_help_formatter_uses_py_get_terminal_width"], "tokens": 260}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_help_formatter_uses_py_get_terminal_width(monkeypatch):\n    from _pytest.config.argparsing import DropShorterLongHelpFormatter\n\n    monkeypatch.setenv(\"COLUMNS\", \"90\")\n    formatter = DropShorterLongHelpFormatter(\"prog\")\n    assert formatter._width == 90\n\n    monkeypatch.setattr(\"_pytest._io.get_terminal_width\", lambda: 160)\n    formatter = DropShorterLongHelpFormatter(\"prog\")\n    assert formatter._width == 160\n\n    formatter = DropShorterLongHelpFormatter(\"prog\", width=42)\n    assert formatter._width == 42\n\n\ndef test_config_does_not_load_blocked_plugin_from_args(testdir):\n    \"\"\"This tests that pytest's config setup handles \"-p no:X\".\"\"\"\n    p = testdir.makepyfile(\"def test(capfd): pass\")\n    result = testdir.runpytest(str(p), \"-pno:capture\")\n    result.stdout.fnmatch_lines([\"E       fixture 'capfd' not found\"])\n    assert result.ret == ExitCode.TESTS_FAILED\n\n    result = testdir.runpytest(str(p), \"-pno:capture\", \"-s\")\n    result.stderr.fnmatch_lines([\"*: error: unrecognized arguments: -s\"])\n    assert result.ret == ExitCode.USAGE_ERROR", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_invocation_args_test_invocation_args": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_config.py_test_invocation_args_test_invocation_args", "embedding": null, "metadata": {"file_path": "testing/test_config.py", "file_name": "test_config.py", "file_type": "text/x-python", "category": "test", "start_line": 1278, "end_line": 1302, "span_ids": ["test_invocation_args"], "tokens": 210}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_invocation_args(testdir):\n    \"\"\"Ensure that Config.invocation_* arguments are correctly defined\"\"\"\n\n    class DummyPlugin:\n        pass\n\n    p = testdir.makepyfile(\"def test(): pass\")\n    plugin = DummyPlugin()\n    rec = testdir.inline_run(p, \"-v\", plugins=[plugin])\n    calls = rec.getcalls(\"pytest_runtest_protocol\")\n    assert len(calls) == 1\n    call = calls[0]\n    config = call.item.config\n\n    assert config.invocation_params.args == (p, \"-v\")\n    assert config.invocation_params.dir == Path(str(testdir.tmpdir))\n\n    plugins = config.invocation_params.plugins\n    assert len(plugins) == 2\n    assert plugins[0] is plugin\n    assert type(plugins[1]).__name__ == \"Collect\"  # installed by testdir.inline_run()\n\n    # args cannot be None\n    with pytest.raises(TypeError):\n        Config.InvocationParams(args=None, plugins=None, dir=Path())", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_os_custom_debugger_hook": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_os_custom_debugger_hook", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 78, "span_ids": ["custom_debugger_hook", "custom_pdb_calls", "imports", "pdb_env", "runpdb_and_get_report"], "tokens": 448}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport sys\n\nimport _pytest._code\nimport pytest\nfrom _pytest.debugging import _validate_usepdb_cls\n\ntry:\n    # Type ignored for Python <= 3.6.\n    breakpoint  # type: ignore\nexcept NameError:\n    SUPPORTS_BREAKPOINT_BUILTIN = False\nelse:\n    SUPPORTS_BREAKPOINT_BUILTIN = True\n\n\n_ENVIRON_PYTHONBREAKPOINT = os.environ.get(\"PYTHONBREAKPOINT\", \"\")\n\n\n@pytest.fixture(autouse=True)\ndef pdb_env(request):\n    if \"testdir\" in request.fixturenames:\n        # Disable pdb++ with inner tests.\n        testdir = request.getfixturevalue(\"testdir\")\n        testdir.monkeypatch.setenv(\"PDBPP_HIJACK_PDB\", \"0\")\n\n\ndef runpdb_and_get_report(testdir, source):\n    p = testdir.makepyfile(source)\n    result = testdir.runpytest_inprocess(\"--pdb\", p)\n    reports = result.reprec.getreports(\"pytest_runtest_logreport\")\n    assert len(reports) == 3, reports  # setup/call/teardown\n    return reports[1]\n\n\n@pytest.fixture\ndef custom_pdb_calls():\n    called = []\n\n    # install dummy debugger class and track which methods were called on it\n    class _CustomPdb:\n        quitting = False\n\n        def __init__(self, *args, **kwargs):\n            called.append(\"init\")\n\n        def reset(self):\n            called.append(\"reset\")\n\n        def interaction(self, *args):\n            called.append(\"interaction\")\n\n    _pytest._CustomPdb = _CustomPdb\n    return called\n\n\n@pytest.fixture\ndef custom_debugger_hook():\n    called = []\n\n    # install dummy debugger class and track which methods were called on it\n    class _CustomDebugger:\n        def __init__(self, *args, **kwargs):\n            called.append(\"init\")\n\n        def reset(self):\n            called.append(\"reset\")\n\n        def interaction(self, *args):\n            called.append(\"interaction\")\n\n        def set_trace(self, frame):\n            print(\"**CustomDebugger**\")\n            called.append(\"set_trace\")\n\n    _pytest._CustomDebugger = _CustomDebugger\n    yield called\n    del _pytest._CustomDebugger", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB_TestPDB.test_pdb_unittest_skip": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB_TestPDB.test_pdb_unittest_skip", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 81, "end_line": 198, "span_ids": ["TestPDB", "TestPDB.flush", "TestPDB.pdblist", "TestPDB.test_pdb_on_BdbQuit", "TestPDB.test_pdb_on_KeyboardInterrupt", "TestPDB.test_pdb_on_fail", "TestPDB.test_pdb_on_skip", "TestPDB.test_pdb_on_xfail", "TestPDB.test_pdb_unittest_postmortem", "TestPDB.test_pdb_unittest_skip"], "tokens": 741}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n    @pytest.fixture\n    def pdblist(self, request):\n        monkeypatch = request.getfixturevalue(\"monkeypatch\")\n        pdblist = []\n\n        def mypdb(*args):\n            pdblist.append(args)\n\n        plugin = request.config.pluginmanager.getplugin(\"debugging\")\n        monkeypatch.setattr(plugin, \"post_mortem\", mypdb)\n        return pdblist\n\n    def test_pdb_on_fail(self, testdir, pdblist):\n        rep = runpdb_and_get_report(\n            testdir,\n            \"\"\"\n            def test_func():\n                assert 0\n        \"\"\",\n        )\n        assert rep.failed\n        assert len(pdblist) == 1\n        tb = _pytest._code.Traceback(pdblist[0][0])\n        assert tb[-1].name == \"test_func\"\n\n    def test_pdb_on_xfail(self, testdir, pdblist):\n        rep = runpdb_and_get_report(\n            testdir,\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail\n            def test_func():\n                assert 0\n        \"\"\",\n        )\n        assert \"xfail\" in rep.keywords\n        assert not pdblist\n\n    def test_pdb_on_skip(self, testdir, pdblist):\n        rep = runpdb_and_get_report(\n            testdir,\n            \"\"\"\n            import pytest\n            def test_func():\n                pytest.skip(\"hello\")\n        \"\"\",\n        )\n        assert rep.skipped\n        assert len(pdblist) == 0\n\n    def test_pdb_on_BdbQuit(self, testdir, pdblist):\n        rep = runpdb_and_get_report(\n            testdir,\n            \"\"\"\n            import bdb\n            def test_func():\n                raise bdb.BdbQuit\n        \"\"\",\n        )\n        assert rep.failed\n        assert len(pdblist) == 0\n\n    def test_pdb_on_KeyboardInterrupt(self, testdir, pdblist):\n        rep = runpdb_and_get_report(\n            testdir,\n            \"\"\"\n            def test_func():\n                raise KeyboardInterrupt\n        \"\"\",\n        )\n        assert rep.failed\n        assert len(pdblist) == 1\n\n    @staticmethod\n    def flush(child):\n        if child.isalive():\n            # Read if the test has not (e.g. test_pdb_unittest_skip).\n            child.read()\n            child.wait()\n        assert not child.isalive()\n\n    def test_pdb_unittest_postmortem(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import unittest\n            class Blub(unittest.TestCase):\n                def tearDown(self):\n                    self.filename = None\n                def test_false(self):\n                    self.filename = 'debug' + '.me'\n                    assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--pdb %s\" % p1)\n        child.expect(\"Pdb\")\n        child.sendline(\"p self.filename\")\n        child.sendeof()\n        rest = child.read().decode(\"utf8\")\n        assert \"debug.me\" in rest\n        self.flush(child)\n\n    def test_pdb_unittest_skip(self, testdir):\n        \"\"\"Test for issue #2137\"\"\"\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import unittest\n            @unittest.skipIf(True, 'Skipping also with pdb active')\n            class MyTestCase(unittest.TestCase):\n                def test_one(self):\n                    assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"-rs --pdb %s\" % p1)\n        child.expect(\"Skipping also with pdb active\")\n        child.expect_exact(\"= 1 skipped in\")\n        child.sendeof()\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_print_captured_stdout_and_stderr_TestPDB.test_pdb_print_captured_logs_nologging": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_print_captured_stdout_and_stderr_TestPDB.test_pdb_print_captured_logs_nologging", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 200, "end_line": 283, "span_ids": ["TestPDB.test_pdb_dont_print_empty_captured_stdout_and_stderr", "TestPDB.test_pdb_print_captured_logs", "TestPDB.test_pdb_print_captured_logs_nologging", "TestPDB.test_pdb_print_captured_stdout_and_stderr"], "tokens": 623}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    def test_pdb_print_captured_stdout_and_stderr(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                import sys\n                sys.stderr.write(\"get\\\\x20rekt\")\n                print(\"get\\\\x20rekt\")\n                assert False\n\n            def test_not_called_due_to_quit():\n                pass\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--pdb %s\" % p1)\n        child.expect(\"captured stdout\")\n        child.expect(\"get rekt\")\n        child.expect(\"captured stderr\")\n        child.expect(\"get rekt\")\n        child.expect(\"traceback\")\n        child.expect(\"def test_1\")\n        child.expect(\"Pdb\")\n        child.sendeof()\n        rest = child.read().decode(\"utf8\")\n        assert \"Exit: Quitting debugger\" in rest\n        assert \"= 1 failed in\" in rest\n        assert \"def test_1\" not in rest\n        assert \"get rekt\" not in rest\n        self.flush(child)\n\n    def test_pdb_dont_print_empty_captured_stdout_and_stderr(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                assert False\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--pdb %s\" % p1)\n        child.expect(\"Pdb\")\n        output = child.before.decode(\"utf8\")\n        child.sendeof()\n        assert \"captured stdout\" not in output\n        assert \"captured stderr\" not in output\n        self.flush(child)\n\n    @pytest.mark.parametrize(\"showcapture\", [\"all\", \"no\", \"log\"])\n    def test_pdb_print_captured_logs(self, testdir, showcapture):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                import logging\n                logging.warn(\"get \" + \"rekt\")\n                assert False\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\n            \"--show-capture={} --pdb {}\".format(showcapture, p1)\n        )\n        if showcapture in (\"all\", \"log\"):\n            child.expect(\"captured log\")\n            child.expect(\"get rekt\")\n        child.expect(\"Pdb\")\n        child.sendeof()\n        rest = child.read().decode(\"utf8\")\n        assert \"1 failed\" in rest\n        self.flush(child)\n\n    def test_pdb_print_captured_logs_nologging(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                import logging\n                logging.warn(\"get \" + \"rekt\")\n                assert False\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--show-capture=all --pdb -p no:logging %s\" % p1)\n        child.expect(\"get rekt\")\n        output = child.before.decode(\"utf8\")\n        assert \"captured log\" not in output\n        child.expect(\"Pdb\")\n        child.sendeof()\n        rest = child.read().decode(\"utf8\")\n        assert \"1 failed\" in rest\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_interaction_exception_TestPDB.test_pdb_set_trace_kwargs": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_interaction_exception_TestPDB.test_pdb_set_trace_kwargs", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 285, "end_line": 390, "span_ids": ["TestPDB.test_pdb_interaction_capturing_simple", "TestPDB.test_pdb_interaction_exception", "TestPDB.test_pdb_interaction_on_collection_issue181", "TestPDB.test_pdb_interaction_on_internal_error", "TestPDB.test_pdb_set_trace_kwargs"], "tokens": 712}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    def test_pdb_interaction_exception(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def globalfunc():\n                pass\n            def test_1():\n                pytest.raises(ValueError, globalfunc)\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--pdb %s\" % p1)\n        child.expect(\".*def test_1\")\n        child.expect(\".*pytest.raises.*globalfunc\")\n        child.expect(\"Pdb\")\n        child.sendline(\"globalfunc\")\n        child.expect(\".*function\")\n        child.sendeof()\n        child.expect(\"1 failed\")\n        self.flush(child)\n\n    def test_pdb_interaction_on_collection_issue181(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            xxx\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--pdb %s\" % p1)\n        # child.expect(\".*import pytest.*\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        child.expect(\"1 error\")\n        self.flush(child)\n\n    def test_pdb_interaction_on_internal_error(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_runtest_protocol():\n                0/0\n        \"\"\"\n        )\n        p1 = testdir.makepyfile(\"def test_func(): pass\")\n        child = testdir.spawn_pytest(\"--pdb %s\" % p1)\n        child.expect(\"Pdb\")\n\n        # INTERNALERROR is only displayed once via terminal reporter.\n        assert (\n            len(\n                [\n                    x\n                    for x in child.before.decode().splitlines()\n                    if x.startswith(\"INTERNALERROR> Traceback\")\n                ]\n            )\n            == 1\n        )\n\n        child.sendeof()\n        self.flush(child)\n\n    def test_pdb_interaction_capturing_simple(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_1():\n                i = 0\n                print(\"hello17\")\n                pytest.set_trace()\n                i == 1\n                assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(r\"test_1\\(\\)\")\n        child.expect(\"i == 1\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        rest = child.read().decode(\"utf-8\")\n        assert \"AssertionError\" in rest\n        assert \"1 failed\" in rest\n        assert \"def test_1\" in rest\n        assert \"hello17\" in rest  # out is captured\n        self.flush(child)\n\n    def test_pdb_set_trace_kwargs(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_1():\n                i = 0\n                print(\"hello17\")\n                pytest.set_trace(header=\"== my_header ==\")\n                x = 3\n                assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(\"== my_header ==\")\n        assert \"PDB set_trace\" not in child.before.decode()\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        rest = child.read().decode(\"utf-8\")\n        assert \"1 failed\" in rest\n        assert \"def test_1\" in rest\n        assert \"hello17\" in rest  # out is captured\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_set_trace_interception_TestPDB.test_pdb_interaction_doctest": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_set_trace_interception_TestPDB.test_pdb_interaction_doctest", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 392, "end_line": 490, "span_ids": ["TestPDB.test_pdb_and_capsys", "TestPDB.test_pdb_interaction_doctest", "TestPDB.test_pdb_set_trace_interception", "TestPDB.test_pdb_with_caplog_on_pdb_invocation", "TestPDB.test_set_trace_capturing_afterwards"], "tokens": 688}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    def test_pdb_set_trace_interception(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pdb\n            def test_1():\n                pdb.set_trace()\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(\"test_1\")\n        child.expect(\"Pdb\")\n        child.sendline(\"q\")\n        rest = child.read().decode(\"utf8\")\n        assert \"no tests ran\" in rest\n        assert \"reading from stdin while output\" not in rest\n        assert \"BdbQuit\" not in rest\n        self.flush(child)\n\n    def test_pdb_and_capsys(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_1(capsys):\n                print(\"hello1\")\n                pytest.set_trace()\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(\"test_1\")\n        child.send(\"capsys.readouterr()\\n\")\n        child.expect(\"hello1\")\n        child.sendeof()\n        child.read()\n        self.flush(child)\n\n    def test_pdb_with_caplog_on_pdb_invocation(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_1(capsys, caplog):\n                import logging\n                logging.getLogger(__name__).warning(\"some_warning\")\n                assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--pdb %s\" % str(p1))\n        child.send(\"caplog.record_tuples\\n\")\n        child.expect_exact(\n            \"[('test_pdb_with_caplog_on_pdb_invocation', 30, 'some_warning')]\"\n        )\n        child.sendeof()\n        child.read()\n        self.flush(child)\n\n    def test_set_trace_capturing_afterwards(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pdb\n            def test_1():\n                pdb.set_trace()\n            def test_2():\n                print(\"hello\")\n                assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(\"test_1\")\n        child.send(\"c\\n\")\n        child.expect(\"test_2\")\n        child.expect(\"Captured\")\n        child.expect(\"hello\")\n        child.sendeof()\n        child.read()\n        self.flush(child)\n\n    def test_pdb_interaction_doctest(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def function_1():\n                '''\n                >>> i = 0\n                >>> assert i == 1\n                '''\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--doctest-modules --pdb %s\" % p1)\n        child.expect(\"Pdb\")\n\n        assert \"UNEXPECTED EXCEPTION: AssertionError()\" in child.before.decode(\"utf8\")\n\n        child.sendline(\"'i=%i.' % i\")\n        child.expect(\"Pdb\")\n        assert \"\\r\\n'i=0.'\\r\\n\" in child.before.decode(\"utf8\")\n\n        child.sendeof()\n        rest = child.read().decode(\"utf8\")\n        assert \"! _pytest.outcomes.Exit: Quitting debugger !\" in rest\n        assert \"BdbQuit\" not in rest\n        assert \"1 failed\" in rest\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_doctest_set_trace_quit_TestPDB.test_pdb_interaction_capturing_twice.self_flush_child_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_doctest_set_trace_quit_TestPDB.test_pdb_interaction_capturing_twice.self_flush_child_", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 492, "end_line": 546, "span_ids": ["TestPDB.test_doctest_set_trace_quit", "TestPDB.test_pdb_interaction_capturing_twice"], "tokens": 428}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    def test_doctest_set_trace_quit(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def function_1():\n                '''\n                >>> __import__('pdb').set_trace()\n                '''\n        \"\"\"\n        )\n        # NOTE: does not use pytest.set_trace, but Python's patched pdb,\n        #       therefore \"-s\" is required.\n        child = testdir.spawn_pytest(\"--doctest-modules --pdb -s %s\" % p1)\n        child.expect(\"Pdb\")\n        child.sendline(\"q\")\n        rest = child.read().decode(\"utf8\")\n\n        assert \"! _pytest.outcomes.Exit: Quitting debugger !\" in rest\n        assert \"= no tests ran in\" in rest\n        assert \"BdbQuit\" not in rest\n        assert \"UNEXPECTED EXCEPTION\" not in rest\n\n    def test_pdb_interaction_capturing_twice(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_1():\n                i = 0\n                print(\"hello17\")\n                pytest.set_trace()\n                x = 3\n                print(\"hello18\")\n                pytest.set_trace()\n                x = 4\n                assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(r\"PDB set_trace \\(IO-capturing turned off\\)\")\n        child.expect(\"test_1\")\n        child.expect(\"x = 3\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        child.expect(r\"PDB continue \\(IO-capturing resumed\\)\")\n        child.expect(r\"PDB set_trace \\(IO-capturing turned off\\)\")\n        child.expect(\"x = 4\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        child.expect(\"_ test_1 _\")\n        child.expect(\"def test_1\")\n        rest = child.read().decode(\"utf8\")\n        assert \"Captured stdout call\" in rest\n        assert \"hello17\" in rest  # out is captured\n        assert \"hello18\" in rest  # out is captured\n        assert \"1 failed\" in rest\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_with_injected_do_debug_TestPDB.test_pdb_without_capture": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_with_injected_do_debug_TestPDB.test_pdb_without_capture", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 548, "end_line": 637, "span_ids": ["TestPDB.test_pdb_with_injected_do_debug", "TestPDB.test_pdb_without_capture"], "tokens": 700}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    def test_pdb_with_injected_do_debug(self, testdir):\n        \"\"\"Simulates pdbpp, which injects Pdb into do_debug, and uses\n        self.__class__ in do_continue.\n        \"\"\"\n        p1 = testdir.makepyfile(\n            mytest=\"\"\"\n            import pdb\n            import pytest\n\n            count_continue = 0\n\n            class CustomPdb(pdb.Pdb, object):\n                def do_debug(self, arg):\n                    import sys\n                    import types\n\n                    do_debug_func = pdb.Pdb.do_debug\n\n                    newglobals = do_debug_func.__globals__.copy()\n                    newglobals['Pdb'] = self.__class__\n                    orig_do_debug = types.FunctionType(\n                        do_debug_func.__code__, newglobals,\n                        do_debug_func.__name__, do_debug_func.__defaults__,\n                    )\n                    return orig_do_debug(self, arg)\n                do_debug.__doc__ = pdb.Pdb.do_debug.__doc__\n\n                def do_continue(self, *args, **kwargs):\n                    global count_continue\n                    count_continue += 1\n                    return super(CustomPdb, self).do_continue(*args, **kwargs)\n\n            def foo():\n                print(\"print_from_foo\")\n\n            def test_1():\n                i = 0\n                print(\"hello17\")\n                pytest.set_trace()\n                x = 3\n                print(\"hello18\")\n\n                assert count_continue == 2, \"unexpected_failure: %d != 2\" % count_continue\n                pytest.fail(\"expected_failure\")\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--pdbcls=mytest:CustomPdb %s\" % str(p1))\n        child.expect(r\"PDB set_trace \\(IO-capturing turned off\\)\")\n        child.expect(r\"\\n\\(Pdb\")\n        child.sendline(\"debug foo()\")\n        child.expect(\"ENTERING RECURSIVE DEBUGGER\")\n        child.expect(r\"\\n\\(\\(Pdb\")\n        child.sendline(\"c\")\n        child.expect(\"LEAVING RECURSIVE DEBUGGER\")\n        assert b\"PDB continue\" not in child.before\n        # No extra newline.\n        assert child.before.endswith(b\"c\\r\\nprint_from_foo\\r\\n\")\n\n        # set_debug should not raise outcomes. Exit, if used recursively.\n        child.sendline(\"debug 42\")\n        child.sendline(\"q\")\n        child.expect(\"LEAVING RECURSIVE DEBUGGER\")\n        assert b\"ENTERING RECURSIVE DEBUGGER\" in child.before\n        assert b\"Quitting debugger\" not in child.before\n\n        child.sendline(\"c\")\n        child.expect(r\"PDB continue \\(IO-capturing resumed\\)\")\n        rest = child.read().decode(\"utf8\")\n        assert \"hello17\" in rest  # out is captured\n        assert \"hello18\" in rest  # out is captured\n        assert \"1 failed\" in rest\n        assert \"Failed: expected_failure\" in rest\n        assert \"AssertionError: unexpected_failure\" not in rest\n        self.flush(child)\n\n    def test_pdb_without_capture(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_1():\n                pytest.set_trace()\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"-s %s\" % p1)\n        child.expect(r\">>> PDB set_trace >>>\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        child.expect(r\">>> PDB continue >>>\")\n        child.expect(\"1 passed\")\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_continue_with_recursive_debug_TestPDB.test_pdb_continue_with_recursive_debug.assert_1_passed_in_in": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_continue_with_recursive_debug_TestPDB.test_pdb_continue_with_recursive_debug.assert_1_passed_in_in", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 639, "end_line": 728, "span_ids": ["TestPDB.test_pdb_continue_with_recursive_debug"], "tokens": 710}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    @pytest.mark.parametrize(\"capture_arg\", (\"\", \"-s\", \"-p no:capture\"))\n    def test_pdb_continue_with_recursive_debug(self, capture_arg, testdir):\n        \"\"\"Full coverage for do_debug without capturing.\n\n        This is very similar to test_pdb_interaction_continue_recursive in general,\n        but mocks out ``pdb.set_trace`` for providing more coverage.\n        \"\"\"\n        p1 = testdir.makepyfile(\n            \"\"\"\n            try:\n                input = raw_input\n            except NameError:\n                pass\n\n            def set_trace():\n                __import__('pdb').set_trace()\n\n            def test_1(monkeypatch):\n                import _pytest.debugging\n\n                class pytestPDBTest(_pytest.debugging.pytestPDB):\n                    @classmethod\n                    def set_trace(cls, *args, **kwargs):\n                        # Init PytestPdbWrapper to handle capturing.\n                        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n\n                        # Mock out pdb.Pdb.do_continue.\n                        import pdb\n                        pdb.Pdb.do_continue = lambda self, arg: None\n\n                        print(\"===\" + \" SET_TRACE ===\")\n                        assert input() == \"debug set_trace()\"\n\n                        # Simulate PytestPdbWrapper.do_debug\n                        cls._recursive_debug += 1\n                        print(\"ENTERING RECURSIVE DEBUGGER\")\n                        print(\"===\" + \" SET_TRACE_2 ===\")\n\n                        assert input() == \"c\"\n                        _pdb.do_continue(\"\")\n                        print(\"===\" + \" SET_TRACE_3 ===\")\n\n                        # Simulate PytestPdbWrapper.do_debug\n                        print(\"LEAVING RECURSIVE DEBUGGER\")\n                        cls._recursive_debug -= 1\n\n                        print(\"===\" + \" SET_TRACE_4 ===\")\n                        assert input() == \"c\"\n                        _pdb.do_continue(\"\")\n\n                    def do_continue(self, arg):\n                        print(\"=== do_continue\")\n\n                monkeypatch.setattr(_pytest.debugging, \"pytestPDB\", pytestPDBTest)\n\n                import pdb\n                monkeypatch.setattr(pdb, \"set_trace\", pytestPDBTest.set_trace)\n\n                set_trace()\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--tb=short {} {}\".format(p1, capture_arg))\n        child.expect(\"=== SET_TRACE ===\")\n        before = child.before.decode(\"utf8\")\n        if not capture_arg:\n            assert \">>> PDB set_trace (IO-capturing turned off) >>>\" in before\n        else:\n            assert \">>> PDB set_trace >>>\" in before\n        child.sendline(\"debug set_trace()\")\n        child.expect(\"=== SET_TRACE_2 ===\")\n        before = child.before.decode(\"utf8\")\n        assert \"\\r\\nENTERING RECURSIVE DEBUGGER\\r\\n\" in before\n        child.sendline(\"c\")\n        child.expect(\"=== SET_TRACE_3 ===\")\n\n        # No continue message with recursive debugging.\n        before = child.before.decode(\"utf8\")\n        assert \">>> PDB continue \" not in before\n\n        child.sendline(\"c\")\n        child.expect(\"=== SET_TRACE_4 ===\")\n        before = child.before.decode(\"utf8\")\n        assert \"\\r\\nLEAVING RECURSIVE DEBUGGER\\r\\n\" in before\n        child.sendline(\"c\")\n        rest = child.read().decode(\"utf8\")\n        if not capture_arg:\n            assert \"> PDB continue (IO-capturing resumed) >\" in rest\n        else:\n            assert \"> PDB continue >\" in rest\n        assert \"= 1 passed in\" in rest", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_used_outside_test_TestPDB.test_pdb_collection_failure_is_shown": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_used_outside_test_TestPDB.test_pdb_collection_failure_is_shown", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 730, "end_line": 766, "span_ids": ["TestPDB.test_pdb_collection_failure_is_shown", "TestPDB.test_pdb_used_in_generate_tests", "TestPDB.test_pdb_used_outside_test"], "tokens": 263}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    def test_pdb_used_outside_test(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            pytest.set_trace()\n            x = 5\n        \"\"\"\n        )\n        child = testdir.spawn(\"{} {}\".format(sys.executable, p1))\n        child.expect(\"x = 5\")\n        child.expect(\"Pdb\")\n        child.sendeof()\n        self.flush(child)\n\n    def test_pdb_used_in_generate_tests(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def pytest_generate_tests(metafunc):\n                pytest.set_trace()\n                x = 5\n            def test_foo(a):\n                pass\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(\"x = 5\")\n        child.expect(\"Pdb\")\n        child.sendeof()\n        self.flush(child)\n\n    def test_pdb_collection_failure_is_shown(self, testdir):\n        p1 = testdir.makepyfile(\"xxx\")\n        result = testdir.runpytest_subprocess(\"--pdb\", p1)\n        result.stdout.fnmatch_lines(\n            [\"E   NameError: *xxx*\", \"*! *Exit: Quitting debugger !*\"]  # due to EOF\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_enter_leave_pdb_hooks_are_called_TestPDB.test_enter_leave_pdb_hooks_are_called.self_flush_child_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_enter_leave_pdb_hooks_are_called_TestPDB.test_enter_leave_pdb_hooks_are_called.self_flush_child_", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 768, "end_line": 820, "span_ids": ["TestPDB.test_enter_leave_pdb_hooks_are_called"], "tokens": 351}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    @pytest.mark.parametrize(\"post_mortem\", (False, True))\n    def test_enter_leave_pdb_hooks_are_called(self, post_mortem, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            mypdb = None\n\n            def pytest_configure(config):\n                config.testing_verification = 'configured'\n\n            def pytest_enter_pdb(config, pdb):\n                assert config.testing_verification == 'configured'\n                print('enter_pdb_hook')\n\n                global mypdb\n                mypdb = pdb\n                mypdb.set_attribute = \"bar\"\n\n            def pytest_leave_pdb(config, pdb):\n                assert config.testing_verification == 'configured'\n                print('leave_pdb_hook')\n\n                global mypdb\n                assert mypdb is pdb\n                assert mypdb.set_attribute == \"bar\"\n        \"\"\"\n        )\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def test_set_trace():\n                pytest.set_trace()\n                assert 0\n\n            def test_post_mortem():\n                assert 0\n        \"\"\"\n        )\n        if post_mortem:\n            child = testdir.spawn_pytest(str(p1) + \" --pdb -s -k test_post_mortem\")\n        else:\n            child = testdir.spawn_pytest(str(p1) + \" -k test_set_trace\")\n        child.expect(\"enter_pdb_hook\")\n        child.sendline(\"c\")\n        if post_mortem:\n            child.expect(r\"PDB continue\")\n        else:\n            child.expect(r\"PDB continue \\(IO-capturing resumed\\)\")\n            child.expect(\"Captured stdout call\")\n        rest = child.read().decode(\"utf8\")\n        assert \"leave_pdb_hook\" in rest\n        assert \"1 failed\" in rest\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_custom_cls_TestPDB.test_pdb_custom_cls_with_set_trace.self_flush_child_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestPDB.test_pdb_custom_cls_TestPDB.test_pdb_custom_cls_with_set_trace.self_flush_child_", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 822, "end_line": 877, "span_ids": ["TestPDB.test_pdb_custom_cls", "TestPDB.test_pdb_custom_cls_invalid", "TestPDB.test_pdb_custom_cls_with_set_trace", "TestPDB.test_pdb_custom_cls_without_pdb", "TestPDB.test_pdb_validate_usepdb_cls"], "tokens": 494}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPDB:\n\n    def test_pdb_custom_cls(self, testdir, custom_pdb_calls):\n        p1 = testdir.makepyfile(\"\"\"xxx \"\"\")\n        result = testdir.runpytest_inprocess(\"--pdb\", \"--pdbcls=_pytest:_CustomPdb\", p1)\n        result.stdout.fnmatch_lines([\"*NameError*xxx*\", \"*1 error*\"])\n        assert custom_pdb_calls == [\"init\", \"reset\", \"interaction\"]\n\n    def test_pdb_custom_cls_invalid(self, testdir):\n        result = testdir.runpytest_inprocess(\"--pdbcls=invalid\")\n        result.stderr.fnmatch_lines(\n            [\n                \"*: error: argument --pdbcls: 'invalid' is not in the format 'modname:classname'\"\n            ]\n        )\n\n    def test_pdb_validate_usepdb_cls(self):\n        assert _validate_usepdb_cls(\"os.path:dirname.__name__\") == (\n            \"os.path\",\n            \"dirname.__name__\",\n        )\n\n        assert _validate_usepdb_cls(\"pdb:DoesNotExist\") == (\"pdb\", \"DoesNotExist\")\n\n    def test_pdb_custom_cls_without_pdb(self, testdir, custom_pdb_calls):\n        p1 = testdir.makepyfile(\"\"\"xxx \"\"\")\n        result = testdir.runpytest_inprocess(\"--pdbcls=_pytest:_CustomPdb\", p1)\n        result.stdout.fnmatch_lines([\"*NameError*xxx*\", \"*1 error*\"])\n        assert custom_pdb_calls == []\n\n    def test_pdb_custom_cls_with_set_trace(self, testdir, monkeypatch):\n        testdir.makepyfile(\n            custom_pdb=\"\"\"\n            class CustomPdb(object):\n                def __init__(self, *args, **kwargs):\n                    skip = kwargs.pop(\"skip\")\n                    assert skip == [\"foo.*\"]\n                    print(\"__init__\")\n                    super(CustomPdb, self).__init__(*args, **kwargs)\n\n                def set_trace(*args, **kwargs):\n                    print('custom set_trace>')\n         \"\"\"\n        )\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            def test_foo():\n                pytest.set_trace(skip=['foo.*'])\n        \"\"\"\n        )\n        monkeypatch.setenv(\"PYTHONPATH\", str(testdir.tmpdir))\n        child = testdir.spawn_pytest(\"--pdbcls=custom_pdb:CustomPdb %s\" % str(p1))\n\n        child.expect(\"__init__\")\n        child.expect(\"custom set_trace>\")\n        self.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints_TestDebuggingBreakpoints.test_sys_breakpointhook_configure_and_unconfigure.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints_TestDebuggingBreakpoints.test_sys_breakpointhook_configure_and_unconfigure.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 880, "end_line": 923, "span_ids": ["TestDebuggingBreakpoints", "TestDebuggingBreakpoints.test_supports_breakpoint_module_global", "TestDebuggingBreakpoints.test_sys_breakpointhook_configure_and_unconfigure"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDebuggingBreakpoints:\n    def test_supports_breakpoint_module_global(self):\n        \"\"\"\n        Test that supports breakpoint global marks on Python 3.7+ and not on\n        CPython 3.5, 2.7\n        \"\"\"\n        if sys.version_info >= (3, 7):\n            assert SUPPORTS_BREAKPOINT_BUILTIN is True\n        if sys.version_info.major == 3 and sys.version_info.minor == 5:\n            assert SUPPORTS_BREAKPOINT_BUILTIN is False\n\n    @pytest.mark.skipif(\n        not SUPPORTS_BREAKPOINT_BUILTIN, reason=\"Requires breakpoint() builtin\"\n    )\n    @pytest.mark.parametrize(\"arg\", [\"--pdb\", \"\"])\n    def test_sys_breakpointhook_configure_and_unconfigure(self, testdir, arg):\n        \"\"\"\n        Test that sys.breakpointhook is set to the custom Pdb class once configured, test that\n        hook is reset to system value once pytest has been unconfigured\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import sys\n            from pytest import hookimpl\n            from _pytest.debugging import pytestPDB\n\n            def pytest_configure(config):\n                config._cleanup.append(check_restored)\n\n            def check_restored():\n                assert sys.breakpointhook == sys.__breakpointhook__\n\n            def test_check():\n                assert sys.breakpointhook == pytestPDB.set_trace\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_nothing(): pass\n        \"\"\"\n        )\n        args = (arg,) if arg else ()\n        result = testdir.runpytest_subprocess(*args)\n        result.stdout.fnmatch_lines([\"*1 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints.test_pdb_custom_cls_TestDebuggingBreakpoints.test_environ_custom_class.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints.test_pdb_custom_cls_TestDebuggingBreakpoints.test_environ_custom_class.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 925, "end_line": 971, "span_ids": ["TestDebuggingBreakpoints.test_environ_custom_class", "TestDebuggingBreakpoints.test_pdb_custom_cls"], "tokens": 334}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDebuggingBreakpoints:\n\n    @pytest.mark.skipif(\n        not SUPPORTS_BREAKPOINT_BUILTIN, reason=\"Requires breakpoint() builtin\"\n    )\n    def test_pdb_custom_cls(self, testdir, custom_debugger_hook):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_nothing():\n                breakpoint()\n        \"\"\"\n        )\n        result = testdir.runpytest_inprocess(\n            \"--pdb\", \"--pdbcls=_pytest:_CustomDebugger\", p1\n        )\n        result.stdout.fnmatch_lines([\"*CustomDebugger*\", \"*1 passed*\"])\n        assert custom_debugger_hook == [\"init\", \"set_trace\"]\n\n    @pytest.mark.parametrize(\"arg\", [\"--pdb\", \"\"])\n    @pytest.mark.skipif(\n        not SUPPORTS_BREAKPOINT_BUILTIN, reason=\"Requires breakpoint() builtin\"\n    )\n    def test_environ_custom_class(self, testdir, custom_debugger_hook, arg):\n        testdir.makeconftest(\n            \"\"\"\n            import os\n            import sys\n\n            os.environ['PYTHONBREAKPOINT'] = '_pytest._CustomDebugger.set_trace'\n\n            def pytest_configure(config):\n                config._cleanup.append(check_restored)\n\n            def check_restored():\n                assert sys.breakpointhook == sys.__breakpointhook__\n\n            def test_check():\n                import _pytest\n                assert sys.breakpointhook is _pytest._CustomDebugger.set_trace\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_nothing(): pass\n        \"\"\"\n        )\n        args = (arg,) if arg else ()\n        result = testdir.runpytest_subprocess(*args)\n        result.stdout.fnmatch_lines([\"*1 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints.test_sys_breakpoint_interception_TestDebuggingBreakpoints.test_pdb_not_altered": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestDebuggingBreakpoints.test_sys_breakpoint_interception_TestDebuggingBreakpoints.test_pdb_not_altered", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 973, "end_line": 1015, "span_ids": ["TestDebuggingBreakpoints.test_pdb_not_altered", "TestDebuggingBreakpoints.test_sys_breakpoint_interception"], "tokens": 311}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDebuggingBreakpoints:\n\n    @pytest.mark.skipif(\n        not SUPPORTS_BREAKPOINT_BUILTIN, reason=\"Requires breakpoint() builtin\"\n    )\n    @pytest.mark.skipif(\n        not _ENVIRON_PYTHONBREAKPOINT == \"\",\n        reason=\"Requires breakpoint() default value\",\n    )\n    def test_sys_breakpoint_interception(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                breakpoint()\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(\"test_1\")\n        child.expect(\"Pdb\")\n        child.sendline(\"quit\")\n        rest = child.read().decode(\"utf8\")\n        assert \"Quitting debugger\" in rest\n        assert \"reading from stdin while output\" not in rest\n        TestPDB.flush(child)\n\n    @pytest.mark.skipif(\n        not SUPPORTS_BREAKPOINT_BUILTIN, reason=\"Requires breakpoint() builtin\"\n    )\n    def test_pdb_not_altered(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pdb\n            def test_1():\n                pdb.set_trace()\n                assert 0\n        \"\"\"\n        )\n        child = testdir.spawn_pytest(str(p1))\n        child.expect(\"test_1\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        rest = child.read().decode(\"utf8\")\n        assert \"1 failed\" in rest\n        assert \"reading from stdin while output\" not in rest\n        TestPDB.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestTraceOption_TestTraceOption.test_trace_with_parametrize_handles_shared_fixtureinfo.TestPDB_flush_child_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_TestTraceOption_TestTraceOption.test_trace_with_parametrize_handles_shared_fixtureinfo.TestPDB_flush_child_", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 1018, "end_line": 1093, "span_ids": ["TestTraceOption", "TestTraceOption.test_trace_sets_breakpoint", "TestTraceOption.test_trace_with_parametrize_handles_shared_fixtureinfo"], "tokens": 637}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTraceOption:\n    def test_trace_sets_breakpoint(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                assert True\n\n            def test_2():\n                pass\n\n            def test_3():\n                pass\n            \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--trace \" + str(p1))\n        child.expect(\"test_1\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        child.expect(\"test_2\")\n        child.expect(\"Pdb\")\n        child.sendline(\"c\")\n        child.expect(\"test_3\")\n        child.expect(\"Pdb\")\n        child.sendline(\"q\")\n        child.expect_exact(\"Exit: Quitting debugger\")\n        rest = child.read().decode(\"utf8\")\n        assert \"= 2 passed in\" in rest\n        assert \"reading from stdin while output\" not in rest\n        # Only printed once - not on stderr.\n        assert \"Exit: Quitting debugger\" not in child.before.decode(\"utf8\")\n        TestPDB.flush(child)\n\n    def test_trace_with_parametrize_handles_shared_fixtureinfo(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('myparam', [1,2])\n            def test_1(myparam, request):\n                assert myparam in (1, 2)\n                assert request.function.__name__ == \"test_1\"\n            @pytest.mark.parametrize('func', [1,2])\n            def test_func(func, request):\n                assert func in (1, 2)\n                assert request.function.__name__ == \"test_func\"\n            @pytest.mark.parametrize('myparam', [1,2])\n            def test_func_kw(myparam, request, func=\"func_kw\"):\n                assert myparam in (1, 2)\n                assert func == \"func_kw\"\n                assert request.function.__name__ == \"test_func_kw\"\n            \"\"\"\n        )\n        child = testdir.spawn_pytest(\"--trace \" + str(p1))\n        for func, argname in [\n            (\"test_1\", \"myparam\"),\n            (\"test_func\", \"func\"),\n            (\"test_func_kw\", \"myparam\"),\n        ]:\n            child.expect_exact(\"> PDB runcall (IO-capturing turned off) >\")\n            child.expect_exact(func)\n            child.expect_exact(\"Pdb\")\n            child.sendline(\"args\")\n            child.expect_exact(\"{} = 1\\r\\n\".format(argname))\n            child.expect_exact(\"Pdb\")\n            child.sendline(\"c\")\n            child.expect_exact(\"Pdb\")\n            child.sendline(\"args\")\n            child.expect_exact(\"{} = 2\\r\\n\".format(argname))\n            child.expect_exact(\"Pdb\")\n            child.sendline(\"c\")\n            child.expect_exact(\"> PDB continue (IO-capturing resumed) >\")\n        rest = child.read().decode(\"utf8\")\n        assert \"= 6 passed in\" in rest\n        assert \"reading from stdin while output\" not in rest\n        # Only printed once - not on stderr.\n        assert \"Exit: Quitting debugger\" not in child.before.decode(\"utf8\")\n        TestPDB.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_trace_after_runpytest_test_quit_with_swallowed_SystemExit.TestPDB_flush_child_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_trace_after_runpytest_test_quit_with_swallowed_SystemExit.TestPDB_flush_child_", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 1096, "end_line": 1152, "span_ids": ["test_quit_with_swallowed_SystemExit", "test_trace_after_runpytest"], "tokens": 348}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_trace_after_runpytest(testdir):\n    \"\"\"Test that debugging's pytest_configure is re-entrant.\"\"\"\n    p1 = testdir.makepyfile(\n        \"\"\"\n        from _pytest.debugging import pytestPDB\n\n        def test_outer(testdir):\n            assert len(pytestPDB._saved) == 1\n\n            testdir.makepyfile(\n                \\\"\"\"\n                from _pytest.debugging import pytestPDB\n\n                def test_inner():\n                    assert len(pytestPDB._saved) == 2\n                    print()\n                    print(\"test_inner_\" + \"end\")\n                \\\"\"\"\n            )\n\n            result = testdir.runpytest(\"-s\", \"-k\", \"test_inner\")\n            assert result.ret == 0\n\n            assert len(pytestPDB._saved) == 1\n    \"\"\"\n    )\n    result = testdir.runpytest_subprocess(\"-s\", \"-p\", \"pytester\", str(p1))\n    result.stdout.fnmatch_lines([\"test_inner_end\"])\n    assert result.ret == 0\n\n\ndef test_quit_with_swallowed_SystemExit(testdir):\n    \"\"\"Test that debugging's pytest_configure is re-entrant.\"\"\"\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def call_pdb_set_trace():\n            __import__('pdb').set_trace()\n\n\n        def test_1():\n            try:\n                call_pdb_set_trace()\n            except SystemExit:\n                pass\n\n\n        def test_2():\n            pass\n    \"\"\"\n    )\n    child = testdir.spawn_pytest(str(p1))\n    child.expect(\"Pdb\")\n    child.sendline(\"q\")\n    child.expect_exact(\"Exit: Quitting debugger\")\n    rest = child.read().decode(\"utf8\")\n    assert \"no tests ran\" in rest\n    TestPDB.flush(child)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_pdb_suspends_fixture_capturing_test_pdb_suspends_fixture_capturing.assert_PDB_continue_I": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_pdb_suspends_fixture_capturing_test_pdb_suspends_fixture_capturing.assert_PDB_continue_I", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 1155, "end_line": 1201, "span_ids": ["test_pdb_suspends_fixture_capturing"], "tokens": 349}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"fixture\", (\"capfd\", \"capsys\"))\ndef test_pdb_suspends_fixture_capturing(testdir, fixture):\n    \"\"\"Using \"-s\" with pytest should suspend/resume fixture capturing.\"\"\"\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def test_inner({fixture}):\n            import sys\n\n            print(\"out_inner_before\")\n            sys.stderr.write(\"err_inner_before\\\\n\")\n\n            __import__(\"pdb\").set_trace()\n\n            print(\"out_inner_after\")\n            sys.stderr.write(\"err_inner_after\\\\n\")\n\n            out, err = {fixture}.readouterr()\n            assert out ==\"out_inner_before\\\\nout_inner_after\\\\n\"\n            assert err ==\"err_inner_before\\\\nerr_inner_after\\\\n\"\n        \"\"\".format(\n            fixture=fixture\n        )\n    )\n\n    child = testdir.spawn_pytest(str(p1) + \" -s\")\n\n    child.expect(\"Pdb\")\n    before = child.before.decode(\"utf8\")\n    assert (\n        \"> PDB set_trace (IO-capturing turned off for fixture %s) >\" % (fixture)\n        in before\n    )\n\n    # Test that capturing is really suspended.\n    child.sendline(\"p 40 + 2\")\n    child.expect(\"Pdb\")\n    assert \"\\r\\n42\\r\\n\" in child.before.decode(\"utf8\")\n\n    child.sendline(\"c\")\n    rest = child.read().decode(\"utf8\")\n    assert \"out_inner\" not in rest\n    assert \"err_inner\" not in rest\n\n    TestPDB.flush(child)\n    assert child.exitstatus == 0\n    assert \"= 1 passed in\" in rest\n    assert \"> PDB continue (IO-capturing resumed for fixture %s) >\" % (fixture) in rest", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_pdbcls_via_local_module_test_pdbcls_via_local_module.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_pdbcls_via_local_module_test_pdbcls_via_local_module.None_2", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 1204, "end_line": 1244, "span_ids": ["test_pdbcls_via_local_module"], "tokens": 324}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_pdbcls_via_local_module(testdir):\n    \"\"\"It should be imported in pytest_configure or later only.\"\"\"\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def test():\n            print(\"before_set_trace\")\n            __import__(\"pdb\").set_trace()\n        \"\"\",\n        mypdb=\"\"\"\n        class Wrapped:\n            class MyPdb:\n                def set_trace(self, *args):\n                    print(\"set_trace_called\", args)\n\n                def runcall(self, *args, **kwds):\n                    print(\"runcall_called\", args, kwds)\n        \"\"\",\n    )\n    result = testdir.runpytest(\n        str(p1), \"--pdbcls=really.invalid:Value\", syspathinsert=True\n    )\n    result.stdout.fnmatch_lines(\n        [\n            \"*= FAILURES =*\",\n            \"E * --pdbcls: could not import 'really.invalid:Value': No module named *really*\",\n        ]\n    )\n    assert result.ret == 1\n\n    result = testdir.runpytest(\n        str(p1), \"--pdbcls=mypdb:Wrapped.MyPdb\", syspathinsert=True\n    )\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*set_trace_called*\", \"* 1 passed in *\"])\n\n    # Ensure that it also works with --trace.\n    result = testdir.runpytest(\n        str(p1), \"--pdbcls=mypdb:Wrapped.MyPdb\", \"--trace\", syspathinsert=True\n    )\n    assert result.ret == 0\n    result.stdout.fnmatch_lines([\"*runcall_called*\", \"* 1 passed in *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_raises_bdbquit_with_eoferror_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_debugging.py_test_raises_bdbquit_with_eoferror_", "embedding": null, "metadata": {"file_path": "testing/test_debugging.py", "file_name": "test_debugging.py", "file_type": "text/x-python", "category": "test", "start_line": 1247, "end_line": 1294, "span_ids": ["test_pdb_wrapper_class_is_reused", "test_raises_bdbquit_with_eoferror"], "tokens": 338}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_raises_bdbquit_with_eoferror(testdir):\n    \"\"\"It is not guaranteed that DontReadFromInput's read is called.\"\"\"\n\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def input_without_read(*args, **kwargs):\n            raise EOFError()\n\n        def test(monkeypatch):\n            import builtins\n            monkeypatch.setattr(builtins, \"input\", input_without_read)\n            __import__('pdb').set_trace()\n        \"\"\"\n    )\n    result = testdir.runpytest(str(p1))\n    result.stdout.fnmatch_lines([\"E *BdbQuit\", \"*= 1 failed in*\"])\n    assert result.ret == 1\n\n\ndef test_pdb_wrapper_class_is_reused(testdir):\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def test():\n            __import__(\"pdb\").set_trace()\n            __import__(\"pdb\").set_trace()\n\n            import mypdb\n            instances = mypdb.instances\n            assert len(instances) == 2\n            assert instances[0].__class__ is instances[1].__class__\n        \"\"\",\n        mypdb=\"\"\"\n        instances = []\n\n        class MyPdb:\n            def __init__(self, *args, **kwargs):\n                instances.append(self)\n\n            def set_trace(self, *args):\n                print(\"set_trace_called\", args)\n        \"\"\",\n    )\n    result = testdir.runpytest(str(p1), \"--pdbcls=mypdb:MyPdb\", syspathinsert=True)\n    assert result.ret == 0\n    result.stdout.fnmatch_lines(\n        [\"*set_trace_called*\", \"*set_trace_called*\", \"* 1 passed in *\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_encoding_TestDoctests.test_doctest_unexpected_exception.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_encoding_TestDoctests.test_doctest_unexpected_exception.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 145, "end_line": 198, "span_ids": ["TestDoctests.test_doctest_unexpected_exception", "TestDoctests.test_encoding"], "tokens": 377}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    @pytest.mark.parametrize(\n        \"   test_string,    encoding\",\n        [(\"foo\", \"ascii\"), (\"\u00f6\u00e4\u00fc\", \"latin1\"), (\"\u00f6\u00e4\u00fc\", \"utf-8\")],\n    )\n    def test_encoding(self, testdir, test_string, encoding):\n        \"\"\"Test support for doctest_encoding ini option.\n        \"\"\"\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            doctest_encoding={}\n        \"\"\".format(\n                encoding\n            )\n        )\n        doctest = \"\"\"\n            >>> \"{}\"\n            {}\n        \"\"\".format(\n            test_string, repr(test_string)\n        )\n        testdir._makefile(\".txt\", [doctest], {}, encoding=encoding)\n\n        result = testdir.runpytest()\n\n        result.stdout.fnmatch_lines([\"*1 passed*\"])\n\n    def test_doctest_unexpected_exception(self, testdir):\n        testdir.maketxtfile(\n            \"\"\"\n            >>> i = 0\n            >>> 0 / i\n            2\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\n                \"test_doctest_unexpected_exception.txt F *\",\n                \"\",\n                \"*= FAILURES =*\",\n                \"*_ [[]doctest[]] test_doctest_unexpected_exception.txt _*\",\n                \"001 >>> i = 0\",\n                \"002 >>> 0 / i\",\n                \"UNEXPECTED EXCEPTION: ZeroDivisionError*\",\n                \"Traceback (most recent call last):\",\n                '  File \"*/doctest.py\", line *, in __run',\n                \"    *\",\n                '  File \"<doctest test_doctest_unexpected_exception.txt[1]>\", line 1, in <module>',\n                \"ZeroDivisionError: division by zero\",\n                \"*/test_doctest_unexpected_exception.txt:2: UnexpectedException\",\n            ],\n            consecutive=True,\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_outcomes_TestDoctests.test_docstring_partial_context_around_error.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_outcomes_TestDoctests.test_docstring_partial_context_around_error.None_3", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 200, "end_line": 278, "span_ids": ["TestDoctests.test_docstring_partial_context_around_error", "TestDoctests.test_doctest_outcomes"], "tokens": 458}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_doctest_outcomes(self, testdir):\n        testdir.maketxtfile(\n            test_skip=\"\"\"\n            >>> 1\n            1\n            >>> import pytest\n            >>> pytest.skip(\"\")\n            >>> 2\n            3\n            \"\"\",\n            test_xfail=\"\"\"\n            >>> import pytest\n            >>> pytest.xfail(\"xfail_reason\")\n            >>> foo\n            bar\n            \"\"\",\n            test_importorskip=\"\"\"\n            >>> import pytest\n            >>> pytest.importorskip(\"doesnotexist\")\n            >>> foo\n            bar\n            \"\"\",\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\n                \"collected 3 items\",\n                \"\",\n                \"test_importorskip.txt s *\",\n                \"test_skip.txt s *\",\n                \"test_xfail.txt x *\",\n                \"\",\n                \"*= 2 skipped, 1 xfailed in *\",\n            ]\n        )\n\n    def test_docstring_partial_context_around_error(self, testdir):\n        \"\"\"Test that we show some context before the actual line of a failing\n        doctest.\n        \"\"\"\n        testdir.makepyfile(\n            '''\n            def foo():\n                \"\"\"\n                text-line-1\n                text-line-2\n                text-line-3\n                text-line-4\n                text-line-5\n                text-line-6\n                text-line-7\n                text-line-8\n                text-line-9\n                text-line-10\n                text-line-11\n                >>> 1 + 1\n                3\n\n                text-line-after\n                \"\"\"\n        '''\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*docstring_partial_context_around_error*\",\n                \"005*text-line-3\",\n                \"006*text-line-4\",\n                \"013*text-line-11\",\n                \"014*>>> 1 + 1\",\n                \"Expected:\",\n                \"    3\",\n                \"Got:\",\n                \"    2\",\n            ]\n        )\n        # lines below should be trimmed out\n        result.stdout.no_fnmatch_line(\"*text-line-2*\")\n        result.stdout.no_fnmatch_line(\"*text-line-after*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_docstring_full_context_around_error_TestDoctests.test_doctest_linedata_on_property.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_docstring_full_context_around_error_TestDoctests.test_doctest_linedata_on_property.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 280, "end_line": 357, "span_ids": ["TestDoctests.test_docstring_full_context_around_error", "TestDoctests.test_doctest_linedata_missing", "TestDoctests.test_doctest_linedata_on_property"], "tokens": 475}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_docstring_full_context_around_error(self, testdir):\n        \"\"\"Test that we show the whole context before the actual line of a failing\n        doctest, provided that the context is up to 10 lines long.\n        \"\"\"\n        testdir.makepyfile(\n            '''\n            def foo():\n                \"\"\"\n                text-line-1\n                text-line-2\n\n                >>> 1 + 1\n                3\n                \"\"\"\n        '''\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*docstring_full_context_around_error*\",\n                \"003*text-line-1\",\n                \"004*text-line-2\",\n                \"006*>>> 1 + 1\",\n                \"Expected:\",\n                \"    3\",\n                \"Got:\",\n                \"    2\",\n            ]\n        )\n\n    def test_doctest_linedata_missing(self, testdir):\n        testdir.tmpdir.join(\"hello.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                class Fun(object):\n                    @property\n                    def test(self):\n                        '''\n                        >>> a = 1\n                        >>> 1/0\n                        '''\n                \"\"\"\n            )\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\"*hello*\", \"006*>>> 1/0*\", \"*UNEXPECTED*ZeroDivision*\", \"*1 failed*\"]\n        )\n\n    def test_doctest_linedata_on_property(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class Sample(object):\n                @property\n                def some_property(self):\n                    '''\n                    >>> Sample().some_property\n                    'another thing'\n                    '''\n                    return 'something'\n            \"\"\"\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*= FAILURES =*\",\n                \"*_ [[]doctest[]] test_doctest_linedata_on_property.Sample.some_property _*\",\n                \"004 \",\n                \"005         >>> Sample().some_property\",\n                \"Expected:\",\n                \"    'another thing'\",\n                \"Got:\",\n                \"    'something'\",\n                \"\",\n                \"*/test_doctest_linedata_on_property.py:5: DocTestFailure\",\n                \"*= 1 failed in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_no_linedata_on_overriden_property_TestDoctests.test_doctest_no_linedata_on_overriden_property.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_no_linedata_on_overriden_property_TestDoctests.test_doctest_no_linedata_on_overriden_property.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 359, "end_line": 388, "span_ids": ["TestDoctests.test_doctest_no_linedata_on_overriden_property"], "tokens": 225}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_doctest_no_linedata_on_overriden_property(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            class Sample(object):\n                @property\n                def some_property(self):\n                    '''\n                    >>> Sample().some_property\n                    'another thing'\n                    '''\n                    return 'something'\n                some_property = property(some_property.__get__, None, None, some_property.__doc__)\n            \"\"\"\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*= FAILURES =*\",\n                \"*_ [[]doctest[]] test_doctest_no_linedata_on_overriden_property.Sample.some_property _*\",\n                \"EXAMPLE LOCATION UNKNOWN, not showing all tests of that example\",\n                \"[?][?][?] >>> Sample().some_property\",\n                \"Expected:\",\n                \"    'another thing'\",\n                \"Got:\",\n                \"    'something'\",\n                \"\",\n                \"*/test_doctest_no_linedata_on_overriden_property.py:None: DocTestFailure\",\n                \"*= 1 failed in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_unex_importerror_only_txt_TestDoctests.test_txtfile_with_fixtures": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_doctest_unex_importerror_only_txt_TestDoctests.test_txtfile_with_fixtures", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 390, "end_line": 502, "span_ids": ["TestDoctests.test_doctest_unex_importerror_only_txt", "TestDoctests.test_doctest_unex_importerror_with_module", "TestDoctests.test_doctestmodule", "TestDoctests.test_doctestmodule_external_and_issue116", "TestDoctests.test_txtfile_failing", "TestDoctests.test_txtfile_with_fixtures"], "tokens": 699}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_doctest_unex_importerror_only_txt(self, testdir):\n        testdir.maketxtfile(\n            \"\"\"\n            >>> import asdalsdkjaslkdjasd\n            >>>\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        # doctest is never executed because of error during hello.py collection\n        result.stdout.fnmatch_lines(\n            [\n                \"*>>> import asdals*\",\n                \"*UNEXPECTED*{e}*\".format(e=MODULE_NOT_FOUND_ERROR),\n                \"{e}: No module named *asdal*\".format(e=MODULE_NOT_FOUND_ERROR),\n            ]\n        )\n\n    def test_doctest_unex_importerror_with_module(self, testdir):\n        testdir.tmpdir.join(\"hello.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                import asdalsdkjaslkdjasd\n                \"\"\"\n            )\n        )\n        testdir.maketxtfile(\n            \"\"\"\n            >>> import hello\n            >>>\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        # doctest is never executed because of error during hello.py collection\n        result.stdout.fnmatch_lines(\n            [\n                \"*ERROR collecting hello.py*\",\n                \"*{e}: No module named *asdals*\".format(e=MODULE_NOT_FOUND_ERROR),\n                \"*Interrupted: 1 error during collection*\",\n            ]\n        )\n\n    def test_doctestmodule(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            '''\n                >>> x = 1\n                >>> x == 1\n                False\n\n            '''\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\")\n        reprec.assertoutcome(failed=1)\n\n    def test_doctestmodule_external_and_issue116(self, testdir):\n        p = testdir.mkpydir(\"hello\")\n        p.join(\"__init__.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                def somefunc():\n                    '''\n                        >>> i = 0\n                        >>> i + 1\n                        2\n                    '''\n                \"\"\"\n            )\n        )\n        result = testdir.runpytest(p, \"--doctest-modules\")\n        result.stdout.fnmatch_lines(\n            [\n                \"003 *>>> i = 0\",\n                \"004 *>>> i + 1\",\n                \"*Expected:\",\n                \"*    2\",\n                \"*Got:\",\n                \"*    1\",\n                \"*:4: DocTestFailure\",\n            ]\n        )\n\n    def test_txtfile_failing(self, testdir):\n        p = testdir.maketxtfile(\n            \"\"\"\n            >>> i = 0\n            >>> i + 1\n            2\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"-s\")\n        result.stdout.fnmatch_lines(\n            [\n                \"001 >>> i = 0\",\n                \"002 >>> i + 1\",\n                \"Expected:\",\n                \"    2\",\n                \"Got:\",\n                \"    1\",\n                \"*test_txtfile_failing.txt:2: DocTestFailure\",\n            ]\n        )\n\n    def test_txtfile_with_fixtures(self, testdir):\n        p = testdir.maketxtfile(\n            \"\"\"\n            >>> dir = getfixture('tmpdir')\n            >>> type(dir).__name__\n            'LocalPath'\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p)\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_txtfile_with_usefixtures_in_ini_TestDoctests.test_non_ignored_whitespace": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_txtfile_with_usefixtures_in_ini_TestDoctests.test_non_ignored_whitespace", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 504, "end_line": 631, "span_ids": ["TestDoctests.test_doctestmodule_three_tests", "TestDoctests.test_doctestmodule_two_tests_one_fail", "TestDoctests.test_doctestmodule_with_fixtures", "TestDoctests.test_ignored_whitespace", "TestDoctests.test_non_ignored_whitespace", "TestDoctests.test_txtfile_with_usefixtures_in_ini"], "tokens": 685}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_txtfile_with_usefixtures_in_ini(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            usefixtures = myfixture\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def myfixture(monkeypatch):\n                monkeypatch.setenv(\"HELLO\", \"WORLD\")\n        \"\"\"\n        )\n\n        p = testdir.maketxtfile(\n            \"\"\"\n            >>> import os\n            >>> os.environ[\"HELLO\"]\n            'WORLD'\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p)\n        reprec.assertoutcome(passed=1)\n\n    def test_doctestmodule_with_fixtures(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            '''\n                >>> dir = getfixture('tmpdir')\n                >>> type(dir).__name__\n                'LocalPath'\n            '''\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\")\n        reprec.assertoutcome(passed=1)\n\n    def test_doctestmodule_three_tests(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            '''\n            >>> dir = getfixture('tmpdir')\n            >>> type(dir).__name__\n            'LocalPath'\n            '''\n            def my_func():\n                '''\n                >>> magic = 42\n                >>> magic - 42\n                0\n                '''\n            def unuseful():\n                pass\n            def another():\n                '''\n                >>> import os\n                >>> os is os\n                True\n                '''\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\")\n        reprec.assertoutcome(passed=3)\n\n    def test_doctestmodule_two_tests_one_fail(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            class MyClass(object):\n                def bad_meth(self):\n                    '''\n                    >>> magic = 42\n                    >>> magic\n                    0\n                    '''\n                def nice_meth(self):\n                    '''\n                    >>> magic = 42\n                    >>> magic - 42\n                    0\n                    '''\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\")\n        reprec.assertoutcome(failed=1, passed=1)\n\n    def test_ignored_whitespace(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            doctest_optionflags = ELLIPSIS NORMALIZE_WHITESPACE\n        \"\"\"\n        )\n        p = testdir.makepyfile(\n            \"\"\"\n            class MyClass(object):\n                '''\n                >>> a = \"foo    \"\n                >>> print(a)\n                foo\n                '''\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\")\n        reprec.assertoutcome(passed=1)\n\n    def test_non_ignored_whitespace(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            doctest_optionflags = ELLIPSIS\n        \"\"\"\n        )\n        p = testdir.makepyfile(\n            \"\"\"\n            class MyClass(object):\n                '''\n                >>> a = \"foo    \"\n                >>> print(a)\n                foo\n                '''\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\")\n        reprec.assertoutcome(failed=1, passed=0)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_ignored_whitespace_glob_TestDoctests.test_unicode_doctest": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_ignored_whitespace_glob_TestDoctests.test_unicode_doctest", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 633, "end_line": 739, "span_ids": ["TestDoctests.test_contains_unicode", "TestDoctests.test_ignore_import_errors_on_doctest", "TestDoctests.test_ignored_whitespace_glob", "TestDoctests.test_junit_report_for_doctest", "TestDoctests.test_non_ignored_whitespace_glob", "TestDoctests.test_unicode_doctest"], "tokens": 667}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_ignored_whitespace_glob(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            doctest_optionflags = ELLIPSIS NORMALIZE_WHITESPACE\n        \"\"\"\n        )\n        p = testdir.maketxtfile(\n            xdoc=\"\"\"\n            >>> a = \"foo    \"\n            >>> print(a)\n            foo\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-glob=x*.txt\")\n        reprec.assertoutcome(passed=1)\n\n    def test_non_ignored_whitespace_glob(self, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            doctest_optionflags = ELLIPSIS\n        \"\"\"\n        )\n        p = testdir.maketxtfile(\n            xdoc=\"\"\"\n            >>> a = \"foo    \"\n            >>> print(a)\n            foo\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-glob=x*.txt\")\n        reprec.assertoutcome(failed=1, passed=0)\n\n    def test_contains_unicode(self, testdir):\n        \"\"\"Fix internal error with docstrings containing non-ascii characters.\n        \"\"\"\n        testdir.makepyfile(\n            '''\\\n            def foo():\n                \"\"\"\n                >>> name = '\u0441' # not letter 'c' but instead Cyrillic 's'.\n                'anything'\n                \"\"\"\n            '''\n        )\n        result = testdir.runpytest(\"--doctest-modules\")\n        result.stdout.fnmatch_lines([\"Got nothing\", \"* 1 failed in*\"])\n\n    def test_ignore_import_errors_on_doctest(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import asdf\n\n            def add_one(x):\n                '''\n                >>> add_one(1)\n                2\n                '''\n                return x + 1\n        \"\"\"\n        )\n\n        reprec = testdir.inline_run(\n            p, \"--doctest-modules\", \"--doctest-ignore-import-errors\"\n        )\n        reprec.assertoutcome(skipped=1, failed=1, passed=0)\n\n    def test_junit_report_for_doctest(self, testdir):\n        \"\"\"\n        #713: Fix --junit-xml option when used with --doctest-modules.\n        \"\"\"\n        p = testdir.makepyfile(\n            \"\"\"\n            def foo():\n                '''\n                >>> 1 + 1\n                3\n                '''\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p, \"--doctest-modules\", \"--junit-xml=junit.xml\")\n        reprec.assertoutcome(failed=1)\n\n    def test_unicode_doctest(self, testdir):\n        \"\"\"\n        Test case for issue 2434: DecodeError on Python 2 when doctest contains non-ascii\n        characters.\n        \"\"\"\n        p = testdir.maketxtfile(\n            test_unicode_doctest=\"\"\"\n            .. doctest::\n\n                >>> print(\n                ...    \"Hi\\\\n\\\\nBy\u00e9\")\n                Hi\n                ...\n                By\u00e9\n                >>> 1/0  # By\u00e9\n                1\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines(\n            [\"*UNEXPECTED EXCEPTION: ZeroDivisionError*\", \"*1 failed*\"]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_unicode_doctest_module_TestDoctests.test_invalid_setup_py": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_doctest.py_TestDoctests.test_unicode_doctest_module_TestDoctests.test_invalid_setup_py", "embedding": null, "metadata": {"file_path": "testing/test_doctest.py", "file_name": "test_doctest.py", "file_type": "text/x-python", "category": "test", "start_line": 741, "end_line": 823, "span_ids": ["TestDoctests.test_invalid_setup_py", "TestDoctests.test_print_unicode_value", "TestDoctests.test_reportinfo", "TestDoctests.test_unicode_doctest_module", "TestDoctests.test_valid_setup_py"], "tokens": 564}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestDoctests:\n\n    def test_unicode_doctest_module(self, testdir):\n        \"\"\"\n        Test case for issue 2434: DecodeError on Python 2 when doctest docstring\n        contains non-ascii characters.\n        \"\"\"\n        p = testdir.makepyfile(\n            test_unicode_doctest_module=\"\"\"\n            def fix_bad_unicode(text):\n                '''\n                    >>> print(fix_bad_unicode('\u00c3\u00banico'))\n                    \u00fanico\n                '''\n                return \"\u00fanico\"\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"--doctest-modules\")\n        result.stdout.fnmatch_lines([\"* 1 passed *\"])\n\n    def test_print_unicode_value(self, testdir):\n        \"\"\"\n        Test case for issue 3583: Printing Unicode in doctest under Python 2.7\n        doesn't work\n        \"\"\"\n        p = testdir.maketxtfile(\n            test_print_unicode_value=r\"\"\"\n            Here is a doctest::\n\n                >>> print('\\xE5\\xE9\\xEE\\xF8\\xFC')\n                \u00e5\u00e9\u00ee\u00f8\u00fc\n        \"\"\"\n        )\n        result = testdir.runpytest(p)\n        result.stdout.fnmatch_lines([\"* 1 passed *\"])\n\n    def test_reportinfo(self, testdir):\n        \"\"\"\n        Test case to make sure that DoctestItem.reportinfo() returns lineno.\n        \"\"\"\n        p = testdir.makepyfile(\n            test_reportinfo=\"\"\"\n            def foo(x):\n                '''\n                    >>> foo('a')\n                    'b'\n                '''\n                return 'c'\n        \"\"\"\n        )\n        items, reprec = testdir.inline_genitems(p, \"--doctest-modules\")\n        reportinfo = items[0].reportinfo()\n        assert reportinfo[1] == 1\n\n    def test_valid_setup_py(self, testdir):\n        \"\"\"\n        Test to make sure that pytest ignores valid setup.py files when ran\n        with --doctest-modules\n        \"\"\"\n        p = testdir.makepyfile(\n            setup=\"\"\"\n            from setuptools import setup, find_packages\n            setup(name='sample',\n                  version='0.0',\n                  description='description',\n                  packages=find_packages()\n            )\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"--doctest-modules\")\n        result.stdout.fnmatch_lines([\"*collected 0 items*\"])\n\n    def test_invalid_setup_py(self, testdir):\n        \"\"\"\n        Test to make sure that pytest reads setup.py files that are not used\n        for python packages when ran with --doctest-modules\n        \"\"\"\n        p = testdir.makepyfile(\n            setup=\"\"\"\n            def test_foo():\n                return 'bar'\n        \"\"\"\n        )\n        result = testdir.runpytest(p, \"--doctest-modules\")\n        result.stdout.fnmatch_lines([\"*collected 1 item*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py___TESTCASES": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py___TESTCASES", "embedding": null, "metadata": {"file_path": "testing/test_error_diffs.py", "file_name": "test_error_diffs.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 212, "span_ids": ["docstring"], "tokens": 40}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nTests and examples for correct \"+/-\" usage in error diffs.\n\nSee https://github.com/pytest-dev/pytest/issues/3333 for details.\n\n\"\"\"\nimport sys\n\nimport pytest\n\n\nTESTCASES =\n # ... other code", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py_TESTCASES.__TESTCASES._": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py_TESTCASES.__TESTCASES._", "embedding": null, "metadata": {"file_path": "testing/test_error_diffs.py", "file_name": "test_error_diffs.py", "file_type": "text/x-python", "category": "test", "start_line": 12, "end_line": 212, "span_ids": ["docstring"], "tokens": 1620}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "TESTCASES = [\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   [1, 4, 3]\n            expected = [1, 2, 3]\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       assert [1, 4, 3] == [1, 2, 3]\n        E         At index 1 diff: 4 != 2\n        E         Full diff:\n        E         - [1, 2, 3]\n        E         ?     ^\n        E         + [1, 4, 3]\n        E         ?     ^\n        \"\"\",\n        id=\"Compare lists, one item differs\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   [1, 2, 3]\n            expected = [1, 2]\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       assert [1, 2, 3] == [1, 2]\n        E         Left contains one more item: 3\n        E         Full diff:\n        E         - [1, 2]\n        E         + [1, 2, 3]\n        E         ?      +++\n        \"\"\",\n        id=\"Compare lists, one extra item\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   [1, 3]\n            expected = [1, 2, 3]\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       assert [1, 3] == [1, 2, 3]\n        E         At index 1 diff: 3 != 2\n        E         Right contains one more item: 3\n        E         Full diff:\n        E         - [1, 2, 3]\n        E         ?     ---\n        E         + [1, 3]\n        \"\"\",\n        id=\"Compare lists, one item missing\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   (1, 4, 3)\n            expected = (1, 2, 3)\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       assert (1, 4, 3) == (1, 2, 3)\n        E         At index 1 diff: 4 != 2\n        E         Full diff:\n        E         - (1, 2, 3)\n        E         ?     ^\n        E         + (1, 4, 3)\n        E         ?     ^\n        \"\"\",\n        id=\"Compare tuples\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   {1, 3, 4}\n            expected = {1, 2, 3}\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       assert {1, 3, 4} == {1, 2, 3}\n        E         Extra items in the left set:\n        E         4\n        E         Extra items in the right set:\n        E         2\n        E         Full diff:\n        E         - {1, 2, 3}\n        E         ?     ^  ^\n        E         + {1, 3, 4}\n        E         ?     ^  ^\n        \"\"\",\n        id=\"Compare sets\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   {1: 'spam', 3: 'eggs'}\n            expected = {1: 'spam', 2: 'eggs'}\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       AssertionError: assert {1: 'spam', 3: 'eggs'} == {1: 'spam', 2: 'eggs'}\n        E         Common items:\n        E         {1: 'spam'}\n        E         Left contains 1 more item:\n        E         {3: 'eggs'}\n        E         Right contains 1 more item:\n        E         {2: 'eggs'}\n        E         Full diff:\n        E         - {1: 'spam', 2: 'eggs'}\n        E         ?             ^\n        E         + {1: 'spam', 3: 'eggs'}\n        E         ?             ^\n        \"\"\",\n        id=\"Compare dicts with differing keys\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   {1: 'spam', 2: 'eggs'}\n            expected = {1: 'spam', 2: 'bacon'}\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       AssertionError: assert {1: 'spam', 2: 'eggs'} == {1: 'spam', 2: 'bacon'}\n        E         Common items:\n        E         {1: 'spam'}\n        E         Differing items:\n        E         {2: 'eggs'} != {2: 'bacon'}\n        E         Full diff:\n        E         - {1: 'spam', 2: 'bacon'}\n        E         ?                 ^^^^^\n        E         + {1: 'spam', 2: 'eggs'}\n        E         ?                 ^^^^\n        \"\"\",\n        id=\"Compare dicts with differing values\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   {1: 'spam', 2: 'eggs'}\n            expected = {1: 'spam', 3: 'bacon'}\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       AssertionError: assert {1: 'spam', 2: 'eggs'} == {1: 'spam', 3: 'bacon'}\n        E         Common items:\n        E         {1: 'spam'}\n        E         Left contains 1 more item:\n        E         {2: 'eggs'}\n        E         Right contains 1 more item:\n        E         {3: 'bacon'}\n        E         Full diff:\n        E         - {1: 'spam', 3: 'bacon'}\n        E         ?             ^   ^^^^^\n        E         + {1: 'spam', 2: 'eggs'}\n        E         ?             ^   ^^^^\n        \"\"\",\n        id=\"Compare dicts with differing items\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   \"spmaeggs\"\n            expected = \"spameggs\"\n            assert result == expected\n        \"\"\",\n        \"\"\"\n        >       assert result == expected\n        E       AssertionError: assert 'spmaeggs' == 'spameggs'\n        E         - spameggs\n        E         ?    -\n        E         + spmaeggs\n        E         ?   +\n        \"\"\",\n        id=\"Compare strings\",\n    ),\n    pytest.param(\n        \"\"\"\n        def test_this():\n            result =   \"spam bacon eggs\"\n            assert \"bacon\" not in result\n        \"\"\",\n        \"\"\"\n        >       assert \"bacon\" not in result\n        E       AssertionError: assert 'bacon' not in 'spam bacon eggs'\n        E         'bacon' is contained here:\n        E           spam bacon eggs\n        E         ?      +++++\n        \"\"\",\n        id='Test \"not in\" string',\n    ),\n]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py_if_sys_version_info_2__": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_error_diffs.py_if_sys_version_info_2__", "embedding": null, "metadata": {"file_path": "testing/test_error_diffs.py", "file_name": "test_error_diffs.py", "file_type": "text/x-python", "category": "test", "start_line": 213, "end_line": 275, "span_ids": ["impl:3", "test_error_diff"], "tokens": 396}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "if sys.version_info[:2] >= (3, 7):\n    TESTCASES.extend(\n        [\n            pytest.param(\n                \"\"\"\n                from dataclasses import dataclass\n\n                @dataclass\n                class A:\n                    a: int\n                    b: str\n\n                def test_this():\n                    result =   A(1, 'spam')\n                    expected = A(2, 'spam')\n                    assert result == expected\n                \"\"\",\n                \"\"\"\n                >       assert result == expected\n                E       AssertionError: assert A(a=1, b='spam') == A(a=2, b='spam')\n                E         Matching attributes:\n                E         ['b']\n                E         Differing attributes:\n                E         a: 1 != 2\n                \"\"\",\n                id=\"Compare data classes\",\n            ),\n            pytest.param(\n                \"\"\"\n                import attr\n\n                @attr.s(auto_attribs=True)\n                class A:\n                    a: int\n                    b: str\n\n                def test_this():\n                    result =   A(1, 'spam')\n                    expected = A(1, 'eggs')\n                    assert result == expected\n                \"\"\",\n                \"\"\"\n                >       assert result == expected\n                E       AssertionError: assert A(a=1, b='spam') == A(a=1, b='eggs')\n                E         Matching attributes:\n                E         ['a']\n                E         Differing attributes:\n                E         b: 'spam' != 'eggs'\n                \"\"\",\n                id=\"Compare attrs classes\",\n            ),\n        ]\n    )\n\n\n@pytest.mark.parametrize(\"code, expected\", TESTCASES)\ndef test_error_diff(code, expected, testdir):\n    expected = [l.lstrip() for l in expected.splitlines()]\n    p = testdir.makepyfile(code)\n    result = testdir.runpytest(p, \"-vv\")\n    result.stdout.fnmatch_lines(expected)\n    assert result.ret == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_test_timeout_test_timeout.assert_result_ret_0": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_test_timeout_test_timeout.assert_result_ret_0", "embedding": null, "metadata": {"file_path": "testing/test_faulthandler.py", "file_name": "test_faulthandler.py", "file_type": "text/x-python", "category": "test", "start_line": 52, "end_line": 87, "span_ids": ["test_timeout"], "tokens": 237}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"enabled\",\n    [\n        pytest.param(\n            True, marks=pytest.mark.skip(reason=\"sometimes crashes on CI (#7022)\")\n        ),\n        False,\n    ],\n)\ndef test_timeout(testdir, enabled: bool) -> None:\n    \"\"\"Test option to dump tracebacks after a certain timeout.\n    If faulthandler is disabled, no traceback will be dumped.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n    import os, time\n    def test_timeout():\n        time.sleep(1 if \"CI\" in os.environ else 0.1)\n    \"\"\"\n    )\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        faulthandler_timeout = 0.01\n        \"\"\"\n    )\n    args = [\"-p\", \"no:faulthandler\"] if not enabled else []\n\n    result = testdir.runpytest_subprocess(*args)\n    tb_output = \"most recent call first\"\n    if enabled:\n        result.stderr.fnmatch_lines([\"*%s*\" % tb_output])\n    else:\n        assert tb_output not in result.stderr.str()\n    result.stdout.fnmatch_lines([\"*1 passed*\"])\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_test_cancel_timeout_on_hook_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_faulthandler.py_test_cancel_timeout_on_hook_", "embedding": null, "metadata": {"file_path": "testing/test_faulthandler.py", "file_name": "test_faulthandler.py", "file_type": "text/x-python", "category": "test", "start_line": 90, "end_line": 139, "span_ids": ["test_already_initialized", "test_cancel_timeout_on_hook"], "tokens": 405}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"hook_name\", [\"pytest_enter_pdb\", \"pytest_exception_interact\"])\ndef test_cancel_timeout_on_hook(monkeypatch, hook_name):\n    \"\"\"Make sure that we are cancelling any scheduled traceback dumping due\n    to timeout before entering pdb (pytest-dev/pytest-faulthandler#12) or any other interactive\n    exception (pytest-dev/pytest-faulthandler#14).\n    \"\"\"\n    import faulthandler\n    from _pytest.faulthandler import FaultHandlerHooks\n\n    called = []\n\n    monkeypatch.setattr(\n        faulthandler, \"cancel_dump_traceback_later\", lambda: called.append(1)\n    )\n\n    # call our hook explicitly, we can trust that pytest will call the hook\n    # for us at the appropriate moment\n    hook_func = getattr(FaultHandlerHooks, hook_name)\n    hook_func(self=None)\n    assert called == [1]\n\n\n@pytest.mark.parametrize(\"faulthandler_timeout\", [0, 2])\ndef test_already_initialized(faulthandler_timeout, testdir):\n    \"\"\"Test for faulthandler being initialized earlier than pytest (#6575)\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        def test():\n            import faulthandler\n            assert faulthandler.is_enabled()\n    \"\"\"\n    )\n    result = testdir.run(\n        sys.executable,\n        \"-X\",\n        \"faulthandler\",\n        \"-mpytest\",\n        testdir.tmpdir,\n        \"-o\",\n        \"faulthandler_timeout={}\".format(faulthandler_timeout),\n    )\n    # ensure warning is emitted if faulthandler_timeout is configured\n    warning_line = \"*faulthandler.py*faulthandler module enabled before*\"\n    if faulthandler_timeout > 0:\n        result.stdout.fnmatch_lines(warning_line)\n    else:\n        result.stdout.no_fnmatch_line(warning_line)\n    result.stdout.fnmatch_lines(\"*1 passed*\")\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_internal_error_TestPython.test_failure_function.if_junit_logging_no_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_internal_error_TestPython.test_failure_function.if_junit_logging_no_", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 436, "end_line": 515, "span_ids": ["TestPython.test_failure_function", "TestPython.test_internal_error"], "tokens": 819}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @parametrize_families\n    def test_internal_error(self, testdir, run_and_parse, xunit_family):\n        testdir.makeconftest(\"def pytest_runtest_protocol(): 0 / 0\")\n        testdir.makepyfile(\"def test_function(): pass\")\n        result, dom = run_and_parse(family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(errors=1, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"pytest\", name=\"internal\")\n        fnode = tnode.find_first_by_tag(\"error\")\n        fnode.assert_attr(message=\"internal error\")\n        assert \"Division\" in fnode.toxml()\n\n    @pytest.mark.parametrize(\n        \"junit_logging\", [\"no\", \"log\", \"system-out\", \"system-err\", \"out-err\", \"all\"]\n    )\n    @parametrize_families\n    def test_failure_function(\n        self, testdir, junit_logging, run_and_parse, xunit_family\n    ):\n        testdir.makepyfile(\n            \"\"\"\n            import logging\n            import sys\n\n            def test_fail():\n                print(\"hello-stdout\")\n                sys.stderr.write(\"hello-stderr\\\\n\")\n                logging.info('info msg')\n                logging.warning('warning msg')\n                raise ValueError(42)\n        \"\"\"\n        )\n\n        result, dom = run_and_parse(\n            \"-o\", \"junit_logging=%s\" % junit_logging, family=xunit_family\n        )\n        assert result.ret, \"Expected ret > 0\"\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(failures=1, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_failure_function\", name=\"test_fail\")\n        fnode = tnode.find_first_by_tag(\"failure\")\n        fnode.assert_attr(message=\"ValueError: 42\")\n        assert \"ValueError\" in fnode.toxml(), \"ValueError not included\"\n\n        if junit_logging in [\"log\", \"all\"]:\n            logdata = tnode.find_first_by_tag(\"system-out\")\n            log_xml = logdata.toxml()\n            assert logdata.tag == \"system-out\", \"Expected tag: system-out\"\n            assert \"info msg\" not in log_xml, \"Unexpected INFO message\"\n            assert \"warning msg\" in log_xml, \"Missing WARN message\"\n        if junit_logging in [\"system-out\", \"out-err\", \"all\"]:\n            systemout = tnode.find_first_by_tag(\"system-out\")\n            systemout_xml = systemout.toxml()\n            assert systemout.tag == \"system-out\", \"Expected tag: system-out\"\n            assert \"info msg\" not in systemout_xml, \"INFO message found in system-out\"\n            assert (\n                \"hello-stdout\" in systemout_xml\n            ), \"Missing 'hello-stdout' in system-out\"\n        if junit_logging in [\"system-err\", \"out-err\", \"all\"]:\n            systemerr = tnode.find_first_by_tag(\"system-err\")\n            systemerr_xml = systemerr.toxml()\n            assert systemerr.tag == \"system-err\", \"Expected tag: system-err\"\n            assert \"info msg\" not in systemerr_xml, \"INFO message found in system-err\"\n            assert (\n                \"hello-stderr\" in systemerr_xml\n            ), \"Missing 'hello-stderr' in system-err\"\n            assert (\n                \"warning msg\" not in systemerr_xml\n            ), \"WARN message found in system-err\"\n        if junit_logging == \"no\":\n            assert not tnode.find_by_tag(\"log\"), \"Found unexpected content: log\"\n            assert not tnode.find_by_tag(\n                \"system-out\"\n            ), \"Found unexpected content: system-out\"\n            assert not tnode.find_by_tag(\n                \"system-err\"\n            ), \"Found unexpected content: system-err\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_failure_verbose_message_TestPython.test_failure_escape.for_index_char_in_enumer": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_failure_verbose_message_TestPython.test_failure_escape.for_index_char_in_enumer", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 517, "end_line": 558, "span_ids": ["TestPython.test_failure_escape", "TestPython.test_failure_verbose_message"], "tokens": 331}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @parametrize_families\n    def test_failure_verbose_message(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            def test_fail():\n                assert 0, \"An error\"\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        node = dom.find_first_by_tag(\"testsuite\")\n        tnode = node.find_first_by_tag(\"testcase\")\n        fnode = tnode.find_first_by_tag(\"failure\")\n        fnode.assert_attr(message=\"AssertionError: An error assert 0\")\n\n    @parametrize_families\n    def test_failure_escape(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('arg1', \"<&'\", ids=\"<&'\")\n            def test_func(arg1):\n                print(arg1)\n                assert 0\n        \"\"\"\n        )\n        result, dom = run_and_parse(\n            \"-o\", \"junit_logging=system-out\", family=xunit_family\n        )\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(failures=3, tests=3)\n\n        for index, char in enumerate(\"<&'\"):\n\n            tnode = node.find_nth_by_tag(\"testcase\", index)\n            tnode.assert_attr(\n                classname=\"test_failure_escape\", name=\"test_func[%s]\" % char\n            )\n            sysout = tnode.find_first_by_tag(\"system-out\")\n            text = sysout.text\n            assert \"%s\\n\" % char in text", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_junit_prefixing_TestPython.test_xfailure_marker": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_junit_prefixing_TestPython.test_xfailure_marker", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 560, "end_line": 617, "span_ids": ["TestPython.test_junit_prefixing", "TestPython.test_xfailure_function", "TestPython.test_xfailure_marker"], "tokens": 515}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @parametrize_families\n    def test_junit_prefixing(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            def test_func():\n                assert 0\n            class TestHello(object):\n                def test_hello(self):\n                    pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(\"--junitprefix=xyz\", family=xunit_family)\n        assert result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(failures=1, tests=2)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"xyz.test_junit_prefixing\", name=\"test_func\")\n        tnode = node.find_nth_by_tag(\"testcase\", 1)\n        tnode.assert_attr(\n            classname=\"xyz.test_junit_prefixing.TestHello\", name=\"test_hello\"\n        )\n\n    @parametrize_families\n    def test_xfailure_function(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_xfail():\n                pytest.xfail(\"42\")\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert not result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(skipped=1, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_xfailure_function\", name=\"test_xfail\")\n        fnode = tnode.find_first_by_tag(\"skipped\")\n        fnode.assert_attr(type=\"pytest.xfail\", message=\"42\")\n\n    @parametrize_families\n    def test_xfailure_marker(self, testdir, run_and_parse, xunit_family):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.xfail(reason=\"42\")\n            def test_xfail():\n                assert False\n        \"\"\"\n        )\n        result, dom = run_and_parse(family=xunit_family)\n        assert not result.ret\n        node = dom.find_first_by_tag(\"testsuite\")\n        node.assert_attr(skipped=1, tests=1)\n        tnode = node.find_first_by_tag(\"testcase\")\n        tnode.assert_attr(classname=\"test_xfailure_marker\", name=\"test_xfail\")\n        fnode = tnode.find_first_by_tag(\"skipped\")\n        fnode.assert_attr(type=\"pytest.xfail\", message=\"42\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_xfail_captures_output_once_TestPython.test_xfail_captures_output_once.if_junit_logging_in_log": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_xfail_captures_output_once_TestPython.test_xfail_captures_output_once.if_junit_logging_in_log", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 619, "end_line": 646, "span_ids": ["TestPython.test_xfail_captures_output_once"], "tokens": 266}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @pytest.mark.parametrize(\n        \"junit_logging\", [\"no\", \"log\", \"system-out\", \"system-err\", \"out-err\", \"all\"]\n    )\n    def test_xfail_captures_output_once(self, testdir, junit_logging, run_and_parse):\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            import pytest\n\n            @pytest.mark.xfail()\n            def test_fail():\n                sys.stdout.write('XFAIL This is stdout')\n                sys.stderr.write('XFAIL This is stderr')\n                assert 0\n        \"\"\"\n        )\n        result, dom = run_and_parse(\"-o\", \"junit_logging=%s\" % junit_logging)\n        node = dom.find_first_by_tag(\"testsuite\")\n        tnode = node.find_first_by_tag(\"testcase\")\n        if junit_logging in [\"system-err\", \"out-err\", \"all\"]:\n            assert len(tnode.find_by_tag(\"system-err\")) == 1\n        else:\n            assert len(tnode.find_by_tag(\"system-err\")) == 0\n\n        if junit_logging in [\"log\", \"system-out\", \"out-err\", \"all\"]:\n            assert len(tnode.find_by_tag(\"system-out\")) == 1\n        else:\n            assert len(tnode.find_by_tag(\"system-out\")) == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_pass_captures_stdout_TestPython.test_pass_captures_stderr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_pass_captures_stdout_TestPython.test_pass_captures_stderr", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 728, "end_line": 769, "span_ids": ["TestPython.test_pass_captures_stderr", "TestPython.test_pass_captures_stdout"], "tokens": 390}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-out\"])\n    def test_pass_captures_stdout(self, testdir, run_and_parse, junit_logging):\n        testdir.makepyfile(\n            \"\"\"\n            def test_pass():\n                print('hello-stdout')\n        \"\"\"\n        )\n        result, dom = run_and_parse(\"-o\", \"junit_logging=%s\" % junit_logging)\n        node = dom.find_first_by_tag(\"testsuite\")\n        pnode = node.find_first_by_tag(\"testcase\")\n        if junit_logging == \"no\":\n            assert not node.find_by_tag(\n                \"system-out\"\n            ), \"system-out should not be generated\"\n        if junit_logging == \"system-out\":\n            systemout = pnode.find_first_by_tag(\"system-out\")\n            assert (\n                \"hello-stdout\" in systemout.toxml()\n            ), \"'hello-stdout' should be in system-out\"\n\n    @pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-err\"])\n    def test_pass_captures_stderr(self, testdir, run_and_parse, junit_logging):\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            def test_pass():\n                sys.stderr.write('hello-stderr')\n        \"\"\"\n        )\n        result, dom = run_and_parse(\"-o\", \"junit_logging=%s\" % junit_logging)\n        node = dom.find_first_by_tag(\"testsuite\")\n        pnode = node.find_first_by_tag(\"testcase\")\n        if junit_logging == \"no\":\n            assert not node.find_by_tag(\n                \"system-err\"\n            ), \"system-err should not be generated\"\n        if junit_logging == \"system-err\":\n            systemerr = pnode.find_first_by_tag(\"system-err\")\n            assert (\n                \"hello-stderr\" in systemerr.toxml()\n            ), \"'hello-stderr' should be in system-err\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_captures_stdout_TestPython.test_setup_error_captures_stdout.if_junit_logging_syst": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_captures_stdout_TestPython.test_setup_error_captures_stdout.if_junit_logging_syst", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 771, "end_line": 796, "span_ids": ["TestPython.test_setup_error_captures_stdout"], "tokens": 206}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-out\"])\n    def test_setup_error_captures_stdout(self, testdir, run_and_parse, junit_logging):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.fixture\n            def arg(request):\n                print('hello-stdout')\n                raise ValueError()\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(\"-o\", \"junit_logging=%s\" % junit_logging)\n        node = dom.find_first_by_tag(\"testsuite\")\n        pnode = node.find_first_by_tag(\"testcase\")\n        if junit_logging == \"no\":\n            assert not node.find_by_tag(\n                \"system-out\"\n            ), \"system-out should not be generated\"\n        if junit_logging == \"system-out\":\n            systemout = pnode.find_first_by_tag(\"system-out\")\n            assert (\n                \"hello-stdout\" in systemout.toxml()\n            ), \"'hello-stdout' should be in system-out\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_captures_stderr_TestPython.test_setup_error_captures_stderr.if_junit_logging_syst": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_setup_error_captures_stderr_TestPython.test_setup_error_captures_stderr.if_junit_logging_syst", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 798, "end_line": 824, "span_ids": ["TestPython.test_setup_error_captures_stderr"], "tokens": 218}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-err\"])\n    def test_setup_error_captures_stderr(self, testdir, run_and_parse, junit_logging):\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            import pytest\n\n            @pytest.fixture\n            def arg(request):\n                sys.stderr.write('hello-stderr')\n                raise ValueError()\n            def test_function(arg):\n                pass\n        \"\"\"\n        )\n        result, dom = run_and_parse(\"-o\", \"junit_logging=%s\" % junit_logging)\n        node = dom.find_first_by_tag(\"testsuite\")\n        pnode = node.find_first_by_tag(\"testcase\")\n        if junit_logging == \"no\":\n            assert not node.find_by_tag(\n                \"system-err\"\n            ), \"system-err should not be generated\"\n        if junit_logging == \"system-err\":\n            systemerr = pnode.find_first_by_tag(\"system-err\")\n            assert (\n                \"hello-stderr\" in systemerr.toxml()\n            ), \"'hello-stderr' should be in system-err\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_avoid_double_stdout_TestPython.test_avoid_double_stdout.if_junit_logging_syst": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_TestPython.test_avoid_double_stdout_TestPython.test_avoid_double_stdout.if_junit_logging_syst", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 826, "end_line": 852, "span_ids": ["TestPython.test_avoid_double_stdout"], "tokens": 221}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPython:\n\n    @pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-out\"])\n    def test_avoid_double_stdout(self, testdir, run_and_parse, junit_logging):\n        testdir.makepyfile(\n            \"\"\"\n            import sys\n            import pytest\n\n            @pytest.fixture\n            def arg(request):\n                yield\n                sys.stdout.write('hello-stdout teardown')\n                raise ValueError()\n            def test_function(arg):\n                sys.stdout.write('hello-stdout call')\n        \"\"\"\n        )\n        result, dom = run_and_parse(\"-o\", \"junit_logging=%s\" % junit_logging)\n        node = dom.find_first_by_tag(\"testsuite\")\n        pnode = node.find_first_by_tag(\"testcase\")\n        if junit_logging == \"no\":\n            assert not node.find_by_tag(\n                \"system-out\"\n            ), \"system-out should not be generated\"\n        if junit_logging == \"system-out\":\n            systemout = pnode.find_first_by_tag(\"system-out\")\n            assert \"hello-stdout call\" in systemout.toxml()\n            assert \"hello-stdout teardown\" in systemout.toxml()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_escaped_skipreason_issue3533_test_logging_passing_tests_disabled_does_not_log_test_output.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_escaped_skipreason_issue3533_test_logging_passing_tests_disabled_does_not_log_test_output.None_3", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1504, "end_line": 1550, "span_ids": ["test_escaped_skipreason_issue3533", "test_logging_passing_tests_disabled_does_not_log_test_output"], "tokens": 298}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_escaped_skipreason_issue3533(testdir, run_and_parse):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.skip(reason='1 <> 2')\n        def test_skip():\n            pass\n    \"\"\"\n    )\n    _, dom = run_and_parse()\n    node = dom.find_first_by_tag(\"testcase\")\n    snode = node.find_first_by_tag(\"skipped\")\n    assert \"1 <> 2\" in snode.text\n    snode.assert_attr(message=\"1 <> 2\")\n\n\n@parametrize_families\ndef test_logging_passing_tests_disabled_does_not_log_test_output(\n    testdir, run_and_parse, xunit_family\n):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        junit_log_passing_tests=False\n        junit_logging=system-out\n        junit_family={family}\n    \"\"\".format(\n            family=xunit_family\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        import sys\n\n        def test_func():\n            sys.stdout.write('This is stdout')\n            sys.stderr.write('This is stderr')\n            logging.warning('hello')\n    \"\"\"\n    )\n    result, dom = run_and_parse(family=xunit_family)\n    assert result.ret == 0\n    node = dom.find_first_by_tag(\"testcase\")\n    assert len(node.find_by_tag(\"system-err\")) == 0\n    assert len(node.find_by_tag(\"system-out\")) == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_logging_passing_tests_disabled_logs_output_for_failing_test_issue5430_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_junitxml.py_test_logging_passing_tests_disabled_logs_output_for_failing_test_issue5430_", "embedding": null, "metadata": {"file_path": "testing/test_junitxml.py", "file_name": "test_junitxml.py", "file_type": "text/x-python", "category": "test", "start_line": 1553, "end_line": 1593, "span_ids": ["test_logging_passing_tests_disabled_logs_output_for_failing_test_issue5430"], "tokens": 305}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@parametrize_families\n@pytest.mark.parametrize(\"junit_logging\", [\"no\", \"system-out\", \"system-err\"])\ndef test_logging_passing_tests_disabled_logs_output_for_failing_test_issue5430(\n    testdir, junit_logging, run_and_parse, xunit_family\n):\n    testdir.makeini(\n        \"\"\"\n        [pytest]\n        junit_log_passing_tests=False\n        junit_family={family}\n    \"\"\".format(\n            family=xunit_family\n        )\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import logging\n        import sys\n\n        def test_func():\n            logging.warning('hello')\n            assert 0\n    \"\"\"\n    )\n    result, dom = run_and_parse(\n        \"-o\", \"junit_logging=%s\" % junit_logging, family=xunit_family\n    )\n    assert result.ret == 1\n    node = dom.find_first_by_tag(\"testcase\")\n    if junit_logging == \"system-out\":\n        assert len(node.find_by_tag(\"system-err\")) == 0\n        assert len(node.find_by_tag(\"system-out\")) == 1\n    elif junit_logging == \"system-err\":\n        assert len(node.find_by_tag(\"system-err\")) == 1\n        assert len(node.find_by_tag(\"system-out\")) == 0\n    else:\n        assert junit_logging == \"no\"\n        assert len(node.find_by_tag(\"system-err\")) == 0\n        assert len(node.find_by_tag(\"system-out\")) == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_main.py_from_typing_import_Option_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_main.py_from_typing_import_Option_", "embedding": null, "metadata": {"file_path": "testing/test_main.py", "file_name": "test_main.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 78, "span_ids": ["imports", "test_wrap_session_exit_sessionfinish", "test_wrap_session_notify_exception"], "tokens": 561}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "from typing import Optional\n\nimport pytest\nfrom _pytest.config import ExitCode\nfrom _pytest.pytester import Testdir\n\n\n@pytest.mark.parametrize(\n    \"ret_exc\",\n    (\n        pytest.param((None, ValueError)),\n        pytest.param((42, SystemExit)),\n        pytest.param((False, SystemExit)),\n    ),\n)\ndef test_wrap_session_notify_exception(ret_exc, testdir):\n    returncode, exc = ret_exc\n    c1 = testdir.makeconftest(\n        \"\"\"\n        import pytest\n\n        def pytest_sessionstart():\n            raise {exc}(\"boom\")\n\n        def pytest_internalerror(excrepr, excinfo):\n            returncode = {returncode!r}\n            if returncode is not False:\n                pytest.exit(\"exiting after %s...\" % excinfo.typename, returncode={returncode!r})\n    \"\"\".format(\n            returncode=returncode, exc=exc.__name__\n        )\n    )\n    result = testdir.runpytest()\n    if returncode:\n        assert result.ret == returncode\n    else:\n        assert result.ret == ExitCode.INTERNAL_ERROR\n    assert result.stdout.lines[0] == \"INTERNALERROR> Traceback (most recent call last):\"\n\n    if exc == SystemExit:\n        assert result.stdout.lines[-3:] == [\n            'INTERNALERROR>   File \"{}\", line 4, in pytest_sessionstart'.format(c1),\n            'INTERNALERROR>     raise SystemExit(\"boom\")',\n            \"INTERNALERROR> SystemExit: boom\",\n        ]\n    else:\n        assert result.stdout.lines[-3:] == [\n            'INTERNALERROR>   File \"{}\", line 4, in pytest_sessionstart'.format(c1),\n            'INTERNALERROR>     raise ValueError(\"boom\")',\n            \"INTERNALERROR> ValueError: boom\",\n        ]\n    if returncode is False:\n        assert result.stderr.lines == [\"mainloop: caught unexpected SystemExit!\"]\n    else:\n        assert result.stderr.lines == [\"Exit: exiting after {}...\".format(exc.__name__)]\n\n\n@pytest.mark.parametrize(\"returncode\", (None, 42))\ndef test_wrap_session_exit_sessionfinish(\n    returncode: Optional[int], testdir: Testdir\n) -> None:\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        def pytest_sessionfinish():\n            pytest.exit(msg=\"exit_pytest_sessionfinish\", returncode={returncode})\n    \"\"\".format(\n            returncode=returncode\n        )\n    )\n    result = testdir.runpytest()\n    if returncode:\n        assert result.ret == returncode\n    else:\n        assert result.ret == ExitCode.NO_TESTS_COLLECTED\n    assert result.stdout.lines[-1] == \"collected 0 items\"\n    assert result.stderr.lines == [\"Exit: exit_pytest_sessionfinish\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_marker_without_description_test_mark_option.assert_passed_expected": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_marker_without_description_test_mark_option.assert_passed_expected", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 122, "end_line": 225, "span_ids": ["test_mark_on_pseudo_function", "test_mark_option", "test_marker_without_description", "test_markers_option_with_plugin_in_current_dir", "test_strict_prohibits_unregistered_markers"], "tokens": 643}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_marker_without_description(testdir):\n    testdir.makefile(\n        \".cfg\",\n        setup=\"\"\"\n        [tool:pytest]\n        markers=slow\n    \"\"\",\n    )\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        pytest.mark.xfail('FAIL')\n    \"\"\"\n    )\n    ftdir = testdir.mkdir(\"ft1_dummy\")\n    testdir.tmpdir.join(\"conftest.py\").move(ftdir.join(\"conftest.py\"))\n    rec = testdir.runpytest(\"--strict-markers\")\n    rec.assert_outcomes()\n\n\ndef test_markers_option_with_plugin_in_current_dir(testdir):\n    testdir.makeconftest('pytest_plugins = \"flip_flop\"')\n    testdir.makepyfile(\n        flip_flop=\"\"\"\\\n        def pytest_configure(config):\n            config.addinivalue_line(\"markers\", \"flip:flop\")\n\n        def pytest_generate_tests(metafunc):\n            try:\n                mark = metafunc.function.flipper\n            except AttributeError:\n                return\n            metafunc.parametrize(\"x\", (10, 20))\"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\\\n        import pytest\n        @pytest.mark.flipper\n        def test_example(x):\n            assert x\"\"\"\n    )\n\n    result = testdir.runpytest(\"--markers\")\n    result.stdout.fnmatch_lines([\"*flip*flop*\"])\n\n\ndef test_mark_on_pseudo_function(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.mark.r(lambda x: 0/0)\n        def test_hello():\n            pass\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\n@pytest.mark.parametrize(\"option_name\", [\"--strict-markers\", \"--strict\"])\ndef test_strict_prohibits_unregistered_markers(testdir, option_name):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.unregisteredmark\n        def test_hello():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(option_name)\n    assert result.ret != 0\n    result.stdout.fnmatch_lines(\n        [\"'unregisteredmark' not found in `markers` configuration option\"]\n    )\n\n\n@pytest.mark.parametrize(\n    (\"expr\", \"expected_passed\"),\n    [\n        (\"xyz\", [\"test_one\"]),\n        (\"(((  xyz))  )\", [\"test_one\"]),\n        (\"not not xyz\", [\"test_one\"]),\n        (\"xyz and xyz2\", []),\n        (\"xyz2\", [\"test_two\"]),\n        (\"xyz or xyz2\", [\"test_one\", \"test_two\"]),\n    ],\n)\ndef test_mark_option(expr: str, expected_passed: str, testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.xyz\n        def test_one():\n            pass\n        @pytest.mark.xyz2\n        def test_two():\n            pass\n    \"\"\"\n    )\n    rec = testdir.inline_run(\"-m\", expr)\n    passed, skipped, fail = rec.listoutcomes()\n    passed = [x.nodeid.split(\"::\")[-1] for x in passed]\n    assert passed == expected_passed", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_mark_option_custom_test_keyword_option_custom.assert_passed_expected": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_mark_option_custom_test_keyword_option_custom.assert_passed_expected", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 228, "end_line": 286, "span_ids": ["test_keyword_option_custom", "test_mark_option_custom"], "tokens": 449}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    (\"expr\", \"expected_passed\"),\n    [(\"interface\", [\"test_interface\"]), (\"not interface\", [\"test_nointer\"])],\n)\ndef test_mark_option_custom(expr: str, expected_passed: str, testdir) -> None:\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        def pytest_collection_modifyitems(items):\n            for item in items:\n                if \"interface\" in item.nodeid:\n                    item.add_marker(pytest.mark.interface)\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        def test_interface():\n            pass\n        def test_nointer():\n            pass\n    \"\"\"\n    )\n    rec = testdir.inline_run(\"-m\", expr)\n    passed, skipped, fail = rec.listoutcomes()\n    passed = [x.nodeid.split(\"::\")[-1] for x in passed]\n    assert passed == expected_passed\n\n\n@pytest.mark.parametrize(\n    (\"expr\", \"expected_passed\"),\n    [\n        (\"interface\", [\"test_interface\"]),\n        (\"not interface\", [\"test_nointer\", \"test_pass\", \"test_1\", \"test_2\"]),\n        (\"pass\", [\"test_pass\"]),\n        (\"not pass\", [\"test_interface\", \"test_nointer\", \"test_1\", \"test_2\"]),\n        (\"not not not (pass)\", [\"test_interface\", \"test_nointer\", \"test_1\", \"test_2\"]),\n        (\"1 or 2\", [\"test_1\", \"test_2\"]),\n        (\"not (1 or 2)\", [\"test_interface\", \"test_nointer\", \"test_pass\"]),\n    ],\n)\ndef test_keyword_option_custom(expr: str, expected_passed: str, testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        def test_interface():\n            pass\n        def test_nointer():\n            pass\n        def test_pass():\n            pass\n        def test_1():\n            pass\n        def test_2():\n            pass\n    \"\"\"\n    )\n    rec = testdir.inline_run(\"-k\", expr)\n    passed, skipped, fail = rec.listoutcomes()\n    passed = [x.nodeid.split(\"::\")[-1] for x in passed]\n    assert passed == expected_passed", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_keyword_option_considers_mark_test_parametrize_with_module": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_keyword_option_considers_mark_test_parametrize_with_module", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 289, "end_line": 331, "span_ids": ["test_keyword_option_considers_mark", "test_keyword_option_parametrize", "test_parametrize_with_module"], "tokens": 333}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_keyword_option_considers_mark(testdir):\n    testdir.copy_example(\"marks/marks_considered_keywords\")\n    rec = testdir.inline_run(\"-k\", \"foo\")\n    passed = rec.listoutcomes()[0]\n    assert len(passed) == 1\n\n\n@pytest.mark.parametrize(\n    (\"expr\", \"expected_passed\"),\n    [\n        (\"None\", [\"test_func[None]\"]),\n        (\"[1.3]\", [\"test_func[1.3]\"]),\n        (\"2-3\", [\"test_func[2-3]\"]),\n    ],\n)\ndef test_keyword_option_parametrize(expr: str, expected_passed: str, testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.parametrize(\"arg\", [None, 1.3, \"2-3\"])\n        def test_func(arg):\n            pass\n    \"\"\"\n    )\n    rec = testdir.inline_run(\"-k\", expr)\n    passed, skipped, fail = rec.listoutcomes()\n    passed = [x.nodeid.split(\"::\")[-1] for x in passed]\n    assert passed == expected_passed\n\n\ndef test_parametrize_with_module(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.parametrize(\"arg\", [pytest,])\n        def test_func(arg):\n            pass\n    \"\"\"\n    )\n    rec = testdir.inline_run()\n    passed, skipped, fail = rec.listoutcomes()\n    expected_id = \"test_func[\" + pytest.__name__ + \"]\"\n    assert passed[0].nodeid.split(\"::\")[-1] == expected_id", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_keyword_option_wrong_arguments_test_keyword_option_wrong_arguments.assert_expected_error_in_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_keyword_option_wrong_arguments_test_keyword_option_wrong_arguments.assert_expected_error_in_", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 334, "end_line": 368, "span_ids": ["test_keyword_option_wrong_arguments"], "tokens": 240}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    (\"expr\", \"expected_error\"),\n    [\n        (\n            \"foo or\",\n            \"at column 7: expected not OR left parenthesis OR identifier; got end of input\",\n        ),\n        (\n            \"foo or or\",\n            \"at column 8: expected not OR left parenthesis OR identifier; got or\",\n        ),\n        (\"(foo\", \"at column 5: expected right parenthesis; got end of input\",),\n        (\"foo bar\", \"at column 5: expected end of input; got identifier\",),\n        (\n            \"or or\",\n            \"at column 1: expected not OR left parenthesis OR identifier; got or\",\n        ),\n        (\n            \"not or\",\n            \"at column 5: expected not OR left parenthesis OR identifier; got or\",\n        ),\n    ],\n)\ndef test_keyword_option_wrong_arguments(\n    expr: str, expected_error: str, testdir, capsys\n) -> None:\n    testdir.makepyfile(\n        \"\"\"\n            def test_func(arg):\n                pass\n        \"\"\"\n    )\n    testdir.inline_run(\"-k\", expr)\n    err = capsys.readouterr().err\n    assert expected_error in err", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional.test_mark_with_wrong_marker_TestFunctional.test_keyword_added_for_session.reprec_assertoutcome_pass": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional.test_mark_with_wrong_marker_TestFunctional.test_keyword_added_for_session.reprec_assertoutcome_pass", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 566, "end_line": 668, "span_ids": ["TestFunctional.test_keyword_added_for_session", "TestFunctional.test_keywords_at_node_level", "TestFunctional.test_mark_dynamically_in_funcarg", "TestFunctional.test_mark_with_wrong_marker", "TestFunctional.test_no_marker_match_on_unmarked_names"], "tokens": 692}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunctional:\n\n    def test_mark_with_wrong_marker(self, testdir):\n        reprec = testdir.inline_runsource(\n            \"\"\"\n                import pytest\n                class pytestmark(object):\n                    pass\n                def test_func():\n                    pass\n        \"\"\"\n        )\n        values = reprec.getfailedcollections()\n        assert len(values) == 1\n        assert \"TypeError\" in str(values[0].longrepr)\n\n    def test_mark_dynamically_in_funcarg(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            @pytest.fixture\n            def arg(request):\n                request.applymarker(pytest.mark.hello)\n            def pytest_terminal_summary(terminalreporter):\n                values = terminalreporter.stats['passed']\n                terminalreporter._tw.line(\"keyword: %s\" % values[0].keywords)\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_func(arg):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"keyword: *hello*\"])\n\n    def test_no_marker_match_on_unmarked_names(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.shouldmatch\n            def test_marked():\n                assert 1\n\n            def test_unmarked():\n                assert 1\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-m\", \"test_unmarked\", p)\n        passed, skipped, failed = reprec.listoutcomes()\n        assert len(passed) + len(skipped) + len(failed) == 0\n        dlist = reprec.getcalls(\"pytest_deselected\")\n        deselected_tests = dlist[0].items\n        assert len(deselected_tests) == 2\n\n    def test_keywords_at_node_level(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.fixture(scope=\"session\", autouse=True)\n            def some(request):\n                request.keywords[\"hello\"] = 42\n                assert \"world\" not in request.keywords\n\n            @pytest.fixture(scope=\"function\", autouse=True)\n            def funcsetup(request):\n                assert \"world\" in request.keywords\n                assert \"hello\" in  request.keywords\n\n            @pytest.mark.world\n            def test_function():\n                pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(passed=1)\n\n    def test_keyword_added_for_session(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            import pytest\n            def pytest_collection_modifyitems(session):\n                session.add_marker(\"mark1\")\n                session.add_marker(pytest.mark.mark2)\n                session.add_marker(pytest.mark.mark3)\n                pytest.raises(ValueError, lambda:\n                        session.add_marker(10))\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_some(request):\n                assert \"mark1\" in request.keywords\n                assert \"mark2\" in request.keywords\n                assert \"mark3\" in request.keywords\n                assert 10 not in request.keywords\n                marker = request.node.get_closest_marker(\"mark1\")\n                assert marker.name == \"mark1\"\n                assert marker.args == ()\n                assert marker.kwargs == {}\n        \"\"\"\n        )\n        reprec = testdir.inline_run(\"-m\", \"mark1\")\n        reprec.assertoutcome(passed=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional.assert_markers_TestFunctional.test_mark_from_parameters": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_TestFunctional.assert_markers_TestFunctional.test_mark_from_parameters", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 670, "end_line": 706, "span_ids": ["TestFunctional.assert_markers", "TestFunctional.test_mark_from_parameters"], "tokens": 243}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestFunctional:\n\n    def assert_markers(self, items, **expected):\n        \"\"\"assert that given items have expected marker names applied to them.\n        expected should be a dict of (item name -> seq of expected marker names)\n\n        .. note:: this could be moved to ``testdir`` if proven to be useful\n        to other modules.\n        \"\"\"\n\n        items = {x.name: x for x in items}\n        for name, expected_markers in expected.items():\n            markers = {m.name for m in items[name].iter_markers()}\n            assert markers == set(expected_markers)\n\n    @pytest.mark.filterwarnings(\"ignore\")\n    def test_mark_from_parameters(self, testdir):\n        \"\"\"#1540\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            pytestmark = pytest.mark.skipif(True, reason='skip all')\n\n            # skipifs inside fixture params\n            params = [pytest.mark.skipif(False, reason='dont skip')('parameter')]\n\n\n            @pytest.fixture(params=params)\n            def parameter(request):\n                return request.param\n\n\n            def test_1(parameter):\n                assert True\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reprec.assertoutcome(skipped=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parameterset_for_parametrize_bad_markname_test_mark_expressions_no_smear._assert_skipped_k_fai": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_parameterset_for_parametrize_bad_markname_test_mark_expressions_no_smear._assert_skipped_k_fai", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 926, "end_line": 963, "span_ids": ["test_mark_expressions_no_smear", "test_parameterset_for_parametrize_bad_markname"], "tokens": 247}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_parameterset_for_parametrize_bad_markname(testdir):\n    with pytest.raises(pytest.UsageError):\n        test_parameterset_for_parametrize_marks(testdir, \"bad\")\n\n\ndef test_mark_expressions_no_smear(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        class BaseTests(object):\n            def test_something(self):\n                pass\n\n        @pytest.mark.FOO\n        class TestFooClass(BaseTests):\n            pass\n\n        @pytest.mark.BAR\n        class TestBarClass(BaseTests):\n            pass\n    \"\"\"\n    )\n\n    reprec = testdir.inline_run(\"-m\", \"FOO\")\n    passed, skipped, failed = reprec.countoutcomes()\n    dlist = reprec.getcalls(\"pytest_deselected\")\n    assert passed == 1\n    assert skipped == failed == 0\n    deselected_tests = dlist[0].items\n    assert len(deselected_tests) == 1\n\n    # todo: fixed\n    # keywords smear - expected behaviour\n    # reprec_keywords = testdir.inline_run(\"-k\", \"FOO\")\n    # passed_k, skipped_k, failed_k = reprec_keywords.countoutcomes()\n    # assert passed_k == 2\n    # assert skipped_k == failed_k == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_addmarker_order_test_markers_from_parametrize.result_assert_outcomes_pa": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_addmarker_order_test_markers_from_parametrize.result_assert_outcomes_pa", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 966, "end_line": 1014, "span_ids": ["test_addmarker_order", "test_markers_from_parametrize"], "tokens": 328}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_addmarker_order():\n    session = mock.Mock()\n    session.own_markers = []\n    session.parent = None\n    session.nodeid = \"\"\n    node = Node.from_parent(session, name=\"Test\")\n    node.add_marker(\"foo\")\n    node.add_marker(\"bar\")\n    node.add_marker(\"baz\", append=False)\n    extracted = [x.name for x in node.iter_markers()]\n    assert extracted == [\"baz\", \"foo\", \"bar\"]\n\n\n@pytest.mark.filterwarnings(\"ignore\")\ndef test_markers_from_parametrize(testdir):\n    \"\"\"#3605\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        first_custom_mark = pytest.mark.custom_marker\n        custom_mark = pytest.mark.custom_mark\n        @pytest.fixture(autouse=True)\n        def trigger(request):\n            custom_mark = list(request.node.iter_markers('custom_mark'))\n            print(\"Custom mark %s\" % custom_mark)\n\n        @custom_mark(\"custom mark non parametrized\")\n        def test_custom_mark_non_parametrized():\n            print(\"Hey from test\")\n\n        @pytest.mark.parametrize(\n            \"obj_type\",\n            [\n                first_custom_mark(\"first custom mark\")(\"template\"),\n                pytest.param( # Think this should be recommended way?\n                    \"disk\",\n                    marks=custom_mark('custom mark1')\n                ),\n                custom_mark(\"custom mark2\")(\"vm\"),  # Tried also this\n            ]\n        )\n        def test_custom_mark_parametrized(obj_type):\n            print(\"obj_type is:\", obj_type)\n    \"\"\"\n    )\n\n    result = testdir.runpytest()\n    result.assert_outcomes(passed=4)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_pytest_param_id_requires_string_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark.py_test_pytest_param_id_requires_string_", "embedding": null, "metadata": {"file_path": "testing/test_mark.py", "file_name": "test_mark.py", "file_type": "text/x-python", "category": "test", "start_line": 1017, "end_line": 1044, "span_ids": ["test_marker_expr_eval_failure_handling", "test_pytest_param_id_allows_none_or_string", "test_pytest_param_id_requires_string"], "tokens": 211}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_pytest_param_id_requires_string():\n    with pytest.raises(TypeError) as excinfo:\n        pytest.param(id=True)\n    (msg,) = excinfo.value.args\n    assert msg == \"Expected id to be a string, got <class 'bool'>: True\"\n\n\n@pytest.mark.parametrize(\"s\", (None, \"hello world\"))\ndef test_pytest_param_id_allows_none_or_string(s):\n    assert pytest.param(id=s)\n\n\n@pytest.mark.parametrize(\"expr\", (\"NOT internal_err\", \"NOT (internal_err)\", \"bogus/\"))\ndef test_marker_expr_eval_failure_handling(testdir, expr):\n    foo = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.mark.internal_err\n        def test_foo():\n            pass\n        \"\"\"\n    )\n    expected = \"ERROR: Wrong expression passed to '-m': {}: *\".format(expr)\n    result = testdir.runpytest(foo, \"-m\", expr)\n    result.stderr.fnmatch_lines([expected])\n    assert result.ret == ExitCode.USAGE_ERROR", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_pytest_test_basic.assert_evaluate_expr_mat": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_pytest_test_basic.assert_evaluate_expr_mat", "embedding": null, "metadata": {"file_path": "testing/test_mark_expression.py", "file_name": "test_mark_expression.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 44, "span_ids": ["imports", "test_basic", "test_empty_is_false"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\nfrom _pytest.mark.expression import evaluate\nfrom _pytest.mark.expression import ParseError\n\n\ndef test_empty_is_false() -> None:\n    assert not evaluate(\"\", lambda ident: False)\n    assert not evaluate(\"\", lambda ident: True)\n    assert not evaluate(\"   \", lambda ident: False)\n    assert not evaluate(\"\\t\", lambda ident: False)\n\n\n@pytest.mark.parametrize(\n    (\"expr\", \"expected\"),\n    (\n        (\"true\", True),\n        (\"true\", True),\n        (\"false\", False),\n        (\"not true\", False),\n        (\"not false\", True),\n        (\"not not true\", True),\n        (\"not not false\", False),\n        (\"true and true\", True),\n        (\"true and false\", False),\n        (\"false and true\", False),\n        (\"true and true and true\", True),\n        (\"true and true and false\", False),\n        (\"true and true and not true\", False),\n        (\"false or false\", False),\n        (\"false or true\", True),\n        (\"true or true\", True),\n        (\"true or true or false\", True),\n        (\"true and true or false\", True),\n        (\"not true or true\", True),\n        (\"(not true) or true\", True),\n        (\"not (true or true)\", False),\n        (\"true and true or false and false\", True),\n        (\"true and (true or false) and false\", False),\n        (\"true and (true or (not (not false))) and false\", False),\n    ),\n)\ndef test_basic(expr: str, expected: bool) -> None:\n    matcher = {\"true\": True, \"false\": False}.__getitem__\n    assert evaluate(expr, matcher) is expected", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_test_syntax_oddeties_test_syntax_errors.assert_excinfo_value_mess": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_test_syntax_oddeties_test_syntax_errors.assert_excinfo_value_mess", "embedding": null, "metadata": {"file_path": "testing/test_mark_expression.py", "file_name": "test_mark_expression.py", "file_type": "text/x-python", "category": "test", "start_line": 47, "end_line": 103, "span_ids": ["test_syntax_errors", "test_syntax_oddeties"], "tokens": 459}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    (\"expr\", \"expected\"),\n    (\n        (\"               true           \", True),\n        (\"               ((((((true))))))           \", True),\n        (\"     (         ((\\t  (((true)))))  \\t   \\t)\", True),\n        (\"(     true     and   (((false))))\", False),\n        (\"not not not not true\", True),\n        (\"not not not not not true\", False),\n    ),\n)\ndef test_syntax_oddeties(expr: str, expected: bool) -> None:\n    matcher = {\"true\": True, \"false\": False}.__getitem__\n    assert evaluate(expr, matcher) is expected\n\n\n@pytest.mark.parametrize(\n    (\"expr\", \"column\", \"message\"),\n    (\n        (\"(\", 2, \"expected not OR left parenthesis OR identifier; got end of input\"),\n        (\" (\", 3, \"expected not OR left parenthesis OR identifier; got end of input\",),\n        (\n            \")\",\n            1,\n            \"expected not OR left parenthesis OR identifier; got right parenthesis\",\n        ),\n        (\n            \") \",\n            1,\n            \"expected not OR left parenthesis OR identifier; got right parenthesis\",\n        ),\n        (\"not\", 4, \"expected not OR left parenthesis OR identifier; got end of input\",),\n        (\n            \"not not\",\n            8,\n            \"expected not OR left parenthesis OR identifier; got end of input\",\n        ),\n        (\n            \"(not)\",\n            5,\n            \"expected not OR left parenthesis OR identifier; got right parenthesis\",\n        ),\n        (\"and\", 1, \"expected not OR left parenthesis OR identifier; got and\"),\n        (\n            \"ident and\",\n            10,\n            \"expected not OR left parenthesis OR identifier; got end of input\",\n        ),\n        (\"ident and or\", 11, \"expected not OR left parenthesis OR identifier; got or\",),\n        (\"ident ident\", 7, \"expected end of input; got identifier\"),\n    ),\n)\ndef test_syntax_errors(expr: str, column: int, message: str) -> None:\n    with pytest.raises(ParseError) as excinfo:\n        evaluate(expr, lambda ident: True)\n    assert excinfo.value.column == column\n    assert excinfo.value.message == message", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_test_valid_idents_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_mark_expression.py_test_valid_idents_", "embedding": null, "metadata": {"file_path": "testing/test_mark_expression.py", "file_name": "test_mark_expression.py", "file_type": "text/x-python", "category": "test", "start_line": 106, "end_line": 163, "span_ids": ["test_invalid_idents", "test_valid_idents"], "tokens": 252}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"ident\",\n    (\n        \".\",\n        \"...\",\n        \":::\",\n        \"a:::c\",\n        \"a+-b\",\n        \"\u05d0\u05d1\u05d2\u05d3\",\n        \"aa\u05d0\u05d1\u05d2\u05d3cc\",\n        \"a[bcd]\",\n        \"1234\",\n        \"1234abcd\",\n        \"1234and\",\n        \"notandor\",\n        \"not_and_or\",\n        \"not[and]or\",\n        \"1234+5678\",\n        \"123.232\",\n        \"True\",\n        \"False\",\n        \"if\",\n        \"else\",\n        \"while\",\n    ),\n)\ndef test_valid_idents(ident: str) -> None:\n    assert evaluate(ident, {ident: True}.__getitem__)\n\n\n@pytest.mark.parametrize(\n    \"ident\",\n    (\n        \"/\",\n        \"\\\\\",\n        \"^\",\n        \"*\",\n        \"=\",\n        \"&\",\n        \"%\",\n        \"$\",\n        \"#\",\n        \"@\",\n        \"!\",\n        \"~\",\n        \"{\",\n        \"}\",\n        '\"',\n        \"'\",\n        \"|\",\n        \";\",\n        \"\u2190\",\n    ),\n)\ndef test_invalid_idents(ident: str) -> None:\n    with pytest.raises(ParseError):\n        evaluate(ident, lambda ident: True)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_meta.py___": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_meta.py___", "embedding": null, "metadata": {"file_path": "testing/test_meta.py", "file_name": "test_meta.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 36, "span_ids": ["_modules", "docstring", "test_no_warnings"], "tokens": 254}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "\"\"\"\nTest importing of all internal packages and modules.\n\nThis ensures all internal packages can be imported without needing the pytest\nnamespace being set, which is critical for the initialization of xdist.\n\"\"\"\nimport pkgutil\nimport subprocess\nimport sys\nfrom typing import List\n\nimport _pytest\nimport pytest\n\n\ndef _modules() -> List[str]:\n    pytest_pkg = _pytest.__path__  # type: str  # type: ignore\n    return sorted(\n        n\n        for _, n, _ in pkgutil.walk_packages(pytest_pkg, prefix=_pytest.__name__ + \".\")\n    )\n\n\n@pytest.mark.slow\n@pytest.mark.parametrize(\"module\", _modules())\ndef test_no_warnings(module: str) -> None:\n    # fmt: off\n    subprocess.check_call((\n        sys.executable,\n        \"-W\", \"error\",\n        # https://github.com/pytest-dev/pytest/issues/5901\n        \"-W\", \"ignore:The usage of `cmp` is deprecated and will be removed on or after 2021-06-01.  Please use `eq` and `order` instead.:DeprecationWarning\",  # noqa: E501\n        \"-c\", \"__import__({!r})\".format(module),\n    ))\n    # fmt: on", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_setup_teardown_linking_issue265_test_skip_test_with_unicode": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_setup_teardown_linking_issue265_test_skip_test_with_unicode", "embedding": null, "metadata": {"file_path": "testing/test_nose.py", "file_name": "test_nose.py", "file_type": "text/x-python", "category": "test", "start_line": 255, "end_line": 377, "span_ids": ["test_SkipTest_during_collection", "test_SkipTest_in_test", "test_istest_class_decorator", "test_istest_function_decorator", "test_nottest_class_decorator", "test_nottest_function_decorator", "test_setup_teardown_linking_issue265", "test_skip_test_with_unicode"], "tokens": 694}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_setup_teardown_linking_issue265(testdir):\n    # we accidentally didn't integrate nose setupstate with normal setupstate\n    # this test ensures that won't happen again\n    testdir.makepyfile(\n        '''\n        import pytest\n\n        class TestGeneric(object):\n            def test_nothing(self):\n                \"\"\"Tests the API of the implementation (for generic and specialized).\"\"\"\n\n        @pytest.mark.skipif(\"True\", reason=\n                    \"Skip tests to check if teardown is skipped as well.\")\n        class TestSkipTeardown(TestGeneric):\n\n            def setup(self):\n                \"\"\"Sets up my specialized implementation for $COOL_PLATFORM.\"\"\"\n                raise Exception(\"should not call setup for skipped tests\")\n\n            def teardown(self):\n                \"\"\"Undoes the setup.\"\"\"\n                raise Exception(\"should not call teardown for skipped tests\")\n        '''\n    )\n    reprec = testdir.runpytest()\n    reprec.assert_outcomes(passed=1, skipped=1)\n\n\ndef test_SkipTest_during_collection(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import nose\n        raise nose.SkipTest(\"during collection\")\n        def test_failing():\n            assert False\n        \"\"\"\n    )\n    result = testdir.runpytest(p)\n    result.assert_outcomes(skipped=1)\n\n\ndef test_SkipTest_in_test(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import nose\n\n        def test_skipping():\n            raise nose.SkipTest(\"in test\")\n        \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(skipped=1)\n\n\ndef test_istest_function_decorator(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import nose.tools\n        @nose.tools.istest\n        def not_test_prefix():\n            pass\n        \"\"\"\n    )\n    result = testdir.runpytest(p)\n    result.assert_outcomes(passed=1)\n\n\ndef test_nottest_function_decorator(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import nose.tools\n        @nose.tools.nottest\n        def test_prefix():\n            pass\n        \"\"\"\n    )\n    reprec = testdir.inline_run()\n    assert not reprec.getfailedcollections()\n    calls = reprec.getreports(\"pytest_runtest_logreport\")\n    assert not calls\n\n\ndef test_istest_class_decorator(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import nose.tools\n        @nose.tools.istest\n        class NotTestPrefix(object):\n            def test_method(self):\n                pass\n        \"\"\"\n    )\n    result = testdir.runpytest(p)\n    result.assert_outcomes(passed=1)\n\n\ndef test_nottest_class_decorator(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import nose.tools\n        @nose.tools.nottest\n        class TestPrefix(object):\n            def test_method(self):\n                pass\n        \"\"\"\n    )\n    reprec = testdir.inline_run()\n    assert not reprec.getfailedcollections()\n    calls = reprec.getreports(\"pytest_runtest_logreport\")\n    assert not calls\n\n\ndef test_skip_test_with_unicode(testdir):\n    testdir.makepyfile(\n        \"\"\"\\\n        import unittest\n        class TestClass():\n            def test_io(self):\n                raise unittest.SkipTest('\ud83d\ude0a')\n        \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"* 1 skipped *\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_raises_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_nose.py_test_raises_", "embedding": null, "metadata": {"file_path": "testing/test_nose.py", "file_name": "test_nose.py", "file_type": "text/x-python", "category": "test", "start_line": 380, "end_line": 425, "span_ids": ["test_raises"], "tokens": 286}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_raises(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        from nose.tools import raises\n\n        @raises(RuntimeError)\n        def test_raises_runtimeerror():\n            raise RuntimeError\n\n        @raises(Exception)\n        def test_raises_baseexception_not_caught():\n            raise BaseException\n\n        @raises(BaseException)\n        def test_raises_baseexception_caught():\n            raise BaseException\n        \"\"\"\n    )\n    result = testdir.runpytest(\"-vv\")\n    result.stdout.fnmatch_lines(\n        [\n            \"test_raises.py::test_raises_runtimeerror PASSED*\",\n            \"test_raises.py::test_raises_baseexception_not_caught FAILED*\",\n            \"test_raises.py::test_raises_baseexception_caught PASSED*\",\n            \"*= FAILURES =*\",\n            \"*_ test_raises_baseexception_not_caught _*\",\n            \"\",\n            \"arg = (), kw = {}\",\n            \"\",\n            \"    def newfunc(*arg, **kw):\",\n            \"        try:\",\n            \">           func(*arg, **kw)\",\n            \"\",\n            \"*/nose/*: \",\n            \"_ _ *\",\n            \"\",\n            \"    @raises(Exception)\",\n            \"    def test_raises_baseexception_not_caught():\",\n            \">       raise BaseException\",\n            \"E       BaseException\",\n            \"\",\n            \"test_raises.py:9: BaseException\",\n            \"* 1 failed, 2 passed *\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginInteractions.test_hook_tracing_TestPytestPluginInteractions.test_hook_tracing.try_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginInteractions.test_hook_tracing_TestPytestPluginInteractions.test_hook_tracing.try_", "embedding": null, "metadata": {"file_path": "testing/test_pluginmanager.py", "file_name": "test_pluginmanager.py", "file_type": "text/x-python", "category": "test", "start_line": 89, "end_line": 120, "span_ids": ["TestPytestPluginInteractions.test_hook_tracing"], "tokens": 204}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPytestPluginInteractions:\n\n    def test_hook_tracing(self, _config_for_test):\n        pytestpm = _config_for_test.pluginmanager  # fully initialized with plugins\n        saveindent = []\n\n        class api1:\n            def pytest_plugin_registered(self):\n                saveindent.append(pytestpm.trace.root.indent)\n\n        class api2:\n            def pytest_plugin_registered(self):\n                saveindent.append(pytestpm.trace.root.indent)\n                raise ValueError()\n\n        values = []\n        pytestpm.trace.root.setwriter(values.append)\n        undo = pytestpm.enable_tracing()\n        try:\n            indent = pytestpm.trace.root.indent\n            p = api1()\n            pytestpm.register(p)\n            assert pytestpm.trace.root.indent == indent\n            assert len(values) >= 2\n            assert \"pytest_plugin_registered\" in values[0]\n            assert \"finish\" in values[1]\n\n            values[:] = []\n            with pytest.raises(ValueError):\n                pytestpm.register(api2())\n            assert pytestpm.trace.root.indent == indent\n            assert saveindent[0] > indent\n        finally:\n            undo()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginInteractions.test_hook_proxy_test_importplugin_error_message": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pluginmanager.py_TestPytestPluginInteractions.test_hook_proxy_test_importplugin_error_message", "embedding": null, "metadata": {"file_path": "testing/test_pluginmanager.py", "file_name": "test_pluginmanager.py", "file_type": "text/x-python", "category": "test", "start_line": 122, "end_line": 194, "span_ids": ["TestPytestPluginInteractions.test_hook_proxy", "TestPytestPluginInteractions.test_hook_with_addoption", "test_default_markers", "test_importplugin_error_message"], "tokens": 583}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestPytestPluginInteractions:\n\n    def test_hook_proxy(self, testdir):\n        \"\"\"Test the gethookproxy function(#2016)\"\"\"\n        config = testdir.parseconfig()\n        session = Session.from_config(config)\n        testdir.makepyfile(**{\"tests/conftest.py\": \"\", \"tests/subdir/conftest.py\": \"\"})\n\n        conftest1 = testdir.tmpdir.join(\"tests/conftest.py\")\n        conftest2 = testdir.tmpdir.join(\"tests/subdir/conftest.py\")\n\n        config.pluginmanager._importconftest(conftest1)\n        ihook_a = session.gethookproxy(testdir.tmpdir.join(\"tests\"))\n        assert ihook_a is not None\n        config.pluginmanager._importconftest(conftest2)\n        ihook_b = session.gethookproxy(testdir.tmpdir.join(\"tests\"))\n        assert ihook_a is not ihook_b\n\n    def test_hook_with_addoption(self, testdir):\n        \"\"\"Test that hooks can be used in a call to pytest_addoption\"\"\"\n        testdir.makepyfile(\n            newhooks=\"\"\"\n            import pytest\n            @pytest.hookspec(firstresult=True)\n            def pytest_default_value():\n                pass\n        \"\"\"\n        )\n        testdir.makepyfile(\n            myplugin=\"\"\"\n            import newhooks\n            def pytest_addhooks(pluginmanager):\n                pluginmanager.add_hookspecs(newhooks)\n            def pytest_addoption(parser, pluginmanager):\n                default_value = pluginmanager.hook.pytest_default_value()\n                parser.addoption(\"--config\", help=\"Config, defaults to %(default)s\", default=default_value)\n        \"\"\"\n        )\n        testdir.makeconftest(\n            \"\"\"\n            pytest_plugins=(\"myplugin\",)\n            def pytest_default_value():\n                return \"default_value\"\n        \"\"\"\n        )\n        res = testdir.runpytest(\"--help\")\n        res.stdout.fnmatch_lines([\"*--config=CONFIG*default_value*\"])\n\n\ndef test_default_markers(testdir):\n    result = testdir.runpytest(\"--markers\")\n    result.stdout.fnmatch_lines([\"*tryfirst*first*\", \"*trylast*last*\"])\n\n\ndef test_importplugin_error_message(testdir, pytestpm):\n    \"\"\"Don't hide import errors when importing plugins and provide\n    an easy to debug message.\n\n    See #375 and #1998.\n    \"\"\"\n    testdir.syspathinsert(testdir.tmpdir)\n    testdir.makepyfile(\n        qwe=\"\"\"\\\n        def test_traceback():\n            raise ImportError('Not possible to import: \u263a')\n        test_traceback()\n        \"\"\"\n    )\n    with pytest.raises(ImportError) as excinfo:\n        pytestpm.import_plugin(\"qwe\")\n\n    assert str(excinfo.value).endswith(\n        'Error importing plugin \"qwe\": Not possible to import: \u263a'\n    )\n    assert \"in test_traceback\" in str(excinfo.traceback[-1])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_parseconfig_make_holder": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_parseconfig_make_holder", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 74, "end_line": 184, "span_ids": ["make_holder", "test_parseconfig", "test_runresult_assertion_on_xfail", "test_runresult_assertion_on_xpassed", "test_testdir_runs_with_plugin", "test_testdir_with_doctest", "test_xpassed_with_strict_is_considered_a_failure"], "tokens": 626}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_parseconfig(testdir) -> None:\n    config1 = testdir.parseconfig()\n    config2 = testdir.parseconfig()\n    assert config2 is not config1\n\n\ndef test_testdir_runs_with_plugin(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        pytest_plugins = \"pytester\"\n        def test_hello(testdir):\n            assert 1\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(passed=1)\n\n\ndef test_testdir_with_doctest(testdir):\n    \"\"\"Check that testdir can be used within doctests.\n\n    It used to use `request.function`, which is `None` with doctests.\"\"\"\n    testdir.makepyfile(\n        **{\n            \"sub/t-doctest.py\": \"\"\"\n        '''\n        >>> import os\n        >>> testdir = getfixture(\"testdir\")\n        >>> str(testdir.makepyfile(\"content\")).replace(os.sep, '/')\n        '.../basetemp/sub.t-doctest0/sub.py'\n        '''\n    \"\"\",\n            \"sub/__init__.py\": \"\",\n        }\n    )\n    result = testdir.runpytest(\n        \"-p\", \"pytester\", \"--doctest-modules\", \"sub/t-doctest.py\"\n    )\n    assert result.ret == 0\n\n\ndef test_runresult_assertion_on_xfail(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        pytest_plugins = \"pytester\"\n\n        @pytest.mark.xfail\n        def test_potato():\n            assert False\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(xfailed=1)\n    assert result.ret == 0\n\n\ndef test_runresult_assertion_on_xpassed(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        pytest_plugins = \"pytester\"\n\n        @pytest.mark.xfail\n        def test_potato():\n            assert True\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(xpassed=1)\n    assert result.ret == 0\n\n\ndef test_xpassed_with_strict_is_considered_a_failure(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        pytest_plugins = \"pytester\"\n\n        @pytest.mark.xfail(strict=True)\n        def test_potato():\n            assert True\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.assert_outcomes(failed=1)\n    assert result.ret != 0\n\n\ndef make_holder():\n    class apiclass:\n        def pytest_xyz(self, arg):\n            \"x\"\n\n        def pytest_xyz_noarg(self):\n            \"x\"\n\n    apimod = type(os)(\"api\")\n\n    def pytest_xyz(arg):\n        \"x\"\n\n    def pytest_xyz_noarg():\n        \"x\"\n\n    apimod.pytest_xyz = pytest_xyz  # type: ignore\n    apimod.pytest_xyz_noarg = pytest_xyz_noarg  # type: ignore\n    return apiclass, apimod", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_hookrecorder_basic_test_makepyfile_utf8": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_hookrecorder_basic_test_makepyfile_utf8", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 187, "end_line": 213, "span_ids": ["test_hookrecorder_basic", "test_makepyfile_unicode", "test_makepyfile_utf8"], "tokens": 242}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"holder\", make_holder())\ndef test_hookrecorder_basic(holder) -> None:\n    pm = PytestPluginManager()\n    pm.add_hookspecs(holder)\n    rec = HookRecorder(pm)\n    pm.hook.pytest_xyz(arg=123)\n    call = rec.popcall(\"pytest_xyz\")\n    assert call.arg == 123\n    assert call._name == \"pytest_xyz\"\n    pytest.raises(pytest.fail.Exception, rec.popcall, \"abc\")\n    pm.hook.pytest_xyz_noarg()\n    call = rec.popcall(\"pytest_xyz_noarg\")\n    assert call._name == \"pytest_xyz_noarg\"\n\n\ndef test_makepyfile_unicode(testdir) -> None:\n    testdir.makepyfile(chr(0xFFFD))\n\n\ndef test_makepyfile_utf8(testdir) -> None:\n    \"\"\"Ensure makepyfile accepts utf-8 bytes as input (#2738)\"\"\"\n    utf8_contents = \"\"\"\n        def setup_function(function):\n            mixed_encoding = 'S\u00e3o Paulo'\n    \"\"\".encode()\n    p = testdir.makepyfile(utf8_contents)\n    assert \"mixed_encoding = 'S\u00e3o Paulo'\".encode() in p.read(\"rb\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_testdir_subprocess_test_testdir_run_timeout_expires": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_testdir_subprocess_test_testdir_run_timeout_expires", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 419, "end_line": 478, "span_ids": ["test_testdir_run_no_timeout", "test_testdir_run_timeout_expires", "test_testdir_run_with_timeout", "test_testdir_subprocess", "test_testdir_subprocess_via_runpytest_arg", "test_unicode_args"], "tokens": 415}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_testdir_subprocess(testdir) -> None:\n    testfile = testdir.makepyfile(\"def test_one(): pass\")\n    assert testdir.runpytest_subprocess(testfile).ret == 0\n\n\ndef test_testdir_subprocess_via_runpytest_arg(testdir) -> None:\n    testfile = testdir.makepyfile(\n        \"\"\"\n        def test_testdir_subprocess(testdir):\n            import os\n            testfile = testdir.makepyfile(\n                \\\"\"\"\n                import os\n                def test_one():\n                    assert {} != os.getpid()\n                \\\"\"\".format(os.getpid())\n            )\n            assert testdir.runpytest(testfile).ret == 0\n        \"\"\"\n    )\n    result = testdir.runpytest_subprocess(\n        \"-p\", \"pytester\", \"--runpytest\", \"subprocess\", testfile\n    )\n    assert result.ret == 0\n\n\ndef test_unicode_args(testdir) -> None:\n    result = testdir.runpytest(\"-k\", \"\ud83d\udca9\")\n    assert result.ret == ExitCode.NO_TESTS_COLLECTED\n\n\ndef test_testdir_run_no_timeout(testdir) -> None:\n    testfile = testdir.makepyfile(\"def test_no_timeout(): pass\")\n    assert testdir.runpytest_subprocess(testfile).ret == ExitCode.OK\n\n\ndef test_testdir_run_with_timeout(testdir) -> None:\n    testfile = testdir.makepyfile(\"def test_no_timeout(): pass\")\n\n    timeout = 120\n\n    start = time.time()\n    result = testdir.runpytest_subprocess(testfile, timeout=timeout)\n    end = time.time()\n    duration = end - start\n\n    assert result.ret == ExitCode.OK\n    assert duration < timeout\n\n\ndef test_testdir_run_timeout_expires(testdir) -> None:\n    testfile = testdir.makepyfile(\n        \"\"\"\n        import time\n\n        def test_timeout():\n            time.sleep(10)\"\"\"\n    )\n    with pytest.raises(testdir.TimeoutExpired):\n        testdir.runpytest_subprocess(testfile, timeout=1)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_with_nonlist_test_linematcher_with_nonlist": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_with_nonlist_test_linematcher_with_nonlist", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 481, "end_line": 502, "span_ids": ["test_linematcher_with_nonlist"], "tokens": 341}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_linematcher_with_nonlist() -> None:\n    \"\"\"Test LineMatcher with regard to passing in a set (accidentally).\"\"\"\n    from _pytest._code.source import Source\n\n    lm = LineMatcher([])\n    with pytest.raises(TypeError, match=\"invalid type for lines2: set\"):\n        lm.fnmatch_lines(set())  # type: ignore[arg-type]  # noqa: F821\n    with pytest.raises(TypeError, match=\"invalid type for lines2: dict\"):\n        lm.fnmatch_lines({})  # type: ignore[arg-type]  # noqa: F821\n    with pytest.raises(TypeError, match=\"invalid type for lines2: set\"):\n        lm.re_match_lines(set())  # type: ignore[arg-type]  # noqa: F821\n    with pytest.raises(TypeError, match=\"invalid type for lines2: dict\"):\n        lm.re_match_lines({})  # type: ignore[arg-type]  # noqa: F821\n    with pytest.raises(TypeError, match=\"invalid type for lines2: Source\"):\n        lm.fnmatch_lines(Source())  # type: ignore[arg-type]  # noqa: F821\n    lm.fnmatch_lines([])\n    lm.fnmatch_lines(())\n    lm.fnmatch_lines(\"\")\n    assert lm._getlines({}) == {}  # type: ignore[arg-type,comparison-overlap]  # noqa: F821\n    assert lm._getlines(set()) == set()  # type: ignore[arg-type,comparison-overlap]  # noqa: F821\n    assert lm._getlines(Source()) == []\n    assert lm._getlines(Source(\"pass\\npass\")) == [\"pass\", \"pass\"]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_match_failure_test_linematcher_consecutive": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_match_failure_test_linematcher_consecutive", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 505, "end_line": 550, "span_ids": ["test_linematcher_consecutive", "test_linematcher_match_failure"], "tokens": 397}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_linematcher_match_failure() -> None:\n    lm = LineMatcher([\"foo\", \"foo\", \"bar\"])\n    with pytest.raises(pytest.fail.Exception) as e:\n        lm.fnmatch_lines([\"foo\", \"f*\", \"baz\"])\n    assert e.value.msg is not None\n    assert e.value.msg.splitlines() == [\n        \"exact match: 'foo'\",\n        \"fnmatch: 'f*'\",\n        \"   with: 'foo'\",\n        \"nomatch: 'baz'\",\n        \"    and: 'bar'\",\n        \"remains unmatched: 'baz'\",\n    ]\n\n    lm = LineMatcher([\"foo\", \"foo\", \"bar\"])\n    with pytest.raises(pytest.fail.Exception) as e:\n        lm.re_match_lines([\"foo\", \"^f.*\", \"baz\"])\n    assert e.value.msg is not None\n    assert e.value.msg.splitlines() == [\n        \"exact match: 'foo'\",\n        \"re.match: '^f.*'\",\n        \"    with: 'foo'\",\n        \" nomatch: 'baz'\",\n        \"     and: 'bar'\",\n        \"remains unmatched: 'baz'\",\n    ]\n\n\ndef test_linematcher_consecutive():\n    lm = LineMatcher([\"1\", \"\", \"2\"])\n    with pytest.raises(pytest.fail.Exception) as excinfo:\n        lm.fnmatch_lines([\"1\", \"2\"], consecutive=True)\n    assert str(excinfo.value).splitlines() == [\n        \"exact match: '1'\",\n        \"no consecutive match: '2'\",\n        \"   with: ''\",\n    ]\n\n    lm.re_match_lines([\"1\", r\"\\d?\", \"2\"], consecutive=True)\n    with pytest.raises(pytest.fail.Exception) as excinfo:\n        lm.re_match_lines([\"1\", r\"\\d\", \"2\"], consecutive=True)\n    assert str(excinfo.value).splitlines() == [\n        \"exact match: '1'\",\n        r\"no consecutive match: '\\\\d'\",\n        \"    with: ''\",\n    ]", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_no_matching_test_linematcher_no_matching._bad_pattern_does_not_ma": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_no_matching_test_linematcher_no_matching._bad_pattern_does_not_ma", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 553, "end_line": 599, "span_ids": ["test_linematcher_no_matching"], "tokens": 395}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"function\", [\"no_fnmatch_line\", \"no_re_match_line\"])\ndef test_linematcher_no_matching(function) -> None:\n    if function == \"no_fnmatch_line\":\n        good_pattern = \"*.py OK*\"\n        bad_pattern = \"*X.py OK*\"\n    else:\n        assert function == \"no_re_match_line\"\n        good_pattern = r\".*py OK\"\n        bad_pattern = r\".*Xpy OK\"\n\n    lm = LineMatcher(\n        [\n            \"cachedir: .pytest_cache\",\n            \"collecting ... collected 1 item\",\n            \"\",\n            \"show_fixtures_per_test.py OK\",\n            \"=== elapsed 1s ===\",\n        ]\n    )\n\n    # check the function twice to ensure we don't accumulate the internal buffer\n    for i in range(2):\n        with pytest.raises(pytest.fail.Exception) as e:\n            func = getattr(lm, function)\n            func(good_pattern)\n        obtained = str(e.value).splitlines()\n        if function == \"no_fnmatch_line\":\n            assert obtained == [\n                \"nomatch: '{}'\".format(good_pattern),\n                \"    and: 'cachedir: .pytest_cache'\",\n                \"    and: 'collecting ... collected 1 item'\",\n                \"    and: ''\",\n                \"fnmatch: '{}'\".format(good_pattern),\n                \"   with: 'show_fixtures_per_test.py OK'\",\n            ]\n        else:\n            assert obtained == [\n                \" nomatch: '{}'\".format(good_pattern),\n                \"     and: 'cachedir: .pytest_cache'\",\n                \"     and: 'collecting ... collected 1 item'\",\n                \"     and: ''\",\n                \"re.match: '{}'\".format(good_pattern),\n                \"    with: 'show_fixtures_per_test.py OK'\",\n            ]\n\n    func = getattr(lm, function)\n    func(bad_pattern)  # bad pattern does not match any line: passes", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_no_matching_after_match_test_popen_stdin_bytes": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_linematcher_no_matching_after_match_test_popen_stdin_bytes", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 602, "end_line": 675, "span_ids": ["test_linematcher_no_matching_after_match", "test_popen_stdin_bytes", "test_popen_stdin_pipe", "test_pytester_addopts_before_testdir", "test_run_stdin"], "tokens": 607}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_linematcher_no_matching_after_match() -> None:\n    lm = LineMatcher([\"1\", \"2\", \"3\"])\n    lm.fnmatch_lines([\"1\", \"3\"])\n    with pytest.raises(pytest.fail.Exception) as e:\n        lm.no_fnmatch_line(\"*\")\n    assert str(e.value).splitlines() == [\"fnmatch: '*'\", \"   with: '1'\"]\n\n\ndef test_pytester_addopts_before_testdir(request, monkeypatch) -> None:\n    orig = os.environ.get(\"PYTEST_ADDOPTS\", None)\n    monkeypatch.setenv(\"PYTEST_ADDOPTS\", \"--orig-unused\")\n    testdir = request.getfixturevalue(\"testdir\")\n    assert \"PYTEST_ADDOPTS\" not in os.environ\n    testdir.finalize()\n    assert os.environ.get(\"PYTEST_ADDOPTS\") == \"--orig-unused\"\n    monkeypatch.undo()\n    assert os.environ.get(\"PYTEST_ADDOPTS\") == orig\n\n\ndef test_run_stdin(testdir) -> None:\n    with pytest.raises(testdir.TimeoutExpired):\n        testdir.run(\n            sys.executable,\n            \"-c\",\n            \"import sys, time; time.sleep(1); print(sys.stdin.read())\",\n            stdin=subprocess.PIPE,\n            timeout=0.1,\n        )\n\n    with pytest.raises(testdir.TimeoutExpired):\n        result = testdir.run(\n            sys.executable,\n            \"-c\",\n            \"import sys, time; time.sleep(1); print(sys.stdin.read())\",\n            stdin=b\"input\\n2ndline\",\n            timeout=0.1,\n        )\n\n    result = testdir.run(\n        sys.executable,\n        \"-c\",\n        \"import sys; print(sys.stdin.read())\",\n        stdin=b\"input\\n2ndline\",\n    )\n    assert result.stdout.lines == [\"input\", \"2ndline\"]\n    assert result.stderr.str() == \"\"\n    assert result.ret == 0\n\n\ndef test_popen_stdin_pipe(testdir) -> None:\n    proc = testdir.popen(\n        [sys.executable, \"-c\", \"import sys; print(sys.stdin.read())\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        stdin=subprocess.PIPE,\n    )\n    stdin = b\"input\\n2ndline\"\n    stdout, stderr = proc.communicate(input=stdin)\n    assert stdout.decode(\"utf8\").splitlines() == [\"input\", \"2ndline\"]\n    assert stderr == b\"\"\n    assert proc.returncode == 0\n\n\ndef test_popen_stdin_bytes(testdir) -> None:\n    proc = testdir.popen(\n        [sys.executable, \"-c\", \"import sys; print(sys.stdin.read())\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        stdin=b\"input\\n2ndline\",\n    )\n    stdout, stderr = proc.communicate()\n    assert stdout.decode(\"utf8\").splitlines() == [\"input\", \"2ndline\"]\n    assert stderr == b\"\"\n    assert proc.returncode == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_popen_default_stdin_stderr_and_stdin_None_test_popen_default_stdin_stderr_and_stdin_None.assert_result_ret_0": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_popen_default_stdin_stderr_and_stdin_None_test_popen_default_stdin_stderr_and_stdin_None.assert_result_ret_0", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 678, "end_line": 705, "span_ids": ["test_popen_default_stdin_stderr_and_stdin_None"], "tokens": 228}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_popen_default_stdin_stderr_and_stdin_None(testdir) -> None:\n    # stdout, stderr default to pipes,\n    # stdin can be None to not close the pipe, avoiding\n    # \"ValueError: flush of closed file\" with `communicate()`.\n    #\n    # Wraps the test to make it not hang when run with \"-s\".\n    p1 = testdir.makepyfile(\n        '''\n        import sys\n\n        def test_inner(testdir):\n            p1 = testdir.makepyfile(\n                \"\"\"\n                import sys\n                print(sys.stdin.read())  # empty\n                print('stdout')\n                sys.stderr.write('stderr')\n                \"\"\"\n            )\n            proc = testdir.popen([sys.executable, str(p1)], stdin=None)\n            stdout, stderr = proc.communicate(b\"ignored\")\n            assert stdout.splitlines() == [b\"\", b\"stdout\"]\n            assert stderr.splitlines() == [b\"stderr\"]\n            assert proc.returncode == 0\n        '''\n    )\n    result = testdir.runpytest(\"-p\", \"pytester\", str(p1))\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_spawn_uses_tmphome_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_pytester.py_test_spawn_uses_tmphome_", "embedding": null, "metadata": {"file_path": "testing/test_pytester.py", "file_name": "test_pytester.py", "file_type": "text/x-python", "category": "test", "start_line": 708, "end_line": 779, "span_ids": ["test_makefile_joins_absolute_path", "test_run_result_repr", "test_spawn_uses_tmphome", "test_testdir_outcomes_with_multiple_errors"], "tokens": 530}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_spawn_uses_tmphome(testdir) -> None:\n    tmphome = str(testdir.tmpdir)\n    assert os.environ.get(\"HOME\") == tmphome\n\n    testdir.monkeypatch.setenv(\"CUSTOMENV\", \"42\")\n\n    p1 = testdir.makepyfile(\n        \"\"\"\n        import os\n\n        def test():\n            assert os.environ[\"HOME\"] == {tmphome!r}\n            assert os.environ[\"CUSTOMENV\"] == \"42\"\n        \"\"\".format(\n            tmphome=tmphome\n        )\n    )\n    child = testdir.spawn_pytest(str(p1))\n    out = child.read()\n    assert child.wait() == 0, out.decode(\"utf8\")\n\n\ndef test_run_result_repr() -> None:\n    outlines = [\"some\", \"normal\", \"output\"]\n    errlines = [\"some\", \"nasty\", \"errors\", \"happened\"]\n\n    # known exit code\n    r = pytester.RunResult(1, outlines, errlines, duration=0.5)\n    assert (\n        repr(r) == \"<RunResult ret=ExitCode.TESTS_FAILED len(stdout.lines)=3\"\n        \" len(stderr.lines)=4 duration=0.50s>\"\n    )\n\n    # unknown exit code: just the number\n    r = pytester.RunResult(99, outlines, errlines, duration=0.5)\n    assert (\n        repr(r) == \"<RunResult ret=99 len(stdout.lines)=3\"\n        \" len(stderr.lines)=4 duration=0.50s>\"\n    )\n\n\ndef test_testdir_outcomes_with_multiple_errors(testdir):\n    p1 = testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture\n        def bad_fixture():\n            raise Exception(\"bad\")\n\n        def test_error1(bad_fixture):\n            pass\n\n        def test_error2(bad_fixture):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(str(p1))\n    result.assert_outcomes(error=2)\n\n    assert result.parseoutcomes() == {\"error\": 2}\n\n\ndef test_makefile_joins_absolute_path(testdir: Testdir) -> None:\n    absfile = testdir.tmpdir / \"absfile\"\n    if sys.platform == \"win32\":\n        with pytest.raises(OSError):\n            testdir.makepyfile(**{str(absfile): \"\"})\n    else:\n        p1 = testdir.makepyfile(**{str(absfile): \"\"})\n        assert str(p1) == (testdir.tmpdir / absfile) + \".py\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_sys_TestReportSerialization.test_xdist_longrepr_to_str_issue_241": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_sys_TestReportSerialization.test_xdist_longrepr_to_str_issue_241", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 33, "span_ids": ["TestReportSerialization", "TestReportSerialization.test_xdist_longrepr_to_str_issue_241", "imports"], "tokens": 246}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import sys\n\nimport pytest\nfrom _pytest._code.code import ExceptionChainRepr\nfrom _pytest.pathlib import Path\nfrom _pytest.reports import CollectReport\nfrom _pytest.reports import TestReport\n\n\nclass TestReportSerialization:\n    def test_xdist_longrepr_to_str_issue_241(self, testdir):\n        \"\"\"\n        Regarding issue pytest-xdist#241\n\n        This test came originally from test_remote.py in xdist (ca03269).\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def test_a(): assert False\n            def test_b(): pass\n        \"\"\"\n        )\n        reprec = testdir.inline_run()\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n        assert len(reports) == 6\n        test_a_call = reports[1]\n        assert test_a_call.when == \"call\"\n        assert test_a_call.outcome == \"failed\"\n        assert test_a_call._to_json()[\"longrepr\"][\"reprtraceback\"][\"style\"] == \"long\"\n        test_b_call = reports[4]\n        assert test_b_call.when == \"call\"\n        assert test_b_call.outcome == \"passed\"\n        assert test_b_call._to_json()[\"longrepr\"] is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_chained_exceptions_no_reprcrash_TestReportSerialization.test_chained_exceptions_no_reprcrash.loaded_report_longrepr_to": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_reports.py_TestReportSerialization.test_chained_exceptions_no_reprcrash_TestReportSerialization.test_chained_exceptions_no_reprcrash.loaded_report_longrepr_to", "embedding": null, "metadata": {"file_path": "testing/test_reports.py", "file_name": "test_reports.py", "file_type": "text/x-python", "category": "test", "start_line": 319, "end_line": 397, "span_ids": ["TestReportSerialization.test_chained_exceptions_no_reprcrash"], "tokens": 590}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestReportSerialization:\n\n    def test_chained_exceptions_no_reprcrash(self, testdir, tw_mock):\n        \"\"\"Regression test for tracebacks without a reprcrash (#5971)\n\n        This happens notably on exceptions raised by multiprocess.pool: the exception transfer\n        from subprocess to main process creates an artificial exception, which ExceptionInfo\n        can't obtain the ReprFileLocation from.\n        \"\"\"\n        # somehow in Python 3.5 on Windows this test fails with:\n        #   File \"c:\\...\\3.5.4\\x64\\Lib\\multiprocessing\\connection.py\", line 302, in _recv_bytes\n        #     overlapped=True)\n        # OSError: [WinError 6] The handle is invalid\n        #\n        # so in this platform we opted to use a mock traceback which is identical to the\n        # one produced by the multiprocessing module\n        if sys.version_info[:2] <= (3, 5) and sys.platform.startswith(\"win\"):\n            testdir.makepyfile(\n                \"\"\"\n                # equivalent of multiprocessing.pool.RemoteTraceback\n                class RemoteTraceback(Exception):\n                    def __init__(self, tb):\n                        self.tb = tb\n                    def __str__(self):\n                        return self.tb\n                def test_a():\n                    try:\n                        raise ValueError('value error')\n                    except ValueError as e:\n                        # equivalent to how multiprocessing.pool.rebuild_exc does it\n                        e.__cause__ = RemoteTraceback('runtime error')\n                        raise e\n            \"\"\"\n            )\n        else:\n            testdir.makepyfile(\n                \"\"\"\n                from concurrent.futures import ProcessPoolExecutor\n\n                def func():\n                    raise ValueError('value error')\n\n                def test_a():\n                    with ProcessPoolExecutor() as p:\n                        p.submit(func).result()\n            \"\"\"\n            )\n\n        testdir.syspathinsert()\n        reprec = testdir.inline_run()\n\n        reports = reprec.getreports(\"pytest_runtest_logreport\")\n\n        def check_longrepr(longrepr):\n            assert isinstance(longrepr, ExceptionChainRepr)\n            assert len(longrepr.chain) == 2\n            entry1, entry2 = longrepr.chain\n            tb1, fileloc1, desc1 = entry1\n            tb2, fileloc2, desc2 = entry2\n\n            assert \"RemoteTraceback\" in str(tb1)\n            assert \"ValueError: value error\" in str(tb2)\n\n            assert fileloc1 is None\n            assert fileloc2.message == \"ValueError: value error\"\n\n        # 3 reports: setup/call/teardown: get the call report\n        assert len(reports) == 3\n        report = reports[1]\n\n        assert report.failed\n        check_longrepr(report.longrepr)\n\n        data = report._to_json()\n        loaded_report = TestReport._from_json(data)\n\n        assert loaded_report.failed\n        check_longrepr(loaded_report.longrepr)\n\n        # for same reasons as previous test, ensure we don't blow up here\n        loaded_report.longrepr.toterminal(tw_mock)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_test_generic_test_no_resultlog_on_slaves": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_test_generic_test_no_resultlog_on_slaves", "embedding": null, "metadata": {"file_path": "testing/test_resultlog.py", "file_name": "test_resultlog.py", "file_type": "text/x-python", "category": "test", "start_line": 133, "end_line": 193, "span_ids": ["test_generic", "test_makedir_for_resultlog", "test_no_resultlog_on_slaves"], "tokens": 409}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_generic(testdir, LineMatcher):\n    testdir.plugins.append(\"resultlog\")\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_pass():\n            pass\n        def test_fail():\n            assert 0\n        def test_skip():\n            pytest.skip(\"\")\n        @pytest.mark.xfail\n        def test_xfail():\n            assert 0\n        @pytest.mark.xfail(run=False)\n        def test_xfail_norun():\n            assert 0\n    \"\"\"\n    )\n    testdir.runpytest(\"--resultlog=result.log\")\n    lines = testdir.tmpdir.join(\"result.log\").readlines(cr=0)\n    LineMatcher(lines).fnmatch_lines(\n        [\n            \". *:test_pass\",\n            \"F *:test_fail\",\n            \"s *:test_skip\",\n            \"x *:test_xfail\",\n            \"x *:test_xfail_norun\",\n        ]\n    )\n\n\ndef test_makedir_for_resultlog(testdir, LineMatcher):\n    \"\"\"--resultlog should automatically create directories for the log file\"\"\"\n    testdir.plugins.append(\"resultlog\")\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_pass():\n            pass\n    \"\"\"\n    )\n    testdir.runpytest(\"--resultlog=path/to/result.log\")\n    lines = testdir.tmpdir.join(\"path/to/result.log\").readlines(cr=0)\n    LineMatcher(lines).fnmatch_lines([\". *:test_pass\"])\n\n\ndef test_no_resultlog_on_slaves(testdir):\n    config = testdir.parseconfig(\"-p\", \"resultlog\", \"--resultlog=resultlog\")\n\n    assert resultlog_key not in config._store\n    pytest_configure(config)\n    assert resultlog_key in config._store\n    pytest_unconfigure(config)\n    assert resultlog_key not in config._store\n\n    config.slaveinput = {}\n    pytest_configure(config)\n    assert resultlog_key not in config._store\n    pytest_unconfigure(config)\n    assert resultlog_key not in config._store", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_test_unknown_teststatus_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_resultlog.py_test_unknown_teststatus_", "embedding": null, "metadata": {"file_path": "testing/test_resultlog.py", "file_name": "test_resultlog.py", "file_type": "text/x-python", "category": "test", "start_line": 196, "end_line": 253, "span_ids": ["test_failure_issue380", "test_unknown_teststatus"], "tokens": 347}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_unknown_teststatus(testdir):\n    \"\"\"Ensure resultlog correctly handles unknown status from pytest_report_teststatus\n\n    Inspired on pytest-rerunfailures.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        def test():\n            assert 0\n    \"\"\"\n    )\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n\n        def pytest_report_teststatus(report):\n            if report.outcome == 'rerun':\n                return \"rerun\", \"r\", \"RERUN\"\n\n        @pytest.hookimpl(hookwrapper=True)\n        def pytest_runtest_makereport():\n            res = yield\n            report = res.get_result()\n            if report.when == \"call\":\n                report.outcome = 'rerun'\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--resultlog=result.log\")\n    result.stdout.fnmatch_lines(\n        [\"test_unknown_teststatus.py r *[[]100%[]]\", \"* 1 rerun *\"]\n    )\n\n    lines = testdir.tmpdir.join(\"result.log\").readlines(cr=0)\n    assert lines[0] == \"r test_unknown_teststatus.py::test\"\n\n\ndef test_failure_issue380(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        class MyCollector(pytest.File):\n            def collect(self):\n                raise ValueError()\n            def repr_failure(self, excinfo):\n                return \"somestring\"\n        def pytest_collect_file(path, parent):\n            return MyCollector(parent=parent, fspath=path)\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        def test_func():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--resultlog=log\")\n    assert result.ret == 2", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_TestExecutionNonForked_test_report_extra_parameters": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_TestExecutionNonForked_test_report_extra_parameters", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 405, "end_line": 464, "span_ids": ["TestExecutionNonForked", "TestExecutionNonForked.getrunner", "TestExecutionNonForked.test_keyboardinterrupt_propagates", "TestSessionReports", "TestSessionReports.test_collect_result", "impl:2", "test_report_extra_parameters"], "tokens": 388}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestExecutionNonForked(BaseFunctionalTests):\n    def getrunner(self):\n        def f(item):\n            return runner.runtestprotocol(item, log=False)\n\n        return f\n\n    def test_keyboardinterrupt_propagates(self, testdir) -> None:\n        try:\n            testdir.runitem(\n                \"\"\"\n                def test_func():\n                    raise KeyboardInterrupt(\"fake\")\n            \"\"\"\n            )\n        except KeyboardInterrupt:\n            pass\n        else:\n            assert False, \"did not raise\"\n\n\nclass TestSessionReports:\n    def test_collect_result(self, testdir) -> None:\n        col = testdir.getmodulecol(\n            \"\"\"\n            def test_func1():\n                pass\n            class TestClass(object):\n                pass\n        \"\"\"\n        )\n        rep = runner.collect_one_node(col)\n        assert not rep.failed\n        assert not rep.skipped\n        assert rep.passed\n        locinfo = rep.location\n        assert locinfo[0] == col.fspath.basename\n        assert not locinfo[1]\n        assert locinfo[2] == col.fspath.basename\n        res = rep.result\n        assert len(res) == 2\n        assert res[0].name == \"test_func1\"\n        assert res[1].name == \"TestClass\"\n\n\nreporttypes = [\n    reports.BaseReport,\n    reports.TestReport,\n    reports.CollectReport,\n]  # type: List[Type[reports.BaseReport]]\n\n\n@pytest.mark.parametrize(\n    \"reporttype\", reporttypes, ids=[x.__name__ for x in reporttypes]\n)\ndef test_report_extra_parameters(reporttype: \"Type[reports.BaseReport]\") -> None:\n    args = list(inspect.signature(reporttype.__init__).parameters.keys())[1:]\n    basekw = dict.fromkeys(args, [])  # type: Dict[str, List[object]]\n    report = reporttype(newthing=1, **basekw)\n    assert report.newthing == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_callinfo_test_callinfo": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_callinfo_test_callinfo", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 467, "end_line": 488, "span_ids": ["test_callinfo"], "tokens": 233}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_callinfo() -> None:\n    ci = runner.CallInfo.from_call(lambda: 0, \"123\")\n    assert ci.when == \"123\"\n    assert ci.result == 0\n    assert \"result\" in repr(ci)\n    assert repr(ci) == \"<CallInfo when='123' result: 0>\"\n    assert str(ci) == \"<CallInfo when='123' result: 0>\"\n\n    ci = runner.CallInfo.from_call(lambda: 0 / 0, \"123\")\n    assert ci.when == \"123\"\n    assert not hasattr(ci, \"result\")\n    assert repr(ci) == \"<CallInfo when='123' excinfo={!r}>\".format(ci.excinfo)\n    assert str(ci) == repr(ci)\n    assert ci.excinfo\n\n    # Newlines are escaped.\n    def raise_assertion():\n        assert 0, \"assert_msg\"\n\n    ci = runner.CallInfo.from_call(raise_assertion, \"call\")\n    assert repr(ci) == \"<CallInfo when='call' excinfo={!r}>\".format(ci.excinfo)\n    assert \"\\n\" not in repr(ci)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_importorskip_test_importorskip.try_.except_pytest_skip_Except": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_importorskip_test_importorskip.try_.except_pytest_skip_Except", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 688, "end_line": 720, "span_ids": ["test_importorskip"], "tokens": 303}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_importorskip(monkeypatch) -> None:\n    importorskip = pytest.importorskip\n\n    def f():\n        importorskip(\"asdlkj\")\n\n    try:\n        sysmod = importorskip(\"sys\")\n        assert sysmod is sys\n        # path = pytest.importorskip(\"os.path\")\n        # assert path == os.path\n        excinfo = pytest.raises(pytest.skip.Exception, f)\n        assert excinfo is not None\n        excrepr = excinfo.getrepr()\n        assert excrepr is not None\n        assert excrepr.reprcrash is not None\n        path = py.path.local(excrepr.reprcrash.path)\n        # check that importorskip reports the actual call\n        # in this test the test_runner.py file\n        assert path.purebasename == \"test_runner\"\n        pytest.raises(SyntaxError, pytest.importorskip, \"x y z\")\n        pytest.raises(SyntaxError, pytest.importorskip, \"x=y\")\n        mod = types.ModuleType(\"hello123\")\n        mod.__version__ = \"1.3\"  # type: ignore\n        monkeypatch.setitem(sys.modules, \"hello123\", mod)\n        with pytest.raises(pytest.skip.Exception):\n            pytest.importorskip(\"hello123\", minversion=\"1.3.1\")\n        mod2 = pytest.importorskip(\"hello123\", minversion=\"1.3\")\n        assert mod2 == mod\n    except pytest.skip.Exception:  # pragma: no cover\n        assert False, \"spurious skip: {}\".format(\n            _pytest._code.ExceptionInfo.from_current()\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_importorskip_imports_last_module_part_test_failure_in_setup": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_importorskip_imports_last_module_part_test_failure_in_setup", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 723, "end_line": 825, "span_ids": ["test_failure_in_setup", "test_importorskip_custom_reason", "test_importorskip_dev_module", "test_importorskip_imports_last_module_part", "test_importorskip_module_level", "test_pytest_cmdline_main", "test_unicode_in_longrepr"], "tokens": 696}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_importorskip_imports_last_module_part() -> None:\n    ospath = pytest.importorskip(\"os.path\")\n    assert os.path == ospath\n\n\ndef test_importorskip_dev_module(monkeypatch) -> None:\n    try:\n        mod = types.ModuleType(\"mockmodule\")\n        mod.__version__ = \"0.13.0.dev-43290\"  # type: ignore\n        monkeypatch.setitem(sys.modules, \"mockmodule\", mod)\n        mod2 = pytest.importorskip(\"mockmodule\", minversion=\"0.12.0\")\n        assert mod2 == mod\n        with pytest.raises(pytest.skip.Exception):\n            pytest.importorskip(\"mockmodule1\", minversion=\"0.14.0\")\n    except pytest.skip.Exception:  # pragma: no cover\n        assert False, \"spurious skip: {}\".format(\n            _pytest._code.ExceptionInfo.from_current()\n        )\n\n\ndef test_importorskip_module_level(testdir) -> None:\n    \"\"\"importorskip must be able to skip entire modules when used at module level\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        foobarbaz = pytest.importorskip(\"foobarbaz\")\n\n        def test_foo():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*collected 0 items / 1 skipped*\"])\n\n\ndef test_importorskip_custom_reason(testdir) -> None:\n    \"\"\"make sure custom reasons are used\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        foobarbaz = pytest.importorskip(\"foobarbaz2\", reason=\"just because\")\n\n        def test_foo():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-ra\")\n    result.stdout.fnmatch_lines([\"*just because*\"])\n    result.stdout.fnmatch_lines([\"*collected 0 items / 1 skipped*\"])\n\n\ndef test_pytest_cmdline_main(testdir) -> None:\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def test_hello():\n            assert 1\n        if __name__ == '__main__':\n           pytest.cmdline.main([__file__])\n    \"\"\"\n    )\n    import subprocess\n\n    popen = subprocess.Popen([sys.executable, str(p)], stdout=subprocess.PIPE)\n    popen.communicate()\n    ret = popen.wait()\n    assert ret == 0\n\n\ndef test_unicode_in_longrepr(testdir) -> None:\n    testdir.makeconftest(\n        \"\"\"\\\n        import pytest\n        @pytest.hookimpl(hookwrapper=True)\n        def pytest_runtest_makereport():\n            outcome = yield\n            rep = outcome.get_result()\n            if rep.when == \"call\":\n                rep.longrepr = '\u00e4'\n        \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        def test_out():\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert result.ret == 1\n    assert \"UnicodeEncodeError\" not in result.stderr.str()\n\n\ndef test_failure_in_setup(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        def setup_module():\n            0/0\n        def test_func():\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--tb=line\")\n    result.stdout.no_fnmatch_line(\"*def setup_module*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_makereport_getsource_test_makereport_getsource_dynamic_code.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_makereport_getsource_test_makereport_getsource_dynamic_code.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 828, "end_line": 869, "span_ids": ["test_makereport_getsource", "test_makereport_getsource_dynamic_code"], "tokens": 252}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_makereport_getsource(testdir) -> None:\n    testdir.makepyfile(\n        \"\"\"\n        def test_foo():\n            if False: pass\n            else: assert False\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR*\")\n    result.stdout.fnmatch_lines([\"*else: assert False*\"])\n\n\ndef test_makereport_getsource_dynamic_code(testdir, monkeypatch) -> None:\n    \"\"\"Test that exception in dynamically generated code doesn't break getting the source line.\"\"\"\n    import inspect\n\n    original_findsource = inspect.findsource\n\n    def findsource(obj):\n        # Can be triggered by dynamically created functions\n        if obj.__name__ == \"foo\":\n            raise IndexError()\n        return original_findsource(obj)\n\n    monkeypatch.setattr(inspect, \"findsource\", findsource)\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n\n        @pytest.fixture\n        def foo(missing):\n            pass\n\n        def test_fix(foo):\n            assert False\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-vv\")\n    result.stdout.no_fnmatch_line(\"*INTERNALERROR*\")\n    result.stdout.fnmatch_lines([\"*test_fix*\", \"*fixture*'missing'*not found*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_store_except_info_on_error_test_store_except_info_on_error.None_6": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner.py_test_store_except_info_on_error_test_store_except_info_on_error.None_6", "embedding": null, "metadata": {"file_path": "testing/test_runner.py", "file_name": "test_runner.py", "file_type": "text/x-python", "category": "test", "start_line": 872, "end_line": 900, "span_ids": ["test_store_except_info_on_error"], "tokens": 210}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_store_except_info_on_error() -> None:\n    \"\"\" Test that upon test failure, the exception info is stored on\n    sys.last_traceback and friends.\n    \"\"\"\n    # Simulate item that might raise a specific exception, depending on `raise_error` class var\n    class ItemMightRaise:\n        nodeid = \"item_that_raises\"\n        raise_error = True\n\n        def runtest(self):\n            if self.raise_error:\n                raise IndexError(\"TEST\")\n\n    try:\n        runner.pytest_runtest_call(ItemMightRaise())\n    except IndexError:\n        pass\n    # Check that exception info is stored on sys\n    assert sys.last_type is IndexError\n    assert isinstance(sys.last_value, IndexError)\n    assert sys.last_value.args[0] == \"TEST\"\n    assert sys.last_traceback\n\n    # The next run should clear the exception info stored by the previous run\n    ItemMightRaise.raise_error = False\n    runner.pytest_runtest_call(ItemMightRaise())\n    assert not hasattr(sys, \"last_type\")\n    assert not hasattr(sys, \"last_value\")\n    assert not hasattr(sys, \"last_traceback\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py_test_method_setup_test_setup_funcarg_setup_when_outer_scope_fails.result_stdout_no_fnmatch_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_runner_xunit.py_test_method_setup_test_setup_funcarg_setup_when_outer_scope_fails.result_stdout_no_fnmatch_", "embedding": null, "metadata": {"file_path": "testing/test_runner_xunit.py", "file_name": "test_runner_xunit.py", "file_type": "text/x-python", "category": "test", "start_line": 127, "end_line": 240, "span_ids": ["test_method_setup", "test_method_setup_failure_no_teardown", "test_method_setup_uses_fresh_instances", "test_setup_fails_again_on_all_tests", "test_setup_funcarg_setup_when_outer_scope_fails", "test_setup_that_skips_calledagain"], "tokens": 612}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_method_setup(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        class TestSetupMethod(object):\n            def setup_method(self, meth):\n                self.methsetup = meth\n            def teardown_method(self, meth):\n                del self.methsetup\n\n            def test_some(self):\n                assert self.methsetup == self.test_some\n\n            def test_other(self):\n                assert self.methsetup == self.test_other\n    \"\"\"\n    )\n    reprec.assertoutcome(passed=2)\n\n\ndef test_method_setup_failure_no_teardown(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        class TestMethodSetup(object):\n            clslevel = []\n            def setup_method(self, method):\n                self.clslevel.append(1)\n                0/0\n\n            def teardown_method(self, method):\n                self.clslevel.append(2)\n\n            def test_method(self):\n                pass\n\n        def test_cleanup():\n            assert TestMethodSetup.clslevel == [1]\n    \"\"\"\n    )\n    reprec.assertoutcome(failed=1, passed=1)\n\n\ndef test_method_setup_uses_fresh_instances(testdir):\n    reprec = testdir.inline_runsource(\n        \"\"\"\n        class TestSelfState1(object):\n            memory = []\n            def test_hello(self):\n                self.memory.append(self)\n\n            def test_afterhello(self):\n                assert self != self.memory[0]\n    \"\"\"\n    )\n    reprec.assertoutcome(passed=2, failed=0)\n\n\ndef test_setup_that_skips_calledagain(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def setup_module(mod):\n            pytest.skip(\"x\")\n        def test_function1():\n            pass\n        def test_function2():\n            pass\n    \"\"\"\n    )\n    reprec = testdir.inline_run(p)\n    reprec.assertoutcome(skipped=2)\n\n\ndef test_setup_fails_again_on_all_tests(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def setup_module(mod):\n            raise ValueError(42)\n        def test_function1():\n            pass\n        def test_function2():\n            pass\n    \"\"\"\n    )\n    reprec = testdir.inline_run(p)\n    reprec.assertoutcome(failed=2)\n\n\ndef test_setup_funcarg_setup_when_outer_scope_fails(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        def setup_module(mod):\n            raise ValueError(42)\n        @pytest.fixture\n        def hello(request):\n            raise ValueError(\"xyz43\")\n        def test_function1(hello):\n            pass\n        def test_function2(hello):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest(p)\n    result.stdout.fnmatch_lines(\n        [\n            \"*function1*\",\n            \"*ValueError*42*\",\n            \"*function2*\",\n            \"*ValueError*42*\",\n            \"*2 errors*\",\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*xyz43*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_broken_repr_SessionTests.test_broken_repr.assert_out_find_reprex": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_session.py_SessionTests.test_broken_repr_SessionTests.test_broken_repr.assert_out_find_reprex", "embedding": null, "metadata": {"file_path": "testing/test_session.py", "file_name": "test_session.py", "file_type": "text/x-python", "category": "test", "start_line": 101, "end_line": 131, "span_ids": ["SessionTests.test_broken_repr"], "tokens": 229}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class SessionTests:\n\n    def test_broken_repr(self, testdir):\n        p = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            class reprexc(BaseException):\n                def __str__(self):\n                    return \"Ha Ha fooled you, I'm a broken repr().\"\n\n            class BrokenRepr1(object):\n                foo=0\n                def __repr__(self):\n                    raise reprexc\n\n            class TestBrokenClass(object):\n                def test_explicit_bad_repr(self):\n                    t = BrokenRepr1()\n                    with pytest.raises(BaseException, match=\"broken repr\"):\n                        repr(t)\n\n                def test_implicit_bad_repr1(self):\n                    t = BrokenRepr1()\n                    assert t.foo == 1\n\n        \"\"\"\n        )\n        reprec = testdir.inline_run(p)\n        passed, skipped, failed = reprec.listoutcomes()\n        assert (len(passed), len(skipped), len(failed)) == (1, 0, 1)\n        out = failed[0].longrepr.reprcrash.message\n        assert out.find(\"<[reprexc() raised in repr()] BrokenRepr1\") != -1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_pytest_test_show_fixtures_with_autouse": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_pytest_test_show_fixtures_with_autouse", "embedding": null, "metadata": {"file_path": "testing/test_setuponly.py", "file_name": "test_setuponly.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 121, "span_ids": ["imports", "mode", "test_show_different_scopes", "test_show_fixtures_with_autouse", "test_show_nested_fixtures", "test_show_only_active_fixtures"], "tokens": 683}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\nfrom _pytest.config import ExitCode\n\n\n@pytest.fixture(params=[\"--setup-only\", \"--setup-plan\", \"--setup-show\"], scope=\"module\")\ndef mode(request):\n    return request.param\n\n\ndef test_show_only_active_fixtures(testdir, mode, dummy_yaml_custom_test):\n    testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture\n        def _arg0():\n            \"\"\"hidden arg0 fixture\"\"\"\n        @pytest.fixture\n        def arg1():\n            \"\"\"arg1 docstring\"\"\"\n        def test_arg1(arg1):\n            pass\n    '''\n    )\n\n    result = testdir.runpytest(mode)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\"*SETUP    F arg1*\", \"*test_arg1 (fixtures used: arg1)*\", \"*TEARDOWN F arg1*\"]\n    )\n    result.stdout.no_fnmatch_line(\"*_arg0*\")\n\n\ndef test_show_different_scopes(testdir, mode):\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture\n        def arg_function():\n            \"\"\"function scoped fixture\"\"\"\n        @pytest.fixture(scope='session')\n        def arg_session():\n            \"\"\"session scoped fixture\"\"\"\n        def test_arg1(arg_session, arg_function):\n            pass\n    '''\n    )\n\n    result = testdir.runpytest(mode, p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"SETUP    S arg_session*\",\n            \"*SETUP    F arg_function*\",\n            \"*test_arg1 (fixtures used: arg_function, arg_session)*\",\n            \"*TEARDOWN F arg_function*\",\n            \"TEARDOWN S arg_session*\",\n        ]\n    )\n\n\ndef test_show_nested_fixtures(testdir, mode):\n    testdir.makeconftest(\n        '''\n        import pytest\n        @pytest.fixture(scope='session')\n        def arg_same():\n            \"\"\"session scoped fixture\"\"\"\n        '''\n    )\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture(scope='function')\n        def arg_same(arg_same):\n            \"\"\"function scoped fixture\"\"\"\n        def test_arg1(arg_same):\n            pass\n    '''\n    )\n\n    result = testdir.runpytest(mode, p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"SETUP    S arg_same*\",\n            \"*SETUP    F arg_same (fixtures used: arg_same)*\",\n            \"*test_arg1 (fixtures used: arg_same)*\",\n            \"*TEARDOWN F arg_same*\",\n            \"TEARDOWN S arg_same*\",\n        ]\n    )\n\n\ndef test_show_fixtures_with_autouse(testdir, mode):\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture\n        def arg_function():\n            \"\"\"function scoped fixture\"\"\"\n        @pytest.fixture(scope='session', autouse=True)\n        def arg_session():\n            \"\"\"session scoped fixture\"\"\"\n        def test_arg1(arg_function):\n            pass\n    '''\n    )\n\n    result = testdir.runpytest(mode, p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"SETUP    S arg_session*\",\n            \"*SETUP    F arg_function*\",\n            \"*test_arg1 (fixtures used: arg_function, arg_session)*\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_test_show_fixtures_with_parameters_test_capturing": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_test_show_fixtures_with_parameters_test_capturing", "embedding": null, "metadata": {"file_path": "testing/test_setuponly.py", "file_name": "test_setuponly.py", "file_type": "text/x-python", "category": "test", "start_line": 124, "end_line": 249, "span_ids": ["test_capturing", "test_dynamic_fixture_request", "test_show_fixtures_with_parameter_ids", "test_show_fixtures_with_parameter_ids_function", "test_show_fixtures_with_parameters"], "tokens": 708}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_show_fixtures_with_parameters(testdir, mode):\n    testdir.makeconftest(\n        '''\n        import pytest\n        @pytest.fixture(scope='session', params=['foo', 'bar'])\n        def arg_same():\n            \"\"\"session scoped fixture\"\"\"\n        '''\n    )\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture(scope='function')\n        def arg_other(arg_same):\n            \"\"\"function scoped fixture\"\"\"\n        def test_arg1(arg_other):\n            pass\n    '''\n    )\n\n    result = testdir.runpytest(mode, p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"SETUP    S arg_same?foo?\",\n            \"TEARDOWN S arg_same?foo?\",\n            \"SETUP    S arg_same?bar?\",\n            \"TEARDOWN S arg_same?bar?\",\n        ]\n    )\n\n\ndef test_show_fixtures_with_parameter_ids(testdir, mode):\n    testdir.makeconftest(\n        '''\n        import pytest\n        @pytest.fixture(\n            scope='session', params=['foo', 'bar'], ids=['spam', 'ham'])\n        def arg_same():\n            \"\"\"session scoped fixture\"\"\"\n        '''\n    )\n    p = testdir.makepyfile(\n        '''\n        import pytest\n        @pytest.fixture(scope='function')\n        def arg_other(arg_same):\n            \"\"\"function scoped fixture\"\"\"\n        def test_arg1(arg_other):\n            pass\n    '''\n    )\n\n    result = testdir.runpytest(mode, p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\"SETUP    S arg_same?spam?\", \"SETUP    S arg_same?ham?\"]\n    )\n\n\ndef test_show_fixtures_with_parameter_ids_function(testdir, mode):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture(params=['foo', 'bar'], ids=lambda p: p.upper())\n        def foobar():\n            pass\n        def test_foobar(foobar):\n            pass\n    \"\"\"\n    )\n\n    result = testdir.runpytest(mode, p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines([\"*SETUP    F foobar?FOO?\", \"*SETUP    F foobar?BAR?\"])\n\n\ndef test_dynamic_fixture_request(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture()\n        def dynamically_requested_fixture():\n            pass\n        @pytest.fixture()\n        def dependent_fixture(request):\n            request.getfixturevalue('dynamically_requested_fixture')\n        def test_dyn(dependent_fixture):\n            pass\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--setup-only\", p)\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\n            \"*SETUP    F dynamically_requested_fixture\",\n            \"*TEARDOWN F dynamically_requested_fixture\",\n        ]\n    )\n\n\ndef test_capturing(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest, sys\n        @pytest.fixture()\n        def one():\n            sys.stdout.write('this should be captured')\n            sys.stderr.write('this should also be captured')\n        @pytest.fixture()\n        def two(one):\n            assert 0\n        def test_capturing(two):\n            pass\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--setup-only\", p)\n    result.stdout.fnmatch_lines(\n        [\"this should be captured\", \"this should also be captured\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_test_show_fixtures_and_execute_test_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setuponly.py_test_show_fixtures_and_execute_test_", "embedding": null, "metadata": {"file_path": "testing/test_setuponly.py", "file_name": "test_setuponly.py", "file_type": "text/x-python", "category": "test", "start_line": 252, "end_line": 295, "span_ids": ["test_setup_show_with_KeyboardInterrupt_in_test", "test_show_fixtures_and_execute_test"], "tokens": 268}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_show_fixtures_and_execute_test(testdir):\n    \"\"\" Verifies that setups are shown and tests are executed. \"\"\"\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture\n        def arg():\n            assert True\n        def test_arg(arg):\n            assert False\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--setup-show\", p)\n    assert result.ret == 1\n\n    result.stdout.fnmatch_lines(\n        [\"*SETUP    F arg*\", \"*test_arg (fixtures used: arg)F*\", \"*TEARDOWN F arg*\"]\n    )\n\n\ndef test_setup_show_with_KeyboardInterrupt_in_test(testdir):\n    p = testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture\n        def arg():\n            pass\n        def test_arg(arg):\n            raise KeyboardInterrupt()\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--setup-show\", p, no_reraise_ctrlc=True)\n    result.stdout.fnmatch_lines(\n        [\n            \"*SETUP    F arg*\",\n            \"*test_arg (fixtures used: arg)*\",\n            \"*TEARDOWN F arg*\",\n            \"*! KeyboardInterrupt !*\",\n            \"*= no tests ran in *\",\n        ]\n    )\n    assert result.ret == ExitCode.INTERRUPTED", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setupplan.py_test_show_fixtures_and_test_test_show_multi_test_fixture_setup_and_teardown_correctly_simple.assert_teardown_count_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setupplan.py_test_show_fixtures_and_test_test_show_multi_test_fixture_setup_and_teardown_correctly_simple.assert_teardown_count_", "embedding": null, "metadata": {"file_path": "testing/test_setupplan.py", "file_name": "test_setupplan.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 67, "span_ids": ["test_show_fixtures_and_test", "test_show_multi_test_fixture_setup_and_teardown_correctly_simple"], "tokens": 454}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_show_fixtures_and_test(testdir, dummy_yaml_custom_test):\n    \"\"\" Verifies that fixtures are not executed. \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture\n        def arg():\n            assert False\n        def test_arg(arg):\n            assert False\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--setup-plan\")\n    assert result.ret == 0\n\n    result.stdout.fnmatch_lines(\n        [\"*SETUP    F arg*\", \"*test_arg (fixtures used: arg)\", \"*TEARDOWN F arg*\"]\n    )\n\n\ndef test_show_multi_test_fixture_setup_and_teardown_correctly_simple(testdir):\n    \"\"\"\n    Verify that when a fixture lives for longer than a single test, --setup-plan\n    correctly displays the SETUP/TEARDOWN indicators the right number of times.\n\n    As reported in https://github.com/pytest-dev/pytest/issues/2049\n    --setup-plan was showing SETUP/TEARDOWN on every test, even when the fixture\n    should persist through multiple tests.\n\n    (Note that this bug never affected actual test execution, which used the\n    correct fixture lifetimes. It was purely a display bug for --setup-plan, and\n    did not affect the related --setup-show or --setup-only.)\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture(scope = 'class')\n        def fix():\n            return object()\n        class TestClass:\n            def test_one(self, fix):\n                assert False\n            def test_two(self, fix):\n                assert False\n    \"\"\"\n    )\n\n    result = testdir.runpytest(\"--setup-plan\")\n    assert result.ret == 0\n\n    setup_fragment = \"SETUP    C fix\"\n    setup_count = 0\n\n    teardown_fragment = \"TEARDOWN C fix\"\n    teardown_count = 0\n\n    for line in result.stdout.lines:\n        if setup_fragment in line:\n            setup_count += 1\n        if teardown_fragment in line:\n            teardown_count += 1\n\n    # before the fix this tests, there would have been a setup/teardown\n    # message for each test, so the counts would each have been 2\n    assert setup_count == 1\n    assert teardown_count == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setupplan.py_test_show_multi_test_fixture_setup_and_teardown_same_as_setup_show_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_setupplan.py_test_show_multi_test_fixture_setup_and_teardown_same_as_setup_show_", "embedding": null, "metadata": {"file_path": "testing/test_setupplan.py", "file_name": "test_setupplan.py", "file_type": "text/x-python", "category": "test", "start_line": 70, "end_line": 111, "span_ids": ["test_show_multi_test_fixture_setup_and_teardown_same_as_setup_show"], "tokens": 281}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_show_multi_test_fixture_setup_and_teardown_same_as_setup_show(testdir):\n    \"\"\"\n    Verify that SETUP/TEARDOWN messages match what comes out of --setup-show.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture(scope = 'session')\n        def sess():\n            return True\n        @pytest.fixture(scope = 'module')\n        def mod():\n            return True\n        @pytest.fixture(scope = 'class')\n        def cls():\n            return True\n        @pytest.fixture(scope = 'function')\n        def func():\n            return True\n        def test_outside(sess, mod, cls, func):\n            assert True\n        class TestCls:\n            def test_one(self, sess, mod, cls, func):\n                assert True\n            def test_two(self, sess, mod, cls, func):\n                assert True\n    \"\"\"\n    )\n\n    plan_result = testdir.runpytest(\"--setup-plan\")\n    show_result = testdir.runpytest(\"--setup-show\")\n\n    # the number and text of these lines should be identical\n    plan_lines = [\n        l for l in plan_result.stdout.lines if \"SETUP\" in l or \"TEARDOWN\" in l\n    ]\n    show_lines = [\n        l for l in show_result.stdout.lines if \"SETUP\" in l or \"TEARDOWN\" in l\n    ]\n\n    assert plan_lines == show_lines", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_store.py_pytest_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_store.py_pytest_", "embedding": null, "metadata": {"file_path": "testing/test_store.py", "file_name": "test_store.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 61, "span_ids": ["imports", "test_store"], "tokens": 404}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import pytest\nfrom _pytest.store import Store\nfrom _pytest.store import StoreKey\n\n\ndef test_store() -> None:\n    store = Store()\n\n    key1 = StoreKey[str]()\n    key2 = StoreKey[int]()\n\n    # Basic functionality - single key.\n    assert key1 not in store\n    store[key1] = \"hello\"\n    assert key1 in store\n    assert store[key1] == \"hello\"\n    assert store.get(key1, None) == \"hello\"\n    store[key1] = \"world\"\n    assert store[key1] == \"world\"\n    # Has correct type (no mypy error).\n    store[key1] + \"string\"\n\n    # No interaction with another key.\n    assert key2 not in store\n    assert store.get(key2, None) is None\n    with pytest.raises(KeyError):\n        store[key2]\n    with pytest.raises(KeyError):\n        del store[key2]\n    store[key2] = 1\n    assert store[key2] == 1\n    # Has correct type (no mypy error).\n    store[key2] + 20\n    del store[key1]\n    with pytest.raises(KeyError):\n        del store[key1]\n    with pytest.raises(KeyError):\n        store[key1]\n\n    # setdefault\n    store[key1] = \"existing\"\n    assert store.setdefault(key1, \"default\") == \"existing\"\n    assert store[key1] == \"existing\"\n    key_setdefault = StoreKey[bytes]()\n    assert store.setdefault(key_setdefault, b\"default\") == b\"default\"\n    assert store[key_setdefault] == b\"default\"\n\n    # Can't accidentally add attributes to store object itself.\n    with pytest.raises(AttributeError):\n        store.foo = \"nope\"  # type: ignore[attr-defined] # noqa: F821\n\n    # No interaction with anoter store.\n    store2 = Store()\n    key3 = StoreKey[int]()\n    assert key2 not in store2\n    store2[key2] = 100\n    store2[key3] = 200\n    assert store2[key2] + store2[key3] == 300\n    assert store[key2] == 1\n    assert key3 not in store", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_report_collect_after_half_a_second_TestTerminal.test_report_collect_after_half_a_second.assert_x1b_32m_x1b_1m": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_report_collect_after_half_a_second_TestTerminal.test_report_collect_after_half_a_second.assert_x1b_32m_x1b_1m", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 144, "end_line": 169, "span_ids": ["TestTerminal.test_report_collect_after_half_a_second"], "tokens": 217}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminal:\n\n    def test_report_collect_after_half_a_second(self, testdir):\n        \"\"\"Test for \"collecting\" being updated after 0.5s\"\"\"\n\n        testdir.makepyfile(\n            **{\n                \"test1.py\": \"\"\"\n                import _pytest.terminal\n\n                _pytest.terminal.REPORT_COLLECTING_RESOLUTION = 0\n\n                def test_1():\n                    pass\n                    \"\"\",\n                \"test2.py\": \"def test_2(): pass\",\n            }\n        )\n        # Explicitly test colored output.\n        testdir.monkeypatch.setenv(\"PY_COLORS\", \"1\")\n\n        child = testdir.spawn_pytest(\"-v test1.py test2.py\")\n        child.expect(r\"collecting \\.\\.\\.\")\n        child.expect(r\"collecting 1 item\")\n        child.expect(r\"collecting 2 items\")\n        child.expect(r\"collected 2 items\")\n        rest = child.read().decode(\"utf8\")\n        assert \"= \\x1b[32m\\x1b[1m2 passed\\x1b[0m\\x1b[32m in\" in rest", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_itemreport_subclasses_show_subclassed_file_TestTerminal.test_itemreport_subclasses_show_subclassed_file.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_itemreport_subclasses_show_subclassed_file_TestTerminal.test_itemreport_subclasses_show_subclassed_file.None_3", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 171, "end_line": 220, "span_ids": ["TestTerminal.test_itemreport_subclasses_show_subclassed_file"], "tokens": 414}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminal:\n\n    def test_itemreport_subclasses_show_subclassed_file(self, testdir):\n        testdir.makepyfile(\n            **{\n                \"tests/test_p1\": \"\"\"\n            class BaseTests(object):\n                fail = False\n\n                def test_p1(self):\n                    if self.fail: assert 0\n                \"\"\",\n                \"tests/test_p2\": \"\"\"\n            from test_p1 import BaseTests\n\n            class TestMore(BaseTests): pass\n                \"\"\",\n                \"tests/test_p3.py\": \"\"\"\n            from test_p1 import BaseTests\n\n            BaseTests.fail = True\n\n            class TestMore(BaseTests): pass\n        \"\"\",\n            }\n        )\n        result = testdir.runpytest(\"tests/test_p2.py\", \"--rootdir=tests\")\n        result.stdout.fnmatch_lines([\"tests/test_p2.py .*\", \"=* 1 passed in *\"])\n\n        result = testdir.runpytest(\"-vv\", \"-rA\", \"tests/test_p2.py\", \"--rootdir=tests\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tests/test_p2.py::TestMore::test_p1 <- test_p1.py PASSED *\",\n                \"*= short test summary info =*\",\n                \"PASSED tests/test_p2.py::TestMore::test_p1\",\n            ]\n        )\n        result = testdir.runpytest(\"-vv\", \"-rA\", \"tests/test_p3.py\", \"--rootdir=tests\")\n        result.stdout.fnmatch_lines(\n            [\n                \"tests/test_p3.py::TestMore::test_p1 <- test_p1.py FAILED *\",\n                \"*_ TestMore.test_p1 _*\",\n                \"    def test_p1(self):\",\n                \">       if self.fail: assert 0\",\n                \"E       assert 0\",\n                \"\",\n                \"tests/test_p1.py:5: AssertionError\",\n                \"*= short test summary info =*\",\n                \"FAILED tests/test_p3.py::TestMore::test_p1 - assert 0\",\n                \"*= 1 failed in *\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_itemreport_directclasses_not_shown_as_subclasses_TestTerminal.test_keyboard_interrupt.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_itemreport_directclasses_not_shown_as_subclasses_TestTerminal.test_keyboard_interrupt.None_2", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 222, "end_line": 268, "span_ids": ["TestTerminal.test_itemreport_directclasses_not_shown_as_subclasses", "TestTerminal.test_keyboard_interrupt"], "tokens": 334}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminal:\n\n    def test_itemreport_directclasses_not_shown_as_subclasses(self, testdir):\n        a = testdir.mkpydir(\"a123\")\n        a.join(\"test_hello123.py\").write(\n            textwrap.dedent(\n                \"\"\"\\\n                class TestClass(object):\n                    def test_method(self):\n                        pass\n                \"\"\"\n            )\n        )\n        result = testdir.runpytest(\"-vv\")\n        assert result.ret == 0\n        result.stdout.fnmatch_lines([\"*a123/test_hello123.py*PASS*\"])\n        result.stdout.no_fnmatch_line(\"* <- *\")\n\n    @pytest.mark.parametrize(\"fulltrace\", (\"\", \"--fulltrace\"))\n    def test_keyboard_interrupt(self, testdir, fulltrace):\n        testdir.makepyfile(\n            \"\"\"\n            def test_foobar():\n                assert 0\n            def test_spamegg():\n                import py; pytest.skip('skip me please!')\n            def test_interrupt_me():\n                raise KeyboardInterrupt   # simulating the user\n        \"\"\"\n        )\n\n        result = testdir.runpytest(fulltrace, no_reraise_ctrlc=True)\n        result.stdout.fnmatch_lines(\n            [\n                \"    def test_foobar():\",\n                \">       assert 0\",\n                \"E       assert 0\",\n                \"*_keyboard_interrupt.py:6: KeyboardInterrupt*\",\n            ]\n        )\n        if fulltrace:\n            result.stdout.fnmatch_lines(\n                [\"*raise KeyboardInterrupt   # simulating the user*\"]\n            )\n        else:\n            result.stdout.fnmatch_lines(\n                [\"(to show a full traceback on KeyboardInterrupt use --full-trace)\"]\n            )\n        result.stdout.fnmatch_lines([\"*KeyboardInterrupt*\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_keyboard_in_sessionstart_TestTerminal.test_report_teststatus_explicit_markup": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminal.test_keyboard_in_sessionstart_TestTerminal.test_report_teststatus_explicit_markup", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 270, "end_line": 330, "span_ids": ["TestTerminal.test_collect_single_item", "TestTerminal.test_keyboard_in_sessionstart", "TestTerminal.test_report_teststatus_explicit_markup", "TestTerminal.test_rewrite"], "tokens": 420}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminal:\n\n    def test_keyboard_in_sessionstart(self, testdir):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_sessionstart():\n                raise KeyboardInterrupt\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_foobar():\n                pass\n        \"\"\"\n        )\n\n        result = testdir.runpytest(no_reraise_ctrlc=True)\n        assert result.ret == 2\n        result.stdout.fnmatch_lines([\"*KeyboardInterrupt*\"])\n\n    def test_collect_single_item(self, testdir):\n        \"\"\"Use singular 'item' when reporting a single test item\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def test_foobar():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest()\n        result.stdout.fnmatch_lines([\"collected 1 item\"])\n\n    def test_rewrite(self, testdir, monkeypatch):\n        config = testdir.parseconfig()\n        f = StringIO()\n        monkeypatch.setattr(f, \"isatty\", lambda *args: True)\n        tr = TerminalReporter(config, f)\n        tr._tw.fullwidth = 10\n        tr.write(\"hello\")\n        tr.rewrite(\"hey\", erase=True)\n        assert f.getvalue() == \"hello\" + \"\\r\" + \"hey\" + (6 * \" \")\n\n    def test_report_teststatus_explicit_markup(\n        self, testdir: Testdir, color_mapping\n    ) -> None:\n        \"\"\"Test that TerminalReporter handles markup explicitly provided by\n        a pytest_report_teststatus hook.\"\"\"\n        testdir.monkeypatch.setenv(\"PY_COLORS\", \"1\")\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_report_teststatus(report):\n                return 'foo', 'F', ('FOO', {'red': True})\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            def test_foobar():\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(\"-v\")\n        result.stdout.fnmatch_lines(\n            color_mapping.format_for_fnmatch([\"*{red}FOO{reset}*\"])\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_showlocals_TestTerminalFunctional.test_more_quiet_reporting": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_showlocals_TestTerminalFunctional.test_more_quiet_reporting", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 725, "end_line": 825, "span_ids": ["TestTerminalFunctional.test_more_quiet_reporting", "TestTerminalFunctional.test_quiet_reporting", "TestTerminalFunctional.test_showlocals", "TestTerminalFunctional.test_showlocals_short", "TestTerminalFunctional.test_verbose_reporting", "TestTerminalFunctional.test_verbose_reporting_xdist", "TestTerminalFunctional.verbose_testfile"], "tokens": 721}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminalFunctional:\n\n    def test_showlocals(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_showlocals():\n                x = 3\n                y = \"x\" * 5000\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p1, \"-l\")\n        result.stdout.fnmatch_lines(\n            [\n                # \"_ _ * Locals *\",\n                \"x* = 3\",\n                \"y* = 'xxxxxx*\",\n            ]\n        )\n\n    def test_showlocals_short(self, testdir):\n        p1 = testdir.makepyfile(\n            \"\"\"\n            def test_showlocals_short():\n                x = 3\n                y = \"xxxx\"\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(p1, \"-l\", \"--tb=short\")\n        result.stdout.fnmatch_lines(\n            [\n                \"test_showlocals_short.py:*\",\n                \"    assert 0\",\n                \"E   assert 0\",\n                \"        x          = 3\",\n                \"        y          = 'xxxx'\",\n            ]\n        )\n\n    @pytest.fixture\n    def verbose_testfile(self, testdir):\n        return testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def test_fail():\n                raise ValueError()\n            def test_pass():\n                pass\n            class TestClass(object):\n                def test_skip(self):\n                    pytest.skip(\"hello\")\n            def test_gen():\n                def check(x):\n                    assert x == 1\n                yield check, 0\n        \"\"\"\n        )\n\n    def test_verbose_reporting(self, verbose_testfile, testdir):\n        result = testdir.runpytest(\n            verbose_testfile, \"-v\", \"-Walways::pytest.PytestWarning\"\n        )\n        result.stdout.fnmatch_lines(\n            [\n                \"*test_verbose_reporting.py::test_fail *FAIL*\",\n                \"*test_verbose_reporting.py::test_pass *PASS*\",\n                \"*test_verbose_reporting.py::TestClass::test_skip *SKIP*\",\n                \"*test_verbose_reporting.py::test_gen *XFAIL*\",\n            ]\n        )\n        assert result.ret == 1\n\n    def test_verbose_reporting_xdist(self, verbose_testfile, testdir, pytestconfig):\n        if not pytestconfig.pluginmanager.get_plugin(\"xdist\"):\n            pytest.skip(\"xdist plugin not installed\")\n\n        testdir.monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\")\n        result = testdir.runpytest(\n            verbose_testfile, \"-v\", \"-n 1\", \"-Walways::pytest.PytestWarning\"\n        )\n        result.stdout.fnmatch_lines(\n            [\"*FAIL*test_verbose_reporting_xdist.py::test_fail*\"]\n        )\n        assert result.ret == 1\n\n    def test_quiet_reporting(self, testdir):\n        p1 = testdir.makepyfile(\"def test_pass(): pass\")\n        result = testdir.runpytest(p1, \"-q\")\n        s = result.stdout.str()\n        assert \"test session starts\" not in s\n        assert p1.basename not in s\n        assert \"===\" not in s\n        assert \"passed\" in s\n\n    def test_more_quiet_reporting(self, testdir):\n        p1 = testdir.makepyfile(\"def test_pass(): pass\")\n        result = testdir.runpytest(p1, \"-qq\")\n        s = result.stdout.str()\n        assert \"test session starts\" not in s\n        assert p1.basename not in s\n        assert \"===\" not in s\n        assert \"passed\" not in s", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_report_collectionfinish_hook_TestTerminalFunctional.test_summary_s_alias": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestTerminalFunctional.test_report_collectionfinish_hook_TestTerminalFunctional.test_summary_s_alias", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 827, "end_line": 875, "span_ids": ["TestTerminalFunctional.test_report_collectionfinish_hook", "TestTerminalFunctional.test_summary_f_alias", "TestTerminalFunctional.test_summary_s_alias"], "tokens": 378}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestTerminalFunctional:\n\n    @pytest.mark.parametrize(\n        \"params\", [(), (\"--collect-only\",)], ids=[\"no-params\", \"collect-only\"]\n    )\n    def test_report_collectionfinish_hook(self, testdir, params):\n        testdir.makeconftest(\n            \"\"\"\n            def pytest_report_collectionfinish(config, startdir, items):\n                return ['hello from hook: {0} items'.format(len(items))]\n        \"\"\"\n        )\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            @pytest.mark.parametrize('i', range(3))\n            def test(i):\n                pass\n        \"\"\"\n        )\n        result = testdir.runpytest(*params)\n        result.stdout.fnmatch_lines([\"collected 3 items\", \"hello from hook: 3 items\"])\n\n    def test_summary_f_alias(self, testdir):\n        \"\"\"Test that 'f' and 'F' report chars are aliases and don't show up twice in the summary (#6334)\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def test():\n                assert False\n            \"\"\"\n        )\n        result = testdir.runpytest(\"-rfF\")\n        expected = \"FAILED test_summary_f_alias.py::test - assert False\"\n        result.stdout.fnmatch_lines([expected])\n        assert result.stdout.lines.count(expected) == 1\n\n    def test_summary_s_alias(self, testdir):\n        \"\"\"Test that 's' and 'S' report chars are aliases and don't show up twice in the summary\"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.skip\n            def test():\n                pass\n            \"\"\"\n        )\n        result = testdir.runpytest(\"-rsS\")\n        expected = \"SKIPPED [1] test_summary_s_alias.py:3: unconditional skip\"\n        result.stdout.fnmatch_lines([expected])\n        assert result.stdout.lines.count(expected) == 1", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_color_yes_test_color_yes.None_2": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_color_yes_test_color_yes.None_2", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 952, "end_line": 1009, "span_ids": ["test_color_yes"], "tokens": 533}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_color_yes(testdir, color_mapping):\n    p1 = testdir.makepyfile(\n        \"\"\"\n        def fail():\n            assert 0\n\n        def test_this():\n            fail()\n        \"\"\"\n    )\n    result = testdir.runpytest(\"--color=yes\", str(p1))\n    color_mapping.requires_ordered_markup(result)\n    result.stdout.fnmatch_lines(\n        color_mapping.format_for_fnmatch(\n            [\n                \"{bold}=*= test session starts =*={reset}\",\n                \"collected 1 item\",\n                \"\",\n                \"test_color_yes.py {red}F{reset}{red} * [100%]{reset}\",\n                \"\",\n                \"=*= FAILURES =*=\",\n                \"{red}{bold}_*_ test_this _*_{reset}\",\n                \"\",\n                \"    {kw}def{hl-reset} {function}test_this{hl-reset}():\",\n                \">       fail()\",\n                \"\",\n                \"{bold}{red}test_color_yes.py{reset}:5: \",\n                \"_ _ * _ _*\",\n                \"\",\n                \"    {kw}def{hl-reset} {function}fail{hl-reset}():\",\n                \">       {kw}assert{hl-reset} {number}0{hl-reset}\",\n                \"{bold}{red}E       assert 0{reset}\",\n                \"\",\n                \"{bold}{red}test_color_yes.py{reset}:2: AssertionError\",\n                \"{red}=*= {red}{bold}1 failed{reset}{red} in *s{reset}{red} =*={reset}\",\n            ]\n        )\n    )\n    result = testdir.runpytest(\"--color=yes\", \"--tb=short\", str(p1))\n    result.stdout.fnmatch_lines(\n        color_mapping.format_for_fnmatch(\n            [\n                \"{bold}=*= test session starts =*={reset}\",\n                \"collected 1 item\",\n                \"\",\n                \"test_color_yes.py {red}F{reset}{red} * [100%]{reset}\",\n                \"\",\n                \"=*= FAILURES =*=\",\n                \"{red}{bold}_*_ test_this _*_{reset}\",\n                \"{bold}{red}test_color_yes.py{reset}:5: in test_this\",\n                \"    fail()\",\n                \"{bold}{red}test_color_yes.py{reset}:2: in fail\",\n                \"    {kw}assert{hl-reset} {number}0{hl-reset}\",\n                \"{bold}{red}E   assert 0{reset}\",\n                \"{red}=*= {red}{bold}1 failed{reset}{red} in *s{reset}{red} =*={reset}\",\n            ]\n        )\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_color_no_test_color_yes_collection_on_non_atty": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_color_no_test_color_yes_collection_on_non_atty", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1012, "end_line": 1041, "span_ids": ["test_color_no", "test_color_yes_collection_on_non_atty"], "tokens": 246}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_color_no(testdir):\n    testdir.makepyfile(\"def test_this(): assert 1\")\n    result = testdir.runpytest(\"--color=no\")\n    assert \"test session starts\" in result.stdout.str()\n    result.stdout.no_fnmatch_line(\"*\\x1b[1m*\")\n\n\n@pytest.mark.parametrize(\"verbose\", [True, False])\ndef test_color_yes_collection_on_non_atty(testdir, verbose):\n    \"\"\"skip collect progress report when working on non-terminals.\n    #1397\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.parametrize('i', range(10))\n        def test_this(i):\n            assert 1\n    \"\"\"\n    )\n    args = [\"--color=yes\"]\n    if verbose:\n        args.append(\"-vv\")\n    result = testdir.runpytest(*args)\n    assert \"test session starts\" in result.stdout.str()\n    assert \"\\x1b[1m\" in result.stdout.str()\n    result.stdout.no_fnmatch_line(\"*collecting 10 items*\")\n    if verbose:\n        assert \"collecting ...\" in result.stdout.str()\n    assert \"collected 10 items\" in result.stdout.str()", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_getreportopt_test_getreportopt.None_14": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_getreportopt_test_getreportopt.None_14", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1044, "end_line": 1100, "span_ids": ["test_getreportopt"], "tokens": 344}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_getreportopt():\n    from _pytest.terminal import _REPORTCHARS_DEFAULT\n\n    class Config:\n        class Option:\n            reportchars = _REPORTCHARS_DEFAULT\n            disable_warnings = False\n\n        option = Option()\n\n    config = Config()\n\n    assert _REPORTCHARS_DEFAULT == \"fE\"\n\n    # Default.\n    assert getreportopt(config) == \"wfE\"\n\n    config.option.reportchars = \"sf\"\n    assert getreportopt(config) == \"wsf\"\n\n    config.option.reportchars = \"sfxw\"\n    assert getreportopt(config) == \"sfxw\"\n\n    config.option.reportchars = \"a\"\n    assert getreportopt(config) == \"wsxXEf\"\n\n    config.option.reportchars = \"N\"\n    assert getreportopt(config) == \"w\"\n\n    config.option.reportchars = \"NwfE\"\n    assert getreportopt(config) == \"wfE\"\n\n    config.option.reportchars = \"NfENx\"\n    assert getreportopt(config) == \"wx\"\n\n    # Now with --disable-warnings.\n    config.option.disable_warnings = True\n    config.option.reportchars = \"a\"\n    assert getreportopt(config) == \"sxXEf\"\n\n    config.option.reportchars = \"sfx\"\n    assert getreportopt(config) == \"sfx\"\n\n    config.option.reportchars = \"sfxw\"\n    assert getreportopt(config) == \"sfx\"\n\n    config.option.reportchars = \"a\"\n    assert getreportopt(config) == \"sxXEf\"\n\n    config.option.reportchars = \"A\"\n    assert getreportopt(config) == \"PpsxXEf\"\n\n    config.option.reportchars = \"AN\"\n    assert getreportopt(config) == \"\"\n\n    config.option.reportchars = \"NwfE\"\n    assert getreportopt(config) == \"fE\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting_TestGenericReporting.test_maxfailures_with_interrupted": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting_TestGenericReporting.test_maxfailures_with_interrupted", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1152, "end_line": 1202, "span_ids": ["TestGenericReporting", "TestGenericReporting.test_collect_fail", "TestGenericReporting.test_maxfailures", "TestGenericReporting.test_maxfailures_with_interrupted"], "tokens": 334}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGenericReporting:\n    \"\"\" this test class can be subclassed with a different option\n        provider to run e.g. distributed tests.\n    \"\"\"\n\n    def test_collect_fail(self, testdir, option):\n        testdir.makepyfile(\"import xyz\\n\")\n        result = testdir.runpytest(*option.args)\n        result.stdout.fnmatch_lines(\n            [\"ImportError while importing*\", \"*No module named *xyz*\", \"*1 error*\"]\n        )\n\n    def test_maxfailures(self, testdir, option):\n        testdir.makepyfile(\n            \"\"\"\n            def test_1():\n                assert 0\n            def test_2():\n                assert 0\n            def test_3():\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--maxfail=2\", *option.args)\n        result.stdout.fnmatch_lines(\n            [\n                \"*def test_1():*\",\n                \"*def test_2():*\",\n                \"*! stopping after 2 failures !*\",\n                \"*2 failed*\",\n            ]\n        )\n\n    def test_maxfailures_with_interrupted(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\n            def test(request):\n                request.session.shouldstop = \"session_interrupted\"\n                assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--maxfail=1\", \"-ra\")\n        result.stdout.fnmatch_lines(\n            [\n                \"*= short test summary info =*\",\n                \"FAILED *\",\n                \"*! stopping after 1 failures !*\",\n                \"*! session_interrupted !*\",\n                \"*= 1 failed in*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_tb_option_TestGenericReporting.test_tb_option.for_tbopt_in_long_sh": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestGenericReporting.test_tb_option_TestGenericReporting.test_tb_option.for_tbopt_in_long_sh", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1204, "end_line": 1229, "span_ids": ["TestGenericReporting.test_tb_option"], "tokens": 207}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestGenericReporting:\n\n    def test_tb_option(self, testdir, option):\n        testdir.makepyfile(\n            \"\"\"\n            import pytest\n            def g():\n                raise IndexError\n            def test_func():\n                print(6*7)\n                g()  # --calling--\n        \"\"\"\n        )\n        for tbopt in [\"long\", \"short\", \"no\"]:\n            print(\"testing --tb=%s...\" % tbopt)\n            result = testdir.runpytest(\"-rN\", \"--tb=%s\" % tbopt)\n            s = result.stdout.str()\n            if tbopt == \"long\":\n                assert \"print(6*7)\" in s\n            else:\n                assert \"print(6*7)\" not in s\n            if tbopt != \"no\":\n                assert \"--calling--\" in s\n                assert \"IndexError\" in s\n            else:\n                assert \"FAILURES\" not in s\n                assert \"--calling--\" not in s\n                assert \"IndexError\" not in s", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_terminal_summary_warnings_are_displayed_tr": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_terminal_summary_warnings_are_displayed_tr", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1419, "end_line": 1484, "span_ids": ["test_terminal_summary_warnings_are_displayed", "test_terminal_summary_warnings_header_once", "tr"], "tokens": 418}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"default\")\ndef test_terminal_summary_warnings_are_displayed(testdir):\n    \"\"\"Test that warnings emitted during pytest_terminal_summary are displayed.\n    (#1305).\n    \"\"\"\n    testdir.makeconftest(\n        \"\"\"\n        import warnings\n        def pytest_terminal_summary(terminalreporter):\n            warnings.warn(UserWarning('internal warning'))\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        def test_failure():\n            import warnings\n            warnings.warn(\"warning_from_\" + \"test\")\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-ra\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*= warnings summary =*\",\n            \"*warning_from_test*\",\n            \"*= short test summary info =*\",\n            \"*= warnings summary (final) =*\",\n            \"*conftest.py:3:*internal warning\",\n            \"*== 1 failed, 2 warnings in *\",\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*None*\")\n    stdout = result.stdout.str()\n    assert stdout.count(\"warning_from_test\") == 1\n    assert stdout.count(\"=== warnings summary \") == 2\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_terminal_summary_warnings_header_once(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        def test_failure():\n            import warnings\n            warnings.warn(\"warning_from_\" + \"test\")\n            assert 0\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-ra\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*= warnings summary =*\",\n            \"*warning_from_test*\",\n            \"*= short test summary info =*\",\n            \"*== 1 failed, 1 warning in *\",\n        ]\n    )\n    result.stdout.no_fnmatch_line(\"*None*\")\n    stdout = result.stdout.str()\n    assert stdout.count(\"warning_from_test\") == 1\n    assert stdout.count(\"=== warnings summary \") == 1\n\n\n@pytest.fixture(scope=\"session\")\ndef tr() -> TerminalReporter:\n    config = _pytest.config._prepareconfig()\n    return TerminalReporter(config)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle_TestProgressOutputStyle.test_normal": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle_TestProgressOutputStyle.test_normal", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1707, "end_line": 1754, "span_ids": ["TestProgressOutputStyle", "TestProgressOutputStyle.many_tests_files", "TestProgressOutputStyle.test_normal", "TestProgressOutputStyle.test_zero_tests_collected"], "tokens": 392}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestProgressOutputStyle:\n    @pytest.fixture\n    def many_tests_files(self, testdir):\n        testdir.makepyfile(\n            test_bar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(10))\n                def test_bar(i): pass\n            \"\"\",\n            test_foo=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(5))\n                def test_foo(i): pass\n            \"\"\",\n            test_foobar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(5))\n                def test_foobar(i): pass\n            \"\"\",\n        )\n\n    def test_zero_tests_collected(self, testdir):\n        \"\"\"Some plugins (testmon for example) might issue pytest_runtest_logreport without any tests being\n        actually collected (#2971).\"\"\"\n        testdir.makeconftest(\n            \"\"\"\n        def pytest_collection_modifyitems(items, config):\n            from _pytest.runner import CollectReport\n            for node_id in ('nodeid1', 'nodeid2'):\n                rep = CollectReport(node_id, 'passed', None, None)\n                rep.when = 'passed'\n                rep.duration = 0.1\n                config.hook.pytest_runtest_logreport(report=rep)\n        \"\"\"\n        )\n        output = testdir.runpytest()\n        output.stdout.no_fnmatch_line(\"*ZeroDivisionError*\")\n        output.stdout.fnmatch_lines([\"=* 2 passed in *=\"])\n\n    def test_normal(self, many_tests_files, testdir):\n        output = testdir.runpytest()\n        output.stdout.re_match_lines(\n            [\n                r\"test_bar.py \\.{10} \\s+ \\[ 50%\\]\",\n                r\"test_foo.py \\.{5} \\s+ \\[ 75%\\]\",\n                r\"test_foobar.py \\.{5} \\s+ \\[100%\\]\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_colored_progress_TestProgressOutputStyle.test_colored_progress.None_3": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_colored_progress_TestProgressOutputStyle.test_colored_progress.None_3", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1756, "end_line": 1804, "span_ids": ["TestProgressOutputStyle.test_colored_progress"], "tokens": 428}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestProgressOutputStyle:\n\n    def test_colored_progress(self, testdir, monkeypatch, color_mapping):\n        monkeypatch.setenv(\"PY_COLORS\", \"1\")\n        testdir.makepyfile(\n            test_axfail=\"\"\"\n                import pytest\n                @pytest.mark.xfail\n                def test_axfail(): assert 0\n            \"\"\",\n            test_bar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(10))\n                def test_bar(i): pass\n            \"\"\",\n            test_foo=\"\"\"\n                import pytest\n                import warnings\n                @pytest.mark.parametrize('i', range(5))\n                def test_foo(i):\n                    warnings.warn(DeprecationWarning(\"collection\"))\n                    pass\n            \"\"\",\n            test_foobar=\"\"\"\n                import pytest\n                @pytest.mark.parametrize('i', range(5))\n                def test_foobar(i): raise ValueError()\n            \"\"\",\n        )\n        result = testdir.runpytest()\n        result.stdout.re_match_lines(\n            color_mapping.format_for_rematch(\n                [\n                    r\"test_axfail.py {yellow}x{reset}{green} \\s+ \\[  4%\\]{reset}\",\n                    r\"test_bar.py ({green}\\.{reset}){{10}}{green} \\s+ \\[ 52%\\]{reset}\",\n                    r\"test_foo.py ({green}\\.{reset}){{5}}{yellow} \\s+ \\[ 76%\\]{reset}\",\n                    r\"test_foobar.py ({red}F{reset}){{5}}{red} \\s+ \\[100%\\]{reset}\",\n                ]\n            )\n        )\n\n        # Only xfail should have yellow progress indicator.\n        result = testdir.runpytest(\"test_axfail.py\")\n        result.stdout.re_match_lines(\n            color_mapping.format_for_rematch(\n                [\n                    r\"test_axfail.py {yellow}x{reset}{yellow} \\s+ \\[100%\\]{reset}\",\n                    r\"^{yellow}=+ ({yellow}{bold}|{bold}{yellow})1 xfailed{reset}{yellow} in \",\n                ]\n            )\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_count_TestProgressOutputStyle.test_xdist_normal_count": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_count_TestProgressOutputStyle.test_xdist_normal_count", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1806, "end_line": 1864, "span_ids": ["TestProgressOutputStyle.test_count", "TestProgressOutputStyle.test_verbose", "TestProgressOutputStyle.test_verbose_count", "TestProgressOutputStyle.test_xdist_normal", "TestProgressOutputStyle.test_xdist_normal_count"], "tokens": 547}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestProgressOutputStyle:\n\n    def test_count(self, many_tests_files, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style = count\n        \"\"\"\n        )\n        output = testdir.runpytest()\n        output.stdout.re_match_lines(\n            [\n                r\"test_bar.py \\.{10} \\s+ \\[10/20\\]\",\n                r\"test_foo.py \\.{5} \\s+ \\[15/20\\]\",\n                r\"test_foobar.py \\.{5} \\s+ \\[20/20\\]\",\n            ]\n        )\n\n    def test_verbose(self, many_tests_files, testdir):\n        output = testdir.runpytest(\"-v\")\n        output.stdout.re_match_lines(\n            [\n                r\"test_bar.py::test_bar\\[0\\] PASSED \\s+ \\[  5%\\]\",\n                r\"test_foo.py::test_foo\\[4\\] PASSED \\s+ \\[ 75%\\]\",\n                r\"test_foobar.py::test_foobar\\[4\\] PASSED \\s+ \\[100%\\]\",\n            ]\n        )\n\n    def test_verbose_count(self, many_tests_files, testdir):\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style = count\n        \"\"\"\n        )\n        output = testdir.runpytest(\"-v\")\n        output.stdout.re_match_lines(\n            [\n                r\"test_bar.py::test_bar\\[0\\] PASSED \\s+ \\[ 1/20\\]\",\n                r\"test_foo.py::test_foo\\[4\\] PASSED \\s+ \\[15/20\\]\",\n                r\"test_foobar.py::test_foobar\\[4\\] PASSED \\s+ \\[20/20\\]\",\n            ]\n        )\n\n    def test_xdist_normal(self, many_tests_files, testdir, monkeypatch):\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        output = testdir.runpytest(\"-n2\")\n        output.stdout.re_match_lines([r\"\\.{20} \\s+ \\[100%\\]\"])\n\n    def test_xdist_normal_count(self, many_tests_files, testdir, monkeypatch):\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            console_output_style = count\n        \"\"\"\n        )\n        output = testdir.runpytest(\"-n2\")\n        output.stdout.re_match_lines([r\"\\.{20} \\s+ \\[20/20\\]\"])", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_xdist_verbose_TestProgressOutputStyle.test_capture_no": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestProgressOutputStyle.test_xdist_verbose_TestProgressOutputStyle.test_capture_no", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 1866, "end_line": 1901, "span_ids": ["TestProgressOutputStyle.test_capture_no", "TestProgressOutputStyle.test_xdist_verbose"], "tokens": 410}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestProgressOutputStyle:\n\n    def test_xdist_verbose(self, many_tests_files, testdir, monkeypatch):\n        pytest.importorskip(\"xdist\")\n        monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n        output = testdir.runpytest(\"-n2\", \"-v\")\n        output.stdout.re_match_lines_random(\n            [\n                r\"\\[gw\\d\\] \\[\\s*\\d+%\\] PASSED test_bar.py::test_bar\\[1\\]\",\n                r\"\\[gw\\d\\] \\[\\s*\\d+%\\] PASSED test_foo.py::test_foo\\[1\\]\",\n                r\"\\[gw\\d\\] \\[\\s*\\d+%\\] PASSED test_foobar.py::test_foobar\\[1\\]\",\n            ]\n        )\n        output.stdout.fnmatch_lines_random(\n            [\n                line.translate(TRANS_FNMATCH)\n                for line in [\n                    \"test_bar.py::test_bar[0] \",\n                    \"test_foo.py::test_foo[0] \",\n                    \"test_foobar.py::test_foobar[0] \",\n                    \"[gw?] [  5%] PASSED test_*[?] \",\n                    \"[gw?] [ 10%] PASSED test_*[?] \",\n                    \"[gw?] [ 55%] PASSED test_*[?] \",\n                    \"[gw?] [ 60%] PASSED test_*[?] \",\n                    \"[gw?] [ 95%] PASSED test_*[?] \",\n                    \"[gw?] [100%] PASSED test_*[?] \",\n                ]\n            ]\n        )\n\n    def test_capture_no(self, many_tests_files, testdir):\n        output = testdir.runpytest(\"-s\")\n        output.stdout.re_match_lines(\n            [r\"test_bar.py \\.{10}\", r\"test_foo.py \\.{5}\", r\"test_foobar.py \\.{5}\"]\n        )\n\n        output = testdir.runpytest(\"--capture=no\")\n        output.stdout.no_fnmatch_line(\"*%]*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_line_with_reprcrash_test_line_with_reprcrash.None_21": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_line_with_reprcrash_test_line_with_reprcrash.None_21", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 2029, "end_line": 2094, "span_ids": ["test_line_with_reprcrash"], "tokens": 753}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_line_with_reprcrash(monkeypatch):\n    import _pytest.terminal\n    from wcwidth import wcswidth\n\n    mocked_verbose_word = \"FAILED\"\n\n    mocked_pos = \"some::nodeid\"\n\n    def mock_get_pos(*args):\n        return mocked_pos\n\n    monkeypatch.setattr(_pytest.terminal, \"_get_pos\", mock_get_pos)\n\n    class config:\n        pass\n\n    class rep:\n        def _get_verbose_word(self, *args):\n            return mocked_verbose_word\n\n        class longrepr:\n            class reprcrash:\n                pass\n\n    def check(msg, width, expected):\n        __tracebackhide__ = True\n        if msg:\n            rep.longrepr.reprcrash.message = msg\n        actual = _get_line_with_reprcrash_message(config, rep(), width)\n\n        assert actual == expected\n        if actual != \"{} {}\".format(mocked_verbose_word, mocked_pos):\n            assert len(actual) <= width\n            assert wcswidth(actual) <= width\n\n    # AttributeError with message\n    check(None, 80, \"FAILED some::nodeid\")\n\n    check(\"msg\", 80, \"FAILED some::nodeid - msg\")\n    check(\"msg\", 3, \"FAILED some::nodeid\")\n\n    check(\"msg\", 24, \"FAILED some::nodeid\")\n    check(\"msg\", 25, \"FAILED some::nodeid - msg\")\n\n    check(\"some longer msg\", 24, \"FAILED some::nodeid\")\n    check(\"some longer msg\", 25, \"FAILED some::nodeid - ...\")\n    check(\"some longer msg\", 26, \"FAILED some::nodeid - s...\")\n\n    check(\"some\\nmessage\", 25, \"FAILED some::nodeid - ...\")\n    check(\"some\\nmessage\", 26, \"FAILED some::nodeid - some\")\n    check(\"some\\nmessage\", 80, \"FAILED some::nodeid - some\")\n\n    # Test unicode safety.\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 25, \"FAILED some::nodeid - ...\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 26, \"FAILED some::nodeid - ...\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 27, \"FAILED some::nodeid - \ud83d\ude04...\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 28, \"FAILED some::nodeid - \ud83d\ude04...\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 29, \"FAILED some::nodeid - \ud83d\ude04\ud83d\ude04...\")\n\n    # NOTE: constructed, not sure if this is supported.\n    mocked_pos = \"nodeid::\ud83d\ude04::withunicode\"\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 29, \"FAILED nodeid::\ud83d\ude04::withunicode\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 40, \"FAILED nodeid::\ud83d\ude04::withunicode - \ud83d\ude04\ud83d\ude04...\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 41, \"FAILED nodeid::\ud83d\ude04::withunicode - \ud83d\ude04\ud83d\ude04...\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 42, \"FAILED nodeid::\ud83d\ude04::withunicode - \ud83d\ude04\ud83d\ude04\ud83d\ude04...\")\n    check(\"\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\\n2nd line\", 80, \"FAILED nodeid::\ud83d\ude04::withunicode - \ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude04\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_format_session_duration_test_via_exec": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_test_format_session_duration_test_via_exec", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 2097, "end_line": 2136, "span_ids": ["test_collecterror", "test_format_session_duration", "test_via_exec"], "tokens": 354}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\n    \"seconds, expected\",\n    [\n        (10.0, \"10.00s\"),\n        (10.34, \"10.34s\"),\n        (59.99, \"59.99s\"),\n        (60.55, \"60.55s (0:01:00)\"),\n        (123.55, \"123.55s (0:02:03)\"),\n        (60 * 60 + 0.5, \"3600.50s (1:00:00)\"),\n    ],\n)\ndef test_format_session_duration(seconds, expected):\n    from _pytest.terminal import format_session_duration\n\n    assert format_session_duration(seconds) == expected\n\n\ndef test_collecterror(testdir):\n    p1 = testdir.makepyfile(\"raise SyntaxError()\")\n    result = testdir.runpytest(\"-ra\", str(p1))\n    result.stdout.fnmatch_lines(\n        [\n            \"collected 0 items / 1 error\",\n            \"*= ERRORS =*\",\n            \"*_ ERROR collecting test_collecterror.py _*\",\n            \"E   SyntaxError: *\",\n            \"*= short test summary info =*\",\n            \"ERROR test_collecterror.py\",\n            \"*! Interrupted: 1 error during collection !*\",\n            \"*= 1 error in *\",\n        ]\n    )\n\n\ndef test_via_exec(testdir: Testdir) -> None:\n    p1 = testdir.makepyfile(\"exec('def test_via_exec(): pass')\")\n    result = testdir.runpytest(str(p1), \"-vv\")\n    result.stdout.fnmatch_lines(\n        [\"test_via_exec.py::test_via_exec <- <string> PASSED*\", \"*= 1 passed in *\"]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestCodeHighlight_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_terminal.py_TestCodeHighlight_", "embedding": null, "metadata": {"file_path": "testing/test_terminal.py", "file_name": "test_terminal.py", "file_type": "text/x-python", "category": "test", "start_line": 2139, "end_line": 2180, "span_ids": ["TestCodeHighlight", "TestCodeHighlight.test_code_highlight_continuation", "TestCodeHighlight.test_code_highlight_simple"], "tokens": 348}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestCodeHighlight:\n    def test_code_highlight_simple(self, testdir: Testdir, color_mapping) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                assert 1 == 10\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--color=yes\")\n        color_mapping.requires_ordered_markup(result)\n        result.stdout.fnmatch_lines(\n            color_mapping.format_for_fnmatch(\n                [\n                    \"    {kw}def{hl-reset} {function}test_foo{hl-reset}():\",\n                    \">       {kw}assert{hl-reset} {number}1{hl-reset} == {number}10{hl-reset}\",\n                    \"{bold}{red}E       assert 1 == 10{reset}\",\n                ]\n            )\n        )\n\n    def test_code_highlight_continuation(self, testdir: Testdir, color_mapping) -> None:\n        testdir.makepyfile(\n            \"\"\"\n            def test_foo():\n                print('''\n                '''); assert 0\n        \"\"\"\n        )\n        result = testdir.runpytest(\"--color=yes\")\n        color_mapping.requires_ordered_markup(result)\n\n        result.stdout.fnmatch_lines(\n            color_mapping.format_for_fnmatch(\n                [\n                    \"    {kw}def{hl-reset} {function}test_foo{hl-reset}():\",\n                    \"        {print}print{hl-reset}({str}'''{hl-reset}{str}{hl-reset}\",\n                    \">   {str}    {hl-reset}{str}'''{hl-reset}); {kw}assert{hl-reset} {number}0{hl-reset}\",\n                    \"{bold}{red}E       assert 0{reset}\",\n                ]\n            )\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_os_test_mktemp": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_os_test_mktemp", "embedding": null, "metadata": {"file_path": "testing/test_tmpdir.py", "file_name": "test_tmpdir.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 112, "span_ids": ["FakeConfig", "FakeConfig.get", "FakeConfig.option", "FakeConfig.trace", "TestConfigTmpdir", "TestConfigTmpdir.test_getbasetemp_custom_removes_old", "TestTempdirHandler", "TestTempdirHandler.test_mktemp", "TestTempdirHandler.test_tmppath_relative_basetemp_absolute", "impl", "imports", "test_mktemp", "test_tmpdir_fixture"], "tokens": 746}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport stat\nimport sys\n\nimport attr\n\nimport pytest\nfrom _pytest import pathlib\nfrom _pytest.pathlib import cleanup_numbered_dir\nfrom _pytest.pathlib import create_cleanup_lock\nfrom _pytest.pathlib import make_numbered_dir\nfrom _pytest.pathlib import maybe_delete_a_numbered_dir\nfrom _pytest.pathlib import on_rm_rf_error\nfrom _pytest.pathlib import Path\nfrom _pytest.pathlib import register_cleanup_lock_removal\nfrom _pytest.pathlib import rm_rf\nfrom _pytest.tmpdir import get_user\nfrom _pytest.tmpdir import TempdirFactory\nfrom _pytest.tmpdir import TempPathFactory\n\n\ndef test_tmpdir_fixture(testdir):\n    p = testdir.copy_example(\"tmpdir/tmpdir_fixture.py\")\n    results = testdir.runpytest(p)\n    results.stdout.fnmatch_lines([\"*1 passed*\"])\n\n\n@attr.s\nclass FakeConfig:\n    basetemp = attr.ib()\n\n    @property\n    def trace(self):\n        return self\n\n    def get(self, key):\n        return lambda *k: None\n\n    @property\n    def option(self):\n        return self\n\n\nclass TestTempdirHandler:\n    def test_mktemp(self, tmp_path):\n        config = FakeConfig(tmp_path)\n        t = TempdirFactory(TempPathFactory.from_config(config))\n        tmp = t.mktemp(\"world\")\n        assert tmp.relto(t.getbasetemp()) == \"world0\"\n        tmp = t.mktemp(\"this\")\n        assert tmp.relto(t.getbasetemp()).startswith(\"this\")\n        tmp2 = t.mktemp(\"this\")\n        assert tmp2.relto(t.getbasetemp()).startswith(\"this\")\n        assert tmp2 != tmp\n\n    def test_tmppath_relative_basetemp_absolute(self, tmp_path, monkeypatch):\n        \"\"\"#4425\"\"\"\n        monkeypatch.chdir(tmp_path)\n        config = FakeConfig(\"hello\")\n        t = TempPathFactory.from_config(config)\n        assert t.getbasetemp().resolve() == (tmp_path / \"hello\").resolve()\n\n\nclass TestConfigTmpdir:\n    def test_getbasetemp_custom_removes_old(self, testdir):\n        mytemp = testdir.tmpdir.join(\"xyz\")\n        p = testdir.makepyfile(\n            \"\"\"\n            def test_1(tmpdir):\n                pass\n        \"\"\"\n        )\n        testdir.runpytest(p, \"--basetemp=%s\" % mytemp)\n        mytemp.check()\n        mytemp.ensure(\"hello\")\n\n        testdir.runpytest(p, \"--basetemp=%s\" % mytemp)\n        mytemp.check()\n        assert not mytemp.join(\"hello\").check()\n\n\ntestdata = [\n    (\"mypath\", True),\n    (\"/mypath1\", False),\n    (\"./mypath1\", True),\n    (\"../mypath3\", False),\n    (\"../../mypath4\", False),\n    (\"mypath5/..\", False),\n    (\"mypath6/../mypath6\", True),\n    (\"mypath7/../mypath7/..\", False),\n]\n\n\n@pytest.mark.parametrize(\"basename, is_ok\", testdata)\ndef test_mktemp(testdir, basename, is_ok):\n    mytemp = testdir.tmpdir.mkdir(\"mytemp\")\n    p = testdir.makepyfile(\n        \"\"\"\n        def test_abs_path(tmpdir_factory):\n            tmpdir_factory.mktemp('{}', numbered=False)\n        \"\"\".format(\n            basename\n        )\n    )\n\n    result = testdir.runpytest(p, \"--basetemp=%s\" % mytemp)\n    if is_ok:\n        assert result.ret == 0\n        assert mytemp.join(basename).check()\n    else:\n        assert result.ret == 1\n        result.stdout.fnmatch_lines(\"*ValueError*\")", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_test_tmpdir_always_is_realpath_break_getuser": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_test_tmpdir_always_is_realpath_break_getuser", "embedding": null, "metadata": {"file_path": "testing/test_tmpdir.py", "file_name": "test_tmpdir.py", "file_type": "text/x-python", "category": "test", "start_line": 115, "end_line": 201, "span_ids": ["break_getuser", "test_tmp_path_always_is_realpath", "test_tmpdir_always_is_realpath", "test_tmpdir_factory", "test_tmpdir_fallback_tox_env", "test_tmpdir_too_long_on_parametrization"], "tokens": 683}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_tmpdir_always_is_realpath(testdir):\n    # the reason why tmpdir should be a realpath is that\n    # when you cd to it and do \"os.getcwd()\" you will anyway\n    # get the realpath.  Using the symlinked path can thus\n    # easily result in path-inequality\n    # XXX if that proves to be a problem, consider using\n    # os.environ[\"PWD\"]\n    realtemp = testdir.tmpdir.mkdir(\"myrealtemp\")\n    linktemp = testdir.tmpdir.join(\"symlinktemp\")\n    attempt_symlink_to(linktemp, str(realtemp))\n    p = testdir.makepyfile(\n        \"\"\"\n        def test_1(tmpdir):\n            import os\n            assert os.path.realpath(str(tmpdir)) == str(tmpdir)\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-s\", p, \"--basetemp=%s/bt\" % linktemp)\n    assert not result.ret\n\n\ndef test_tmp_path_always_is_realpath(testdir, monkeypatch):\n    # for reasoning see: test_tmpdir_always_is_realpath test-case\n    realtemp = testdir.tmpdir.mkdir(\"myrealtemp\")\n    linktemp = testdir.tmpdir.join(\"symlinktemp\")\n    attempt_symlink_to(linktemp, str(realtemp))\n    monkeypatch.setenv(\"PYTEST_DEBUG_TEMPROOT\", str(linktemp))\n    testdir.makepyfile(\n        \"\"\"\n        def test_1(tmp_path):\n            assert tmp_path.resolve() == tmp_path\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\ndef test_tmpdir_too_long_on_parametrization(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.mark.parametrize(\"arg\", [\"1\"*1000])\n        def test_some(arg, tmpdir):\n            tmpdir.ensure(\"hello\")\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\ndef test_tmpdir_factory(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        @pytest.fixture(scope='session')\n        def session_dir(tmpdir_factory):\n            return tmpdir_factory.mktemp('data', numbered=False)\n        def test_some(session_dir):\n            assert session_dir.isdir()\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\ndef test_tmpdir_fallback_tox_env(testdir, monkeypatch):\n    \"\"\"Test that tmpdir works even if environment variables required by getpass\n    module are missing (#1010).\n    \"\"\"\n    monkeypatch.delenv(\"USER\", raising=False)\n    monkeypatch.delenv(\"USERNAME\", raising=False)\n    testdir.makepyfile(\n        \"\"\"\n        def test_some(tmpdir):\n            assert tmpdir.isdir()\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\n@pytest.fixture\ndef break_getuser(monkeypatch):\n    monkeypatch.setattr(\"os.getuid\", lambda: -1)\n    # taken from python 2.7/3.4\n    for envvar in (\"LOGNAME\", \"USER\", \"LNAME\", \"USERNAME\"):\n        monkeypatch.delenv(envvar, raising=False)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_test_tmpdir_fallback_uid_not_found_test_get_user": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_tmpdir.py_test_tmpdir_fallback_uid_not_found_test_get_user", "embedding": null, "metadata": {"file_path": "testing/test_tmpdir.py", "file_name": "test_tmpdir.py", "file_type": "text/x-python", "category": "test", "start_line": 204, "end_line": 239, "span_ids": ["test_get_user", "test_get_user_uid_not_found", "test_tmpdir_fallback_uid_not_found"], "tokens": 290}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.usefixtures(\"break_getuser\")\n@pytest.mark.skipif(sys.platform.startswith(\"win\"), reason=\"no os.getuid on windows\")\ndef test_tmpdir_fallback_uid_not_found(testdir):\n    \"\"\"Test that tmpdir works even if the current process's user id does not\n    correspond to a valid user.\n    \"\"\"\n\n    testdir.makepyfile(\n        \"\"\"\n        def test_some(tmpdir):\n            assert tmpdir.isdir()\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\n@pytest.mark.usefixtures(\"break_getuser\")\n@pytest.mark.skipif(sys.platform.startswith(\"win\"), reason=\"no os.getuid on windows\")\ndef test_get_user_uid_not_found():\n    \"\"\"Test that get_user() function works even if the current process's\n    user id does not correspond to a valid user (e.g. running pytest in a\n    Docker container with 'docker run -u'.\n    \"\"\"\n    assert get_user() is None\n\n\n@pytest.mark.skipif(not sys.platform.startswith(\"win\"), reason=\"win only\")\ndef test_get_user(monkeypatch):\n    \"\"\"Test that get_user() function works even if environment variables\n    required by getpass module are missing from the environment on Windows\n    (#1010).\n    \"\"\"\n    monkeypatch.delenv(\"USER\", raising=False)\n    monkeypatch.delenv(\"USERNAME\", raising=False)\n    assert get_user() is None", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_non_unittest_no_setupclass_support_test_unittest_raise_skip_issue748": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_non_unittest_no_setupclass_support_test_unittest_raise_skip_issue748", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 821, "end_line": 945, "span_ids": ["test_cleanup_functions", "test_issue333_result_clearing", "test_no_teardown_if_setupclass_failed", "test_non_unittest_no_setupclass_support", "test_unittest_raise_skip_issue748"], "tokens": 665}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_non_unittest_no_setupclass_support(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        class TestFoo(object):\n            x = 0\n\n            @classmethod\n            def setUpClass(cls):\n                cls.x = 1\n\n            def test_method1(self):\n                assert self.x == 0\n\n            @classmethod\n            def tearDownClass(cls):\n                cls.x = 1\n\n        def test_not_teareddown():\n            assert TestFoo.x == 0\n\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    reprec.assertoutcome(passed=2)\n\n\ndef test_no_teardown_if_setupclass_failed(testdir):\n    testpath = testdir.makepyfile(\n        \"\"\"\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            x = 0\n\n            @classmethod\n            def setUpClass(cls):\n                cls.x = 1\n                assert False\n\n            def test_func1(self):\n                cls.x = 10\n\n            @classmethod\n            def tearDownClass(cls):\n                cls.x = 100\n\n        def test_notTornDown():\n            assert MyTestCase.x == 1\n    \"\"\"\n    )\n    reprec = testdir.inline_run(testpath)\n    reprec.assertoutcome(passed=1, failed=1)\n\n\ndef test_cleanup_functions(testdir):\n    \"\"\"Ensure functions added with addCleanup are always called after each test ends (#6947)\"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n\n        cleanups = []\n\n        class Test(unittest.TestCase):\n\n            def test_func_1(self):\n                self.addCleanup(cleanups.append, \"test_func_1\")\n\n            def test_func_2(self):\n                self.addCleanup(cleanups.append, \"test_func_2\")\n                assert 0\n\n            def test_func_3_check_cleanups(self):\n                assert cleanups == [\"test_func_1\", \"test_func_2\"]\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-v\")\n    result.stdout.fnmatch_lines(\n        [\n            \"*::test_func_1 PASSED *\",\n            \"*::test_func_2 FAILED *\",\n            \"*::test_func_3_check_cleanups PASSED *\",\n        ]\n    )\n\n\ndef test_issue333_result_clearing(testdir):\n    testdir.makeconftest(\n        \"\"\"\n        import pytest\n        @pytest.hookimpl(hookwrapper=True)\n        def pytest_runtest_call(item):\n            yield\n            assert 0\n    \"\"\"\n    )\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        class TestIt(unittest.TestCase):\n            def test_func(self):\n                0/0\n    \"\"\"\n    )\n\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(failed=1)\n\n\ndef test_unittest_raise_skip_issue748(testdir):\n    testdir.makepyfile(\n        test_foo=\"\"\"\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            def test_one(self):\n                raise unittest.SkipTest('skipping due to reasons')\n    \"\"\"\n    )\n    result = testdir.runpytest(\"-v\", \"-rs\")\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *SKIP*[1]*test_foo.py*skipping due to reasons*\n        *1 skipped*\n    \"\"\"\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_skip_issue1169_test_usefixtures_marker_on_unittest.result_assert_outcomes_pa": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_unittest_skip_issue1169_test_usefixtures_marker_on_unittest.result_assert_outcomes_pa", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 948, "end_line": 1045, "span_ids": ["test_class_method_containing_test_issue1558", "test_unittest_skip_issue1169", "test_usefixtures_marker_on_unittest"], "tokens": 529}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_unittest_skip_issue1169(testdir):\n    testdir.makepyfile(\n        test_foo=\"\"\"\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            @unittest.skip(\"skipping due to reasons\")\n            def test_skip(self):\n                 self.fail()\n        \"\"\"\n    )\n    result = testdir.runpytest(\"-v\", \"-rs\")\n    result.stdout.fnmatch_lines(\n        \"\"\"\n        *SKIP*[1]*skipping due to reasons*\n        *1 skipped*\n    \"\"\"\n    )\n\n\ndef test_class_method_containing_test_issue1558(testdir):\n    testdir.makepyfile(\n        test_foo=\"\"\"\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            def test_should_run(self):\n                pass\n            def test_should_not_run(self):\n                pass\n            test_should_not_run.__test__ = False\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(passed=1)\n\n\n@pytest.mark.parametrize(\"base\", [\"builtins.object\", \"unittest.TestCase\"])\ndef test_usefixtures_marker_on_unittest(base, testdir):\n    \"\"\"#3498\"\"\"\n    module = base.rsplit(\".\", 1)[0]\n    pytest.importorskip(module)\n    testdir.makepyfile(\n        conftest=\"\"\"\n        import pytest\n\n        @pytest.fixture(scope='function')\n        def fixture1(request, monkeypatch):\n            monkeypatch.setattr(request.instance, 'fixture1', True )\n\n\n        @pytest.fixture(scope='function')\n        def fixture2(request, monkeypatch):\n            monkeypatch.setattr(request.instance, 'fixture2', True )\n\n        def node_and_marks(item):\n            print(item.nodeid)\n            for mark in item.iter_markers():\n                print(\"  \", mark)\n\n        @pytest.fixture(autouse=True)\n        def my_marks(request):\n            node_and_marks(request.node)\n\n        def pytest_collection_modifyitems(items):\n            for item in items:\n               node_and_marks(item)\n\n        \"\"\"\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import pytest\n        import {module}\n\n        class Tests({base}):\n            fixture1 = False\n            fixture2 = False\n\n            @pytest.mark.usefixtures(\"fixture1\")\n            def test_one(self):\n                assert self.fixture1\n                assert not self.fixture2\n\n            @pytest.mark.usefixtures(\"fixture1\", \"fixture2\")\n            def test_two(self):\n                assert self.fixture1\n                assert self.fixture2\n\n\n    \"\"\".format(\n            module=module, base=base\n        )\n    )\n\n    result = testdir.runpytest(\"-s\")\n    result.assert_outcomes(passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_handles_init_exceptions_test_trace.assert_result_ret_0": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_testcase_handles_init_exceptions_test_trace.assert_result_ret_0", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 1048, "end_line": 1158, "span_ids": ["test_BdbQuit", "test_error_message_with_parametrized_fixtures", "test_exit_outcome", "test_setup_inheritance_skipping", "test_testcase_handles_init_exceptions", "test_trace"], "tokens": 682}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_testcase_handles_init_exceptions(testdir):\n    \"\"\"\n    Regression test to make sure exceptions in the __init__ method are bubbled up correctly.\n    See https://github.com/pytest-dev/pytest/issues/3788\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        from unittest import TestCase\n        import pytest\n        class MyTestCase(TestCase):\n            def __init__(self, *args, **kwargs):\n                raise Exception(\"should raise this exception\")\n            def test_hello(self):\n                pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    assert \"should raise this exception\" in result.stdout.str()\n    result.stdout.no_fnmatch_line(\"*ERROR at teardown of MyTestCase.test_hello*\")\n\n\ndef test_error_message_with_parametrized_fixtures(testdir):\n    testdir.copy_example(\"unittest/test_parametrized_fixture_error_message.py\")\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*test_two does not support fixtures*\",\n            \"*TestSomethingElse::test_two\",\n            \"*Function type: TestCaseFunction\",\n        ]\n    )\n\n\n@pytest.mark.parametrize(\n    \"test_name, expected_outcome\",\n    [\n        (\"test_setup_skip.py\", \"1 skipped\"),\n        (\"test_setup_skip_class.py\", \"1 skipped\"),\n        (\"test_setup_skip_module.py\", \"1 error\"),\n    ],\n)\ndef test_setup_inheritance_skipping(testdir, test_name, expected_outcome):\n    \"\"\"Issue #4700\"\"\"\n    testdir.copy_example(\"unittest/{}\".format(test_name))\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"* {} in *\".format(expected_outcome)])\n\n\ndef test_BdbQuit(testdir):\n    testdir.makepyfile(\n        test_foo=\"\"\"\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            def test_bdbquit(self):\n                import bdb\n                raise bdb.BdbQuit()\n\n            def test_should_not_run(self):\n                pass\n    \"\"\"\n    )\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(failed=1, passed=1)\n\n\ndef test_exit_outcome(testdir):\n    testdir.makepyfile(\n        test_foo=\"\"\"\n        import pytest\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            def test_exit_outcome(self):\n                pytest.exit(\"pytest_exit called\")\n\n            def test_should_not_run(self):\n                pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines([\"*Exit: pytest_exit called*\", \"*= no tests ran in *\"])\n\n\ndef test_trace(testdir, monkeypatch):\n    calls = []\n\n    def check_call(*args, **kwargs):\n        calls.append((args, kwargs))\n        assert args == (\"runcall\",)\n\n        class _pdb:\n            def runcall(*args, **kwargs):\n                calls.append((args, kwargs))\n\n        return _pdb\n\n    monkeypatch.setattr(\"_pytest.debugging.pytestPDB._init_pdb\", check_call)\n\n    p1 = testdir.makepyfile(\n        \"\"\"\n        import unittest\n\n        class MyTestCase(unittest.TestCase):\n            def test(self):\n                self.assertEqual('foo', 'foo')\n    \"\"\"\n    )\n    result = testdir.runpytest(\"--trace\", str(p1))\n    assert len(calls) == 2\n    assert result.ret == 0", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_pdb_teardown_called_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_unittest.py_test_pdb_teardown_called_", "embedding": null, "metadata": {"file_path": "testing/test_unittest.py", "file_name": "test_unittest.py", "file_type": "text/x-python", "category": "test", "start_line": 1161, "end_line": 1211, "span_ids": ["test_async_support", "test_asynctest_support", "test_pdb_teardown_called"], "tokens": 346}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "def test_pdb_teardown_called(testdir, monkeypatch):\n    \"\"\"Ensure tearDown() is always called when --pdb is given in the command-line.\n\n    We delay the normal tearDown() calls when --pdb is given, so this ensures we are calling\n    tearDown() eventually to avoid memory leaks when using --pdb.\n    \"\"\"\n    teardowns = []\n    monkeypatch.setattr(\n        pytest, \"test_pdb_teardown_called_teardowns\", teardowns, raising=False\n    )\n\n    testdir.makepyfile(\n        \"\"\"\n        import unittest\n        import pytest\n\n        class MyTestCase(unittest.TestCase):\n\n            def tearDown(self):\n                pytest.test_pdb_teardown_called_teardowns.append(self.id())\n\n            def test_1(self):\n                pass\n            def test_2(self):\n                pass\n    \"\"\"\n    )\n    result = testdir.runpytest_inprocess(\"--pdb\")\n    result.stdout.fnmatch_lines(\"* 2 passed in *\")\n    assert teardowns == [\n        \"test_pdb_teardown_called.MyTestCase.test_1\",\n        \"test_pdb_teardown_called.MyTestCase.test_2\",\n    ]\n\n\ndef test_async_support(testdir):\n    pytest.importorskip(\"unittest.async_case\")\n\n    testdir.copy_example(\"unittest/test_unittest_asyncio.py\")\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(failed=1, passed=2)\n\n\ndef test_asynctest_support(testdir):\n    \"\"\"Check asynctest support (#7110)\"\"\"\n    pytest.importorskip(\"asynctest\")\n\n    testdir.copy_example(\"unittest/test_unittest_asynctest.py\")\n    reprec = testdir.inline_run()\n    reprec.assertoutcome(failed=1, passed=2)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_os_test_as_errors": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_os_test_as_errors", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 1, "end_line": 108, "span_ids": ["imports", "pyfile_with_warnings", "test_as_errors", "test_normal_flow", "test_setup_teardown_warnings"], "tokens": 682}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import os\nimport warnings\n\nimport pytest\nfrom _pytest.fixtures import FixtureRequest\nfrom _pytest.pytester import Testdir\n\nWARNINGS_SUMMARY_HEADER = \"warnings summary\"\n\n\n@pytest.fixture\ndef pyfile_with_warnings(testdir: Testdir, request: FixtureRequest) -> str:\n    \"\"\"\n    Create a test file which calls a function in a module which generates warnings.\n    \"\"\"\n    testdir.syspathinsert()\n    test_name = request.function.__name__\n    module_name = test_name.lstrip(\"test_\") + \"_module\"\n    test_file = testdir.makepyfile(\n        \"\"\"\n        import {module_name}\n        def test_func():\n            assert {module_name}.foo() == 1\n        \"\"\".format(\n            module_name=module_name\n        ),\n        **{\n            module_name: \"\"\"\n            import warnings\n            def foo():\n                warnings.warn(UserWarning(\"user warning\"))\n                warnings.warn(RuntimeWarning(\"runtime warning\"))\n                return 1\n            \"\"\",\n        },\n    )\n    return str(test_file)\n\n\n@pytest.mark.filterwarnings(\"default\")\ndef test_normal_flow(testdir, pyfile_with_warnings):\n    \"\"\"\n    Check that the warnings section is displayed.\n    \"\"\"\n    result = testdir.runpytest(pyfile_with_warnings)\n    result.stdout.fnmatch_lines(\n        [\n            \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n            \"test_normal_flow.py::test_func\",\n            \"*normal_flow_module.py:3: UserWarning: user warning\",\n            '*  warnings.warn(UserWarning(\"user warning\"))',\n            \"*normal_flow_module.py:4: RuntimeWarning: runtime warning\",\n            '*  warnings.warn(RuntimeWarning(\"runtime warning\"))',\n            \"* 1 passed, 2 warnings*\",\n        ]\n    )\n\n\n@pytest.mark.filterwarnings(\"always\")\ndef test_setup_teardown_warnings(testdir):\n    testdir.makepyfile(\n        \"\"\"\n        import warnings\n        import pytest\n\n        @pytest.fixture\n        def fix():\n            warnings.warn(UserWarning(\"warning during setup\"))\n            yield\n            warnings.warn(UserWarning(\"warning during teardown\"))\n\n        def test_func(fix):\n            pass\n    \"\"\"\n    )\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n            \"*test_setup_teardown_warnings.py:6: UserWarning: warning during setup\",\n            '*warnings.warn(UserWarning(\"warning during setup\"))',\n            \"*test_setup_teardown_warnings.py:8: UserWarning: warning during teardown\",\n            '*warnings.warn(UserWarning(\"warning during teardown\"))',\n            \"* 1 passed, 2 warnings*\",\n        ]\n    )\n\n\n@pytest.mark.parametrize(\"method\", [\"cmdline\", \"ini\"])\ndef test_as_errors(testdir, pyfile_with_warnings, method):\n    args = (\"-W\", \"error\") if method == \"cmdline\" else ()\n    if method == \"ini\":\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            filterwarnings=error\n            \"\"\"\n        )\n    # Use a subprocess, since changing logging level affects other threads\n    # (xdist).\n    result = testdir.runpytest_subprocess(*args, pyfile_with_warnings)\n    result.stdout.fnmatch_lines(\n        [\n            \"E       UserWarning: user warning\",\n            \"as_errors_module.py:3: UserWarning\",\n            \"* 1 failed in *\",\n        ]\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_deprecation_warning_as_error_test_warnings_checker_twice": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_deprecation_warning_as_error_test_warnings_checker_twice", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 504, "end_line": 567, "span_ids": ["TestAssertionWarnings", "TestAssertionWarnings.assert_result_warns", "TestAssertionWarnings.test_tuple_warning", "test_deprecation_warning_as_error", "test_warnings_checker_twice"], "tokens": 429}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.parametrize(\"change_default\", [None, \"ini\", \"cmdline\"])\n@pytest.mark.skip(\n    reason=\"This test should be enabled again before pytest 6.0 is released\"\n)\ndef test_deprecation_warning_as_error(testdir, change_default):\n    \"\"\"This ensures that PytestDeprecationWarnings raised by pytest are turned into errors.\n\n    This test should be enabled as part of each major release, and skipped again afterwards\n    to ensure our deprecations are turning into warnings as expected.\n    \"\"\"\n    testdir.makepyfile(\n        \"\"\"\n        import warnings, pytest\n        def test():\n            warnings.warn(pytest.PytestDeprecationWarning(\"some warning\"))\n    \"\"\"\n    )\n    if change_default == \"ini\":\n        testdir.makeini(\n            \"\"\"\n            [pytest]\n            filterwarnings =\n                ignore::pytest.PytestDeprecationWarning\n        \"\"\"\n        )\n\n    args = (\n        (\"-Wignore::pytest.PytestDeprecationWarning\",)\n        if change_default == \"cmdline\"\n        else ()\n    )\n    result = testdir.runpytest(*args)\n    if change_default is None:\n        result.stdout.fnmatch_lines([\"* 1 failed in *\"])\n    else:\n        assert change_default in (\"ini\", \"cmdline\")\n        result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n\n\nclass TestAssertionWarnings:\n    @staticmethod\n    def assert_result_warns(result, msg):\n        result.stdout.fnmatch_lines([\"*PytestAssertRewriteWarning: %s*\" % msg])\n\n    def test_tuple_warning(self, testdir):\n        testdir.makepyfile(\n            \"\"\"\\\n            def test_foo():\n                assert (1,2)\n            \"\"\"\n        )\n        result = testdir.runpytest()\n        self.assert_result_warns(\n            result, \"assertion is always true, perhaps remove parentheses?\"\n        )\n\n\ndef test_warnings_checker_twice():\n    \"\"\"Issue #4617\"\"\"\n    expectation = pytest.warns(UserWarning)\n    with expectation:\n        warnings.warn(\"Message A\", UserWarning)\n    with expectation:\n        warnings.warn(\"Message B\", UserWarning)", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_group_warnings_by_message_test_group_warnings_by_message.result_stdout_fnmatch_lin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_group_warnings_by_message_test_group_warnings_by_message.result_stdout_fnmatch_lin", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 570, "end_line": 599, "span_ids": ["test_group_warnings_by_message"], "tokens": 337}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"ignore::pytest.PytestExperimentalApiWarning\")\n@pytest.mark.filterwarnings(\"always\")\ndef test_group_warnings_by_message(testdir):\n    testdir.copy_example(\"warnings/test_group_warnings_by_message.py\")\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n            \"test_group_warnings_by_message.py::test_foo[[]0[]]\",\n            \"test_group_warnings_by_message.py::test_foo[[]1[]]\",\n            \"test_group_warnings_by_message.py::test_foo[[]2[]]\",\n            \"test_group_warnings_by_message.py::test_foo[[]3[]]\",\n            \"test_group_warnings_by_message.py::test_foo[[]4[]]\",\n            \"test_group_warnings_by_message.py::test_foo_1\",\n            \"  */test_group_warnings_by_message.py:*: UserWarning: foo\",\n            \"    warnings.warn(UserWarning(msg))\",\n            \"\",\n            \"test_group_warnings_by_message.py::test_bar[[]0[]]\",\n            \"test_group_warnings_by_message.py::test_bar[[]1[]]\",\n            \"test_group_warnings_by_message.py::test_bar[[]2[]]\",\n            \"test_group_warnings_by_message.py::test_bar[[]3[]]\",\n            \"test_group_warnings_by_message.py::test_bar[[]4[]]\",\n            \"  */test_group_warnings_by_message.py:*: UserWarning: bar\",\n            \"    warnings.warn(UserWarning(msg))\",\n            \"\",\n            \"-- Docs: *\",\n            \"*= 11 passed, 11 warnings *\",\n        ],\n        consecutive=True,\n    )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_group_warnings_by_message_summary_test_pytest_configure_warning": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_test_group_warnings_by_message_summary_test_pytest_configure_warning", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 602, "end_line": 642, "span_ids": ["test_group_warnings_by_message_summary", "test_pytest_configure_warning"], "tokens": 297}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "@pytest.mark.filterwarnings(\"ignore::pytest.PytestExperimentalApiWarning\")\n@pytest.mark.filterwarnings(\"always\")\ndef test_group_warnings_by_message_summary(testdir):\n    testdir.copy_example(\"warnings/test_group_warnings_by_message_summary\")\n    testdir.syspathinsert()\n    result = testdir.runpytest()\n    result.stdout.fnmatch_lines(\n        [\n            \"*== %s ==*\" % WARNINGS_SUMMARY_HEADER,\n            \"test_1.py: 21 warnings\",\n            \"test_2.py: 1 warning\",\n            \"  */test_1.py:7: UserWarning: foo\",\n            \"    warnings.warn(UserWarning(msg))\",\n            \"\",\n            \"test_1.py: 20 warnings\",\n            \"  */test_1.py:7: UserWarning: bar\",\n            \"    warnings.warn(UserWarning(msg))\",\n            \"\",\n            \"-- Docs: *\",\n            \"*= 42 passed, 42 warnings *\",\n        ],\n        consecutive=True,\n    )\n\n\ndef test_pytest_configure_warning(testdir, recwarn):\n    \"\"\"Issue 5115.\"\"\"\n    testdir.makeconftest(\n        \"\"\"\n        def pytest_configure():\n            import warnings\n\n            warnings.warn(\"from pytest_configure\")\n        \"\"\"\n    )\n\n    result = testdir.runpytest()\n    assert result.ret == 5\n    assert \"INTERNALERROR\" not in result.stderr.str()\n    warning = recwarn.pop()\n    assert str(warning.message) == \"from pytest_configure\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel_TestStackLevel.test_issue4445_rewrite": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel_TestStackLevel.test_issue4445_rewrite", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 645, "end_line": 683, "span_ids": ["TestStackLevel", "TestStackLevel.capwarn", "TestStackLevel.test_issue4445_rewrite"], "tokens": 281}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestStackLevel:\n    @pytest.fixture\n    def capwarn(self, testdir):\n        class CapturedWarnings:\n            captured = []\n\n            @classmethod\n            def pytest_warning_captured(cls, warning_message, when, item, location):\n                cls.captured.append((warning_message, location))\n\n        testdir.plugins = [CapturedWarnings()]\n\n        return CapturedWarnings\n\n    def test_issue4445_rewrite(self, testdir, capwarn):\n        \"\"\"#4445: Make sure the warning points to a reasonable location\n        See origin of _issue_warning_captured at: _pytest.assertion.rewrite.py:241\n        \"\"\"\n        testdir.makepyfile(some_mod=\"\")\n        conftest = testdir.makeconftest(\n            \"\"\"\n                import some_mod\n                import pytest\n\n                pytest.register_assert_rewrite(\"some_mod\")\n            \"\"\"\n        )\n        testdir.parseconfig()\n\n        # with stacklevel=5 the warning originates from register_assert_rewrite\n        # function in the created conftest.py\n        assert len(capwarn.captured) == 1\n        warning, location = capwarn.captured.pop()\n        file, lineno, func = location\n\n        assert \"Module already imported\" in str(warning.message)\n        assert file == str(conftest)\n        assert func == \"<module>\"  # the above conftest.py\n        assert lineno == 4", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel.test_issue4445_preparse_TestStackLevel.test_issue4445_import_plugin": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel.test_issue4445_preparse_TestStackLevel.test_issue4445_import_plugin", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 685, "end_line": 728, "span_ids": ["TestStackLevel.test_issue4445_import_plugin", "TestStackLevel.test_issue4445_preparse"], "tokens": 401}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestStackLevel:\n\n    def test_issue4445_preparse(self, testdir, capwarn):\n        \"\"\"#4445: Make sure the warning points to a reasonable location\n        See origin of _issue_warning_captured at: _pytest.config.__init__.py:910\n        \"\"\"\n        testdir.makeconftest(\n            \"\"\"\n            import nothing\n            \"\"\"\n        )\n        testdir.parseconfig(\"--help\")\n\n        # with stacklevel=2 the warning should originate from config._preparse and is\n        # thrown by an errorneous conftest.py\n        assert len(capwarn.captured) == 1\n        warning, location = capwarn.captured.pop()\n        file, _, func = location\n\n        assert \"could not load initial conftests\" in str(warning.message)\n        assert \"config{sep}__init__.py\".format(sep=os.sep) in file\n        assert func == \"_preparse\"\n\n    def test_issue4445_import_plugin(self, testdir, capwarn):\n        \"\"\"#4445: Make sure the warning points to a reasonable location\n        See origin of _issue_warning_captured at: _pytest.config.__init__.py:585\n        \"\"\"\n        testdir.makepyfile(\n            some_plugin=\"\"\"\n            import pytest\n            pytest.skip(\"thing\", allow_module_level=True)\n            \"\"\"\n        )\n        testdir.syspathinsert()\n        testdir.parseconfig(\"-p\", \"some_plugin\")\n\n        # with stacklevel=2 the warning should originate from\n        # config.PytestPluginManager.import_plugin is thrown by a skipped plugin\n\n        assert len(capwarn.captured) == 1\n        warning, location = capwarn.captured.pop()\n        file, _, func = location\n\n        assert \"skipped plugin 'some_plugin': thing\" in str(warning.message)\n        assert \"config{sep}__init__.py\".format(sep=os.sep) in file\n        assert func == \"import_plugin\"", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel.test_issue4445_resultlog_": {"__data__": {"id_": "/tmp/repos/swe-bench_pytest-dev__pytest/testing/test_warnings.py_TestStackLevel.test_issue4445_resultlog_", "embedding": null, "metadata": {"file_path": "testing/test_warnings.py", "file_name": "test_warnings.py", "file_type": "text/x-python", "category": "test", "start_line": 730, "end_line": 776, "span_ids": ["TestStackLevel.test_issue4445_issue5928_mark_generator", "TestStackLevel.test_issue4445_resultlog"], "tokens": 351}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date", "start_line", "end_line", "tokens"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "class TestStackLevel:\n\n    def test_issue4445_resultlog(self, testdir, capwarn):\n        \"\"\"#4445: Make sure the warning points to a reasonable location\n        See origin of _issue_warning_captured at: _pytest.resultlog.py:35\n        \"\"\"\n        testdir.makepyfile(\n            \"\"\"\n            def test_dummy():\n                pass\n        \"\"\"\n        )\n        # Use parseconfigure() because the warning in resultlog.py is triggered in\n        # the pytest_configure hook\n        testdir.parseconfigure(\n            \"--result-log={dir}\".format(dir=testdir.tmpdir.join(\"result.log\"))\n        )\n\n        # with stacklevel=2 the warning originates from resultlog.pytest_configure\n        # and is thrown when --result-log is used\n        warning, location = capwarn.captured.pop()\n        file, _, func = location\n\n        assert \"--result-log is deprecated\" in str(warning.message)\n        assert \"resultlog.py\" in file\n        assert func == \"pytest_configure\"\n\n    def test_issue4445_issue5928_mark_generator(self, testdir):\n        \"\"\"#4445 and #5928: Make sure the warning from an unknown mark points to\n        the test file where this mark is used.\n        \"\"\"\n        testfile = testdir.makepyfile(\n            \"\"\"\n            import pytest\n\n            @pytest.mark.unknown\n            def test_it():\n                pass\n            \"\"\"\n        )\n        result = testdir.runpytest_subprocess()\n        # with stacklevel=2 the warning should originate from the above created test file\n        result.stdout.fnmatch_lines_random(\n            [\n                \"*{testfile}:3*\".format(testfile=str(testfile)),\n                \"*Unknown pytest.mark.unknown*\",\n            ]\n        )", "mimetype": "text/plain", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}}